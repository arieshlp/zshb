(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[40],{

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var D_helipingWork_APP_kmEnvPortable_webappOS_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regenerator-runtime/runtime.js */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.function.name.js */ "./node_modules/core-js/modules/es.function.name.js");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.array.map.js */ "./node_modules/core-js/modules/es.array.map.js");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ "./node_modules/core-js/modules/es.regexp.to-string.js");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _api_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/api/index */ "./src/api/index.js");
/* harmony import */ var _utils_olMap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/olMap */ "./src/utils/olMap.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_8__);






//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



var arcgisMapServer = "http://10.221.29.4:8080/OneMapServer/rest/services/X_KmWryDasjgjfw_V4/MapServer";
/* harmony default export */ __webpack_exports__["default"] = ({
  name: "mapMng",
  mixins: [_utils_olMap__WEBPACK_IMPORTED_MODULE_7__["default"]],
  data: function data() {
    return {
      name: '',
      hbm: ['2', '3'],
      active: 'up',
      listData: [],
      loading: false,
      location: []
    };
  },
  watch: {
    '$store.state.pointName': function $storeStatePointName() {
      this.name = this.$store.state.pointName;
      this.queryMapPoints();
    },
    'hbm': function hbm() {
      this.queryMapPoints();
    },
    'name': function name() {
      if (this.name === '') {
        this.clearSearch();
      } else {
        this.queryMapPoints();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    return Object(D_helipingWork_APP_kmEnvPortable_webappOS_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this.location = [_this.$route.query.longitude, _this.$route.query.latitude];

              _this.getMapServer().then(function (server) {
                setTimeout(function () {
                  _this.initMap(server, _this.$refs.map, _this.location);

                  _this.drawCircle(_this.location, 5);

                  _this.queryMapPoints();
                }, 300);
              });

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  methods: {
    getMapServer: function getMapServer() {
      return new Promise(function (resolve) {
        axios__WEBPACK_IMPORTED_MODULE_8___default()({
          method: "get",
          url: arcgisMapServer,
          params: {
            f: "pjson",
            token: localStorage.getItem("map_token")
          }
        }).then(function (res) {
          resolve(res.data);
        });
      });
    },
    getColor: function getColor(type) {
      if (type === '红色') {
        return 'color:red';
      } else if (type === '黄色') {
        return 'color:#FFC420';
      } else if (type === '绿色') {
        return 'color:#3FC75F';
      } else {
        return 'color: #eeeeee';
      }
    },
    showDetails: function showDetails(data) {
      this.$router.push({
        name: 'companyDetail',
        query: {
          id: data.id,
          type: data.qr_code_color === '红色' ? 'red' : data.qr_code_color === '黄色' ? 'yellow' : data.qr_code_color === '绿色' ? 'green' : ''
        }
      });
    },
    clearSearch: function clearSearch() {
      this.name = '';
      this.clearSelectByAttribute();
      this.panToCoordinate([102.82797786933142, 24.89106777437279], false);
      this.queryMapPoints();
    },
    queryMapPoints: function queryMapPoints() {
      var _this2 = this;

      this.loading = true;
      var params = {
        name: this.name,
        division_code: '',
        type: this.hbm.toString()
      };
      Object(_api_index__WEBPACK_IMPORTED_MODULE_6__["queryWRYMap"])(params).then(function (res) {
        if (res.code === '200') {
          _this2.listData = res.data;
          var points = [];

          for (var i = 0; i < res.data.length; i++) {
            if (res.data[i].qr_code_color !== '') {
              points.push(res.data[i]);
            }
          }

          _this2.getPoints(points, '环保码');
        }
      }).finally(function (a) {
        _this2.loading = false;
      });
    },
    showPoint: function showPoint(info) {
      this.findFeatureById(info.id);
    },
    //回到定位
    onBackLoaction: function onBackLoaction() {
      this.panToCoordinate(this.location, 9);
    }
  }
});

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true&":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true& ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "index-page" },
    [
      _c("van-nav-bar", {
        attrs: {
          title: "环保码地图",
          "left-arrow": "",
          fixed: "",
          "right-text": "回到定位",
        },
        on: {
          "click-left": function ($event) {
            return _vm.$router.go(-1)
          },
          "click-right": _vm.onBackLoaction,
        },
      }),
      _vm.loading
        ? _c(
            "van-loading",
            {
              staticClass: "mask",
              attrs: { size: "24px", color: "#0094ff", vertical: "" },
            },
            [_vm._v("数据加载中...")]
          )
        : _vm._e(),
      _c("div", { staticClass: "headerWrapper" }, [
        _c(
          "div",
          { staticClass: "mapHeader searchInput" },
          [
            _c(
              "van-checkbox-group",
              {
                staticStyle: {
                  "margin-left": "10px",
                  width: "calc(50% - 10px)",
                },
                attrs: { direction: "horizontal" },
                model: {
                  value: _vm.hbm,
                  callback: function ($$v) {
                    _vm.hbm = $$v
                  },
                  expression: "hbm",
                },
              },
              [
                _c(
                  "van-checkbox",
                  {
                    attrs: { name: "1", shape: "square", "icon-size": "12px" },
                  },
                  [_vm._v("绿码")]
                ),
                _c(
                  "van-checkbox",
                  {
                    attrs: { name: "2", shape: "square", "icon-size": "12px" },
                  },
                  [_vm._v("黄码")]
                ),
                _c(
                  "van-checkbox",
                  {
                    attrs: { name: "3", shape: "square", "icon-size": "12px" },
                  },
                  [_vm._v("红码")]
                ),
              ],
              1
            ),
            _c("van-search", {
              staticStyle: { width: "50%" },
              attrs: {
                size: "small",
                shape: "round",
                "input-align": "center",
                placeholder: "请输入关键字/标签",
              },
              model: {
                value: _vm.name,
                callback: function ($$v) {
                  _vm.name = $$v
                },
                expression: "name",
              },
            }),
          ],
          1
        ),
      ]),
      _c("div", { staticClass: "detailContent" }, [
        _c("div", { staticClass: "mapDiv" }, [
          _c(
            "div",
            { ref: "map", staticStyle: { width: "100%", height: "100%" } },
            [_vm._m(0)]
          ),
        ]),
        _c(
          "div",
          { staticClass: "mapCard" },
          _vm._l(_vm.listData, function (item) {
            return _c("div", { staticClass: "mapItems" }, [
              _c("div", { staticClass: "title" }, [
                _c("img", {
                  attrs: { src: __webpack_require__(/*! @/assets/code/地址.png */ "./src/assets/code/地址.png") },
                }),
                _c(
                  "span",
                  {
                    on: {
                      click: function ($event) {
                        return _vm.showDetails(item)
                      },
                    },
                  },
                  [_vm._v(_vm._s(item.wrymc))]
                ),
              ]),
              _c("div", [
                _c("span", [_vm._v("环保码：")]),
                _c("span", { style: _vm.getColor(item.qr_code_color) }, [
                  _vm._v(
                    " " +
                      _vm._s(
                        item.qr_code_color === "绿色"
                          ? "绿码"
                          : item.qr_code_color === "黄色"
                          ? "黄码"
                          : item.qr_code_color === "红色"
                          ? "红码"
                          : "-"
                      ) +
                      " "
                  ),
                ]),
              ]),
              _c("span", [_vm._v("联系方式：" + _vm._s(item.lxrdh))]),
              _c("span", [_vm._v("地址：" + _vm._s(item.szdz))]),
            ])
          }),
          0
        ),
      ]),
    ],
    1
  )
}
var staticRenderFns = [
  function () {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "legend" }, [
      _c("div", [
        _c("img", { attrs: { src: __webpack_require__(/*! @/assets/code/绿码.png */ "./src/assets/code/绿码.png") } }),
        _c("span", [_vm._v("绿码")]),
      ]),
      _c("div", [
        _c("img", { attrs: { src: __webpack_require__(/*! @/assets/code/黄码.png */ "./src/assets/code/黄码.png") } }),
        _c("span", [_vm._v("黄码")]),
      ]),
      _c("div", [
        _c("img", { attrs: { src: __webpack_require__(/*! @/assets/code/红码.png */ "./src/assets/code/红码.png") } }),
        _c("span", [_vm._v("红码")]),
      ]),
    ])
  },
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/ol/ol.css":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!./node_modules/postcss-loader/src??ref--7-oneOf-3-2!./node_modules/ol/ol.css ***!
  \********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ":root,\n:host {\n  --ol-background-color: white;\n  --ol-accent-background-color: #F5F5F5;\n  --ol-subtle-background-color: rgba(128, 128, 128, 0.25);\n  --ol-partial-background-color: rgba(255, 255, 255, 0.75);\n  --ol-foreground-color: #333333;\n  --ol-subtle-foreground-color: #666666;\n  --ol-brand-color: #00AAFF;\n}\n\n.ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 1.5px solid var(--ol-background-color);\n  background-color: var(--ol-partial-background-color);\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: var(--ol-partial-background-color);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n\n.ol-scale-line-inner {\n  border: 1px solid var(--ol-subtle-foreground-color);\n  border-top: none;\n  color: var(--ol-foreground-color);\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n  transition: all 0.25s;\n}\n\n.ol-scale-bar {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n}\n\n.ol-scale-bar-inner {\n  display: flex;\n}\n\n.ol-scale-step-marker {\n  width: 1px;\n  height: 15px;\n  background-color: var(--ol-foreground-color);\n  float: right;\n  z-index: 10;\n}\n\n.ol-scale-step-text {\n  position: absolute;\n  bottom: -5px;\n  font-size: 10px;\n  z-index: 11;\n  color: var(--ol-foreground-color);\n  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);\n}\n\n.ol-scale-text {\n  position: absolute;\n  font-size: 12px;\n  text-align: center;\n  bottom: 25px;\n  color: var(--ol-foreground-color);\n  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);\n}\n\n.ol-scale-singlebar {\n  position: relative;\n  height: 10px;\n  z-index: 9;\n  box-sizing: border-box;\n  border: 1px solid var(--ol-foreground-color);\n}\n\n.ol-scale-singlebar-even {\n  background-color: var(--ol-subtle-foreground-color);\n}\n\n.ol-scale-singlebar-odd {\n  background-color: var(--ol-background-color);\n}\n\n.ol-unsupported {\n  display: none;\n}\n\n.ol-viewport,\n.ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n      user-select: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.ol-viewport canvas {\n  all: unset;\n}\n\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n      user-select: text;\n}\n\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: grabbing;\n}\n\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: grab;\n}\n\n.ol-control {\n  position: absolute;\n  background-color: var(--ol-subtle-background-color);\n  border-radius: 4px;\n}\n\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: var(--ol-subtle-foreground-color);\n  font-weight: bold;\n  text-decoration: none;\n  font-size: inherit;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: var(--ol-background-color);\n  border: none;\n  border-radius: 2px;\n}\n\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  will-change: transform;\n}\n\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  outline: 1px solid var(--ol-subtle-foreground-color);\n  color: var(--ol-foreground-color);\n}\n\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n  display: flex;\n  flex-flow: row-reverse;\n  align-items: center;\n}\n\n.ol-attribution a {\n  color: var(--ol-subtle-foreground-color);\n  text-decoration: none;\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 1px .5em;\n  color: var(--ol-foreground-color);\n  text-shadow: 0 0 2px var(--ol-background-color);\n  font-size: 12px;\n}\n\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n}\n\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n\n.ol-attribution button {\n  flex-shrink: 0;\n}\n\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n\n.ol-attribution:not(.ol-collapsed) {\n  background: var(--ol-partial-background-color);\n}\n\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n}\n\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: block;\n}\n\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid var(--ol-subtle-foreground-color);\n  height: 150px;\n  width: 150px;\n}\n\n.ol-overviewmap:not(.ol-collapsed) button {\n  bottom: 0;\n  left: 0;\n  position: absolute;\n}\n\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-overviewmap:not(.ol-collapsed) {\n  background: var(--ol-subtle-background-color);\n}\n\n.ol-overviewmap-box {\n  border: 1.5px dotted var(--ol-subtle-foreground-color);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".index-page[data-v-a9ba7ed4] {\n  height: calc(100vh - 50px);\n  overflow-y: auto;\n  padding-top: 50px;\n}\n.index-page .headerWrapper[data-v-a9ba7ed4] {\n  width: 100%;\n  height: 55px;\n  line-height: 45px;\n}\n.index-page .headerWrapper .mapHeader[data-v-a9ba7ed4] {\n  width: 100%;\n  margin: 0 auto;\n  background-color: #fff;\n  height: 55px;\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n}\n.index-page .headerWrapper .mapHeader > input[data-v-a9ba7ed4] {\n  width: 80%;\n  height: 35px;\n  border-left: 0;\n  border-top: 0;\n  border-bottom: 0;\n  border-right: 1px solid #eeeeee;\n  text-indent: 8px;\n  padding-left: 20px;\n  margin-left: 20px;\n  background-color: #f7f7f7;\n}\n.index-page .detailContent[data-v-a9ba7ed4] {\n  width: 100%;\n  height: calc(100% - 55px);\n  background-color: #eee;\n}\n.index-page .detailContent .mapDiv[data-v-a9ba7ed4] {\n  height: 300px;\n  background-color: #fff;\n}\n.index-page .detailContent .mapDiv .legend[data-v-a9ba7ed4] {\n  background-color: #fff;\n  font-size: 14px;\n  height: 35px;\n  top: 110px;\n  position: absolute;\n  z-index: 1;\n  width: 180px;\n  right: 5px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 10px;\n  box-shadow: 0 0 6px 2px rgba(0, 0, 0, 0.09);\n}\n.index-page .detailContent .mapDiv .legend div[data-v-a9ba7ed4] {\n  align-items: center;\n  display: flex;\n}\n.index-page .detailContent .mapDiv .legend img[data-v-a9ba7ed4] {\n  margin-right: 5px;\n}\n.index-page .detailContent .mapCard[data-v-a9ba7ed4] {\n  height: calc(100% - 300px);\n  overflow-y: auto;\n}\n.index-page .detailContent .mapCard .mapItems[data-v-a9ba7ed4] {\n  width: 85%;\n  height: 115px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);\n  background: #fff;\n  margin: 10px auto;\n  padding: 10px 20px 15px 20px;\n  line-height: 20px;\n  display: grid;\n  border-radius: 10px;\n}\n.index-page .detailContent .mapCard .mapItems .title[data-v-a9ba7ed4] {\n  display: flex;\n  height: 35px;\n  align-items: center;\n}\n.index-page .detailContent .mapCard .mapItems .title > span[data-v-a9ba7ed4] {\n  font-weight: bold;\n  cursor: pointer;\n}\n.index-page .detailContent .mapCard .mapItems .title > img[data-v-a9ba7ed4] {\n  margin-right: 5px;\n  height: 15px;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/ol/format.js":
/*!***********************************!*\
  !*** ./node_modules/ol/format.js ***!
  \***********************************/
/*! exports provided: EsriJSON, GeoJSON, GML, GPX, IGC, IIIFInfo, KML, MVT, OWS, Polyline, TopoJSON, WFS, WKB, WKT, WMSCapabilities, WMSGetFeatureInfo, WMTSCapabilities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_EsriJSON_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format/EsriJSON.js */ "./node_modules/ol/format/EsriJSON.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EsriJSON", function() { return _format_EsriJSON_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/GeoJSON.js */ "./node_modules/ol/format/GeoJSON.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeoJSON", function() { return _format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _format_GML_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./format/GML.js */ "./node_modules/ol/format/GML.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GML", function() { return _format_GML_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _format_GPX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./format/GPX.js */ "./node_modules/ol/format/GPX.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GPX", function() { return _format_GPX_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _format_IGC_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./format/IGC.js */ "./node_modules/ol/format/IGC.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IGC", function() { return _format_IGC_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./format/IIIFInfo.js */ "./node_modules/ol/format/IIIFInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IIIFInfo", function() { return _format_IIIFInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _format_KML_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./format/KML.js */ "./node_modules/ol/format/KML.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KML", function() { return _format_KML_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _format_MVT_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format/MVT.js */ "./node_modules/ol/format/MVT.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MVT", function() { return _format_MVT_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _format_OWS_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./format/OWS.js */ "./node_modules/ol/format/OWS.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OWS", function() { return _format_OWS_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _format_Polyline_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./format/Polyline.js */ "./node_modules/ol/format/Polyline.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return _format_Polyline_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _format_TopoJSON_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./format/TopoJSON.js */ "./node_modules/ol/format/TopoJSON.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TopoJSON", function() { return _format_TopoJSON_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _format_WFS_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./format/WFS.js */ "./node_modules/ol/format/WFS.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WFS", function() { return _format_WFS_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _format_WKB_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./format/WKB.js */ "./node_modules/ol/format/WKB.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WKB", function() { return _format_WKB_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _format_WKT_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./format/WKT.js */ "./node_modules/ol/format/WKT.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WKT", function() { return _format_WKT_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _format_WMSCapabilities_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./format/WMSCapabilities.js */ "./node_modules/ol/format/WMSCapabilities.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMSCapabilities", function() { return _format_WMSCapabilities_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _format_WMSGetFeatureInfo_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./format/WMSGetFeatureInfo.js */ "./node_modules/ol/format/WMSGetFeatureInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMSGetFeatureInfo", function() { return _format_WMSGetFeatureInfo_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _format_WMTSCapabilities_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./format/WMTSCapabilities.js */ "./node_modules/ol/format/WMTSCapabilities.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMTSCapabilities", function() { return _format_WMTSCapabilities_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/**
 * @module ol/format
 */




















/***/ }),

/***/ "./node_modules/ol/format/GML.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/GML.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML3.js */ "./node_modules/ol/format/GML3.js");
/**
 * @module ol/format/GML
 */


/**
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @class
 * @param {import("./GMLBase.js").Options} [options]
 *     Optional configuration object.
 * @api
 */
const GML = _GML3_js__WEBPACK_IMPORTED_MODULE_0__["default"];

/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [options] Options.
 * @return {string} Result.
 * @api
 */
GML.prototype.writeFeatures;

/**
 * Encode an array of features in the GML 3.1.1 format as an XML node.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [options] Options.
 * @return {Node} Node.
 * @api
 */
GML.prototype.writeFeaturesNode;

/* harmony default export */ __webpack_exports__["default"] = (GML);


/***/ }),

/***/ "./node_modules/ol/format/GML2.js":
/*!****************************************!*\
  !*** ./node_modules/ol/format/GML2.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GMLBase.js */ "./node_modules/ol/format/GMLBase.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/**
 * @module ol/format/GML2
 */







/**
 * @const
 * @type {string}
 */
const schemaLocation =
  _GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["GMLNS"] + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';

/**
 * @const
 * @type {Object<string, string>}
 */
const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  'MultiLineString': 'lineStringMember',
  'MultiCurve': 'curveMember',
  'MultiPolygon': 'polygonMember',
  'MultiSurface': 'surfaceMember',
};

/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @api
 */
class GML2 extends _GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(options) {
    options = options ? options : {};

    super(options);

    this.FEATURE_COLLECTION_PARSERS[_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["GMLNS"]]['featureMember'] = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeArrayPusher"])(
      this.readFeaturesInternal
    );

    /**
     * @type {string}
     */
    this.schemaLocation = options.schemaLocation
      ? options.schemaLocation
      : schemaLocation;
  }

  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(node, objectStack) {
    const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["getAllTextContent"])(node, false).replace(/^\s*|\s*$/g, '');
    const context = /** @type {import("../xml.js").NodeStackItem} */ (
      objectStack[0]
    );
    const containerSrs = context['srsName'];
    let axisOrientation = 'enu';
    if (containerSrs) {
      const proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["get"])(containerSrs);
      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }
    const coordsGroups = s.trim().split(/\s+/);
    const flatCoordinates = [];
    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {
      const coords = coordsGroups[i].split(/,+/);
      const x = parseFloat(coords[0]);
      const y = parseFloat(coords[1]);
      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;
      if (axisOrientation.substr(0, 2) === 'en') {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(node, objectStack) {
    /** @type {Array<number>} */
    const flatCoordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
      [null],
      this.BOX_PARSERS_,
      node,
      objectStack,
      this
    );
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(
      flatCoordinates[1][0],
      flatCoordinates[1][1],
      flatCoordinates[1][3],
      flatCoordinates[1][4]
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(node, objectStack) {
    /** @type {Array<number>|undefined} */
    const flatLinearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
      undefined,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings =
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
      flatLinearRings.push(flatLinearRing);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(node, objectStack) {
    /** @type {Array<number>|undefined} */
    const flatLinearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
      undefined,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings =
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
      flatLinearRings[0] = flatLinearRing;
    }
  }

  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const multiSurface = context['multiSurface'];
    const surface = context['surface'];
    const multiCurve = context['multiCurve'];
    if (!Array.isArray(value)) {
      nodeName = /** @type {import("../geom/Geometry.js").default} */ (
        value
      ).getType();
      if (nodeName === 'MultiPolygon' && multiSurface === true) {
        nodeName = 'MultiSurface';
      } else if (nodeName === 'Polygon' && surface === true) {
        nodeName = 'Surface';
      } else if (nodeName === 'MultiLineString' && multiCurve === true) {
        nodeName = 'MultiCurve';
      }
    } else {
      nodeName = 'Envelope';
    }
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])('http://www.opengis.net/gml', nodeName);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(node, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node.setAttribute('fid', /** @type {string} */ (fid));
    }
    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    const featureNS = context['featureNS'];
    const geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    const keys = [];
    const values = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (
            key == geometryName ||
            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===
              'function'
          ) {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
                this.writeGeometryElement,
                this
              );
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] =
                Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_5__["writeStringTextNode"]);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context);
    item.node = node;
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      (item),
      context.serializers,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeSimpleNodeFactory"])(undefined, featureNS),
      values,
      objectStack,
      keys
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (node.nodeName !== 'LineStringSegment' && srsName) {
      node.setAttribute('srsName', srsName);
    }
    if (
      node.nodeName === 'LineString' ||
      node.nodeName === 'LineStringSegment'
    ) {
      const coordinates = this.createCoordinatesNode_(node.namespaceURI);
      node.appendChild(coordinates);
      this.writeCoordinates_(coordinates, geometry, objectStack);
    } else if (node.nodeName === 'Curve') {
      const segments = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'segments');
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(node, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    const curve = context['curve'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const lines = geometry.getLineStrings();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      lines,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(node, geometry, objectStack) {
    const context = /** @type {import("./Feature.js").WriteOptions} */ (
      objectStack[objectStack.length - 1]
    );
    const item = Object.assign({}, context);
    item['node'] = node;
    let value;
    if (Array.isArray(geometry)) {
      value = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_4__["transformExtentWithOptions"])(
        /** @type {import("../extent.js").Extent} */ (geometry),
        context
      );
    } else {
      value = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_4__["transformGeometryWithOptions"])(
        /** @type {import("../geom/Geometry.js").default} */ (geometry),
        true,
        context
      );
    }
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      (item),
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [value],
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(namespaceURI) {
    const coordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(namespaceURI, 'coordinates');
    coordinates.setAttribute('decimal', '.');
    coordinates.setAttribute('cs', ',');
    coordinates.setAttribute('ts', ' ');

    return coordinates;
  }

  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    // only 2d for simple features profile
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    for (let i = 0; i < len; ++i) {
      const point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_5__["writeStringTextNode"])(node, parts.join(' '));
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(node, line, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'LineStringSegment');
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    if (node.nodeName !== 'PolygonPatch' && srsName) {
      node.setAttribute('srsName', srsName);
    }
    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
      const rings = geometry.getLinearRings();
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
        {node: node, hasZ: hasZ, srsName: srsName},
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        rings,
        objectStack,
        undefined,
        this
      );
    } else if (node.nodeName === 'Surface') {
      const patches = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'patches');
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }

  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const parentNode = context.node;
    const exteriorWritten = context['exteriorWritten'];
    if (exteriorWritten === undefined) {
      context['exteriorWritten'] = true;
    }
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(
      parentNode.namespaceURI,
      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs'
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(node, polygon, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'PolygonPatch');
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(node, ring, objectStack) {
    const linearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'LinearRing');
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  }

  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = 'enu';
    if (srsName) {
      axisOrientation = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["get"])(srsName).getAxisOrientation();
    }
    let coords =
      axisOrientation.substr(0, 2) === 'en'
        ? point[0] + ',' + point[1]
        : point[1] + ',' + point[0];
    if (hasZ) {
      // For newly created points, Z can be undefined.
      const z = point[2] || 0;
      coords += ',' + z;
    }

    return coords;
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    const point = geometry.getCoordinates();
    const coord = this.getCoords_(point, srsName, hasZ);
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_5__["writeStringTextNode"])(coordinates, coord);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const points = geometry.getPoints();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName},
      this.POINTMEMBER_SERIALIZERS,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeSimpleNodeFactory"])('pointMember'),
      points,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(node, point, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(node.namespaceURI, 'Point');
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    this.writeCoordinates_(coordinates, geometry, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    const surface = context['surface'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const polygons = geometry.getPolygons();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      polygons,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(node, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(node, extent, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const keys = ['lowerCorner', 'upperCorner'];
    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      ({node: node}),
      this.ENVELOPE_SERIALIZERS,
      _xml_js__WEBPACK_IMPORTED_MODULE_1__["OBJECT_PROPERTY_NODE_FACTORY"],
      values,
      objectStack,
      keys,
      this
    );
  }

  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["createElementNS"])(
      'http://www.opengis.net/gml',
      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]
    );
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {
    'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(GML2.prototype.readFlatCoordinates),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {
    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,
    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML2.prototype.BOX_PARSERS_ = {
  'http://www.opengis.net/gml': {
    'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeArrayPusher"])(GML2.prototype.readFlatCoordinates),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML2.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readPoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readMultiLineString),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readMultiPolygon),
    'Box': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeReplacer"])(GML2.prototype.readBox),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeCurveOrLineString),
    'MultiCurve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeMultiCurveOrLineString),
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writePoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeCurveOrLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeMultiCurveOrLineString
    ),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeSurfaceOrPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeMultiSurfaceOrPolygon
    ),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeSurfaceOrPolygon),
    'MultiSurface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeMultiSurfaceOrPolygon
    ),
    'Envelope': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeEnvelope),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeLineStringOrCurveMember
    ),
    'curveMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeLineStringOrCurveMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'outerBoundaryIs': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeRing),
    'innerBoundaryIs': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writeRing),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'pointMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(GML2.prototype.writePointMember),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeSurfaceOrPolygonMember
    ),
    'polygonMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(
      GML2.prototype.writeSurfaceOrPolygonMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML2.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_5__["writeStringTextNode"]),
    'upperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_5__["writeStringTextNode"]),
  },
};

/* harmony default export */ __webpack_exports__["default"] = (GML2);


/***/ }),

/***/ "./node_modules/ol/format/GML3.js":
/*!****************************************!*\
  !*** ./node_modules/ol/format/GML3.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML2.js */ "./node_modules/ol/format/GML2.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GMLBase.js */ "./node_modules/ol/format/GMLBase.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/GML3
 */













/**
 * @const
 * @type {string}
 * @private
 */
const schemaLocation =
  _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["GMLNS"] +
  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +
  '1.0.0/gmlsf.xsd';

/**
 * @const
 * @type {Object<string, string>}
 */
const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  'MultiLineString': 'lineStringMember',
  'MultiCurve': 'curveMember',
  'MultiPolygon': 'polygonMember',
  'MultiSurface': 'surfaceMember',
};

/**
 * @classdesc
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @api
 */
class GML3 extends _GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(options) {
    options = options ? options : {};

    super(options);

    /**
     * @private
     * @type {boolean}
     */
    this.surface_ = options.surface !== undefined ? options.surface : false;

    /**
     * @private
     * @type {boolean}
     */
    this.curve_ = options.curve !== undefined ? options.curve : false;

    /**
     * @private
     * @type {boolean}
     */
    this.multiCurve_ =
      options.multiCurve !== undefined ? options.multiCurve : true;

    /**
     * @private
     * @type {boolean}
     */
    this.multiSurface_ =
      options.multiSurface !== undefined ? options.multiSurface : true;

    /**
     * @type {string}
     */
    this.schemaLocation = options.schemaLocation
      ? options.schemaLocation
      : schemaLocation;

    /**
     * @private
     * @type {boolean}
     */
    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(node, objectStack) {
    /** @type {Array<LineString>} */
    const lineStrings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [],
      this.MULTICURVE_PARSERS,
      node,
      objectStack,
      this
    );
    if (lineStrings) {
      const multiLineString = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](lineStrings);
      return multiLineString;
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(node, objectStack) {
    /** @type {Array<LineString>} */
    const lineStrings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [],
      this.MULTICURVE_PARSERS,
      node,
      objectStack,
      this
    );
    const flatCoordinates = [];
    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_8__["extend"])(flatCoordinates, lineStrings[i].getFlatCoordinates());
    }
    return flatCoordinates;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(node, objectStack) {
    /** @type {Array<Polygon>} */
    const polygons = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [],
      this.MULTISURFACE_PARSERS,
      node,
      objectStack,
      this
    );
    if (polygons) {
      return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_4__["default"](polygons);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(node, objectStack) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["parseNode"])(this.CURVEMEMBER_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(node, objectStack) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["parseNode"])(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(node, objectStack) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.PATCHES_PARSERS,
      node,
      objectStack,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(node, objectStack) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])([], this.SEGMENTS_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(node, objectStack) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      node,
      objectStack,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(node, objectStack) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(node, objectStack) {
    /** @type {Array<number>|undefined} */
    const flatLinearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      undefined,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings =
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
      flatLinearRings.push(flatLinearRing);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(node, objectStack) {
    /** @type {Array<number>|undefined} */
    const flatLinearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      undefined,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings =
        /** @type {Array<Array<number>>} */
        (objectStack[objectStack.length - 1]);
      flatLinearRings[0] = flatLinearRing;
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(node, objectStack) {
    /** @type {Array<Array<number>>} */
    const flatLinearRings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.SURFACE_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i, ii;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_8__["extend"])(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates, 'XYZ', ends);
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(node, objectStack) {
    /** @type {Array<number>} */
    const flatCoordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.CURVE_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatCoordinates) {
      const lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__["default"](flatCoordinates, 'XYZ');
      return lineString;
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(node, objectStack) {
    /** @type {Array<number>} */
    const flatCoordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushParseAndPop"])(
      [null],
      this.ENVELOPE_PARSERS,
      node,
      objectStack,
      this
    );
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(
      flatCoordinates[1][0],
      flatCoordinates[1][1],
      flatCoordinates[2][0],
      flatCoordinates[2][1]
    );
  }

  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(node, objectStack) {
    let s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["getAllTextContent"])(node, false);
    const re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    /** @type {Array<number>} */
    const flatCoordinates = [];
    let m;
    while ((m = re.exec(s))) {
      flatCoordinates.push(parseFloat(m[1]));
      s = s.substr(m[0].length);
    }
    if (s !== '') {
      return undefined;
    }
    const context = objectStack[0];
    const containerSrs = context['srsName'];
    let axisOrientation = 'enu';
    if (containerSrs) {
      const proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    if (axisOrientation === 'neu') {
      let i, ii;
      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
        const y = flatCoordinates[i];
        const x = flatCoordinates[i + 1];
        flatCoordinates[i] = x;
        flatCoordinates[i + 1] = y;
      }
    }
    const len = flatCoordinates.length;
    if (len == 2) {
      flatCoordinates.push(0);
    }
    if (len === 0) {
      return undefined;
    }
    return flatCoordinates;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(node, objectStack) {
    const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["getAllTextContent"])(node, false).replace(/^\s*|\s*$/g, '');
    const context = objectStack[0];
    const containerSrs = context['srsName'];
    const contextDimension = context['srsDimension'];
    let axisOrientation = 'enu';
    if (containerSrs) {
      const proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    const coords = s.split(/\s+/);
    // The "dimension" attribute is from the GML 3.0.1 spec.
    let dim = 2;
    if (node.getAttribute('srsDimension')) {
      dim = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["readNonNegativeIntegerString"])(node.getAttribute('srsDimension'));
    } else if (node.getAttribute('dimension')) {
      dim = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["readNonNegativeIntegerString"])(node.getAttribute('dimension'));
    } else if (
      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')
    ) {
      dim = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["readNonNegativeIntegerString"])(
        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')
      );
    } else if (contextDimension) {
      dim = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["readNonNegativeIntegerString"])(contextDimension);
    }
    let x, y, z;
    const flatCoordinates = [];
    for (let i = 0, ii = coords.length; i < ii; i += dim) {
      x = parseFloat(coords[i]);
      y = parseFloat(coords[i + 1]);
      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
      if (axisOrientation.substr(0, 2) === 'en') {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsDimension = hasZ ? '3' : '2';
    node.setAttribute('srsDimension', srsDimension);
    const srsName = context['srsName'];
    let axisOrientation = 'enu';
    if (srsName) {
      axisOrientation = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])(srsName).getAxisOrientation();
    }
    const point = value.getCoordinates();
    let coords;
    // only 2d for simple features profile
    if (axisOrientation.substr(0, 2) === 'en') {
      coords = point[0] + ' ' + point[1];
    } else {
      coords = point[1] + ' ' + point[0];
    }
    if (hasZ) {
      // For newly created points, Z can be undefined.
      const z = point[2] || 0;
      coords += ' ' + z;
    }
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["writeStringTextNode"])(node, coords);
  }

  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = 'enu';
    if (srsName) {
      axisOrientation = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])(srsName).getAxisOrientation();
    }
    let coords =
      axisOrientation.substr(0, 2) === 'en'
        ? point[0] + ' ' + point[1]
        : point[1] + ' ' + point[0];
    if (hasZ) {
      // For newly created points, Z can be undefined.
      const z = point[2] || 0;
      coords += ' ' + z;
    }

    return coords;
  }

  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsDimension = hasZ ? '3' : '2';
    node.setAttribute('srsDimension', srsDimension);
    const srsName = context['srsName'];
    // only 2d for simple features profile
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    let point;
    for (let i = 0; i < len; ++i) {
      point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["writeStringTextNode"])(node, parts.join(' '));
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const pos = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'pos');
    node.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(node, extent, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const keys = ['lowerCorner', 'upperCorner'];
    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      ({node: node}),
      this.ENVELOPE_SERIALIZERS,
      _xml_js__WEBPACK_IMPORTED_MODULE_6__["OBJECT_PROPERTY_NODE_FACTORY"],
      values,
      objectStack,
      keys,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const posList = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'posList');
    node.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  }

  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const parentNode = context.node;
    const exteriorWritten = context['exteriorWritten'];
    if (exteriorWritten === undefined) {
      context['exteriorWritten'] = true;
    }
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(
      parentNode.namespaceURI,
      exteriorWritten !== undefined ? 'interior' : 'exterior'
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    if (node.nodeName !== 'PolygonPatch' && srsName) {
      node.setAttribute('srsName', srsName);
    }
    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
      const rings = geometry.getLinearRings();
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
        {node: node, hasZ: hasZ, srsName: srsName},
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        rings,
        objectStack,
        undefined,
        this
      );
    } else if (node.nodeName === 'Surface') {
      const patches = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'patches');
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    if (node.nodeName !== 'LineStringSegment' && srsName) {
      node.setAttribute('srsName', srsName);
    }
    if (
      node.nodeName === 'LineString' ||
      node.nodeName === 'LineStringSegment'
    ) {
      const posList = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'posList');
      node.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node.nodeName === 'Curve') {
      const segments = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'segments');
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    const surface = context['surface'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const polygons = geometry.getPolygons();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      polygons,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context['srsName'];
    const hasZ = context['hasZ'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const points = geometry.getPoints();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName},
      this.POINTMEMBER_SERIALIZERS,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeSimpleNodeFactory"])('pointMember'),
      points,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context['hasZ'];
    const srsName = context['srsName'];
    const curve = context['curve'];
    if (srsName) {
      node.setAttribute('srsName', srsName);
    }
    const lines = geometry.getLineStrings();
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      lines,
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(node, ring, objectStack) {
    const linearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'LinearRing');
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  }

  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(node, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(node, point, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'Point');
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  }

  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(node, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(node, polygon, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'PolygonPatch');
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }

  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(node, line, objectStack) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(node.namespaceURI, 'LineStringSegment');
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }

  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(node, geometry, objectStack) {
    const context = /** @type {import("./Feature.js").WriteOptions} */ (
      objectStack[objectStack.length - 1]
    );
    const item = Object.assign({}, context);
    item['node'] = node;
    let value;
    if (Array.isArray(geometry)) {
      value = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_11__["transformExtentWithOptions"])(
        /** @type {import("../extent.js").Extent} */ (geometry),
        context
      );
    } else {
      value = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_11__["transformGeometryWithOptions"])(
        /** @type {import("../geom/Geometry.js").default} */ (geometry),
        true,
        context
      );
    }
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      (item),
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [value],
      objectStack,
      undefined,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(node, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node.setAttribute('fid', /** @type {string} */ (fid));
    }
    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    const featureNS = context['featureNS'];
    const geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    const keys = [];
    const values = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (
            key == geometryName ||
            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===
              'function'
          ) {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
                this.writeGeometryElement,
                this
              );
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] =
                Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["writeStringTextNode"]);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context);
    item.node = node;
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      (item),
      context.serializers,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeSimpleNodeFactory"])(undefined, featureNS),
      values,
      objectStack,
      keys
    );
  }

  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(node, features, objectStack) {
    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
    const featureType = context['featureType'];
    const featureNS = context['featureNS'];
    /** @type {Object<string, Object<string, import("../xml.js").Serializer>>} */
    const serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      this.writeFeatureElement,
      this
    );
    const item = Object.assign({}, context);
    item.node = node;
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      (item),
      serializers,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeSimpleNodeFactory"])(featureType, featureNS),
      features,
      objectStack
    );
  }

  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(
      this.namespace,
      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]
    );
  }

  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const multiSurface = context['multiSurface'];
    const surface = context['surface'];
    const curve = context['curve'];
    const multiCurve = context['multiCurve'];
    if (!Array.isArray(value)) {
      nodeName = /** @type {import("../geom/Geometry.js").default} */ (
        value
      ).getType();
      if (nodeName === 'MultiPolygon' && multiSurface === true) {
        nodeName = 'MultiSurface';
      } else if (nodeName === 'Polygon' && surface === true) {
        nodeName = 'Surface';
      } else if (nodeName === 'LineString' && curve === true) {
        nodeName = 'Curve';
      } else if (nodeName === 'MultiLineString' && multiCurve === true) {
        nodeName = 'MultiCurve';
      }
    } else {
      nodeName = 'Envelope';
    }
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(this.namespace, nodeName);
  }

  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(geometry, options) {
    options = this.adaptOptions(options);
    const geom = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(this.namespace, 'geom');
    const context = {
      node: geom,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
    };
    if (options) {
      Object.assign(context, options);
    }
    this.writeGeometryElement(geom, geometry, [context]);
    return geom;
  }

  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const node = Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["createElementNS"])(this.namespace, 'featureMembers');
    node.setAttributeNS(
      _xml_js__WEBPACK_IMPORTED_MODULE_6__["XML_SCHEMA_INSTANCE_URI"],
      'xsi:schemaLocation',
      this.schemaLocation
    );
    const context = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType,
    };
    if (options) {
      Object.assign(context, options);
    }
    this.writeFeatureMembers_(node, features, [context]);
    return node;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {
    'pos': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readFlatPos),
    'posList': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readFlatPosList),
    'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatCoordinates),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {
    'interior': GML3.prototype.interiorParser,
    'exterior': GML3.prototype.exteriorParser,
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiLineString),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiPolygon),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readSurface),
    'MultiSurface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readMultiSurface),
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readCurve),
    'MultiCurve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readMultiCurve),
    'Envelope': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readEnvelope),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.MULTICURVE_PARSERS = {
  'http://www.opengis.net/gml': {
    'curveMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.curveMemberParser),
    'curveMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.curveMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.MULTISURFACE_PARSERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.surfaceMemberParser),
    'surfaceMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.surfaceMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.CURVEMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineString),
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.readCurve),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.SURFACEMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygon),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.readSurface),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.SURFACE_PARSERS = {
  'http://www.opengis.net/gml': {
    'patches': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readPatch),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.CURVE_PARSERS = {
  'http://www.opengis.net/gml': {
    'segments': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readSegment),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.ENVELOPE_PARSERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.readFlatPosList),
    'upperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayPusher"])(GML3.prototype.readFlatPosList),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.PATCHES_PARSERS = {
  'http://www.opengis.net/gml': {
    'PolygonPatch': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readPolygonPatch),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML3.prototype.SEGMENTS_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineStringSegment': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeArrayExtender"])(
      GML3.prototype.readLineStringSegment
    ),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.RING_PARSERS = {
  'http://www.opengis.net/gml': {
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readFlatLinearRing),
    'Ring': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeReplacer"])(GML3.prototype.readFlatCurveRing),
  },
};

/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [options] Options.
 * @return {string} Result.
 * @api
 */
GML3.prototype.writeFeatures;

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'exterior': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeRing),
    'interior': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeRing),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["writeStringTextNode"]),
    'upperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_10__["writeStringTextNode"]),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'surfaceMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeSurfaceOrPolygonMember
    ),
    'polygonMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeSurfaceOrPolygonMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'pointMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writePointMember),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeLineStringOrCurveMember
    ),
    'curveMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeLineStringOrCurveMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML3.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml': {
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeCurveOrLineString),
    'MultiCurve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeMultiCurveOrLineString),
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writePoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeCurveOrLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeMultiCurveOrLineString
    ),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeSurfaceOrPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeMultiSurfaceOrPolygon
    ),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeSurfaceOrPolygon),
    'MultiSurface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(
      GML3.prototype.writeMultiSurfaceOrPolygon
    ),
    'Envelope': Object(_xml_js__WEBPACK_IMPORTED_MODULE_6__["makeChildAppender"])(GML3.prototype.writeEnvelope),
  },
};

/* harmony default export */ __webpack_exports__["default"] = (GML3);


/***/ }),

/***/ "./node_modules/ol/format/GML32.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/format/GML32.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML2.js */ "./node_modules/ol/format/GML2.js");
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GML3.js */ "./node_modules/ol/format/GML3.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GMLBase.js */ "./node_modules/ol/format/GMLBase.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _format_xsd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../format/xsd.js */ "./node_modules/ol/format/xsd.js");
/**
 * @module ol/format/GML32
 */






/**
 * @classdesc Feature format for reading and writing data in the GML format
 *            version 3.2.1.
 * @api
 */
class GML32 extends _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(options) {
    options = options ? options : {};

    super(options);

    /**
     * @type {string}
     */
    this.schemaLocation = options.schemaLocation
      ? options.schemaLocation
      : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';
  }

  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    objectStack[objectStack.length - 1] = Object.assign(
      {multiCurve: true, multiSurface: true},
      context
    );
    super.writeGeometryElement(node, geometry, objectStack);
  }
}

GML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'pos': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readFlatPos),
    'posList': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readFlatPosList),
    'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.readFlatCoordinates),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'interior': _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.interiorParser,
    'exterior': _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.exteriorParser,
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readPoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readMultiLineString),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readMultiPolygon),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(GML32.prototype.readSurface),
    'MultiSurface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiSurface),
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(GML32.prototype.readCurve),
    'MultiCurve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readMultiCurve),
    'Envelope': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(GML32.prototype.readEnvelope),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.MULTICURVE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'curveMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.curveMemberParser),
    'curveMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.curveMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.MULTISURFACE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'surfaceMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.surfaceMemberParser),
    'surfaceMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.surfaceMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.CURVEMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readLineString),
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readCurve),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.SURFACEMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readPolygon),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readSurface),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.SURFACE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'patches': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPatch),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.CURVE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'segments': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readSegment),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.ENVELOPE_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'lowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readFlatPosList),
    'upperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readFlatPosList),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.PATCHES_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'PolygonPatch': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readPolygonPatch),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.SEGMENTS_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineStringSegment': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayExtender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.readLineStringSegment
    ),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.MULTIPOINT_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'pointMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.pointMemberParser),
    'pointMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.pointMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.MULTILINESTRING_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'lineStringMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(
      _GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.lineStringMemberParser
    ),
    'lineStringMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(
      _GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.lineStringMemberParser
    ),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.MULTIPOLYGON_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'polygonMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.polygonMemberParser),
    'polygonMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.polygonMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.POINTMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readFlatCoordinatesFromNode),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readLineString),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.POLYGONMEMBER_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readPolygon),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GML32.prototype.RING_PARSERS = {
  'http://www.opengis.net/gml/3.2': {
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.readFlatLinearRing),
    'Ring': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeReplacer"])(GML32.prototype.readFlatCurveRing),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.RING_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'exterior': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeRing),
    'interior': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeRing),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.ENVELOPE_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'lowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["writeStringTextNode"]),
    'upperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_format_xsd_js__WEBPACK_IMPORTED_MODULE_4__["writeStringTextNode"]),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'surfaceMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeSurfaceOrPolygonMember
    ),
    'polygonMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeSurfaceOrPolygonMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.POINTMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'pointMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writePointMember),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'lineStringMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeLineStringOrCurveMember
    ),
    'curveMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeLineStringOrCurveMember
    ),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
GML32.prototype.GEOMETRY_SERIALIZERS = {
  'http://www.opengis.net/gml/3.2': {
    'Curve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeCurveOrLineString),
    'MultiCurve': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeMultiCurveOrLineString),
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(GML32.prototype.writePoint),
    'MultiPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeMultiPoint),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeCurveOrLineString),
    'MultiLineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeMultiCurveOrLineString
    ),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeLinearRing),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeSurfaceOrPolygon),
    'MultiPolygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeMultiSurfaceOrPolygon
    ),
    'Surface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeSurfaceOrPolygon),
    'MultiSurface': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(
      _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeMultiSurfaceOrPolygon
    ),
    'Envelope': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeChildAppender"])(_GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeEnvelope),
  },
};

/* harmony default export */ __webpack_exports__["default"] = (GML32);


/***/ }),

/***/ "./node_modules/ol/format/GMLBase.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/GMLBase.js ***!
  \*******************************************/
/*! exports provided: GMLNS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GMLNS", function() { return GMLNS; });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_Geometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./XMLFeature.js */ "./node_modules/ol/format/XMLFeature.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/GMLBase
 */
// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part
// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect
// envelopes/extents, only geometries!















/**
 * @const
 * @type {string}
 */
const GMLNS = 'http://www.opengis.net/gml';

/**
 * A regular expression that matches if a string only contains whitespace
 * characters. It will e.g. match `''`, `' '`, `'\n'` etc.
 *
 * @const
 * @type {RegExp}
 */
const ONLY_WHITESPACE_RE = /^\s*$/;

/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] Feature
 * namespace. If not defined will be derived from GML. If multiple
 * feature types have been configured which come from different feature
 * namespaces, this will be an object with the keys being the prefixes used
 * in the entries of featureType array. The values of the object will be the
 * feature namespaces themselves. So for instance there might be a featureType
 * item `topp:states` in the `featureType` array and then there will be a key
 * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
 * @property {Array<string>|string} [featureType] Feature type(s) to parse.
 * If multiple feature types need to be configured
 * which come from different feature namespaces, `featureNS` will be an object
 * with the keys being the prefixes used in the entries of featureType array.
 * The values of the object will be the feature namespaces themselves.
 * So for instance there might be a featureType item `topp:states` and then
 * there will be a key named `topp` in the featureNS object with value
 * `http://www.openplans.org/topp`.
 * @property {string} [srsName] srsName to use when writing geometries.
 * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.
 * Since the latter is deprecated in GML 3.
 * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of
 * gml:MultiPolygon. Since the latter is deprecated in GML 3.
 * @property {string} [schemaLocation] Optional schemaLocation to use when
 * writing out the GML, this will override the default provided.
 * @property {boolean} [hasZ=false] If coordinates have a Z value.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes GML2 and GML3.
 *
 * @abstract
 * @api
 */
class GMLBase extends _XMLFeature_js__WEBPACK_IMPORTED_MODULE_9__["default"] {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @protected
     * @type {Array<string>|string|undefined}
     */
    this.featureType = options.featureType;

    /**
     * @protected
     * @type {Object<string, string>|string|undefined}
     */
    this.featureNS = options.featureNS;

    /**
     * @protected
     * @type {string|undefined}
     */
    this.srsName = options.srsName;

    /**
     * @protected
     * @type {string}
     */
    this.schemaLocation = '';

    /**
     * @type {Object<string, Object<string, Object>>}
     */
    this.FEATURE_COLLECTION_PARSERS = {};
    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      'featureMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(this.readFeaturesInternal),
      'featureMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeReplacer"])(this.readFeaturesInternal),
    };

    this.supportedMediaTypes = ['application/gml+xml'];
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(node, objectStack) {
    const localName = node.localName;
    let features = null;
    if (localName == 'FeatureCollection') {
      features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        node,
        objectStack,
        this
      );
    } else if (
      localName == 'featureMembers' ||
      localName == 'featureMember' ||
      localName == 'member'
    ) {
      const context = objectStack[0];
      let featureType = context['featureType'];
      let featureNS = context['featureNS'];
      const prefix = 'p';
      const defaultPrefix = 'p0';
      if (!featureType && node.childNodes) {
        (featureType = []), (featureNS = {});
        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {
          const child = /** @type {Element} */ (node.childNodes[i]);
          if (child.nodeType === 1) {
            const ft = child.nodeName.split(':').pop();
            if (!featureType.includes(ft)) {
              let key = '';
              let count = 0;
              const uri = child.namespaceURI;
              for (const candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ':' + ft);
            }
          }
        }
        if (localName != 'featureMember') {
          // recheck featureType for each featureMember
          context['featureType'] = featureType;
          context['featureNS'] = featureNS;
        }
      }
      if (typeof featureNS === 'string') {
        const ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */
      const parsersNS = {};
      const featureTypes = Array.isArray(featureType)
        ? featureType
        : [featureType];
      for (const p in featureNS) {
        /** @type {Object<string, import("../xml.js").Parser>} */
        const parsers = {};
        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {
          const featurePrefix = featureTypes[i].includes(':')
            ? featureTypes[i].split(':')[0]
            : defaultPrefix;
          if (featurePrefix === p) {
            parsers[featureTypes[i].split(':').pop()] =
              localName == 'featureMembers'
                ? Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(this.readFeatureElement, this)
                : Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeReplacer"])(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p]] = parsers;
      }
      if (localName == 'featureMember' || localName == 'member') {
        features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(undefined, parsersNS, node, objectStack);
      } else {
        features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])([], parsersNS, node, objectStack);
      }
    }
    if (features === null) {
      features = [];
    }
    return features;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(node, objectStack) {
    const context = /** @type {Object} */ (objectStack[0]);
    context['srsName'] = node.firstElementChild.getAttribute('srsName');
    context['srsDimension'] =
      node.firstElementChild.getAttribute('srsDimension');
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      null,
      this.GEOMETRY_PARSERS,
      node,
      objectStack,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(node, objectStack) {
    const context = /** @type {Object} */ (objectStack[0]);
    const extent = /** @type {import("../extent.js").Extent} */ (
      this.readGeometryOrExtent(node, objectStack)
    );
    return extent ? Object(_Feature_js__WEBPACK_IMPORTED_MODULE_13__["transformExtentWithOptions"])(extent, context) : undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(node, objectStack) {
    const context = /** @type {Object} */ (objectStack[0]);
    const geometry = /** @type {import("../geom/Geometry.js").default} */ (
      this.readGeometryOrExtent(node, objectStack)
    );
    return geometry
      ? Object(_Feature_js__WEBPACK_IMPORTED_MODULE_13__["transformGeometryWithOptions"])(geometry, false, context)
      : undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(node, objectStack, asFeature) {
    let geometryName;
    const values = {};
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      let value;
      const localName = n.localName;
      // first, check if it is simple attribute
      if (
        n.childNodes.length === 0 ||
        (n.childNodes.length === 1 &&
          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))
      ) {
        value = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["getAllTextContent"])(n, false);
        if (ONLY_WHITESPACE_RE.test(value)) {
          value = undefined;
        }
      } else {
        if (asFeature) {
          //if feature, try it as a geometry or extent
          value =
            localName === 'boundedBy'
              ? this.readExtentElement(n, objectStack)
              : this.readGeometryElement(n, objectStack);
        }
        if (!value) {
          //if not a geometry or not a feature, treat it as a complex attribute
          value = this.readFeatureElementInternal(n, objectStack, false);
        } else if (localName !== 'boundedBy') {
          // boundedBy is an extent and must not be considered as a geometry
          geometryName = localName;
        }
      }

      const len = n.attributes.length;
      if (len > 0 && !(value instanceof _geom_Geometry_js__WEBPACK_IMPORTED_MODULE_1__["default"])) {
        value = {_content_: value};
        for (let i = 0; i < len; i++) {
          const attName = n.attributes[i].name;
          value[attName] = n.attributes[i].value;
        }
      }

      if (values[localName]) {
        if (!(values[localName] instanceof Array)) {
          values[localName] = [values[localName]];
        }
        values[localName].push(value);
      } else {
        values[localName] = value;
      }
    }
    if (!asFeature) {
      return values;
    }
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](values);
    if (geometryName) {
      feature.setGeometryName(geometryName);
    }
    const fid =
      node.getAttribute('fid') || Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["getAttributeNS"])(node, this.namespace, 'id');
    if (fid) {
      feature.setId(fid);
    }
    return feature;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(node, objectStack) {
    return this.readFeatureElementInternal(node, objectStack, true);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__["default"](flatCoordinates, 'XYZ');
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(node, objectStack) {
    /** @type {Array<Array<number>>} */
    const coordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      [],
      this.MULTIPOINT_PARSERS,
      node,
      objectStack,
      this
    );
    if (coordinates) {
      return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__["default"](coordinates);
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(node, objectStack) {
    /** @type {Array<LineString>} */
    const lineStrings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      [],
      this.MULTILINESTRING_PARSERS,
      node,
      objectStack,
      this
    );
    if (lineStrings) {
      return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](lineStrings);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(node, objectStack) {
    /** @type {Array<Polygon>} */
    const polygons = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      [],
      this.MULTIPOLYGON_PARSERS,
      node,
      objectStack,
      this
    );
    if (polygons) {
      return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](polygons);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(node, objectStack) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["parseNode"])(this.POINTMEMBER_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(node, objectStack) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["parseNode"])(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(node, objectStack) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["parseNode"])(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      const lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__["default"](flatCoordinates, 'XYZ');
      return lineString;
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(node, objectStack) {
    const ring = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
    if (ring) {
      return ring;
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_3__["default"](flatCoordinates, 'XYZ');
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(node, objectStack) {
    /** @type {Array<Array<number>>} */
    const flatLinearRings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i, ii;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_10__["extend"])(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["default"](flatCoordinates, 'XYZ', ends);
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(node, objectStack) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["pushParseAndPop"])(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(node, options) {
    const geometry = this.readGeometryElement(node, [
      this.getReadOptions(node, options ? options : {}),
    ]);
    return geometry ? geometry : null;
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    const internalOptions = {
      featureType: this.featureType,
      featureNS: this.featureNS,
    };
    if (internalOptions) {
      Object.assign(internalOptions, this.getReadOptions(node, options));
    }
    const features = this.readFeaturesInternal(node, [internalOptions]);
    return features || [];
  }

  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(node) {
    return Object(_proj_js__WEBPACK_IMPORTED_MODULE_12__["get"])(
      this.srsName
        ? this.srsName
        : node.firstElementChild.getAttribute('srsName')
    );
  }
}

GMLBase.prototype.namespace = GMLNS;

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  'http://www.opengis.net/gml': {},
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  'http://www.opengis.net/gml': {},
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.GEOMETRY_PARSERS = {
  'http://www.opengis.net/gml': {},
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.MULTIPOINT_PARSERS = {
  'http://www.opengis.net/gml': {
    'pointMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.pointMemberParser),
    'pointMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.pointMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.MULTILINESTRING_PARSERS = {
  'http://www.opengis.net/gml': {
    'lineStringMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(
      GMLBase.prototype.lineStringMemberParser
    ),
    'lineStringMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(
      GMLBase.prototype.lineStringMemberParser
    ),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  'http://www.opengis.net/gml': {
    'polygonMember': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.polygonMemberParser),
    'polygonMembers': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.polygonMemberParser),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.POINTMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.readFlatCoordinatesFromNode),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.readLineString),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  'http://www.opengis.net/gml': {
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeArrayPusher"])(GMLBase.prototype.readPolygon),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
GMLBase.prototype.RING_PARSERS = {
  'http://www.opengis.net/gml': {
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_11__["makeReplacer"])(GMLBase.prototype.readFlatLinearRing),
  },
};

/* harmony default export */ __webpack_exports__["default"] = (GMLBase);


/***/ }),

/***/ "./node_modules/ol/format/GPX.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/GPX.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XMLFeature.js */ "./node_modules/ol/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/GPX
 */










/**
 * @const
 * @type {Array<null|string>}
 */
const NAMESPACE_URIS = [
  null,
  'http://www.topografix.com/GPX/1/0',
  'http://www.topografix.com/GPX/1/1',
];

/**
 * @const
 * @type {string}
 */
const SCHEMA_LOCATION =
  'http://www.topografix.com/GPX/1/1 ' +
  'http://www.topografix.com/GPX/1/1/gpx.xsd';

/**
 * @const
 * @type {Object<string, function(Node, Array<*>): (Feature|undefined)>}
 */
const FEATURE_READER = {
  'rte': readRte,
  'trk': readTrk,
  'wpt': readWpt,
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const GPX_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'rte': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(readRte),
  'trk': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(readTrk),
  'wpt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(readWpt),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LINK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'text': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"], 'linkText'),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"], 'linkType'),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const GPX_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'rte': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeRte),
  'trk': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeTrk),
  'wpt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeWpt),
});

/**
 * @typedef {Object} Options
 * @property {function(Feature, Node):void} [readExtensions] Callback function
 * to process `extensions` nodes. To prevent memory leaks, this callback function must
 * not store any references to the node. Note that the `extensions`
 * node is not allowed in GPX 1.0. Moreover, only `extensions`
 * nodes from `wpt`, `rte` and `trk` can be processed, as those are
 * directly mapped to a feature.
 */

/**
 * @typedef {Object} LayoutOptions
 * @property {boolean} [hasZ] HasZ.
 * @property {boolean} [hasM] HasM.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GPX format.
 *
 * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first
 * feature of the source.
 *
 * When reading, routes (`<rte>`) are converted into LineString geometries, and
 * tracks (`<trk>`) into MultiLineString. Any properties on route and track
 * waypoints are ignored.
 *
 * When writing, LineString geometries are output as routes (`<rte>`), and
 * MultiLineString as tracks (`<trk>`).
 *
 * @api
 */
class GPX extends _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_6__["get"])('EPSG:4326');

    /**
     * @type {function(Feature, Node): void|undefined}
     * @private
     */
    this.readExtensions_ = options.readExtensions;
  }

  /**
   * @param {Array<Feature>} features List of features.
   * @private
   */
  handleReadExtensions_(features) {
    if (!features) {
      features = [];
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      const feature = features[i];
      if (this.readExtensions_) {
        const extensionsNode = feature.get('extensionsNode_') || null;
        this.readExtensions_(feature, extensionsNode);
      }
      feature.set('extensionsNode_', undefined);
    }
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return null;
    }
    const featureReader = FEATURE_READER[node.localName];
    if (!featureReader) {
      return null;
    }
    const feature = featureReader(node, [this.getReadOptions(node, options)]);
    if (!feature) {
      return null;
    }
    this.handleReadExtensions_([feature]);
    return feature;
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return [];
    }
    if (node.localName == 'gpx') {
      /** @type {Array<Feature>} */
      const features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])([], GPX_PARSERS, node, [
        this.getReadOptions(node, options),
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      }
      return [];
    }
    return [];
  }

  /**
   * Encode an array of features in the GPX format as an XML node.
   * LineString geometries are output as routes (`<rte>`), and MultiLineString
   * as tracks (`<trk>`).
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    //FIXME Serialize metadata
    const gpx = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])('http://www.topografix.com/GPX/1/1', 'gpx');
    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';
    gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', _xml_js__WEBPACK_IMPORTED_MODULE_5__["XML_SCHEMA_INSTANCE_URI"]);
    gpx.setAttributeNS(
      _xml_js__WEBPACK_IMPORTED_MODULE_5__["XML_SCHEMA_INSTANCE_URI"],
      'xsi:schemaLocation',
      SCHEMA_LOCATION
    );
    gpx.setAttribute('version', '1.1');
    gpx.setAttribute('creator', 'OpenLayers');

    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */
      ({node: gpx}),
      GPX_SERIALIZERS,
      GPX_NODE_FACTORY,
      features,
      [options]
    );
    return gpx;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const RTE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'link': parseLink,
  'number': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readPositiveInteger"]),
  'extensions': parseExtensions,
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'rtept': parseRtePt,
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const RTEPT_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'ele': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'time': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDateTime"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TRK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'link': parseLink,
  'number': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readPositiveInteger"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'extensions': parseExtensions,
  'trkseg': parseTrkSeg,
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TRKSEG_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'trkpt': parseTrkPt,
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TRKPT_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'ele': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'time': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDateTime"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const WPT_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'ele': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'time': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDateTime"]),
  'magvar': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'geoidheight': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'link': parseLink,
  'sym': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'fix': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readString"]),
  'sat': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readPositiveInteger"]),
  'hdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'vdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'pdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'ageofdgpsdata': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readDecimal"]),
  'dgpsid': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["readPositiveInteger"]),
  'extensions': parseExtensions,
});

/**
 * @const
 * @type {Array<string>}
 */
const LINK_SEQUENCE = ['text', 'type'];

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const LINK_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'text': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
});

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const RTE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, [
  'name',
  'cmt',
  'desc',
  'src',
  'link',
  'number',
  'type',
  'rtept',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const RTE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'link': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLink),
  'number': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeNonNegativeIntegerTextNode"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'rtept': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArraySerializer"])(Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeWptType)),
});

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const RTEPT_TYPE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, ['ele', 'time']);

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const TRK_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, [
  'name',
  'cmt',
  'desc',
  'src',
  'link',
  'number',
  'type',
  'trkseg',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const TRK_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'link': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLink),
  'number': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeNonNegativeIntegerTextNode"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'trkseg': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArraySerializer"])(Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeTrkSeg)),
});

/**
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const TRKSEG_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])('trkpt');

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const TRKSEG_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'trkpt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeWptType),
});

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const WPT_TYPE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, [
  'ele',
  'time',
  'magvar',
  'geoidheight',
  'name',
  'cmt',
  'desc',
  'src',
  'link',
  'sym',
  'type',
  'fix',
  'sat',
  'hdop',
  'vdop',
  'pdop',
  'ageofdgpsdata',
  'dgpsid',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const WPT_TYPE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeStructureNS"])(NAMESPACE_URIS, {
  'ele': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'time': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDateTimeTextNode"]),
  'magvar': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'geoidheight': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'cmt': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'desc': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'src': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'link': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLink),
  'sym': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'type': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'fix': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeStringTextNode"]),
  'sat': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeNonNegativeIntegerTextNode"]),
  'hdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'vdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'pdop': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'ageofdgpsdata': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeDecimalTextNode"]),
  'dgpsid': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_7__["writeNonNegativeIntegerTextNode"]),
});

/**
 * @const
 * @type {Object<string, string>}
 */
const GEOMETRY_TYPE_TO_NODENAME = {
  'Point': 'wpt',
  'LineString': 'rte',
  'MultiLineString': 'trk',
};

/**
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [nodeName] Node name.
 * @return {Node|undefined} Node.
 */
function GPX_NODE_FACTORY(value, objectStack, nodeName) {
  const geometry = /** @type {Feature} */ (value).getGeometry();
  if (geometry) {
    const nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
    if (nodeName) {
      const parentNode = objectStack[objectStack.length - 1].node;
      return Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(parentNode.namespaceURI, nodeName);
    }
  }
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {LayoutOptions} layoutOptions Layout options.
 * @param {Element} node Node.
 * @param {!Object} values Values.
 * @return {Array<number>} Flat coordinates.
 */
function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(
    parseFloat(node.getAttribute('lon')),
    parseFloat(node.getAttribute('lat'))
  );
  if ('ele' in values) {
    flatCoordinates.push(/** @type {number} */ (values['ele']));
    delete values['ele'];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ('time' in values) {
    flatCoordinates.push(/** @type {number} */ (values['time']));
    delete values['time'];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}

/**
 * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates
 * and ends arrays by shrinking them accordingly (removing unused zero entries).
 *
 * @param {LayoutOptions} layoutOptions Layout options.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {Array<number>} [ends] Ends.
 * @return {import("../geom/Geometry.js").GeometryLayout} Layout.
 */
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  /** @type {import("../geom/Geometry.js").GeometryLayout} */
  let layout = 'XY';
  let stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = 'XYZM';
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = 'XYZ';
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = 'XYM';
    stride = 3;
  }
  if (stride !== 4) {
    for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }
    flatCoordinates.length = (flatCoordinates.length / 4) * stride;
    if (ends) {
      for (let i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = (ends[i] / 4) * stride;
      }
    }
  }
  return layout;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function parseLink(node, objectStack) {
  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const href = node.getAttribute('href');
  if (href !== null) {
    values['link'] = href;
  }
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["parseNode"])(LINK_PARSERS, node, objectStack);
}

/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function parseExtensions(node, objectStack) {
  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  values['extensionsNode_'] = node;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function parseRtePt(node, objectStack) {
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])({}, RTEPT_PARSERS, node, objectStack);
  if (values) {
    const rteValues = /** @type {!Object} */ (
      objectStack[objectStack.length - 1]
    );
    const flatCoordinates = /** @type {Array<number>} */ (
      rteValues['flatCoordinates']
    );
    const layoutOptions = /** @type {LayoutOptions} */ (
      rteValues['layoutOptions']
    );
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function parseTrkPt(node, objectStack) {
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])({}, TRKPT_PARSERS, node, objectStack);
  if (values) {
    const trkValues = /** @type {!Object} */ (
      objectStack[objectStack.length - 1]
    );
    const flatCoordinates = /** @type {Array<number>} */ (
      trkValues['flatCoordinates']
    );
    const layoutOptions = /** @type {LayoutOptions} */ (
      trkValues['layoutOptions']
    );
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function parseTrkSeg(node, objectStack) {
  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["parseNode"])(TRKSEG_PARSERS, node, objectStack);
  const flatCoordinates =
    /** @type {Array<number>} */
    (values['flatCoordinates']);
  const ends = /** @type {Array<number>} */ (values['ends']);
  ends.push(flatCoordinates.length);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Track.
 */
function readRte(node, objectStack) {
  const options = /** @type {import("./Feature.js").ReadOptions} */ (
    objectStack[0]
  );
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])(
    {
      'flatCoordinates': [],
      'layoutOptions': {},
    },
    RTE_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return undefined;
  }
  const flatCoordinates =
    /** @type {Array<number>} */
    (values['flatCoordinates']);
  delete values['flatCoordinates'];
  const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
  delete values['layoutOptions'];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  const geometry = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](flatCoordinates, layout);
  Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, false, options);
  const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Track.
 */
function readTrk(node, objectStack) {
  const options = /** @type {import("./Feature.js").ReadOptions} */ (
    objectStack[0]
  );
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])(
    {
      'flatCoordinates': [],
      'ends': [],
      'layoutOptions': {},
    },
    TRK_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return undefined;
  }
  const flatCoordinates =
    /** @type {Array<number>} */
    (values['flatCoordinates']);
  delete values['flatCoordinates'];
  const ends = /** @type {Array<number>} */ (values['ends']);
  delete values['ends'];
  const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);
  delete values['layoutOptions'];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  const geometry = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_2__["default"](flatCoordinates, layout, ends);
  Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, false, options);
  const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Feature|undefined} Waypoint.
 */
function readWpt(node, objectStack) {
  const options = /** @type {import("./Feature.js").ReadOptions} */ (
    objectStack[0]
  );
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])({}, WPT_PARSERS, node, objectStack);
  if (!values) {
    return undefined;
  }
  const layoutOptions = /** @type {LayoutOptions} */ ({});
  const coordinates = appendCoordinate([], layoutOptions, node, values);
  const layout = applyLayoutOptions(layoutOptions, coordinates);
  const geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](coordinates, layout);
  Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, false, options);
  const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](geometry);
  feature.setProperties(values, true);
  return feature;
}

/**
 * @param {Element} node Node.
 * @param {string} value Value for the link's `href` attribute.
 * @param {Array<*>} objectStack Node stack.
 */
function writeLink(node, value, objectStack) {
  node.setAttribute('href', value);
  const context = objectStack[objectStack.length - 1];
  const properties = context['properties'];
  const link = [properties['linkText'], properties['linkType']];
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    /** @type {import("../xml.js").NodeStackItem} */ ({node: node}),
    LINK_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_5__["OBJECT_PROPERTY_NODE_FACTORY"],
    link,
    objectStack,
    LINK_SEQUENCE
  );
}

/**
 * @param {Element} node Node.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Array<*>} objectStack Object stack.
 */
function writeWptType(node, coordinate, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const parentNode = context.node;
  const namespaceURI = parentNode.namespaceURI;
  const properties = context['properties'];
  //FIXME Projection handling
  node.setAttributeNS(null, 'lat', String(coordinate[1]));
  node.setAttributeNS(null, 'lon', String(coordinate[0]));
  const geometryLayout = context['geometryLayout'];
  switch (geometryLayout) {
    case 'XYZM':
      if (coordinate[3] !== 0) {
        properties['time'] = coordinate[3];
      }
    // fall through
    case 'XYZ':
      if (coordinate[2] !== 0) {
        properties['ele'] = coordinate[2];
      }
      break;
    case 'XYM':
      if (coordinate[2] !== 0) {
        properties['time'] = coordinate[2];
      }
      break;
    default:
    // pass
  }
  const orderedKeys =
    node.nodeName == 'rtept'
      ? RTEPT_TYPE_SEQUENCE[namespaceURI]
      : WPT_TYPE_SEQUENCE[namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    /** @type {import("../xml.js").NodeStackItem} */
    ({node: node, 'properties': properties}),
    WPT_TYPE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_5__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @param {Node} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */
function writeRte(node, feature, objectStack) {
  const options = /** @type {import("./Feature.js").WriteOptions} */ (
    objectStack[0]
  );
  const properties = feature.getProperties();
  const context = {node: node};
  context['properties'] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == 'LineString') {
    const lineString = /** @type {LineString} */ (
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, true, options)
    );
    context['geometryLayout'] = lineString.getLayout();
    properties['rtept'] = lineString.getCoordinates();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    context,
    RTE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_5__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */
function writeTrk(node, feature, objectStack) {
  const options = /** @type {import("./Feature.js").WriteOptions} */ (
    objectStack[0]
  );
  const properties = feature.getProperties();
  /** @type {import("../xml.js").NodeStackItem} */
  const context = {node: node};
  context['properties'] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == 'MultiLineString') {
    const multiLineString = /** @type {MultiLineString} */ (
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, true, options)
    );
    properties['trkseg'] = multiLineString.getLineStrings();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    context,
    TRK_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_5__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @param {Element} node Node.
 * @param {LineString} lineString LineString.
 * @param {Array<*>} objectStack Object stack.
 */
function writeTrkSeg(node, lineString, objectStack) {
  /** @type {import("../xml.js").NodeStackItem} */
  const context = {node: node};
  context['geometryLayout'] = lineString.getLayout();
  context['properties'] = {};
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    context,
    TRKSEG_SERIALIZERS,
    TRKSEG_NODE_FACTORY,
    lineString.getCoordinates(),
    objectStack
  );
}

/**
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 */
function writeWpt(node, feature, objectStack) {
  const options = /** @type {import("./Feature.js").WriteOptions} */ (
    objectStack[0]
  );
  const context = objectStack[objectStack.length - 1];
  context['properties'] = feature.getProperties();
  const geometry = feature.getGeometry();
  if (geometry.getType() == 'Point') {
    const point = /** @type {Point} */ (
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, true, options)
    );
    context['geometryLayout'] = point.getLayout();
    writeWptType(node, point.getCoordinates(), objectStack);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (GPX);


/***/ }),

/***/ "./node_modules/ol/format/IGC.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/IGC.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextFeature.js */ "./node_modules/ol/format/TextFeature.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/IGC
 */






/**
 * @typedef {'barometric' | 'gps' | 'none'} IGCZ
 * IGC altitude/z. One of 'barometric', 'gps', 'none'.
 */

/**
 * @const
 * @type {RegExp}
 */
const B_RECORD_RE =
  /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;

/**
 * @const
 * @type {RegExp}
 */
const H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;

/**
 * @const
 * @type {RegExp}
 */
const HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;

/**
 * A regular expression matching the newline characters `\r\n`, `\r` and `\n`.
 *
 * @const
 * @type {RegExp}
 */
const NEWLINE_RE = /\r\n|\r|\n/;

/**
 * @typedef {Object} Options
 * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible
 * values are `'barometric'`, `'gps'`, and `'none'`.
 */

/**
 * @classdesc
 * Feature format for `*.igc` flight recording files.
 *
 * As IGC sources contain a single feature,
 * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an
 * array
 *
 * @api
 */
class IGC extends _TextFeature_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["get"])('EPSG:4326');

    /**
     * @private
     * @type {IGCZ}
     */
    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';
  }

  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(text, options) {
    const altitudeMode = this.altitudeMode_;
    const lines = text.split(NEWLINE_RE);
    /** @type {Object<string, string>} */
    const properties = {};
    const flatCoordinates = [];
    let year = 2000;
    let month = 0;
    let day = 1;
    let lastDateTime = -1;
    let i, ii;
    for (i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      let m;
      if (line.charAt(0) == 'B') {
        m = B_RECORD_RE.exec(line);
        if (m) {
          const hour = parseInt(m[1], 10);
          const minute = parseInt(m[2], 10);
          const second = parseInt(m[3], 10);
          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;
          if (m[6] == 'S') {
            y = -y;
          }
          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;
          if (m[9] == 'W') {
            x = -x;
          }
          flatCoordinates.push(x, y);
          if (altitudeMode != 'none') {
            let z;
            if (altitudeMode == 'gps') {
              z = parseInt(m[11], 10);
            } else if (altitudeMode == 'barometric') {
              z = parseInt(m[12], 10);
            } else {
              z = 0;
            }
            flatCoordinates.push(z);
          }
          let dateTime = Date.UTC(year, month, day, hour, minute, second);
          // Detect UTC midnight wrap around.
          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }
          flatCoordinates.push(dateTime / 1000);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == 'H') {
        m = HFDTE_RECORD_RE.exec(line);
        if (m) {
          day = parseInt(m[1], 10);
          month = parseInt(m[2], 10) - 1;
          year = 2000 + parseInt(m[3], 10);
        } else {
          m = H_RECORD_RE.exec(line);
          if (m) {
            properties[m[1]] = m[2].trim();
          }
        }
      }
    }
    if (flatCoordinates.length === 0) {
      return null;
    }
    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';
    const lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](flatCoordinates, layout);
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_4__["transformGeometryWithOptions"])(lineString, false, options)
    );
    feature.setProperties(properties, true);
    return feature;
  }

  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(text, options) {
    const feature = this.readFeatureFromText(text, options);
    if (feature) {
      return [feature];
    }
    return [];
  }
}

/* harmony default export */ __webpack_exports__["default"] = (IGC);


/***/ }),

/***/ "./node_modules/ol/format/KML.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/KML.js ***!
  \***************************************/
/*! exports provided: getDefaultFillStyle, getDefaultImageStyle, getDefaultStrokeStyle, getDefaultTextStyle, getDefaultStyle, getDefaultStyleArray, readFlatCoordinates, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultFillStyle", function() { return getDefaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageStyle", function() { return getDefaultImageStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultStrokeStyle", function() { return getDefaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultTextStyle", function() { return getDefaultTextStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultStyle", function() { return getDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultStyleArray", function() { return getDefaultStyleArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFlatCoordinates", function() { return readFlatCoordinates; });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _style_Icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style/Icon.js */ "./node_modules/ol/style/Icon.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../style/Stroke.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _style_Text_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../style/Text.js */ "./node_modules/ol/style/Text.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./XMLFeature.js */ "./node_modules/ol/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/KML
 */
























/**
 * @typedef {Object} Vec2
 * @property {number} x X coordinate.
 * @property {import("../style/Icon.js").IconAnchorUnits} xunits Units of x.
 * @property {number} y Y coordinate.
 * @property {import("../style/Icon.js").IconAnchorUnits} yunits Units of Y.
 * @property {import("../style/Icon.js").IconOrigin} [origin] Origin.
 */

/**
 * @typedef {Object} GxTrackObject
 * @property {Array<Array<number>>} coordinates Coordinates.
 * @property {Array<number>} whens Whens.
 */

/**
 * @const
 * @type {Array<string>}
 */
const GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];

/**
 * @const
 * @type {Array<null|string>}
 */
const NAMESPACE_URIS = [
  null,
  'http://earth.google.com/kml/2.0',
  'http://earth.google.com/kml/2.1',
  'http://earth.google.com/kml/2.2',
  'http://www.opengis.net/kml/2.2',
];

/**
 * @const
 * @type {string}
 */
const SCHEMA_LOCATION =
  'http://www.opengis.net/kml/2.2 ' +
  'https://developers.google.com/kml/schema/kml22gx.xsd';

/**
 * @type {Object<string, import("../style/Icon.js").IconAnchorUnits>}
 */
const ICON_ANCHOR_UNITS_MAP = {
  'fraction': 'fraction',
  'pixels': 'pixels',
  'insetPixels': 'pixels',
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PLACEMARK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'ExtendedData': extendedDataParser,
    'Region': regionParser,
    'MultiGeometry': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readMultiGeometry, 'geometry'),
    'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readLineString, 'geometry'),
    'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readLinearRing, 'geometry'),
    'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readPoint, 'geometry'),
    'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readPolygon, 'geometry'),
    'Style': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readStyle),
    'StyleMap': placemarkStyleMapParser,
    'address': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
    'description': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
    'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
    'open': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
    'phoneNumber': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
    'styleUrl': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readStyleURL),
    'visibility': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, {
    'MultiTrack': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readGxMultiTrack, 'geometry'),
    'Track': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readGxTrack, 'geometry'),
  })
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const NETWORK_LINK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'ExtendedData': extendedDataParser,
  'Region': regionParser,
  'Link': linkParser,
  'address': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'description': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'open': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
  'phoneNumber': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'visibility': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LINK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'href': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readURI),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CAMERA_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  Altitude: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  Longitude: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  Latitude: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  Tilt: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  AltitudeMode: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  Heading: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  Roll: Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const REGION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'LatLonAltBox': latLonAltBoxParser,
  'Lod': lodParser,
});

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const KML_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, ['Document', 'Placemark']);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const KML_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Document': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeDocument),
  'Placemark': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePlacemark),
});

/**
 * @type {import("../color.js").Color}
 */
let DEFAULT_COLOR;

/**
 * @type {Fill|null}
 */
let DEFAULT_FILL_STYLE = null;

/**
 * Get the default fill style (or null if not yet set).
 * @return {Fill|null} The default fill style.
 */
function getDefaultFillStyle() {
  return DEFAULT_FILL_STYLE;
}

/**
 * @type {import("../size.js").Size}
 */
let DEFAULT_IMAGE_STYLE_ANCHOR;

/**
 * @type {import("../style/Icon.js").IconAnchorUnits}
 */
let DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;

/**
 * @type {import("../style/Icon.js").IconAnchorUnits}
 */
let DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;

/**
 * @type {import("../size.js").Size}
 */
let DEFAULT_IMAGE_STYLE_SIZE;

/**
 * @type {string}
 */
let DEFAULT_IMAGE_STYLE_SRC;

/**
 * @type {import("../style/Image.js").default|null}
 */
let DEFAULT_IMAGE_STYLE = null;

/**
 * Get the default image style (or null if not yet set).
 * @return {import("../style/Image.js").default|null} The default image style.
 */
function getDefaultImageStyle() {
  return DEFAULT_IMAGE_STYLE;
}

/**
 * @type {string}
 */
let DEFAULT_NO_IMAGE_STYLE;

/**
 * @type {Stroke|null}
 */
let DEFAULT_STROKE_STYLE = null;

/**
 * Get the default stroke style (or null if not yet set).
 * @return {Stroke|null} The default stroke style.
 */
function getDefaultStrokeStyle() {
  return DEFAULT_STROKE_STYLE;
}

/**
 * @type {Stroke}
 */
let DEFAULT_TEXT_STROKE_STYLE;

/**
 * @type {Text|null}
 */
let DEFAULT_TEXT_STYLE = null;

/**
 * Get the default text style (or null if not yet set).
 * @return {Text|null} The default text style.
 */
function getDefaultTextStyle() {
  return DEFAULT_TEXT_STYLE;
}

/**
 * @type {Style|null}
 */
let DEFAULT_STYLE = null;

/**
 * Get the default style (or null if not yet set).
 * @return {Style|null} The default style.
 */
function getDefaultStyle() {
  return DEFAULT_STYLE;
}

/**
 * @type {Array<Style>|null}
 */
let DEFAULT_STYLE_ARRAY = null;

/**
 * Get the default style array (or null if not yet set).
 * @return {Array<Style>|null} The default style.
 */
function getDefaultStyleArray() {
  return DEFAULT_STYLE_ARRAY;
}

/**
 * Function that returns the scale needed to normalize an icon image to 32 pixels.
 * @param {import("../size.js").Size} size Image size.
 * @return {number} Scale.
 */
function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}

function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];

  DEFAULT_FILL_STYLE = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    color: DEFAULT_COLOR,
  });

  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];

  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';

  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';

  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];

  DEFAULT_IMAGE_STYLE_SRC =
    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';

  DEFAULT_IMAGE_STYLE = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: 'bottom-left',
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: 'anonymous',
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC,
  });

  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';

  DEFAULT_STROKE_STYLE = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
    color: DEFAULT_COLOR,
    width: 1,
  });

  DEFAULT_TEXT_STROKE_STYLE = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
    color: [51, 51, 51, 1],
    width: 2,
  });

  DEFAULT_TEXT_STYLE = new _style_Text_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
    font: 'bold 16px Helvetica',
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8,
  });

  DEFAULT_STYLE = new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0,
  });

  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}

/**
 * @type {HTMLTextAreaElement}
 */
let TEXTAREA;

/**
 * A function that takes a url `{string}` and returns a url `{string}`.
 * Might be used to change an icon path or to substitute a
 * data url obtained from a KMZ array buffer.
 *
 * @typedef {function(string):string} IconUrlFunction
 * @api
 */

/**
 * Function that returns a url unchanged.
 * @param {string} href Input url.
 * @return {string} Output url.
 */
function defaultIconUrlFunction(href) {
  return href;
}

/**
 * @typedef {Object} Options
 * @property {boolean} [extractStyles=true] Extract styles from the KML.
 * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.
 * @property {Array<Style>} [defaultStyle] Default style. The
 * default default style is the same as Google Earth.
 * @property {boolean} [writeStyles=true] Write styles into KML.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.
 * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the KML format.
 *
 * {@link module:ol/format/KML~KML#readFeature} will read the first feature from
 * a KML source.
 *
 * MultiGeometries are converted into GeometryCollections if they are a mix of
 * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are
 * all of the same type.
 *
 * @api
 */
class KML extends _XMLFeature_js__WEBPACK_IMPORTED_MODULE_14__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__["get"])('EPSG:4326');

    /**
     * @private
     * @type {Array<Style>}
     */
    this.defaultStyle_ = options.defaultStyle
      ? options.defaultStyle
      : DEFAULT_STYLE_ARRAY;

    /**
     * @private
     * @type {boolean}
     */
    this.extractStyles_ =
      options.extractStyles !== undefined ? options.extractStyles : true;

    /**
     * @type {boolean}
     */
    this.writeStyles_ =
      options.writeStyles !== undefined ? options.writeStyles : true;

    /**
     * @private
     * @type {!Object<string, (Array<Style>|string)>}
     */
    this.sharedStyles_ = {};

    /**
     * @private
     * @type {boolean}
     */
    this.showPointNames_ =
      options.showPointNames !== undefined ? options.showPointNames : true;

    /**
     * @type {null|string}
     */
    this.crossOrigin_ =
      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';

    /**
     * @type {IconUrlFunction}
     */
    this.iconUrlFunction_ = options.iconUrlFunction
      ? options.iconUrlFunction
      : defaultIconUrlFunction;

    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];
  }

  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(node, objectStack) {
    // FIXME use scope somehow
    const parsersNS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
      'Document': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayExtender"])(this.readDocumentOrFolder_, this),
      'Folder': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayExtender"])(this.readDocumentOrFolder_, this),
      'Placemark': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(this.readPlacemark_, this),
      'Style': this.readSharedStyle_.bind(this),
      'StyleMap': this.readSharedStyleMap_.bind(this),
    });
    /** @type {Array<Feature>} */
    // @ts-ignore
    const features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])([], parsersNS, node, objectStack, this);
    if (features) {
      return features;
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(node, objectStack) {
    const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
      {'geometry': null},
      PLACEMARK_PARSERS,
      node,
      objectStack,
      this
    );
    if (!object) {
      return undefined;
    }
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    const id = node.getAttribute('id');
    if (id !== null) {
      feature.setId(id);
    }
    const options = /** @type {import("./Feature.js").ReadOptions} */ (
      objectStack[0]
    );

    const geometry = object['geometry'];
    if (geometry) {
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_22__["transformGeometryWithOptions"])(geometry, false, options);
    }
    feature.setGeometry(geometry);
    delete object['geometry'];

    if (this.extractStyles_) {
      const style = object['Style'];
      const styleUrl = object['styleUrl'];
      const styleFunction = createFeatureStyleFunction(
        style,
        styleUrl,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      feature.setStyle(styleFunction);
    }
    delete object['Style'];
    // we do not remove the styleUrl property from the object, so it
    // gets stored on feature when setProperties is called

    feature.setProperties(object, true);

    return feature;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(node, objectStack) {
    const id = node.getAttribute('id');
    if (id !== null) {
      const style = readStyle.call(this, node, objectStack);
      if (style) {
        let styleUri;
        let baseURI = node.baseURI;
        if (!baseURI || baseURI == 'about:blank') {
          baseURI = window.location.href;
        }
        if (baseURI) {
          const url = new URL('#' + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = '#' + id;
        }
        this.sharedStyles_[styleUri] = style;
      }
    }
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(node, objectStack) {
    const id = node.getAttribute('id');
    if (id === null) {
      return;
    }
    const styleMapValue = readStyleMapValue.call(this, node, objectStack);
    if (!styleMapValue) {
      return;
    }
    let styleUri;
    let baseURI = node.baseURI;
    if (!baseURI || baseURI == 'about:blank') {
      baseURI = window.location.href;
    }
    if (baseURI) {
      const url = new URL('#' + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = '#' + id;
    }
    this.sharedStyles_[styleUri] = styleMapValue;
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return null;
    }
    const feature = this.readPlacemark_(node, [
      this.getReadOptions(node, options),
    ]);
    if (feature) {
      return feature;
    }
    return null;
  }

  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return [];
    }
    let features;
    const localName = node.localName;
    if (localName == 'Document' || localName == 'Folder') {
      features = this.readDocumentOrFolder_(node, [
        this.getReadOptions(node, options),
      ]);
      if (features) {
        return features;
      }
      return [];
    }
    if (localName == 'Placemark') {
      const feature = this.readPlacemark_(node, [
        this.getReadOptions(node, options),
      ]);
      if (feature) {
        return [feature];
      }
      return [];
    }
    if (localName == 'kml') {
      features = [];
      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
        const fs = this.readFeaturesFromNode(n, options);
        if (fs) {
          Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(features, fs);
        }
      }
      return features;
    }
    return [];
  }

  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(source) {
    if (!source) {
      return undefined;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parse"])(source);
      return this.readNameFromDocument(doc);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["isDocument"])(source)) {
      return this.readNameFromDocument(/** @type {Document} */ (source));
    }
    return this.readNameFromNode(/** @type {Element} */ (source));
  }

  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(doc) {
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        const name = this.readNameFromNode(/** @type {Element} */ (n));
        if (name) {
          return name;
        }
      }
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(node) {
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {
        return Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"])(n);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (
        NAMESPACE_URIS.includes(n.namespaceURI) &&
        (localName == 'Document' ||
          localName == 'Folder' ||
          localName == 'Placemark' ||
          localName == 'kml')
      ) {
        const name = this.readNameFromNode(n);
        if (name) {
          return name;
        }
      }
    }
    return undefined;
  }

  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(source) {
    const networkLinks = [];
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parse"])(source);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["isDocument"])(source)) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(
        networkLinks,
        this.readNetworkLinksFromDocument(/** @type {Document} */ (source))
      );
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(
        networkLinks,
        this.readNetworkLinksFromNode(/** @type {Element} */ (source))
      );
    }
    return networkLinks;
  }

  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(doc) {
    const networkLinks = [];
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(
          networkLinks,
          this.readNetworkLinksFromNode(/** @type {Element} */ (n))
        );
      }
    }
    return networkLinks;
  }

  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(node) {
    const networkLinks = [];
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (
        NAMESPACE_URIS.includes(n.namespaceURI) &&
        n.localName == 'NetworkLink'
      ) {
        const obj = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, NETWORK_LINK_PARSERS, n, []);
        networkLinks.push(obj);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (
        NAMESPACE_URIS.includes(n.namespaceURI) &&
        (localName == 'Document' || localName == 'Folder' || localName == 'kml')
      ) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(networkLinks, this.readNetworkLinksFromNode(n));
      }
    }
    return networkLinks;
  }

  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(source) {
    const regions = [];
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parse"])(source);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(regions, this.readRegionFromDocument(doc));
    } else if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["isDocument"])(source)) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(
        regions,
        this.readRegionFromDocument(/** @type {Document} */ (source))
      );
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(regions, this.readRegionFromNode(/** @type {Element} */ (source)));
    }
    return regions;
  }

  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(doc) {
    const regions = [];
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(regions, this.readRegionFromNode(/** @type {Element} */ (n)));
      }
    }
    return regions;
  }

  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(node) {
    const regions = [];
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {
        const obj = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, REGION_PARSERS, n, []);
        regions.push(obj);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (
        NAMESPACE_URIS.includes(n.namespaceURI) &&
        (localName == 'Document' || localName == 'Folder' || localName == 'kml')
      ) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(regions, this.readRegionFromNode(n));
      }
    }
    return regions;
  }

  /**
   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.
   * @property {number} [Latitude] Latitude of the camera.
   * @property {number} [Longitude] Longitude of the camera.
   * @property {number} [Altitude] Altitude of the camera.
   * @property {string} [AltitudeMode] Floor-related altitude mode.
   * @property {number} [Heading] Horizontal camera rotation.
   * @property {number} [Tilt] Lateral camera rotation.
   * @property {number} [Roll] Vertical camera rotation.
   */

  /**
   * Read the cameras of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCamera(source) {
    const cameras = [];
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parse"])(source);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(cameras, this.readCameraFromDocument(doc));
    } else if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["isDocument"])(source)) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(
        cameras,
        this.readCameraFromDocument(/** @type {Document} */ (source))
      );
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(cameras, this.readCameraFromNode(/** @type {Element} */ (source)));
    }
    return cameras;
  }

  /**
   * @param {Document} doc Document.
   * @return {Array<KMLCamera>} Cameras.
   */
  readCameraFromDocument(doc) {
    const cameras = [];
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType === Node.ELEMENT_NODE) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(cameras, this.readCameraFromNode(/** @type {Element} */ (n)));
      }
    }
    return cameras;
  }

  /**
   * @param {Element} node Node.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCameraFromNode(node) {
    const cameras = [];
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName === 'Camera') {
        const obj = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, CAMERA_PARSERS, n, []);
        cameras.push(obj);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (
        NAMESPACE_URIS.includes(n.namespaceURI) &&
        (localName === 'Document' ||
          localName === 'Folder' ||
          localName === 'Placemark' ||
          localName === 'kml')
      ) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(cameras, this.readCameraFromNode(n));
      }
    }
    return cameras;
  }

  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const kml = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["createElementNS"])(NAMESPACE_URIS[4], 'kml');
    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';
    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', _xml_js__WEBPACK_IMPORTED_MODULE_15__["XML_SCHEMA_INSTANCE_URI"]);
    kml.setAttributeNS(
      _xml_js__WEBPACK_IMPORTED_MODULE_15__["XML_SCHEMA_INSTANCE_URI"],
      'xsi:schemaLocation',
      SCHEMA_LOCATION
    );

    const /** @type {import("../xml.js").NodeStackItem} */ context = {
        node: kml,
      };
    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */
    const properties = {};
    if (features.length > 1) {
      properties['Document'] = features;
    } else if (features.length == 1) {
      properties['Placemark'] = features[0];
    }
    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
      context,
      KML_SERIALIZERS,
      _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
      values,
      [options],
      orderedKeys,
      this
    );
    return kml;
  }
}

/**
 * @param {Style|undefined} foundStyle Style.
 * @param {string} name Name.
 * @return {Style} style Style.
 */
function createNameStyleFunction(foundStyle, name) {
  const textOffset = [0, 0];
  /** @type {CanvasTextAlign} */
  let textAlign = 'start';
  const imageStyle = foundStyle.getImage();
  if (imageStyle) {
    const imageSize = imageStyle.getSize();
    if (imageSize && imageSize.length == 2) {
      const imageScale = imageStyle.getScaleArray();
      const anchor = imageStyle.getAnchor();
      // Offset the label to be centered to the right of the icon,
      // if there is one.
      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign = 'left';
    }
  }
  let textStyle = foundStyle.getText();
  if (textStyle) {
    // clone the text style, customizing it with name, alignments and offset.
    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);

  const nameStyle = new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
    image: imageStyle,
    text: textStyle,
  });
  return nameStyle;
}

/**
 * @param {Array<Style>|undefined} style Style.
 * @param {string} styleUrl Style URL.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.
 * @param {boolean|undefined} showPointNames true to show names for point placemarks.
 * @return {import("../style/Style.js").StyleFunction} Feature style function.
 */
function createFeatureStyleFunction(
  style,
  styleUrl,
  defaultStyle,
  sharedStyles,
  showPointNames
) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function (feature, resolution) {
      let drawName = showPointNames;
      let name = '';
      let multiGeometryPoints = [];
      if (drawName) {
        const geometry = feature.getGeometry();
        if (geometry) {
          if (geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            multiGeometryPoints = geometry
              .getGeometriesArrayRecursive()
              .filter(function (geometry) {
                const type = geometry.getType();
                return type === 'Point' || type === 'MultiPoint';
              });
            drawName = multiGeometryPoints.length > 0;
          } else {
            const type = geometry.getType();
            drawName = type === 'Point' || type === 'MultiPoint';
          }
        }
      }

      if (drawName) {
        name = /** @type {string} */ (feature.get('name'));
        drawName = drawName && !!name;
        // convert any html character codes
        if (drawName && /&[^&]+;/.test(name)) {
          if (!TEXTAREA) {
            TEXTAREA = document.createElement('textarea');
          }
          TEXTAREA.innerHTML = name;
          name = TEXTAREA.value;
        }
      }

      let featureStyle = defaultStyle;
      if (style) {
        featureStyle = style;
      } else if (styleUrl) {
        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
      }
      if (drawName) {
        const nameStyle = createNameStyleFunction(featureStyle[0], name);
        if (multiGeometryPoints.length > 0) {
          // in multigeometries restrict the name style to points and create a
          // style without image or text for geometries requiring fill or stroke
          // including any polygon specific style if there is one
          nameStyle.setGeometry(new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](multiGeometryPoints));
          const baseStyle = new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
            geometry: featureStyle[0].getGeometry(),
            image: null,
            fill: featureStyle[0].getFill(),
            stroke: featureStyle[0].getStroke(),
            text: null,
          });
          return [nameStyle, baseStyle].concat(featureStyle.slice(1));
        }
        return nameStyle;
      }
      return featureStyle;
    }
  );
}

/**
 * @param {Array<Style>|string|undefined} styleValue Style value.
 * @param {Array<Style>} defaultStyle Default style.
 * @param {!Object<string, (Array<Style>|string)>} sharedStyles
 * Shared styles.
 * @return {Array<Style>} Style.
 */
function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  }
  if (typeof styleValue === 'string') {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  }
  return defaultStyle;
}

/**
 * @param {Node} node Node.
 * @return {import("../color.js").Color|undefined} Color.
 */
function readColor(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false);
  // The KML specification states that colors should not include a leading `#`
  // but we tolerate them.
  const m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
  if (m) {
    const hexColor = m[1];
    return [
      parseInt(hexColor.substr(6, 2), 16),
      parseInt(hexColor.substr(4, 2), 16),
      parseInt(hexColor.substr(2, 2), 16),
      parseInt(hexColor.substr(0, 2), 16) / 255,
    ];
  }
  return undefined;
}

/**
 * @param {Node} node Node.
 * @return {Array<number>|undefined} Flat coordinates.
 */
function readFlatCoordinates(node) {
  let s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false);
  const flatCoordinates = [];
  // The KML specification states that coordinate tuples should not include
  // spaces, but we tolerate them.
  s = s.replace(/\s*,\s*/g, ',');
  const re =
    /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let m;
  while ((m = re.exec(s))) {
    const x = parseFloat(m[1]);
    const y = parseFloat(m[2]);
    const z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }
  if (s !== '') {
    return undefined;
  }
  return flatCoordinates;
}

/**
 * @param {Node} node Node.
 * @return {string} URI.
 */
function readURI(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false).trim();
  let baseURI = node.baseURI;
  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s, baseURI);
    return url.href;
  }
  return s;
}

/**
 * @param {Node} node Node.
 * @return {string} URI.
 */
function readStyleURL(node) {
  // KML files in the wild occasionally forget the leading
  // `#` on styleUrlsdefined in the same document.
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false)
    .trim()
    .replace(/^(?!.*#)/, '#');
  let baseURI = node.baseURI;
  if (!baseURI || baseURI == 'about:blank') {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s, baseURI);
    return url.href;
  }
  return s;
}

/**
 * @param {Element} node Node.
 * @return {Vec2} Vec2.
 */
function readVec2(node) {
  const xunits = node.getAttribute('xunits');
  const yunits = node.getAttribute('yunits');
  /** @type {import('../style/Icon.js').IconOrigin} */
  let origin;
  if (xunits !== 'insetPixels') {
    if (yunits !== 'insetPixels') {
      origin = 'bottom-left';
    } else {
      origin = 'top-left';
    }
  } else {
    if (yunits !== 'insetPixels') {
      origin = 'bottom-right';
    } else {
      origin = 'top-right';
    }
  }
  return {
    x: parseFloat(node.getAttribute('x')),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node.getAttribute('y')),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin: origin,
  };
}

/**
 * @param {Node} node Node.
 * @return {number|undefined} Scale.
 */
function readScale(node) {
  return Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"])(node);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const STYLE_MAP_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Pair': pairDataParser,
});

/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>|string|undefined} StyleMap.
 */
function readStyleMapValue(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(undefined, STYLE_MAP_PARSERS, node, objectStack, this);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const ICON_STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Icon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readIcon),
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readColor),
  'heading': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'hotSpot': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readVec2),
  'scale': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readScale),
});

/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function iconStyleParser(node, objectStack) {
  // FIXME refreshMode
  // FIXME refreshInterval
  // FIXME viewRefreshTime
  // FIXME viewBoundScale
  // FIXME viewFormat
  // FIXME httpQuery
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, ICON_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = /** @type {Object} */ (
    objectStack[objectStack.length - 1]
  );
  const IconObject = 'Icon' in object ? object['Icon'] : {};
  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;
  let src;
  const href = /** @type {string|undefined} */ (IconObject['href']);
  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }
  let anchor, anchorXUnits, anchorYUnits;
  /** @type {import('../style/Icon.js').IconOrigin|undefined} */
  let anchorOrigin = 'bottom-left';
  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes
    if (src.includes('pushpin')) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes('arrow-reverse')) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes('paddle')) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }

  let offset;
  const x = /** @type {number|undefined} */ (IconObject['x']);
  const y = /** @type {number|undefined} */ (IconObject['y']);
  if (x !== undefined && y !== undefined) {
    offset = [x, y];
  }

  let size;
  const w = /** @type {number|undefined} */ (IconObject['w']);
  const h = /** @type {number|undefined} */ (IconObject['h']);
  if (w !== undefined && h !== undefined) {
    size = [w, h];
  }

  let rotation;
  const heading = /** @type {number} */ (object['heading']);
  if (heading !== undefined) {
    rotation = Object(_math_js__WEBPACK_IMPORTED_MODULE_21__["toRadians"])(heading);
  }

  const scale = /** @type {number|undefined} */ (object['scale']);

  const color = /** @type {Array<number>|undefined} */ (object['color']);

  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }

    const imageStyle = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      anchor: anchor,
      anchorOrigin: anchorOrigin,
      anchorXUnits: anchorXUnits,
      anchorYUnits: anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset: offset,
      offsetOrigin: 'bottom-left',
      rotation: rotation,
      scale: scale,
      size: size,
      src: this.iconUrlFunction_(src),
      color: color,
    });

    const imageScale = imageStyle.getScaleArray()[0];
    const imageSize = imageStyle.getSize();
    if (imageSize === null) {
      const imageState = imageStyle.getImageState();
      if (imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE || imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING) {
        const listener = function () {
          const imageState = imageStyle.getImageState();
          if (
            !(
              imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE ||
              imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADING
            )
          ) {
            const imageSize = imageStyle.getSize();
            if (imageSize && imageSize.length == 2) {
              const resizeScale = scaleForSize(imageSize);
              imageStyle.setScale(imageScale * resizeScale);
            }
            imageStyle.unlistenImageChange(listener);
          }
        };
        imageStyle.listenImageChange(listener);
        if (imageState === _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          imageStyle.load();
        }
      }
    } else if (imageSize.length == 2) {
      const resizeScale = scaleForSize(imageSize);
      imageStyle.setScale(imageScale * resizeScale);
    }
    styleObject['imageStyle'] = imageStyle;
  } else {
    // handle the case when we explicitly want to draw no icon.
    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LABEL_STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readColor),
  'scale': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readScale),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function labelStyleParser(node, objectStack) {
  // FIXME colorMode
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, LABEL_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const textStyle = new _style_Text_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
    fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color:
        /** @type {import("../color.js").Color} */
        ('color' in object ? object['color'] : DEFAULT_COLOR),
    }),
    scale: /** @type {number|undefined} */ (object['scale']),
  });
  styleObject['textStyle'] = textStyle;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LINE_STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readColor),
  'width': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function lineStyleParser(node, objectStack) {
  // FIXME colorMode
  // FIXME gx:outerColor
  // FIXME gx:outerWidth
  // FIXME gx:physicalWidth
  // FIXME gx:labelVisibility
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, LINE_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const strokeStyle = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
    color:
      /** @type {import("../color.js").Color} */
      ('color' in object ? object['color'] : DEFAULT_COLOR),
    width: /** @type {number} */ ('width' in object ? object['width'] : 1),
  });
  styleObject['strokeStyle'] = strokeStyle;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const POLY_STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readColor),
  'fill': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
  'outline': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function polyStyleParser(node, objectStack) {
  // FIXME colorMode
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, POLY_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const fillStyle = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
    color:
      /** @type {import("../color.js").Color} */
      ('color' in object ? object['color'] : DEFAULT_COLOR),
  });
  styleObject['fillStyle'] = fillStyle;
  const fill = /** @type {boolean|undefined} */ (object['fill']);
  if (fill !== undefined) {
    styleObject['fill'] = fill;
  }
  const outline = /** @type {boolean|undefined} */ (object['outline']);
  if (outline !== undefined) {
    styleObject['outline'] = outline;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const FLAT_LINEAR_RING_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeReplacer"])(readFlatCoordinates),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} LinearRing flat coordinates.
 */
function readFlatLinearRing(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
}

/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function gxCoordParser(node, objectStack) {
  const gxTrackObject =
    /** @type {GxTrackObject} */
    (objectStack[objectStack.length - 1]);
  const coordinates = gxTrackObject.coordinates;
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false);
  const re =
    /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  const m = re.exec(s);
  if (m) {
    const x = parseFloat(m[1]);
    const y = parseFloat(m[2]);
    const z = parseFloat(m[3]);
    coordinates.push([x, y, z]);
  } else {
    coordinates.push([]);
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const GX_MULTITRACK_GEOMETRY_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, {
  'Track': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readGxTrack),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {MultiLineString|undefined} MultiLineString.
 */
function readGxMultiTrack(node, objectStack) {
  const lineStrings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    [],
    GX_MULTITRACK_GEOMETRY_PARSERS,
    node,
    objectStack
  );
  if (!lineStrings) {
    return undefined;
  }
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](lineStrings);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const GX_TRACK_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'when': whenParser,
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, {
    'coord': gxCoordParser,
  })
);

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */
function readGxTrack(node, objectStack) {
  const gxTrackObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    /** @type {GxTrackObject} */ ({
      coordinates: [],
      whens: [],
    }),
    GX_TRACK_PARSERS,
    node,
    objectStack
  );
  if (!gxTrackObject) {
    return undefined;
  }
  const flatCoordinates = [];
  const coordinates = gxTrackObject.coordinates;
  const whens = gxTrackObject.whens;
  for (
    let i = 0, ii = Math.min(coordinates.length, whens.length);
    i < ii;
    ++i
  ) {
    if (coordinates[i].length == 3) {
      flatCoordinates.push(
        coordinates[i][0],
        coordinates[i][1],
        coordinates[i][2],
        whens[i]
      );
    }
  }
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates, 'XYZM');
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const ICON_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'href': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readURI),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, {
    'x': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
    'y': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
    'w': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
    'h': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  })
);

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Icon object.
 */
function readIcon(node, objectStack) {
  const iconObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, ICON_PARSERS, node, objectStack);
  if (iconObject) {
    return iconObject;
  }
  return null;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const GEOMETRY_FLAT_COORDINATES_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeReplacer"])(readFlatCoordinates),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<number>} Flat coordinates.
 */
function readFlatCoordinatesFromNode(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    null,
    GEOMETRY_FLAT_COORDINATES_PARSERS,
    node,
    objectStack
  );
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const EXTRUDE_AND_ALTITUDE_MODE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'extrude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
  'tessellate': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readBoolean"]),
  'altitudeMode': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {LineString|undefined} LineString.
 */
function readLineString(node, objectStack) {
  const properties = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates, 'XYZ');
    lineString.setProperties(properties, true);
    return lineString;
  }
  return undefined;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */
function readLinearRing(node, objectStack) {
  const properties = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const polygon = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates, 'XYZ', [
      flatCoordinates.length,
    ]);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return undefined;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const MULTI_GEOMETRY_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readLineString),
  'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readLinearRing),
  'MultiGeometry': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readMultiGeometry),
  'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readPoint),
  'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readPolygon),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */
function readMultiGeometry(node, objectStack) {
  const geometries = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    [],
    MULTI_GEOMETRY_PARSERS,
    node,
    objectStack
  );
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](geometries);
  }
  let multiGeometry;
  let homogeneous = true;
  const type = geometries[0].getType();
  let geometry;
  for (let i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    let layout;
    let flatCoordinates;
    if (type == 'Point') {
      const point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (let i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_7__["default"](flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == 'LineString') {
      multiGeometry = new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == 'Polygon') {
      multiGeometry = new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_8__["default"](geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == 'GeometryCollection') {
      multiGeometry = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](geometries);
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_17__["assert"])(false, 37); // Unknown geometry type found
    }
  } else {
    multiGeometry = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](geometries);
  }
  return /** @type {import("../geom/Geometry.js").default} */ (multiGeometry);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Point|undefined} Point.
 */
function readPoint(node, objectStack) {
  const properties = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_9__["default"](flatCoordinates, 'XYZ');
    point.setProperties(properties, true);
    return point;
  }
  return undefined;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const FLAT_LINEAR_RINGS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'innerBoundaryIs': innerBoundaryIsParser,
  'outerBoundaryIs': outerBoundaryIsParser,
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Polygon|undefined} Polygon.
 */
function readPolygon(node, objectStack) {
  const properties = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    /** @type {Object<string,*>} */ ({}),
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatLinearRings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    [null],
    FLAT_LINEAR_RINGS_PARSERS,
    node,
    objectStack
  );
  if (flatLinearRings && flatLinearRings[0]) {
    const flatCoordinates = flatLinearRings[0];
    const ends = [flatCoordinates.length];
    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_18__["extend"])(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    const polygon = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](flatCoordinates, 'XYZ', ends);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return undefined;
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'IconStyle': iconStyleParser,
  'LabelStyle': labelStyleParser,
  'LineStyle': lineStyleParser,
  'PolyStyle': polyStyleParser,
});

/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<Style>} Style.
 */
function readStyle(node, objectStack) {
  const styleObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    {},
    STYLE_PARSERS,
    node,
    objectStack,
    this
  );
  if (!styleObject) {
    return null;
  }
  let fillStyle =
    /** @type {Fill} */
    (
      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE
    );
  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);
  if (fill !== undefined && !fill) {
    fillStyle = null;
  }
  let imageStyle;
  if ('imageStyle' in styleObject) {
    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = /** @type {import("../style/Image.js").default} */ (
        styleObject['imageStyle']
      );
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }
  const textStyle =
    /** @type {Text} */
    (
      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE
    );
  const strokeStyle =
    /** @type {Stroke} */
    (
      'strokeStyle' in styleObject
        ? styleObject['strokeStyle']
        : DEFAULT_STROKE_STYLE
    );
  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);
  if (outline !== undefined && !outline) {
    // if the polystyle specifies no outline two styles are needed,
    // one for non-polygon geometries where linestrings require a stroke
    // and one for polygons where there should be no stroke
    return [
      new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
        geometry: function (feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === 'GeometryCollection') {
            const collection =
              /** @type {import("../geom/GeometryCollection").default} */ (
                geometry
              );
            return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](
              collection
                .getGeometriesArrayRecursive()
                .filter(function (geometry) {
                  const type = geometry.getType();
                  return type !== 'Polygon' && type !== 'MultiPolygon';
                })
            );
          }
          if (type !== 'Polygon' && type !== 'MultiPolygon') {
            return geometry;
          }
        },
        fill: fillStyle,
        image: imageStyle,
        stroke: strokeStyle,
        text: textStyle,
        zIndex: undefined, // FIXME
      }),
      new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
        geometry: function (feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === 'GeometryCollection') {
            const collection =
              /** @type {import("../geom/GeometryCollection").default} */ (
                geometry
              );
            return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](
              collection
                .getGeometriesArrayRecursive()
                .filter(function (geometry) {
                  const type = geometry.getType();
                  return type === 'Polygon' || type === 'MultiPolygon';
                })
            );
          }
          if (type === 'Polygon' || type === 'MultiPolygon') {
            return geometry;
          }
        },
        fill: fillStyle,
        stroke: null,
        zIndex: undefined, // FIXME
      }),
    ];
  }
  return [
    new _style_Style_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: undefined, // FIXME
    }),
  ];
}

/**
 * Reads an array of geometries and creates arrays for common geometry
 * properties. Then sets them to the multi geometry.
 * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.
 * @param {Array<import("../geom/Geometry.js").default>} geometries List of geometries.
 */
function setCommonGeometryProperties(multiGeometry, geometries) {
  const ii = geometries.length;
  const extrudes = new Array(geometries.length);
  const tessellates = new Array(geometries.length);
  const altitudeModes = new Array(geometries.length);
  let hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;
  for (let i = 0; i < ii; ++i) {
    const geometry = geometries[i];
    extrudes[i] = geometry.get('extrude');
    tessellates[i] = geometry.get('tessellate');
    altitudeModes[i] = geometry.get('altitudeMode');
    hasExtrude = hasExtrude || extrudes[i] !== undefined;
    hasTessellate = hasTessellate || tessellates[i] !== undefined;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }
  if (hasExtrude) {
    multiGeometry.set('extrude', extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set('tessellate', tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set('altitudeMode', altitudeModes);
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const DATA_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'displayName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'value': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function dataParser(node, objectStack) {
  const name = node.getAttribute('name');
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parseNode"])(DATA_PARSERS, node, objectStack);
  const featureObject = /** @type {Object} */ (
    objectStack[objectStack.length - 1]
  );
  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function () {
        return featureObject.value;
      },
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }
  delete featureObject['value'];
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const EXTENDED_DATA_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Data': dataParser,
  'SchemaData': schemaDataParser,
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function extendedDataParser(node, objectStack) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parseNode"])(EXTENDED_DATA_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function regionParser(node, objectStack) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parseNode"])(REGION_PARSERS, node, objectStack);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PAIR_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Style': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readStyle),
  'key': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'styleUrl': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(readStyleURL),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function pairDataParser(node, objectStack) {
  const pairObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, PAIR_PARSERS, node, objectStack, this);
  if (!pairObject) {
    return;
  }
  const key = /** @type {string|undefined} */ (pairObject['key']);
  if (key && key == 'normal') {
    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    const style = /** @type {Style} */ (pairObject['Style']);
    if (style) {
      objectStack[objectStack.length - 1] = style;
    }
  }
}

/**
 * @this {KML}
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function placemarkStyleMapParser(node, objectStack) {
  const styleMapValue = readStyleMapValue.call(this, node, objectStack);
  if (!styleMapValue) {
    return;
  }
  const placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject['Style'] = styleMapValue;
  } else if (typeof styleMapValue === 'string') {
    placemarkObject['styleUrl'] = styleMapValue;
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_17__["assert"])(false, 38); // `styleMapValue` has an unknown type
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const SCHEMA_DATA_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'SimpleData': simpleDataParser,
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function schemaDataParser(node, objectStack) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parseNode"])(SCHEMA_DATA_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function simpleDataParser(node, objectStack) {
  const name = node.getAttribute('name');
  if (name !== null) {
    const data = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"])(node);
    const featureObject = /** @type {Object} */ (
      objectStack[objectStack.length - 1]
    );
    featureObject[name] = data;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LAT_LON_ALT_BOX_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'altitudeMode': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readString"]),
  'minAltitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'maxAltitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'north': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'south': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'east': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'west': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function latLonAltBoxParser(node, objectStack) {
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    {},
    LAT_LON_ALT_BOX_PARSERS,
    node,
    objectStack
  );
  if (!object) {
    return;
  }
  const regionObject = /** @type {Object} */ (
    objectStack[objectStack.length - 1]
  );
  const extent = [
    parseFloat(object['west']),
    parseFloat(object['south']),
    parseFloat(object['east']),
    parseFloat(object['north']),
  ];
  regionObject['extent'] = extent;
  regionObject['altitudeMode'] = object['altitudeMode'];
  regionObject['minAltitude'] = parseFloat(object['minAltitude']);
  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LOD_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'minLodPixels': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'maxLodPixels': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'minFadeExtent': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
  'maxFadeExtent': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["readDecimal"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function lodParser(node, objectStack) {
  const object = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])({}, LOD_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);
  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);
  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);
  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const INNER_BOUNDARY_IS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeArrayPusher"])(readFlatLinearRing),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function innerBoundaryIsParser(node, objectStack) {
  const innerBoundaryFlatLinearRings = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    /** @type {Array<Array<number>>} */ ([]),
    INNER_BOUNDARY_IS_PARSERS,
    node,
    objectStack
  );
  if (innerBoundaryFlatLinearRings.length > 0) {
    const flatLinearRings =
      /** @type {Array<Array<number>>} */
      (objectStack[objectStack.length - 1]);
    flatLinearRings.push(...innerBoundaryFlatLinearRings);
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const OUTER_BOUNDARY_IS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeReplacer"])(readFlatLinearRing),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function outerBoundaryIsParser(node, objectStack) {
  /** @type {Array<number>|undefined} */
  const flatLinearRing = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushParseAndPop"])(
    undefined,
    OUTER_BOUNDARY_IS_PARSERS,
    node,
    objectStack
  );
  if (flatLinearRing) {
    const flatLinearRings =
      /** @type {Array<Array<number>>} */
      (objectStack[objectStack.length - 1]);
    flatLinearRings[0] = flatLinearRing;
  }
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function linkParser(node, objectStack) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["parseNode"])(LINK_PARSERS, node, objectStack);
}

/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function whenParser(node, objectStack) {
  const gxTrackObject =
    /** @type {GxTrackObject} */
    (objectStack[objectStack.length - 1]);
  const whens = gxTrackObject.whens;
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["getAllTextContent"])(node, false);
  const when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
}

/**
 * @param {Node} node Node to append a TextNode with the color to.
 * @param {import("../color.js").Color|string} color Color.
 */
function writeColorTextNode(node, color) {
  const rgba = Object(_color_js__WEBPACK_IMPORTED_MODULE_16__["asArray"])(color);
  const opacity = rgba.length == 4 ? rgba[3] : 1;
  /** @type {Array<string|number>} */
  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
  for (let i = 0; i < 4; ++i) {
    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);
    abgr[i] = hex.length == 1 ? '0' + hex : hex;
  }
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"])(node, abgr.join(''));
}

/**
 * @param {Node} node Node to append a TextNode with the coordinates to.
 * @param {Array<number>} coordinates Coordinates.
 * @param {Array<*>} objectStack Object stack.
 */
function writeCoordinatesTextNode(node, coordinates, objectStack) {
  const context = objectStack[objectStack.length - 1];

  const layout = context['layout'];
  const stride = context['stride'];

  let dimension;
  if (layout == 'XY' || layout == 'XYM') {
    dimension = 2;
  } else if (layout == 'XYZ' || layout == 'XYZM') {
    dimension = 3;
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_17__["assert"])(false, 34); // Invalid geometry layout
  }

  const ii = coordinates.length;
  let text = '';
  if (ii > 0) {
    text += coordinates[0];
    for (let d = 1; d < dimension; ++d) {
      text += ',' + coordinates[d];
    }
    for (let i = stride; i < ii; i += stride) {
      text += ' ' + coordinates[i];
      for (let d = 1; d < dimension; ++d) {
        text += ',' + coordinates[i + d];
      }
    }
  }
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"])(node, text);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const EXTENDEDDATA_NODE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Data': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeDataNode),
  'value': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeDataNodeValue),
  'displayName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeDataNodeName),
});

/**
 * @param {Element} node Node.
 * @param {{name: *, value: *}} pair Name value pair.
 * @param {Array<*>} objectStack Object stack.
 */
function writeDataNode(node, pair, objectStack) {
  node.setAttribute('name', pair.name);
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const value = pair.value;

  if (typeof value == 'object') {
    if (value !== null && value.displayName) {
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
        context,
        EXTENDEDDATA_NODE_SERIALIZERS,
        _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
        [value.displayName],
        objectStack,
        ['displayName']
      );
    }

    if (value !== null && value.value) {
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
        context,
        EXTENDEDDATA_NODE_SERIALIZERS,
        _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
        [value.value],
        objectStack,
        ['value']
      );
    }
  } else {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
      context,
      EXTENDEDDATA_NODE_SERIALIZERS,
      _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
      [value],
      objectStack,
      ['value']
    );
  }
}

/**
 * @param {Node} node Node to append a TextNode with the name to.
 * @param {string} name DisplayName.
 */
function writeDataNodeName(node, name) {
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeCDATASection"])(node, name);
}

/**
 * @param {Node} node Node to append a CDATA Section with the value to.
 * @param {string} value Value.
 */
function writeDataNodeValue(node, value) {
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"])(node, value);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const DOCUMENT_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Placemark': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePlacemark),
});

/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [nodeName] Node name.
 * @return {Node|undefined} Node.
 */
const DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {
  const parentNode = objectStack[objectStack.length - 1].node;
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["createElementNS"])(parentNode.namespaceURI, 'Placemark');
};

/**
 * @param {Element} node Node.
 * @param {Array<Feature>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */
function writeDocument(node, features, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    DOCUMENT_SERIALIZERS,
    DOCUMENT_NODE_FACTORY,
    features,
    objectStack,
    undefined,
    this
  );
}

/**
 * A factory for creating Data nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */
const DATA_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('Data');

/**
 * @param {Element} node Node.
 * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.
 * @param {Array<*>} objectStack Object stack.
 */
function writeExtendedData(node, namesAndValues, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const names = namesAndValues.names;
  const values = namesAndValues.values;
  const length = names.length;

  for (let i = 0; i < length; i++) {
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
      context,
      EXTENDEDDATA_NODE_SERIALIZERS,
      DATA_NODE_FACTORY,
      [{name: names[i], value: values[i]}],
      objectStack
    );
  }
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const ICON_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(
  NAMESPACE_URIS,
  ['href'],
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h'])
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const ICON_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'href': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(GX_NAMESPACE_URIS, {
    'x': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
    'y': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
    'w': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
    'h': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
  })
);

/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [nodeName] Node name.
 * @return {Node|undefined} Node.
 */
const GX_NODE_FACTORY = function (value, objectStack, nodeName) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["createElementNS"])(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);
};

/**
 * @param {Element} node Node.
 * @param {Object} icon Icon object.
 * @param {Array<*>} objectStack Object stack.
 */
function writeIcon(node, icon, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const parentNode = objectStack[objectStack.length - 1].node;
  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  let values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(icon, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    ICON_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(icon, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    ICON_SERIALIZERS,
    GX_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const ICON_STYLE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'scale',
  'heading',
  'Icon',
  'color',
  'hotSpot',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const ICON_STYLE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'Icon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeIcon),
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeColorTextNode),
  'heading': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
  'hotSpot': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeVec2),
  'scale': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeScaleTextNode),
});

/**
 * @param {Element} node Node.
 * @param {import("../style/Icon.js").default} style Icon style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeIconStyle(node, style, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const /** @type {Object<string, any>} */ properties = {};
  const src = style.getSrc();
  const size = style.getSize();
  const iconImageSize = style.getImageSize();
  const iconProperties = {
    'href': src,
  };

  if (size) {
    iconProperties['w'] = size[0];
    iconProperties['h'] = size[1];
    const anchor = style.getAnchor(); // top-left
    const origin = style.getOrigin(); // top-left

    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
      iconProperties['x'] = origin[0];
      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);
    }

    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      const /** @type {Vec2} */ hotSpot = {
          x: anchor[0],
          xunits: 'pixels',
          y: size[1] - anchor[1],
          yunits: 'pixels',
        };
      properties['hotSpot'] = hotSpot;
    }
  }

  properties['Icon'] = iconProperties;

  let scale = style.getScaleArray()[0];
  let imageSize = size;
  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }
  if (imageSize.length == 2) {
    const resizeScale = scaleForSize(imageSize);
    scale = scale / resizeScale;
  }
  if (scale !== 1) {
    properties['scale'] = scale;
  }

  const rotation = style.getRotation();
  if (rotation !== 0) {
    properties['heading'] = rotation; // 0-360
  }

  const color = style.getColor();
  if (color) {
    properties['color'] = color;
  }

  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    ICON_STYLE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const LABEL_STYLE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'color',
  'scale',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const LABEL_STYLE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeColorTextNode),
  'scale': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeScaleTextNode),
});

/**
 * @param {Element} node Node.
 * @param {Text} style style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeLabelStyle(node, style, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const properties = {};
  const fill = style.getFill();
  if (fill) {
    properties['color'] = fill.getColor();
  }
  const scale = style.getScale();
  if (scale && scale !== 1) {
    properties['scale'] = scale;
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    LABEL_STYLE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const LINE_STYLE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, ['color', 'width']);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const LINE_STYLE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeColorTextNode),
  'width': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"]),
});

/**
 * @param {Element} node Node.
 * @param {Stroke} style style.
 * @param {Array<*>} objectStack Object stack.
 */
function writeLineStyle(node, style, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const properties = {
    'color': style.getColor(),
    'width': Number(style.getWidth()) || 1,
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    LINE_STYLE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @const
 * @type {Object<string, string>}
 */
const GEOMETRY_TYPE_TO_NODENAME = {
  'Point': 'Point',
  'LineString': 'LineString',
  'LinearRing': 'LinearRing',
  'Polygon': 'Polygon',
  'MultiPoint': 'MultiGeometry',
  'MultiLineString': 'MultiGeometry',
  'MultiPolygon': 'MultiGeometry',
  'GeometryCollection': 'MultiGeometry',
};

/**
 * @const
 * @param {*} value Value.
 * @param {Array<*>} objectStack Object stack.
 * @param {string} [nodeName] Node name.
 * @return {Node|undefined} Node.
 */
const GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {
  if (value) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["createElementNS"])(
      parentNode.namespaceURI,
      GEOMETRY_TYPE_TO_NODENAME[
        /** @type {import("../geom/Geometry.js").default} */ (value).getType()
      ]
    );
  }
};

/**
 * A factory for creating Point nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const POINT_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('Point');

/**
 * A factory for creating LineString nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const LINE_STRING_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('LineString');

/**
 * A factory for creating LinearRing nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const LINEAR_RING_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('LinearRing');

/**
 * A factory for creating Polygon nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const POLYGON_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('Polygon');

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const MULTI_GEOMETRY_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
  'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
  'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePolygon),
  'GeometryCollection': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeMultiGeometry),
});

/**
 * @param {Element} node Node.
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */
function writeMultiGeometry(node, geometry, objectStack) {
  /** @type {import("../xml.js").NodeStackItem} */
  const context = {node: node};
  const type = geometry.getType();
  /** @type {Array<import("../geom/Geometry.js").default>} */
  let geometries = [];
  /** @type {function(*, Array<*>, string=): (Node|undefined)} */
  let factory;
  if (type === 'GeometryCollection') {
    /** @type {GeometryCollection} */ (geometry)
      .getGeometriesArrayRecursive()
      .forEach(function (geometry) {
        const type = geometry.getType();
        if (type === 'MultiPoint') {
          geometries = geometries.concat(
            /** @type {MultiPoint} */ (geometry).getPoints()
          );
        } else if (type === 'MultiLineString') {
          geometries = geometries.concat(
            /** @type {MultiLineString} */ (geometry).getLineStrings()
          );
        } else if (type === 'MultiPolygon') {
          geometries = geometries.concat(
            /** @type {MultiPolygon} */ (geometry).getPolygons()
          );
        } else if (
          type === 'Point' ||
          type === 'LineString' ||
          type === 'Polygon'
        ) {
          geometries.push(geometry);
        } else {
          Object(_asserts_js__WEBPACK_IMPORTED_MODULE_17__["assert"])(false, 39); // Unknown geometry type
        }
      });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === 'MultiPoint') {
    geometries = /** @type {MultiPoint} */ (geometry).getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === 'MultiLineString') {
    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === 'MultiPolygon') {
    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_17__["assert"])(false, 39); // Unknown geometry type
  }
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    MULTI_GEOMETRY_SERIALIZERS,
    factory,
    geometries,
    objectStack
  );
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const BOUNDARY_IS_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
});

/**
 * @param {Element} node Node.
 * @param {import("../geom/LinearRing.js").default} linearRing Linear ring.
 * @param {Array<*>} objectStack Object stack.
 */
function writeBoundaryIs(node, linearRing, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    BOUNDARY_IS_SERIALIZERS,
    LINEAR_RING_NODE_FACTORY,
    [linearRing],
    objectStack
  );
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const PLACEMARK_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'ExtendedData': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeExtendedData),
  'MultiGeometry': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeMultiGeometry),
  'LineString': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
  'LinearRing': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
  'Point': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePrimitiveGeometry),
  'Polygon': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePolygon),
  'Style': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeStyle),
  'address': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'description': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'open': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
  'phoneNumber': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'styleUrl': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'visibility': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
});

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const PLACEMARK_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'name',
  'open',
  'visibility',
  'address',
  'phoneNumber',
  'description',
  'styleUrl',
  'Style',
]);

/**
 * A factory for creating ExtendedData nodes.
 * @const
 * @type {function(*, Array<*>): (Node|undefined)}
 */
const EXTENDEDDATA_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('ExtendedData');

/**
 * FIXME currently we do serialize arbitrary/custom feature properties
 * (ExtendedData).
 * @param {Element} node Node.
 * @param {Feature} feature Feature.
 * @param {Array<*>} objectStack Object stack.
 * @this {KML}
 */
function writePlacemark(node, feature, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};

  // set id
  if (feature.getId()) {
    node.setAttribute('id', /** @type {string} */ (feature.getId()));
  }

  // serialize properties (properties unknown to KML are not serialized)
  const properties = feature.getProperties();

  // don't export these to ExtendedData
  const filter = {
    'address': 1,
    'description': 1,
    'name': 1,
    'open': 1,
    'phoneNumber': 1,
    'styleUrl': 1,
    'visibility': 1,
  };
  filter[feature.getGeometryName()] = 1;
  const keys = Object.keys(properties || {})
    .sort()
    .filter(function (v) {
      return !filter[v];
    });

  const styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    // FIXME the styles returned by the style function are supposed to be
    // resolution-independent here
    const styles = styleFunction(feature, 0);
    if (styles) {
      const styleArray = Array.isArray(styles) ? styles : [styles];
      let pointStyles = styleArray;
      if (feature.getGeometry()) {
        pointStyles = styleArray.filter(function (style) {
          const geometry = style.getGeometryFunction()(feature);
          if (geometry) {
            const type = geometry.getType();
            if (type === 'GeometryCollection') {
              return /** @type {GeometryCollection} */ (geometry)
                .getGeometriesArrayRecursive()
                .filter(function (geometry) {
                  const type = geometry.getType();
                  return type === 'Point' || type === 'MultiPoint';
                }).length;
            }
            return type === 'Point' || type === 'MultiPoint';
          }
        });
        ('Point');
      }
      if (this.writeStyles_) {
        let lineStyles = styleArray;
        let polyStyles = styleArray;
        if (feature.getGeometry()) {
          lineStyles = styleArray.filter(function (style) {
            const geometry = style.getGeometryFunction()(feature);
            if (geometry) {
              const type = geometry.getType();
              if (type === 'GeometryCollection') {
                return /** @type {GeometryCollection} */ (geometry)
                  .getGeometriesArrayRecursive()
                  .filter(function (geometry) {
                    const type = geometry.getType();
                    return type === 'LineString' || type === 'MultiLineString';
                  }).length;
              }
              return type === 'LineString' || type === 'MultiLineString';
            }
          });
          polyStyles = styleArray.filter(function (style) {
            const geometry = style.getGeometryFunction()(feature);
            if (geometry) {
              const type = geometry.getType();
              if (type === 'GeometryCollection') {
                return /** @type {GeometryCollection} */ (geometry)
                  .getGeometriesArrayRecursive()
                  .filter(function (geometry) {
                    const type = geometry.getType();
                    return type === 'Polygon' || type === 'MultiPolygon';
                  }).length;
              }
              return type === 'Polygon' || type === 'MultiPolygon';
            }
          });
        }
        properties['Style'] = {
          pointStyles: pointStyles,
          lineStyles: lineStyles,
          polyStyles: polyStyles,
        };
      }
      if (pointStyles.length && properties['name'] === undefined) {
        const textStyle = pointStyles[0].getText();
        if (textStyle) {
          properties['name'] = textStyle.getText();
        }
      }
    }
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    PLACEMARK_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );

  if (keys.length > 0) {
    const sequence = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, keys);
    const namesAndValues = {names: keys, values: sequence};
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
      context,
      PLACEMARK_SERIALIZERS,
      EXTENDEDDATA_NODE_FACTORY,
      [namesAndValues],
      objectStack
    );
  }

  // serialize geometry
  const options = /** @type {import("./Feature.js").WriteOptions} */ (
    objectStack[0]
  );
  let geometry = feature.getGeometry();
  if (geometry) {
    geometry = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_22__["transformGeometryWithOptions"])(geometry, true, options);
  }
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    PLACEMARK_SERIALIZERS,
    GEOMETRY_NODE_FACTORY,
    [geometry],
    objectStack
  );
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const PRIMITIVE_GEOMETRY_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'extrude',
  'tessellate',
  'altitudeMode',
  'coordinates',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const PRIMITIVE_GEOMETRY_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'extrude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
  'tessellate': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
  'altitudeMode': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeStringTextNode"]),
  'coordinates': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeCoordinatesTextNode),
});

/**
 * @param {Element} node Node.
 * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @param {Array<*>} objectStack Object stack.
 */
function writePrimitiveGeometry(node, geometry, objectStack) {
  const flatCoordinates = geometry.getFlatCoordinates();
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  context['layout'] = geometry.getLayout();
  context['stride'] = geometry.getStride();

  // serialize properties (properties unknown to KML are not serialized)
  const properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;

  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    PRIMITIVE_GEOMETRY_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const POLY_STYLE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'color',
  'fill',
  'outline',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const POLYGON_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'outerBoundaryIs': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeBoundaryIs),
  'innerBoundaryIs': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeBoundaryIs),
});

/**
 * A factory for creating innerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const INNER_BOUNDARY_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('innerBoundaryIs');

/**
 * A factory for creating outerBoundaryIs nodes.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const OUTER_BOUNDARY_NODE_FACTORY = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSimpleNodeFactory"])('outerBoundaryIs');

/**
 * @param {Element} node Node.
 * @param {Polygon} polygon Polygon.
 * @param {Array<*>} objectStack Object stack.
 */
function writePolygon(node, polygon, objectStack) {
  const linearRings = polygon.getLinearRings();
  const outerRing = linearRings.shift();
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  // inner rings
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    POLYGON_SERIALIZERS,
    INNER_BOUNDARY_NODE_FACTORY,
    linearRings,
    objectStack
  );
  // outer ring
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    POLYGON_SERIALIZERS,
    OUTER_BOUNDARY_NODE_FACTORY,
    [outerRing],
    objectStack
  );
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const POLY_STYLE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'color': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeColorTextNode),
  'fill': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
  'outline': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeBooleanTextNode"]),
});

/**
 * @param {Element} node Node.
 * @param {Style} style Style.
 * @param {Array<*>} objectStack Object stack.
 */
function writePolyStyle(node, style, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const fill = style.getFill();
  const stroke = style.getStroke();
  const properties = {
    'color': fill ? fill.getColor() : undefined,
    'fill': fill ? undefined : false,
    'outline': stroke ? undefined : false,
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    POLY_STYLE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @param {Node} node Node to append a TextNode with the scale to.
 * @param {number|undefined} scale Scale.
 */
function writeScaleTextNode(node, scale) {
  // the Math is to remove any excess decimals created by float arithmetic
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_20__["writeDecimalTextNode"])(node, Math.round(scale * 1e6) / 1e6);
}

/**
 * @const
 * @type {Object<string, Array<string>>}
 */
// @ts-ignore
const STYLE_SEQUENCE = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, [
  'IconStyle',
  'LabelStyle',
  'LineStyle',
  'PolyStyle',
]);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
// @ts-ignore
const STYLE_SERIALIZERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeStructureNS"])(NAMESPACE_URIS, {
  'IconStyle': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeIconStyle),
  'LabelStyle': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeLabelStyle),
  'LineStyle': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writeLineStyle),
  'PolyStyle': Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeChildAppender"])(writePolyStyle),
});

/**
 * @param {Element} node Node.
 * @param {Object<string, Array<Style>>} styles Styles.
 * @param {Array<*>} objectStack Object stack.
 */
function writeStyle(node, styles, objectStack) {
  const /** @type {import("../xml.js").NodeStackItem} */ context = {node: node};
  const properties = {};
  if (styles.pointStyles.length) {
    const textStyle = styles.pointStyles[0].getText();
    if (textStyle) {
      properties['LabelStyle'] = textStyle;
    }
    const imageStyle = styles.pointStyles[0].getImage();
    if (
      imageStyle &&
      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'
    ) {
      properties['IconStyle'] = imageStyle;
    }
  }
  if (styles.lineStyles.length) {
    const strokeStyle = styles.lineStyles[0].getStroke();
    if (strokeStyle) {
      properties['LineStyle'] = strokeStyle;
    }
  }
  if (styles.polyStyles.length) {
    const strokeStyle = styles.polyStyles[0].getStroke();
    if (strokeStyle && !properties['LineStyle']) {
      properties['LineStyle'] = strokeStyle;
    }
    properties['PolyStyle'] = styles.polyStyles[0];
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["makeSequence"])(properties, orderedKeys);
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_15__["pushSerializeAndPop"])(
    context,
    STYLE_SERIALIZERS,
    _xml_js__WEBPACK_IMPORTED_MODULE_15__["OBJECT_PROPERTY_NODE_FACTORY"],
    values,
    objectStack,
    orderedKeys
  );
}

/**
 * @param {Element} node Node to append a TextNode with the Vec2 to.
 * @param {Vec2} vec2 Vec2.
 */
function writeVec2(node, vec2) {
  node.setAttribute('x', String(vec2.x));
  node.setAttribute('y', String(vec2.y));
  node.setAttribute('xunits', vec2.xunits);
  node.setAttribute('yunits', vec2.yunits);
}

/* harmony default export */ __webpack_exports__["default"] = (KML);


/***/ }),

/***/ "./node_modules/ol/format/OWS.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/OWS.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XML.js */ "./node_modules/ol/format/XML.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xlink.js */ "./node_modules/ol/format/xlink.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/**
 * @module ol/format/OWS
 */





/**
 * @const
 * @type {Array<null|string>}
 */
const NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'ServiceIdentification': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readServiceIdentification),
  'ServiceProvider': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readServiceProvider),
  'OperationsMetadata': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readOperationsMetadata),
});

class OWS extends _XML_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
  }

  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(node) {
    const owsObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, PARSERS, node, []);
    return owsObject ? owsObject : null;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const ADDRESS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'DeliveryPoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'City': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'AdministrativeArea': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'PostalCode': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'Country': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'ElectronicMailAddress': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const ALLOWED_VALUES_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Value': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readValue),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONSTRAINT_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'AllowedValues': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readAllowedValues),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONTACT_INFO_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Phone': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readPhone),
  'Address': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readAddress),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const DCP_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'HTTP': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readHttp),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const HTTP_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Get': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readGet),
  'Post': undefined, // TODO
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const OPERATION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'DCP': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readDcp),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const OPERATIONS_METADATA_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Operation': readOperation,
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PHONE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Voice': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'Facsimile': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const REQUEST_METHOD_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Constraint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readConstraint),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const SERVICE_CONTACT_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'IndividualName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'PositionName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'ContactInfo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readContactInfo),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const SERVICE_IDENTIFICATION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Abstract': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'AccessConstraints': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'Fees': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'ServiceTypeVersion': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'ServiceType': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const SERVICE_PROVIDER_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'ProviderName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"]),
  'ProviderSite': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xlink_js__WEBPACK_IMPORTED_MODULE_2__["readHref"]),
  'ServiceContact': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readServiceContact),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The address.
 */
function readAddress(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, ADDRESS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The values.
 */
function readAllowedValues(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The constraint.
 */
function readConstraint(node, objectStack) {
  const name = node.getAttribute('name');
  if (!name) {
    return undefined;
  }
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({'name': name}, CONSTRAINT_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The contact info.
 */
function readContactInfo(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, CONTACT_INFO_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The DCP.
 */
function readDcp(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, DCP_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The GET object.
 */
function readGet(node, objectStack) {
  const href = Object(_xlink_js__WEBPACK_IMPORTED_MODULE_2__["readHref"])(node);
  if (!href) {
    return undefined;
  }
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
    {'href': href},
    REQUEST_METHOD_PARSERS,
    node,
    objectStack
  );
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The HTTP object.
 */
function readHttp(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, HTTP_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operation.
 */
function readOperation(node, objectStack) {
  const name = node.getAttribute('name');
  const value = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, OPERATION_PARSERS, node, objectStack);
  if (!value) {
    return undefined;
  }
  const object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  object[name] = value;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operations metadata.
 */
function readOperationsMetadata(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The phone.
 */
function readPhone(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, PHONE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service identification.
 */
function readServiceIdentification(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service contact.
 */
function readServiceContact(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service provider.
 */
function readServiceProvider(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}

/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {string|undefined} The value.
 */
function readValue(node, objectStack) {
  return Object(_xsd_js__WEBPACK_IMPORTED_MODULE_3__["readString"])(node);
}

/* harmony default export */ __webpack_exports__["default"] = (OWS);


/***/ }),

/***/ "./node_modules/ol/format/Polyline.js":
/*!********************************************!*\
  !*** ./node_modules/ol/format/Polyline.js ***!
  \********************************************/
/*! exports provided: encodeDeltas, decodeDeltas, encodeFloats, decodeFloats, encodeSignedIntegers, decodeSignedIntegers, encodeUnsignedIntegers, decodeUnsignedIntegers, encodeUnsignedInteger, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeDeltas", function() { return encodeDeltas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeDeltas", function() { return decodeDeltas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeFloats", function() { return encodeFloats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeFloats", function() { return decodeFloats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeSignedIntegers", function() { return encodeSignedIntegers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeSignedIntegers", function() { return decodeSignedIntegers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeUnsignedIntegers", function() { return encodeUnsignedIntegers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeUnsignedIntegers", function() { return decodeUnsignedIntegers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeUnsignedInteger", function() { return encodeUnsignedInteger; });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextFeature.js */ "./node_modules/ol/format/TextFeature.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/flip.js */ "./node_modules/ol/geom/flat/flip.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/Polyline
 */










/**
 * @typedef {Object} Options
 * @property {number} [factor=1e5] The factor by which the coordinates values will be scaled.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the format reader.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the Encoded
 * Polyline Algorithm Format.
 *
 * When reading features, the coordinates are assumed to be in two dimensions
 * and in [latitude, longitude] order.
 *
 * As Polyline sources contain a single feature,
 * {@link module:ol/format/Polyline~Polyline#readFeatures} will return the
 * feature in an array.
 *
 * @api
 */
class Polyline extends _TextFeature_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])('EPSG:4326');

    /**
     * @private
     * @type {number}
     */
    this.factor_ = options.factor ? options.factor : 1e5;

    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    this.geometryLayout_ = options.geometryLayout
      ? options.geometryLayout
      : 'XY';
  }

  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(text, options) {
    const geometry = this.readGeometryFromText(text, options);
    return new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](geometry);
  }

  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(text, options) {
    const feature = this.readFeatureFromText(text, options);
    return [feature];
  }

  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(text, options) {
    const stride = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["getStrideForLayout"])(this.geometryLayout_);
    const flatCoordinates = decodeDeltas(text, stride, this.factor_);
    Object(_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__["flipXY"])(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    const coordinates = Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    const lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__["default"](coordinates, this.geometryLayout_);

    return Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(
      lineString,
      false,
      this.adaptOptions(options)
    );
  }

  /**
   * @param {import("../Feature.js").default<LineString>} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_3__["assert"])(false, 40); // Expected `feature` to have a geometry
    return '';
  }

  /**
   * @param {Array<import("../Feature.js").default<LineString>>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(features, options) {
    return this.writeFeatureText(features[0], options);
  }

  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(geometry, options) {
    geometry =
      /** @type {LineString} */
      (
        Object(_Feature_js__WEBPACK_IMPORTED_MODULE_8__["transformGeometryWithOptions"])(geometry, true, this.adaptOptions(options))
      );
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    Object(_geom_flat_flip_js__WEBPACK_IMPORTED_MODULE_4__["flipXY"])(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  }
}

/**
 * Encode a list of n-dimensional points and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of n-dimensional points.
 * @param {number} stride The number of dimension of the points in the list.
 * @param {number} [factor] The factor by which the numbers will be
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * @return {string} The encoded string.
 * @api
 */
function encodeDeltas(numbers, stride, factor) {
  factor = factor ? factor : 1e5;
  let d;

  const lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }

  for (let i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      const num = numbers[i];
      const delta = num - lastNumbers[d];
      lastNumbers[d] = num;

      numbers[i] = delta;
    }
  }

  return encodeFloats(numbers, factor);
}

/**
 * Decode a list of n-dimensional points from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @param {number} stride The number of dimension of the points in the
 *     encoded string.
 * @param {number} [factor] The factor by which the resulting numbers will
 *     be divided. Default is `1e5`.
 * @return {Array<number>} A list of n-dimensional points.
 * @api
 */
function decodeDeltas(encoded, stride, factor) {
  factor = factor ? factor : 1e5;
  let d;

  /** @type {Array<number>} */
  const lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }

  const numbers = decodeFloats(encoded, factor);

  for (let i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      lastNumbers[d] += numbers[i];

      numbers[i] = lastNumbers[d];
    }
  }

  return numbers;
}

/**
 * Encode a list of floating point numbers and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of floating point numbers.
 * @param {number} [factor] The factor by which the numbers will be
 *     multiplied. The remaining decimal places will get rounded away.
 *     Default is `1e5`.
 * @return {string} The encoded string.
 * @api
 */
function encodeFloats(numbers, factor) {
  factor = factor ? factor : 1e5;
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] = Math.round(numbers[i] * factor);
  }

  return encodeSignedIntegers(numbers);
}

/**
 * Decode a list of floating point numbers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @param {number} [factor] The factor by which the result will be divided.
 *     Default is `1e5`.
 * @return {Array<number>} A list of floating point numbers.
 * @api
 */
function decodeFloats(encoded, factor) {
  factor = factor ? factor : 1e5;
  const numbers = decodeSignedIntegers(encoded);
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] /= factor;
  }
  return numbers;
}

/**
 * Encode a list of signed integers and return an encoded string
 *
 * Attention: This function will modify the passed array!
 *
 * @param {Array<number>} numbers A list of signed integers.
 * @return {string} The encoded string.
 */
function encodeSignedIntegers(numbers) {
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    const num = numbers[i];
    numbers[i] = num < 0 ? ~(num << 1) : num << 1;
  }
  return encodeUnsignedIntegers(numbers);
}

/**
 * Decode a list of signed integers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @return {Array<number>} A list of signed integers.
 */
function decodeSignedIntegers(encoded) {
  const numbers = decodeUnsignedIntegers(encoded);
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    const num = numbers[i];
    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
}

/**
 * Encode a list of unsigned integers and return an encoded string
 *
 * @param {Array<number>} numbers A list of unsigned integers.
 * @return {string} The encoded string.
 */
function encodeUnsignedIntegers(numbers) {
  let encoded = '';
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    encoded += encodeUnsignedInteger(numbers[i]);
  }
  return encoded;
}

/**
 * Decode a list of unsigned integers from an encoded string
 *
 * @param {string} encoded An encoded string.
 * @return {Array<number>} A list of unsigned integers.
 */
function decodeUnsignedIntegers(encoded) {
  const numbers = [];
  let current = 0;
  let shift = 0;
  for (let i = 0, ii = encoded.length; i < ii; ++i) {
    const b = encoded.charCodeAt(i) - 63;
    current |= (b & 0x1f) << shift;
    if (b < 0x20) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
}

/**
 * Encode one single unsigned integer and return an encoded string
 *
 * @param {number} num Unsigned integer that should be encoded.
 * @return {string} The encoded string.
 */
function encodeUnsignedInteger(num) {
  let value,
    encoded = '';
  while (num >= 0x20) {
    value = (0x20 | (num & 0x1f)) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}

/* harmony default export */ __webpack_exports__["default"] = (Polyline);


/***/ }),

/***/ "./node_modules/ol/format/TextFeature.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/format/TextFeature.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../format/Feature.js */ "./node_modules/ol/format/Feature.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/format/TextFeature
 */



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for text feature formats.
 *
 * @abstract
 */
class TextFeature extends _format_Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
  }

  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return 'text';
  }

  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(source, options) {
    return this.readFeatureFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }

  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(text, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(source, options) {
    return this.readFeaturesFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }

  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromText(text, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(source, options) {
    return this.readGeometryFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }

  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(text, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(source) {
    return this.readProjectionFromText(getText(source));
  }

  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjectionFromText(text) {
    return this.dataProjection;
  }

  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(feature, options) {
    return this.writeFeatureText(feature, this.adaptOptions(options));
  }

  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(feature, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(features, options) {
    return this.writeFeaturesText(features, this.adaptOptions(options));
  }

  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(features, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Geometry.
   * @api
   */
  writeGeometry(geometry, options) {
    return this.writeGeometryText(geometry, this.adaptOptions(options));
  }

  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(geometry, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }
}

/**
 * @param {Document|Element|Object|string} source Source.
 * @return {string} Text.
 */
function getText(source) {
  if (typeof source === 'string') {
    return source;
  }
  return '';
}

/* harmony default export */ __webpack_exports__["default"] = (TextFeature);


/***/ }),

/***/ "./node_modules/ol/format/TopoJSON.js":
/*!********************************************!*\
  !*** ./node_modules/ol/format/TopoJSON.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JSONFeature.js */ "./node_modules/ol/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/TopoJSON
 */











/**
 * @typedef {import("topojson-specification").Topology} TopoJSONTopology
 * @typedef {import("topojson-specification").GeometryCollection} TopoJSONGeometryCollection
 * @typedef {import("topojson-specification").GeometryObject} TopoJSONGeometry
 * @typedef {import("topojson-specification").Point} TopoJSONPoint
 * @typedef {import("topojson-specification").MultiPoint} TopoJSONMultiPoint
 * @typedef {import("topojson-specification").LineString} TopoJSONLineString
 * @typedef {import("topojson-specification").MultiLineString} TopoJSONMultiLineString
 * @typedef {import("topojson-specification").Polygon} TopoJSONPolygon
 * @typedef {import("topojson-specification").MultiPolygon} TopoJSONMultiPolygon
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {string} [layerName] Set the name of the TopoJSON topology
 * `objects`'s children as feature property with the specified name. This means
 * that when set to `'layer'`, a topology like
 * ```
 * {
 *   "type": "Topology",
 *   "objects": {
 *     "example": {
 *       "type": "GeometryCollection",
 *       "geometries": []
 *     }
 *   }
 * }
 * ```
 * will result in features that have a property `'layer'` set to `'example'`.
 * When not set, no property will be added to features.
 * @property {Array<string>} [layers] Names of the TopoJSON topology's
 * `objects`'s children to read features from.  If not provided, features will
 * be read from all children.
 */

/**
 * @classdesc
 * Feature format for reading data in the TopoJSON format.
 *
 * @api
 */
class TopoJSON extends _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.layerName_ = options.layerName;

    /**
     * @private
     * @type {?Array<string>}
     */
    this.layers_ = options.layers ? options.layers : null;

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_8__["get"])(
      options.dataProjection ? options.dataProjection : 'EPSG:4326'
    );
  }

  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(object, options) {
    if (object.type == 'Topology') {
      const topoJSONTopology = /** @type {TopoJSONTopology} */ (object);
      let transform,
        scale = null,
        translate = null;
      if (topoJSONTopology['transform']) {
        transform = topoJSONTopology['transform'];
        scale = transform['scale'];
        translate = transform['translate'];
      }
      const arcs = topoJSONTopology['arcs'];
      if (transform) {
        transformArcs(arcs, scale, translate);
      }
      /** @type {Array<Feature>} */
      const features = [];
      const topoJSONFeatures = topoJSONTopology['objects'];
      const property = this.layerName_;
      let feature;
      for (const objectName in topoJSONFeatures) {
        if (this.layers_ && !this.layers_.includes(objectName)) {
          continue;
        }
        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {
          feature = /** @type {TopoJSONGeometryCollection} */ (
            topoJSONFeatures[objectName]
          );
          features.push.apply(
            features,
            readFeaturesFromGeometryCollection(
              feature,
              arcs,
              scale,
              translate,
              property,
              objectName,
              options
            )
          );
        } else {
          feature = /** @type {TopoJSONGeometry} */ (
            topoJSONFeatures[objectName]
          );
          features.push(
            readFeatureFromGeometry(
              feature,
              arcs,
              scale,
              translate,
              property,
              objectName,
              options
            )
          );
        }
      }
      return features;
    }
    return [];
  }

  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(object) {
    return this.dataProjection;
  }
}

/**
 * @const
 * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import("../geom/Geometry.js").default>}
 */
const GEOMETRY_READERS = {
  'Point': readPointGeometry,
  'LineString': readLineStringGeometry,
  'Polygon': readPolygonGeometry,
  'MultiPoint': readMultiPointGeometry,
  'MultiLineString': readMultiLineStringGeometry,
  'MultiPolygon': readMultiPolygonGeometry,
};

/**
 * Concatenate arcs into a coordinate array.
 * @param {Array<number>} indices Indices of arcs to concatenate.  Negative
 *     values indicate arcs need to be reversed.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs (already
 *     transformed).
 * @return {Array<import("../coordinate.js").Coordinate>} Coordinates array.
 */
function concatenateArcs(indices, arcs) {
  /** @type {Array<import("../coordinate.js").Coordinate>} */
  const coordinates = [];
  let index;
  for (let i = 0, ii = indices.length; i < ii; ++i) {
    index = indices[i];
    if (i > 0) {
      // splicing together arcs, discard last point
      coordinates.pop();
    }
    if (index >= 0) {
      // forward arc
      const arc = arcs[index];
      for (let j = 0, jj = arc.length; j < jj; ++j) {
        coordinates.push(arc[j].slice(0));
      }
    } else {
      // reverse arc
      const arc = arcs[~index];
      for (let j = arc.length - 1; j >= 0; --j) {
        coordinates.push(arc[j].slice(0));
      }
    }
  }
  return coordinates;
}

/**
 * Create a point from a TopoJSON geometry object.
 *
 * @param {TopoJSONPoint} object TopoJSON object.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @return {Point} Geometry.
 */
function readPointGeometry(object, scale, translate) {
  const coordinates = object['coordinates'];
  if (scale && translate) {
    transformVertex(coordinates, scale, translate);
  }
  return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates);
}

/**
 * Create a multi-point from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiPoint} object TopoJSON object.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @return {MultiPoint} Geometry.
 */
function readMultiPointGeometry(object, scale, translate) {
  const coordinates = object['coordinates'];
  if (scale && translate) {
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      transformVertex(coordinates[i], scale, translate);
    }
  }
  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](coordinates);
}

/**
 * Create a linestring from a TopoJSON geometry object.
 *
 * @param {TopoJSONLineString} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {LineString} Geometry.
 */
function readLineStringGeometry(object, arcs) {
  const coordinates = concatenateArcs(object['arcs'], arcs);
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__["default"](coordinates);
}

/**
 * Create a multi-linestring from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiLineString} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {MultiLineString} Geometry.
 */
function readMultiLineStringGeometry(object, arcs) {
  const coordinates = [];
  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
  }
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](coordinates);
}

/**
 * Create a polygon from a TopoJSON geometry object.
 *
 * @param {TopoJSONPolygon} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {Polygon} Geometry.
 */
function readPolygonGeometry(object, arcs) {
  const coordinates = [];
  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
  }
  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"](coordinates);
}

/**
 * Create a multi-polygon from a TopoJSON geometry object.
 *
 * @param {TopoJSONMultiPolygon} object TopoJSON object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @return {MultiPolygon} Geometry.
 */
function readMultiPolygonGeometry(object, arcs) {
  const coordinates = [];
  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {
    // for each polygon
    const polyArray = object['arcs'][i];
    const ringCoords = [];
    for (let j = 0, jj = polyArray.length; j < jj; ++j) {
      // for each ring
      ringCoords[j] = concatenateArcs(polyArray[j], arcs);
    }
    coordinates[i] = ringCoords;
  }
  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](coordinates);
}

/**
 * Create features from a TopoJSON GeometryCollection object.
 *
 * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry
 *     object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
 *     object to.
 * @param {string} name Name of the `Topology`'s child object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {Array<Feature>} Array of features.
 */
function readFeaturesFromGeometryCollection(
  collection,
  arcs,
  scale,
  translate,
  property,
  name,
  options
) {
  const geometries = collection['geometries'];
  const features = [];
  for (let i = 0, ii = geometries.length; i < ii; ++i) {
    features[i] = readFeatureFromGeometry(
      geometries[i],
      arcs,
      scale,
      translate,
      property,
      name,
      options
    );
  }
  return features;
}

/**
 * Create a feature from a TopoJSON geometry object.
 *
 * @param {TopoJSONGeometry} object TopoJSON geometry object.
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
 *     object to.
 * @param {string} name Name of the `Topology`'s child object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {Feature} Feature.
 */
function readFeatureFromGeometry(
  object,
  arcs,
  scale,
  translate,
  property,
  name,
  options
) {
  let geometry = null;
  const type = object.type;
  if (type) {
    const geometryReader = GEOMETRY_READERS[type];
    if (type === 'Point' || type === 'MultiPoint') {
      geometry = geometryReader(object, scale, translate);
    } else {
      geometry = geometryReader(object, arcs);
    }
    geometry = Object(_Feature_js__WEBPACK_IMPORTED_MODULE_9__["transformGeometryWithOptions"])(geometry, false, options);
  }
  const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({geometry: geometry});
  if (object.id !== undefined) {
    feature.setId(object.id);
  }
  let properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature.setProperties(properties, true);
  }
  return feature;
}

/**
 * Apply a linear transform to array of arcs.  The provided array of arcs is
 * modified in place.
 *
 * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */
function transformArcs(arcs, scale, translate) {
  for (let i = 0, ii = arcs.length; i < ii; ++i) {
    transformArc(arcs[i], scale, translate);
  }
}

/**
 * Apply a linear transform to an arc.  The provided arc is modified in place.
 *
 * @param {Array<import("../coordinate.js").Coordinate>} arc Arc.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */
function transformArc(arc, scale, translate) {
  let x = 0;
  let y = 0;
  for (let i = 0, ii = arc.length; i < ii; ++i) {
    const vertex = arc[i];
    x += vertex[0];
    y += vertex[1];
    vertex[0] = x;
    vertex[1] = y;
    transformVertex(vertex, scale, translate);
  }
}

/**
 * Apply a linear transform to a vertex.  The provided vertex is modified in
 * place.
 *
 * @param {import("../coordinate.js").Coordinate} vertex Vertex.
 * @param {Array<number>} scale Scale for each dimension.
 * @param {Array<number>} translate Translation for each dimension.
 */
function transformVertex(vertex, scale, translate) {
  vertex[0] = vertex[0] * scale[0] + translate[0];
  vertex[1] = vertex[1] * scale[1] + translate[1];
}

/* harmony default export */ __webpack_exports__["default"] = (TopoJSON);


/***/ }),

/***/ "./node_modules/ol/format/WFS.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/WFS.js ***!
  \***************************************/
/*! exports provided: writeFilter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFilter", function() { return writeFilter; });
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML2.js */ "./node_modules/ol/format/GML2.js");
/* harmony import */ var _GML3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GML3.js */ "./node_modules/ol/format/GML3.js");
/* harmony import */ var _GML32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GML32.js */ "./node_modules/ol/format/GML32.js");
/* harmony import */ var _GMLBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GMLBase.js */ "./node_modules/ol/format/GMLBase.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XMLFeature.js */ "./node_modules/ol/format/XMLFeature.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter.js */ "./node_modules/ol/format/filter.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/**
 * @module ol/format/WFS
 */











/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
const FEATURE_COLLECTION_PARSERS = {
  'http://www.opengis.net/gml': {
    'boundedBy': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(
      _GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readExtentElement,
      'bounds'
    ),
  },
  'http://www.opengis.net/wfs/2.0': {
    'member': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.readFeaturesInternal),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
const TRANSACTION_SUMMARY_PARSERS = {
  'http://www.opengis.net/wfs': {
    'totalInserted': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
    'totalUpdated': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
    'totalDeleted': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
  },
  'http://www.opengis.net/wfs/2.0': {
    'totalInserted': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
    'totalUpdated': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
    'totalDeleted': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readPositiveInteger"]),
  },
};

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
const TRANSACTION_RESPONSE_PARSERS = {
  'http://www.opengis.net/wfs': {
    'TransactionSummary': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(
      readTransactionSummary,
      'transactionSummary'
    ),
    'InsertResults': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(readInsertResults, 'insertIds'),
  },
  'http://www.opengis.net/wfs/2.0': {
    'TransactionSummary': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(
      readTransactionSummary,
      'transactionSummary'
    ),
    'InsertResults': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeObjectPropertySetter"])(readInsertResults, 'insertIds'),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
const QUERY_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'PropertyName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"]),
  },
  'http://www.opengis.net/wfs/2.0': {
    'PropertyName': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"]),
  },
};

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
const TRANSACTION_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'Insert': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeFeature),
    'Update': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeUpdate),
    'Delete': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDelete),
    'Property': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeProperty),
    'Native': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeNative),
  },
  'http://www.opengis.net/wfs/2.0': {
    'Insert': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeFeature),
    'Update': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeUpdate),
    'Delete': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDelete),
    'Property': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeProperty),
    'Native': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeNative),
  },
};

/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.
 * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.
 * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.
 * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.
 * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.
 * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */

/**
 * @typedef {Object} WriteGetFeatureOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to
 * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are
 * ignored.).
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {string} [outputFormat] Output format.
 * @property {number} [maxFeatures] Maximum number of features to fetch.
 * @property {string} [geometryName] Geometry name to use in a BBOX filter.
 * @property {Array<string>} [propertyNames] Optional list of property names to serialize.
 * @property {string} [viewParams] viewParams GeoServer vendor parameter.
 * @property {number} [startIndex] Start index to use for WFS paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.
 * @property {number} [count] Number of features to retrieve when paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some
 * Web Feature Services have repurposed `maxfeatures` instead.
 * @property {import("../extent.js").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`
 * option must be set.
 * @property {import("./filter/Filter.js").default} [filter] Filter condition. See
 * {@link module:ol/format/filter} for more information.
 * @property {string} [resultType] Indicates what response should be returned,
 * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.
 */

/**
 * @typedef {Object} FeatureType
 * @property {!string} name The feature type name.
 * @property {!import("../extent.js").Extent} bbox Extent to use for the BBOX filter.
 * @property {!string} geometryName Geometry name to use in the BBOX filter.
 */

/**
 * @typedef {Object} WriteTransactionOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {string} featureType The feature type name.
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {boolean} [hasZ] Must be set to true if the transaction is for
 * a 3D layer. This will allow the Z coordinate to be included in the transaction.
 * @property {Array<Object>} nativeElements Native elements. Currently not supported.
 * @property {import("./GMLBase.js").Options} [gmlOptions] GML options for the WFS transaction writer.
 * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */

/**
 * Number of features; bounds/extent.
 * @typedef {Object} FeatureCollectionMetadata
 * @property {number} numberOfFeatures NumberOfFeatures.
 * @property {import("../extent.js").Extent} bounds Bounds.
 */

/**
 * Total deleted; total inserted; total updated; array of insert ids.
 * @typedef {Object} TransactionResponse
 * @property {number} totalDeleted TotalDeleted.
 * @property {number} totalInserted TotalInserted.
 * @property {number} totalUpdated TotalUpdated.
 * @property {Array<string>} insertIds InsertIds.
 */

/**
 * @type {string}
 */
const FEATURE_PREFIX = 'feature';

/**
 * @type {string}
 */
const XMLNS = 'http://www.w3.org/2000/xmlns/';

/**
 * @type {Object<string, string>}
 */
const OGCNS = {
  '2.0.0': 'http://www.opengis.net/ogc/1.1',
  '1.1.0': 'http://www.opengis.net/ogc',
  '1.0.0': 'http://www.opengis.net/ogc',
};

/**
 * @type {Object<string, string>}
 */
const WFSNS = {
  '2.0.0': 'http://www.opengis.net/wfs/2.0',
  '1.1.0': 'http://www.opengis.net/wfs',
  '1.0.0': 'http://www.opengis.net/wfs',
};

/**
 * @type {Object<string, string>}
 */
const FESNS = {
  '2.0.0': 'http://www.opengis.net/fes/2.0',
  '1.1.0': 'http://www.opengis.net/fes',
  '1.0.0': 'http://www.opengis.net/fes',
};

/**
 * @type {Object<string, string>}
 */
const SCHEMA_LOCATIONS = {
  '2.0.0':
    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',
  '1.1.0':
    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',
  '1.0.0':
    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',
};

/**
 * @type {Object<string, object>}
 */
const GML_FORMATS = {
  '2.0.0': _GML32_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  '1.1.0': _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  '1.0.0': _GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"],
};

/**
 * @const
 * @type {string}
 */
const DEFAULT_VERSION = '1.1.0';

/**
 * @classdesc
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option to override the default.
 * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.
 *
 * @api
 */
class WFS extends _XMLFeature_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {string}
     */
    this.version_ = options.version ? options.version : DEFAULT_VERSION;

    /**
     * @private
     * @type {Array<string>|string|undefined}
     */
    this.featureType_ = options.featureType;

    /**
     * @private
     * @type {Object<string, string>|string|undefined}
     */
    this.featureNS_ = options.featureNS;

    /**
     * @private
     * @type {GMLBase}
     */
    this.gmlFormat_ = options.gmlFormat
      ? options.gmlFormat
      : new GML_FORMATS[this.version_]();

    /**
     * @private
     * @type {string}
     */
    this.schemaLocation_ = options.schemaLocation
      ? options.schemaLocation
      : SCHEMA_LOCATIONS[this.version_];
  }

  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }

  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(featureType) {
    this.featureType_ = featureType;
  }

  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    /** @type {import("../xml.js").NodeStackItem} */
    const context = {
      node,
    };
    Object.assign(context, {
      'featureType': this.featureType_,
      'featureNS': this.featureNS_,
    });

    Object.assign(context, this.getReadOptions(node, options ? options : {}));
    const objectStack = [context];
    let featuresNS;
    if (this.version_ === '2.0.0') {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }
    let features = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])(
      [],
      featuresNS,
      node,
      objectStack,
      this.gmlFormat_
    );
    if (!features) {
      features = [];
    }
    return features;
  }

  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(source) {
    if (!source) {
      return undefined;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["parse"])(source);
      return this.readTransactionResponseFromDocument(doc);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["isDocument"])(source)) {
      return this.readTransactionResponseFromDocument(
        /** @type {Document} */ (source)
      );
    }
    return this.readTransactionResponseFromNode(
      /** @type {Element} */ (source)
    );
  }

  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(source) {
    if (!source) {
      return undefined;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["parse"])(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["isDocument"])(source)) {
      return this.readFeatureCollectionMetadataFromDocument(
        /** @type {Document} */ (source)
      );
    }
    return this.readFeatureCollectionMetadataFromNode(
      /** @type {Element} */ (source)
    );
  }

  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(doc) {
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */ (n)
        );
      }
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(node) {
    const result = {};
    const value = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["readNonNegativeIntegerString"])(
      node.getAttribute('numberOfFeatures')
    );
    result['numberOfFeatures'] = value;
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])(
      /** @type {FeatureCollectionMetadata} */ (result),
      FEATURE_COLLECTION_PARSERS,
      node,
      [],
      this.gmlFormat_
    );
  }

  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(doc) {
    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));
      }
    }
    return undefined;
  }

  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(node) {
    return Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])(
      /** @type {TransactionResponse} */ ({}),
      TRANSACTION_RESPONSE_PARSERS,
      node,
      []
    );
  }

  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(options) {
    const node = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(WFSNS[this.version_], 'GetFeature');
    node.setAttribute('service', 'WFS');
    node.setAttribute('version', this.version_);
    if (options.handle) {
      node.setAttribute('handle', options.handle);
    }
    if (options.outputFormat) {
      node.setAttribute('outputFormat', options.outputFormat);
    }
    if (options.maxFeatures !== undefined) {
      node.setAttribute('maxFeatures', String(options.maxFeatures));
    }
    if (options.resultType) {
      node.setAttribute('resultType', options.resultType);
    }
    if (options.startIndex !== undefined) {
      node.setAttribute('startIndex', String(options.startIndex));
    }
    if (options.count !== undefined) {
      node.setAttribute('count', String(options.count));
    }
    if (options.viewParams !== undefined) {
      node.setAttribute('viewParams', options.viewParams);
    }
    node.setAttributeNS(
      _xml_js__WEBPACK_IMPORTED_MODULE_5__["XML_SCHEMA_INSTANCE_URI"],
      'xsi:schemaLocation',
      this.schemaLocation_
    );
    /** @type {import("../xml.js").NodeStackItem} */
    const context = {
      node,
    };
    Object.assign(context, {
      'version': this.version_,
      'srsName': options.srsName,
      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,
      'featurePrefix': options.featurePrefix,
      'propertyNames': options.propertyNames ? options.propertyNames : [],
    });
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_7__["assert"])(Array.isArray(options.featureTypes), 11); // `options.featureTypes` must be an Array
    if (typeof options.featureTypes[0] === 'string') {
      let filter = options.filter;
      if (options.bbox) {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_7__["assert"])(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set
        filter = this.combineBboxAndFilter(
          options.geometryName,
          options.bbox,
          options.srsName,
          filter
        );
      }
      Object.assign(context, {
        'geometryName': options.geometryName,
        'filter': filter,
      });
      writeGetFeature(
        node,
        /** @type {!Array<string>} */ (options.featureTypes),
        [context]
      );
    } else {
      // Write one query node per element in featuresType.
      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {
        const completeFilter = this.combineBboxAndFilter(
          featureType.geometryName,
          featureType.bbox,
          options.srsName,
          options.filter
        );
        Object.assign(context, {
          'geometryName': featureType.geometryName,
          'filter': completeFilter,
        });
        writeGetFeature(node, [featureType.name], [context]);
      });
    }
    return node;
  }

  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(geometryName, extent, srsName, filter) {
    const bboxFilter = Object(_filter_js__WEBPACK_IMPORTED_MODULE_6__["bbox"])(geometryName, extent, srsName);
    if (filter) {
      // if bbox and filter are both set, combine the two into a single filter
      return Object(_filter_js__WEBPACK_IMPORTED_MODULE_6__["and"])(filter, bboxFilter);
    }
    return bboxFilter;
  }

  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(inserts, updates, deletes, options) {
    const objectStack = [];
    const version = options.version ? options.version : this.version_;
    const node = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(WFSNS[version], 'Transaction');

    node.setAttribute('service', 'WFS');
    node.setAttribute('version', version);
    let baseObj;
    /** @type {import("../xml.js").NodeStackItem} */
    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};
      if (options.handle) {
        node.setAttribute('handle', options.handle);
      }
    }
    node.setAttributeNS(
      _xml_js__WEBPACK_IMPORTED_MODULE_5__["XML_SCHEMA_INSTANCE_URI"],
      'xsi:schemaLocation',
      SCHEMA_LOCATIONS[version]
    );

    const request = createTransactionRequest(node, baseObj, version, options);
    if (inserts) {
      serializeTransactionRequest('Insert', inserts, objectStack, request);
    }
    if (updates) {
      serializeTransactionRequest('Update', updates, objectStack, request);
    }
    if (deletes) {
      serializeTransactionRequest('Delete', deletes, objectStack, request);
    }
    if (options.nativeElements) {
      serializeTransactionRequest(
        'Native',
        options.nativeElements,
        objectStack,
        request
      );
    }
    return node;
  }

  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(/** @type {Element} */ (n));
      }
    }
    return null;
  }

  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(node) {
    if (node.firstElementChild && node.firstElementChild.firstElementChild) {
      node = node.firstElementChild.firstElementChild;
      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
        if (
          !(
            n.childNodes.length === 0 ||
            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)
          )
        ) {
          const objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n, objectStack);
          return Object(_proj_js__WEBPACK_IMPORTED_MODULE_8__["get"])(objectStack.pop().srsName);
        }
      }
    }

    return null;
  }
}

/**
 * @param {Element} node Node.
 * @param {*} baseObj Base object.
 * @param {string} version Version.
 * @param {WriteTransactionOptions} options Options.
 * @return {Object} Request object.
 */
function createTransactionRequest(node, baseObj, version, options) {
  const featurePrefix = options.featurePrefix
    ? options.featurePrefix
    : FEATURE_PREFIX;
  let gmlVersion;
  if (version === '1.0.0') {
    gmlVersion = 2;
  } else if (version === '1.1.0') {
    gmlVersion = 3;
  } else if (version === '2.0.0') {
    gmlVersion = 3.2;
  }
  const obj = Object.assign(
    {node},
    {
      version,
      'featureNS': options.featureNS,
      'featureType': options.featureType,
      'featurePrefix': featurePrefix,
      'gmlVersion': gmlVersion,
      'hasZ': options.hasZ,
      'srsName': options.srsName,
    },
    baseObj
  );
  return obj;
}

/**
 * @param {string} type Request type.
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @param {Element} request Transaction Request.
 */
function serializeTransactionRequest(type, features, objectStack, request) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    request,
    TRANSACTION_SERIALIZERS,
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])(type),
    features,
    objectStack
  );
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Transaction Summary.
 */
function readTransactionSummary(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
const OGC_FID_PARSERS = {
  'http://www.opengis.net/ogc': {
    'FeatureId': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(function (node, objectStack) {
      return node.getAttribute('fid');
    }),
  },
  'http://www.opengis.net/ogc/1.1': {
    'FeatureId': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeArrayPusher"])(function (node, objectStack) {
      return node.getAttribute('fid');
    }),
  },
};

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */
function fidParser(node, objectStack) {
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["parseNode"])(OGC_FID_PARSERS, node, objectStack);
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
const INSERT_RESULTS_PARSERS = {
  'http://www.opengis.net/wfs': {
    'Feature': fidParser,
  },
  'http://www.opengis.net/wfs/2.0': {
    'Feature': fidParser,
  },
};

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Insert results.
 */
function readInsertResults(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushParseAndPop"])([], INSERT_RESULTS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */
function writeFeature(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const featureType = context['featureType'];
  const featureNS = context['featureNS'];
  const gmlVersion = context['gmlVersion'];
  const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(featureNS, featureType);
  node.appendChild(child);
  if (gmlVersion === 2) {
    _GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  } else if (gmlVersion === 3) {
    _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    _GML32_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.writeFeatureElement(child, feature, objectStack);
  }
}

/**
 * @param {Node} node Node.
 * @param {number|string} fid Feature identifier.
 * @param {Array<*>} objectStack Node stack.
 */
function writeOgcFidFilter(node, fid, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const version = context['version'];
  const ns = OGCNS[version];
  const filter = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'Filter');
  const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'FeatureId');
  filter.appendChild(child);
  child.setAttribute('fid', /** @type {string} */ (fid));
  node.appendChild(filter);
}

/**
 * @param {string|undefined} featurePrefix The prefix of the feature.
 * @param {string} featureType The type of the feature.
 * @return {string} The value of the typeName property.
 */
function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  const prefix = featurePrefix + ':';
  // The featureType already contains the prefix.
  if (featureType.startsWith(prefix)) {
    return featureType;
  }
  return prefix + featureType;
}

/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */
function writeDelete(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_7__["assert"])(feature.getId() !== undefined, 26); // Features must have an id set
  const featureType = context['featureType'];
  const featurePrefix = context['featurePrefix'];
  const featureNS = context['featureNS'];
  const typeName = getTypeName(featurePrefix, featureType);
  node.setAttribute('typeName', typeName);
  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== undefined) {
    writeOgcFidFilter(node, fid, objectStack);
  }
}

/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */
function writeUpdate(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_7__["assert"])(feature.getId() !== undefined, 27); // Features must have an id set
  const version = context['version'];
  const featureType = context['featureType'];
  const featurePrefix = context['featurePrefix'];
  const featureNS = context['featureNS'];
  const typeName = getTypeName(featurePrefix, featureType);
  const geometryName = feature.getGeometryName();
  node.setAttribute('typeName', typeName);
  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== undefined) {
    const keys = feature.getKeys();
    const values = [];
    for (let i = 0, ii = keys.length; i < ii; i++) {
      const value = feature.get(keys[i]);
      if (value !== undefined) {
        let name = keys[i];
        if (
          value &&
          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'
        ) {
          name = geometryName;
        }
        values.push({name: name, value: value});
      }
    }
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
      /** @type {import("../xml.js").NodeStackItem} */ ({
        version,
        'gmlVersion': context['gmlVersion'],
        node,
        'hasZ': context['hasZ'],
        'srsName': context['srsName'],
      }),
      TRANSACTION_SERIALIZERS,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])('Property'),
      values,
      objectStack
    );
    writeOgcFidFilter(node, fid, objectStack);
  }
}

/**
 * @param {Node} node Node.
 * @param {Object} pair Property name and value.
 * @param {Array<*>} objectStack Node stack.
 */
function writeProperty(node, pair, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const version = context['version'];
  const ns = WFSNS[version];
  const name = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'Name');
  const gmlVersion = context['gmlVersion'];
  node.appendChild(name);
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(name, pair.name);
  if (pair.value !== undefined && pair.value !== null) {
    const value = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'Value');
    node.appendChild(value);
    if (
      pair.value &&
      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===
        'function'
    ) {
      if (gmlVersion === 2) {
        _GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        _GML3_js__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        _GML32_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(value, pair.value);
    }
  }
}

/**
 * @param {Element} node Node.
 * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.
 * @param {Array<*>} objectStack Node stack.
 */
function writeNative(node, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node.setAttribute('vendorId', nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== undefined) {
    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));
  }
  if (nativeElement.value !== undefined) {
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(node, nativeElement.value);
  }
}

/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */
const GETFEATURE_SERIALIZERS = {
  'http://www.opengis.net/wfs': {
    'Query': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeQuery),
  },
  'http://www.opengis.net/wfs/2.0': {
    'Query': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeQuery),
  },
  'http://www.opengis.net/ogc': {
    'During': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDuringFilter),
    'And': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLogicalFilter),
    'Or': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLogicalFilter),
    'Not': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeNotFilter),
    'BBOX': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeBboxFilter),
    'Contains': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'Intersects': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'Within': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'DWithin': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDWithinFilter),
    'PropertyIsEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsNotEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsLessThan': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsLessThanOrEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsGreaterThan': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsGreaterThanOrEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsNull': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsNullFilter),
    'PropertyIsBetween': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsBetweenFilter),
    'PropertyIsLike': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsLikeFilter),
  },
  'http://www.opengis.net/fes/2.0': {
    'During': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDuringFilter),
    'And': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLogicalFilter),
    'Or': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeLogicalFilter),
    'Not': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeNotFilter),
    'BBOX': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeBboxFilter),
    'Contains': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'Disjoint': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'Intersects': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'ResourceId': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeResourceIdFilter),
    'Within': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeSpatialFilter),
    'DWithin': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeDWithinFilter),
    'PropertyIsEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsNotEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsLessThan': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsLessThanOrEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsGreaterThan': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsGreaterThanOrEqualTo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeComparisonFilter),
    'PropertyIsNull': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsNullFilter),
    'PropertyIsBetween': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsBetweenFilter),
    'PropertyIsLike': Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeChildAppender"])(writeIsLikeFilter),
  },
};

/**
 * @param {Element} node Node.
 * @param {string} featureType Feature type.
 * @param {Array<*>} objectStack Node stack.
 */
function writeQuery(node, featureType, objectStack) {
  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const version = context['version'];
  const featurePrefix = context['featurePrefix'];
  const featureNS = context['featureNS'];
  const propertyNames = context['propertyNames'];
  const srsName = context['srsName'];
  let typeName;
  // If feature prefix is not defined, we must not use the default prefix.
  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  let typeNameAttr;
  if (version === '2.0.0') {
    typeNameAttr = 'typeNames';
  } else {
    typeNameAttr = 'typeName';
  }
  node.setAttribute(typeNameAttr, typeName);
  if (srsName) {
    node.setAttribute('srsName', srsName);
  }
  if (featureNS) {
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
  }
  const item = /** @type {import("../xml.js").NodeStackItem} */ (
    Object.assign({}, context)
  );
  item.node = node;
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    item,
    QUERY_SERIALIZERS,
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])('PropertyName'),
    propertyNames,
    objectStack
  );
  const filter = context['filter'];
  if (filter) {
    const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(getFilterNS(version), 'Filter');
    node.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}

/**
 * @param {Element} node Node.
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeFilterCondition(node, filter, objectStack) {
  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  /** @type {import("../xml.js").NodeStackItem} */
  const item = {node};
  Object.assign(item, {context});
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    item,
    GETFEATURE_SERIALIZERS,
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])(filter.getTagName()),
    [filter],
    objectStack
  );
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/Bbox.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeBboxFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  parent['srsName'] = filter.srsName;
  const format = GML_FORMATS[version];

  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}

/**
 * @param {Element} node Element.
 * @param {import("./filter/ResourceId.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeResourceIdFilter(node, filter, objectStack) {
  node.setAttribute('rid', /** @type {string} */ (filter.rid));
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/Spatial.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeSpatialFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  parent['srsName'] = filter.srsName;
  const format = GML_FORMATS[version];

  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/DWithin.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeDWithinFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  writeSpatialFilter(node, filter, objectStack);
  const distance = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(getFilterNS(version), 'Distance');
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(distance, filter.distance.toString());
  if (version === '2.0.0') {
    distance.setAttribute('uom', filter.unit);
  } else {
    distance.setAttribute('units', filter.unit);
  }
  node.appendChild(distance);
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/During.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeDuringFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];

  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);
  const timePeriod = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["GMLNS"], 'TimePeriod');

  node.appendChild(timePeriod);

  const begin = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["GMLNS"], 'begin');
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);

  const end = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["GMLNS"], 'end');
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}

/**
 * @param {Element} node Node.
 * @param {import("./filter/LogicalNary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeLogicalFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  /** @type {import("../xml.js").NodeStackItem} */
  const item = {node};
  Object.assign(item, {context});
  const conditions = filter.conditions;
  for (let i = 0, ii = conditions.length; i < ii; ++i) {
    const condition = conditions[i];
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
      item,
      GETFEATURE_SERIALIZERS,
      Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])(condition.getTagName()),
      [condition],
      objectStack
    );
  }
}

/**
 * @param {Element} node Node.
 * @param {import("./filter/Not.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeNotFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  /** @type {import("../xml.js").NodeStackItem} */
  const item = {node};
  Object.assign(item, {context});
  const condition = filter.condition;
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    item,
    GETFEATURE_SERIALIZERS,
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])(condition.getTagName()),
    [condition],
    objectStack
  );
}

/**
 * @param {Element} node Node.
 * @param {import("./filter/ComparisonBinary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeComparisonFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  if (filter.matchCase !== undefined) {
    node.setAttribute('matchCase', filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, '' + filter.expression);
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/IsNull.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeIsNullFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  writePropertyName(version, node, filter.propertyName);
}

/**
 * @param {Node} node Node.
 * @param {import("./filter/IsBetween.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeIsBetweenFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  const ns = getFilterNS(version);

  writePropertyName(version, node, filter.propertyName);

  const lowerBoundary = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'LowerBoundary');
  node.appendChild(lowerBoundary);
  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);

  const upperBoundary = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, 'UpperBoundary');
  node.appendChild(upperBoundary);
  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);
}

/**
 * @param {Element} node Node.
 * @param {import("./filter/IsLike.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */
function writeIsLikeFilter(node, filter, objectStack) {
  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const context = parent['context'];
  const version = context['version'];
  node.setAttribute('wildCard', filter.wildCard);
  node.setAttribute('singleChar', filter.singleChar);
  node.setAttribute('escapeChar', filter.escapeChar);
  if (filter.matchCase !== undefined) {
    node.setAttribute('matchCase', filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, '' + filter.pattern);
}

/**
 * @param {string} ns Namespace.
 * @param {string} tagName Tag name.
 * @param {Node} node Node.
 * @param {string} value Value.
 */
function writeExpression(ns, tagName, node, value) {
  const property = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(ns, tagName);
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(property, value);
  node.appendChild(property);
}

/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */
function writeLiteral(version, node, value) {
  writeExpression(getFilterNS(version), 'Literal', node, value);
}

/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */
function writePropertyName(version, node, value) {
  if (version === '2.0.0') {
    writeExpression(FESNS[version], 'ValueReference', node, value);
  } else {
    writeExpression(OGCNS[version], 'PropertyName', node, value);
  }
}

/**
 * @param {Node} node Node.
 * @param {string} time PropertyName value.
 */
function writeTimeInstant(node, time) {
  const timeInstant = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["GMLNS"], 'TimeInstant');
  node.appendChild(timeInstant);

  const timePosition = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(_GMLBase_js__WEBPACK_IMPORTED_MODULE_3__["GMLNS"], 'timePosition');
  timeInstant.appendChild(timePosition);
  Object(_xsd_js__WEBPACK_IMPORTED_MODULE_9__["writeStringTextNode"])(timePosition, time);
}

/**
 * Encode filter as WFS `Filter` and return the Node.
 *
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {string} version WFS version. If not provided defaults to '1.1.0'
 * @return {Node} Result.
 * @api
 */
function writeFilter(filter, version) {
  version = version || '1.1.0';
  const child = Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["createElementNS"])(getFilterNS(version), 'Filter');
  const context = {
    node: child,
  };
  Object.assign(context, {
    'version': version,
    'filter': filter,
  });
  writeFilterCondition(child, filter, [context]);
  return child;
}

/**
 * @param {Element} node Node.
 * @param {Array<string>} featureTypes Feature types.
 * @param {Array<*>} objectStack Node stack.
 */
function writeGetFeature(node, featureTypes, objectStack) {
  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);
  const item = /** @type {import("../xml.js").NodeStackItem} */ (
    Object.assign({}, context)
  );
  item.node = node;
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["pushSerializeAndPop"])(
    item,
    GETFEATURE_SERIALIZERS,
    Object(_xml_js__WEBPACK_IMPORTED_MODULE_5__["makeSimpleNodeFactory"])('Query'),
    featureTypes,
    objectStack
  );
}

function getFilterNS(version) {
  let ns;
  if (version === '2.0.0') {
    ns = FESNS[version];
  } else {
    ns = OGCNS[version];
  }
  return ns;
}

/* harmony default export */ __webpack_exports__["default"] = (WFS);


/***/ }),

/***/ "./node_modules/ol/format/WKB.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/WKB.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/**
 * @module ol/format/WKB
 */













// WKB spec: https://www.ogc.org/standards/sfa
// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt

/**
 * @const
 * @enum {number}
 */
const WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,

  /*
  CIRCULAR_STRING: 8,
  COMPOUND_CURVE: 9,
  CURVE_POLYGON: 10,

  MULTI_CURVE: 11,
  MULTI_SURFACE: 12,
  CURVE: 13,
  SURFACE: 14,
  */

  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17,
};

class WkbReader {
  /**
   * @param {DataView} view source to read
   */
  constructor(view) {
    /** @private */
    this.view_ = view;

    /**
     * @type {number}
     * @private
     */
    this.pos_ = 0;

    /**
     * @type {boolean}
     * @private
     */
    this.initialized_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.isLittleEndian_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.hasZ_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.hasM_ = false;

    /**
     * @type {number|null}
     * @private
     */
    this.srid_ = null;

    /**
     * @type {import("../geom/Geometry.js").GeometryLayout}
     * @private
     */
    this.layout_ = 'XY';
  }

  /**
   * @return {number} value
   */
  readUint8() {
    return this.view_.getUint8(this.pos_++);
  }

  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readUint32(isLittleEndian) {
    return this.view_.getUint32(
      (this.pos_ += 4) - 4,
      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_
    );
  }

  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readDouble(isLittleEndian) {
    return this.view_.getFloat64(
      (this.pos_ += 8) - 8,
      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_
    );
  }

  /**
   * @return {import('../coordinate.js').Coordinate} coords for Point
   */
  readPoint() {
    /** @type import('../coordinate.js').Coordinate */
    const coords = [];

    coords.push(this.readDouble());
    coords.push(this.readDouble());
    if (this.hasZ_) {
      coords.push(this.readDouble());
    }
    if (this.hasM_) {
      coords.push(this.readDouble());
    }

    return coords;
  }

  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing
   */
  readLineString() {
    const numPoints = this.readUint32();

    /** @type Array<import('../coordinate.js').Coordinate> */
    const coords = [];
    for (let i = 0; i < numPoints; i++) {
      coords.push(this.readPoint());
    }

    return coords;
  }

  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like
   */
  readPolygon() {
    const numRings = this.readUint32();

    /** @type Array<Array<import('../coordinate.js').Coordinate>> */
    const rings = [];
    for (let i = 0; i < numRings; i++) {
      rings.push(this.readLineString()); // as a LinearRing
    }

    return rings;
  }

  /**
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {number} WKB Type ID
   */
  readWkbHeader(expectedTypeId) {
    const byteOrder = this.readUint8();
    const isLittleEndian = byteOrder > 0;

    const wkbType = this.readUint32(isLittleEndian);
    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);
    const hasZ =
      Boolean(wkbType & 0x80000000) ||
      wkbTypeThousandth === 1 ||
      wkbTypeThousandth === 3;
    const hasM =
      Boolean(wkbType & 0x40000000) ||
      wkbTypeThousandth === 2 ||
      wkbTypeThousandth === 3;
    const hasSRID = Boolean(wkbType & 0x20000000);
    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID
    const layout = /** @type {import("../geom/Geometry.js").GeometryLayout} */ (
      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('')
    );

    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;

    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {
      throw new Error('Unexpected WKB geometry type ' + typeId);
    }

    if (this.initialized_) {
      // sanity checks
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error('Inconsistent endian');
      }
      if (this.layout_ !== layout) {
        throw new Error('Inconsistent geometry layout');
      }
      if (srid && this.srid_ !== srid) {
        throw new Error('Inconsistent coordinate system (SRID)');
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }

    return typeId;
  }

  /**
   * @param {number} typeId WKB Type ID
   * @return {any} values read
   */
  readWkbPayload(typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();

      case WKBGeometryType.LINE_STRING:
        return this.readLineString();

      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();

      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();

      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();

      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();

      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();

      default:
        throw new Error(
          'Unsupported WKB geometry type ' + typeId + ' is found'
        );
    }
  }

  /**
   * @param {number} expectedTypeId Expected WKB Type ID
   * @return {any} values read
   */
  readWkbBlock(expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  }

  /**
   * @param {Function} reader reader function for each item
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {any} values read
   */
  readWkbCollection(reader, expectedTypeId) {
    const num = this.readUint32();

    const items = [];
    for (let i = 0; i < num; i++) {
      const result = reader.call(this, expectedTypeId);
      if (result) {
        items.push(result);
      }
    }

    return items;
  }

  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint
   */
  readMultiPoint() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  }

  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like
   */
  readMultiLineString() {
    return this.readWkbCollection(
      this.readWkbBlock,
      WKBGeometryType.LINE_STRING
    );
  }

  /**
   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like
   */
  readMultiPolygon() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  }

  /**
   * @return {Array<import('../geom/Geometry.js').default>} array of geometries
   */
  readGeometryCollection() {
    return this.readWkbCollection(this.readGeometry);
  }

  /**
   * @return {import('../geom/Geometry.js').default} geometry
   */
  readGeometry() {
    const typeId = this.readWkbHeader();
    const result = this.readWkbPayload(typeId);

    switch (typeId) {
      case WKBGeometryType.POINT:
        return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__["default"](
          /** @type {import('../coordinate.js').Coordinate} */ (result),
          this.layout_
        );

      case WKBGeometryType.LINE_STRING:
        return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_3__["default"](
          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),
          this.layout_
        );

      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["default"](
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (
            result
          ),
          this.layout_
        );

      case WKBGeometryType.MULTI_POINT:
        return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_5__["default"](
          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),
          this.layout_
        );

      case WKBGeometryType.MULTI_LINE_STRING:
        return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (
            result
          ),
          this.layout_
        );

      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_6__["default"](
          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (
            result
          ),
          this.layout_
        );

      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](
          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)
        );

      default:
        return null;
    }
  }

  /**
   * @return {number|null} SRID in the EWKB. `null` if not defined.
   */
  getSrid() {
    return this.srid_;
  }
}

class WkbWriter {
  /**
   * @type {Object}
   * @property {string} [layout] geometryLayout
   * @property {boolean} [littleEndian=true] littleEndian
   * @property {boolean} [ewkb=true] Whether writes in EWKB format
   * @property {Object} [nodata] NoData value for each axes
   * @param {Object} opts options
   */
  constructor(opts) {
    opts = opts || {};

    /** @type {string} */
    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;

    this.isEWKB_ = opts.ewkb !== false;

    /** @type {Array<Array<number>>} */
    this.writeQueue_ = [];

    /**
     * @type {Object}
     * @property {number} X NoData value for X
     * @property {number} Y NoData value for Y
     * @property {number} Z NoData value for Z
     * @property {number} M NoData value for M
     */
    this.nodata_ = Object.assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);
  }

  /**
   * @param {number} value value
   */
  writeUint8(value) {
    this.writeQueue_.push([1, value]);
  }

  /**
   * @param {number} value value
   */
  writeUint32(value) {
    this.writeQueue_.push([4, value]);
  }

  /**
   * @param {number} value value
   */
  writeDouble(value) {
    this.writeQueue_.push([8, value]);
  }

  /**
   * @param {import('../coordinate.js').Coordinate} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePoint(coords, layout) {
    /**
     * @type {Object}
     * @property {number} X NoData value for X
     * @property {number} Y NoData value for Y
     * @property {number} [Z] NoData value for Z
     * @property {number} [M] NoData value for M
     */
    const coordsObj = Object.assign.apply(
      null,
      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))
    );

    for (const axis of this.layout_) {
      this.writeDouble(
        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]
      );
    }
  }

  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeLineString(coords, layout) {
    this.writeUint32(coords.length); // numPoints
    for (let i = 0; i < coords.length; i++) {
      this.writePoint(coords[i], layout);
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePolygon(rings, layout) {
    this.writeUint32(rings.length); // numRings
    for (let i = 0; i < rings.length; i++) {
      this.writeLineString(rings[i], layout); // as a LinearRing
    }
  }

  /**
   * @param {number} wkbType WKB Type ID
   * @param {number} [srid] SRID
   */
  writeWkbHeader(wkbType, srid) {
    wkbType %= 1000; // Assume 1000 is an upper limit for type ID
    if (this.layout_.includes('Z')) {
      wkbType += this.isEWKB_ ? 0x80000000 : 1000;
    }
    if (this.layout_.includes('M')) {
      wkbType += this.isEWKB_ ? 0x40000000 : 2000;
    }
    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 0x20000000;
    }

    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);
    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  }

  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPoint(coords, layout) {
    this.writeUint32(coords.length); // numItems
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i], layout);
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiLineString(coords, layout) {
    this.writeUint32(coords.length); // numItems
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i], layout);
    }
  }

  /**
   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPolygon(coords, layout) {
    this.writeUint32(coords.length); // numItems
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i], layout);
    }
  }

  /**
   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries
   */
  writeGeometryCollection(geometries) {
    this.writeUint32(geometries.length); // numItems

    for (let i = 0; i < geometries.length; i++) {
      this.writeGeometry(geometries[i]);
    }
  }

  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {import("../geom/Geometry.js").GeometryLayout} [layout] layout
   * @return {import("../geom/Geometry.js").GeometryLayout} minimum layout made by common axes
   */
  findMinimumLayout(geom, layout = 'XYZM') {
    /**
     * @param {import("../geom/Geometry.js").GeometryLayout} a A
     * @param {import("../geom/Geometry.js").GeometryLayout} b B
     * @return {import("../geom/Geometry.js").GeometryLayout} minimum layout made by common axes
     */
    const GeometryLayout_min = (a, b) => {
      if (a === b) {
        return a;
      }

      if (a === 'XYZM') {
        // anything `b` is minimum
        return b;
      }
      if (b === 'XYZM') {
        // anything `a` is minimum
        return a;
      }

      // otherwise, incompatible
      return 'XY';
    };

    if (geom instanceof _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      return GeometryLayout_min(geom.getLayout(), layout);
    }

    if (geom instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const geoms = geom.getGeometriesArray();
      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {
        layout = this.findMinimumLayout(geoms[i], layout);
      }
    }

    return layout;
  }

  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {number} [srid] SRID
   */
  writeGeometry(geom, srid) {
    /**
     * @type {Object<import("../geom/Geometry.js").Type, WKBGeometryType>}
     */
    const wkblut = {
      Point: WKBGeometryType.POINT,
      LineString: WKBGeometryType.LINE_STRING,
      Polygon: WKBGeometryType.POLYGON,
      MultiPoint: WKBGeometryType.MULTI_POINT,
      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,
      MultiPolygon: WKBGeometryType.MULTI_POLYGON,
      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,
    };
    const geomType = geom.getType();
    const typeId = wkblut[geomType];

    if (!typeId) {
      throw new Error('GeometryType ' + geomType + ' is not supported');
    }

    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.
    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom);
    }

    this.writeWkbHeader(typeId, srid);

    if (geom instanceof _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      const writerLUT = {
        Point: this.writePoint,
        LineString: this.writeLineString,
        Polygon: this.writePolygon,
        MultiPoint: this.writeMultiPoint,
        MultiLineString: this.writeMultiLineString,
        MultiPolygon: this.writeMultiPolygon,
      };
      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());
    } else if (geom instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      this.writeGeometryCollection(geom.getGeometriesArray());
    }
  }

  getBuffer() {
    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);
    const buffer = new ArrayBuffer(byteLength);
    const view = new DataView(buffer);

    let pos = 0;
    this.writeQueue_.forEach((item) => {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;
        case 4:
          view.setUint32(pos, item[1], this.isLittleEndian_);
          break;
        case 8:
          view.setFloat64(pos, item[1], this.isLittleEndian_);
          break;
        default:
          break;
      }

      pos += item[0];
    });

    return buffer;
  }
}

/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.
 * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.
 * @property {boolean} [littleEndian=true] Use littleEndian for output.
 * @property {boolean} [ewkb=true] Use EWKB format for output.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)
 * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.
 * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.
 * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.
 */

/**
 * @classdesc
 * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.
 * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.
 *
 * @api
 */
class WKB extends _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    this.splitCollection = Boolean(options.splitCollection);

    this.viewCache_ = null;

    this.hex_ = options.hex !== false;
    this.littleEndian_ = options.littleEndian !== false;
    this.ewkb_ = options.ewkb !== false;

    this.layout_ = options.geometryLayout; // null for auto detect
    this.nodataZ_ = options.nodataZ || 0;
    this.nodataM_ = options.nodataM || 0;

    this.srid_ = options.srid;
  }

  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return this.hex_ ? 'text' : 'arraybuffer';
  }

  /**
   * Read a single feature from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(source, options) {
    return new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
      geometry: this.readGeometry(source, options),
    });
  }

  /**
   * Read all features from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(source, options) {
    let geometries = [];
    const geometry = this.readGeometry(source, options);
    if (this.splitCollection && geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    return geometries.map((geometry) => new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({geometry}));
  }

  /**
   * Read a single geometry from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(source, options) {
    const view = getDataView(source);
    if (!view) {
      return null;
    }

    const reader = new WkbReader(view);
    const geometry = reader.readGeometry();

    this.viewCache_ = view; // cache for internal subsequent call of readProjection()
    options = this.getReadOptions(source, options);
    this.viewCache_ = null; // release

    return Object(_Feature_js__WEBPACK_IMPORTED_MODULE_1__["transformGeometryWithOptions"])(geometry, false, options);
  }

  /**
   * Read the projection from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(source) {
    const view = this.viewCache_ || getDataView(source);
    if (!view) {
      return undefined;
    }

    const reader = new WkbReader(view);
    reader.readWkbHeader();

    return (
      (reader.getSrid() && Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])('EPSG:' + reader.getSrid())) ||
      undefined
    );
  }

  /**
   * Encode a feature in this format.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeFeature(feature, options) {
    return this.writeGeometry(feature.getGeometry(), options);
  }

  /**
   * Encode an array of features in this format.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeFeatures(features, options) {
    return this.writeGeometry(
      new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_2__["default"](features.map((f) => f.getGeometry())),
      options
    );
  }

  /**
   * Write a single geometry in this format.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeGeometry(geometry, options) {
    options = this.adaptOptions(options);

    const writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,

      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_,
      },
    });

    // extract SRID from `dataProjection`
    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      const dataProjection =
        options.dataProjection && Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["get"])(options.dataProjection);
      if (dataProjection) {
        const code = dataProjection.getCode();
        if (code.startsWith('EPSG:')) {
          srid = Number(code.substring(5));
        }
      }
    }

    writer.writeGeometry(
      Object(_Feature_js__WEBPACK_IMPORTED_MODULE_1__["transformGeometryWithOptions"])(geometry, true, options),
      srid
    );
    const buffer = writer.getBuffer();

    return this.hex_ ? encodeHexString(buffer) : buffer;
  }
}

/**
 * @param {ArrayBuffer} buffer source buffer
 * @return {string} encoded hex string
 */
function encodeHexString(buffer) {
  const view = new Uint8Array(buffer);
  return Array.from(view.values())
    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())
    .join('');
}

/**
 * @param {string} text source text
 * @return {DataView} decoded binary buffer
 */
function decodeHexString(text) {
  const buffer = new Uint8Array(text.length / 2);
  for (let i = 0; i < text.length / 2; i++) {
    buffer[i] = parseInt(text.substr(i * 2, 2), 16);
  }
  return new DataView(buffer.buffer);
}

/**
 * @param {string | ArrayBuffer | ArrayBufferView} source source
 * @return {DataView} data view
 */
function getDataView(source) {
  if (typeof source === 'string') {
    return decodeHexString(source);
  }
  if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }
    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  }
  if (source instanceof ArrayBuffer) {
    return new DataView(source);
  }
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (WKB);


/***/ }),

/***/ "./node_modules/ol/format/WKT.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/WKT.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _TextFeature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TextFeature.js */ "./node_modules/ol/format/TextFeature.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/WKT
 */











/**
 * Geometry constructors
 * @enum {function (new:import("../geom/Geometry.js").default, Array, import("../geom/Geometry.js").GeometryLayout)}
 */
const GeometryConstructor = {
  'POINT': _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  'LINESTRING': _geom_LineString_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'POLYGON': _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  'MULTIPOINT': _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  'MULTILINESTRING': _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  'MULTIPOLYGON': _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__["default"],
};

/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into
 * multiple features on reading.
 */

/**
 * @typedef {Object} Token
 * @property {number} type Type.
 * @property {number|string} [value] Value.
 * @property {number} position Position.
 */

/**
 * @const
 * @type {string}
 */
const EMPTY = 'EMPTY';

/**
 * @const
 * @type {string}
 */
const Z = 'Z';

/**
 * @const
 * @type {string}
 */
const M = 'M';

/**
 * @const
 * @type {string}
 */
const ZM = 'ZM';

/**
 * @const
 * @enum {number}
 */
const TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6,
};

/**
 * @type {Object<import("../geom/Geometry.js").Type, string>}
 */
const wktTypeLookup = {
  Point: 'POINT',
  LineString: 'LINESTRING',
  Polygon: 'POLYGON',
  MultiPoint: 'MULTIPOINT',
  MultiLineString: 'MULTILINESTRING',
  MultiPolygon: 'MULTIPOLYGON',
  GeometryCollection: 'GEOMETRYCOLLECTION',
  Circle: 'CIRCLE',
};

/**
 * Class to tokenize a WKT string.
 */
class Lexer {
  /**
   * @param {string} wkt WKT string.
   */
  constructor(wkt) {
    /**
     * @type {string}
     */
    this.wkt = wkt;

    /**
     * @type {number}
     * @private
     */
    this.index_ = -1;
  }

  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */
  isAlpha_(c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
  }

  /**
   * @param {string} c Character.
   * @param {boolean} [decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */
  isNumeric_(c, decimal) {
    decimal = decimal !== undefined ? decimal : false;
    return (c >= '0' && c <= '9') || (c == '.' && !decimal);
  }

  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */
  isWhiteSpace_(c) {
    return c == ' ' || c == '\t' || c == '\r' || c == '\n';
  }

  /**
   * @return {string} Next string character.
   * @private
   */
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }

  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */
  nextToken() {
    const c = this.nextChar_();
    const position = this.index_;
    /** @type {number|string} */
    let value = c;
    let type;

    if (c == '(') {
      type = TokenType.LEFT_PAREN;
    } else if (c == ',') {
      type = TokenType.COMMA;
    } else if (c == ')') {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c) || c == '-') {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c)) {
      return this.nextToken();
    } else if (c === '') {
      type = TokenType.EOF;
    } else {
      throw new Error('Unexpected character: ' + c);
    }

    return {position: position, value: value, type: type};
  }

  /**
   * @return {number} Numeric token value.
   * @private
   */
  readNumber_() {
    let c;
    const index = this.index_;
    let decimal = false;
    let scientificNotation = false;
    do {
      if (c == '.') {
        decimal = true;
      } else if (c == 'e' || c == 'E') {
        scientificNotation = true;
      }
      c = this.nextChar_();
    } while (
      this.isNumeric_(c, decimal) ||
      // if we haven't detected a scientific number before, 'e' or 'E'
      // hint that we should continue to read
      (!scientificNotation && (c == 'e' || c == 'E')) ||
      // once we know that we have a scientific number, both '-' and '+'
      // are allowed
      (scientificNotation && (c == '-' || c == '+'))
    );
    return parseFloat(this.wkt.substring(index, this.index_--));
  }

  /**
   * @return {string} String token value.
   * @private
   */
  readText_() {
    let c;
    const index = this.index_;
    do {
      c = this.nextChar_();
    } while (this.isAlpha_(c));
    return this.wkt.substring(index, this.index_--).toUpperCase();
  }
}

/**
 * Class to parse the tokens from the WKT string.
 */
class Parser {
  /**
   * @param {Lexer} lexer The lexer.
   */
  constructor(lexer) {
    /**
     * @type {Lexer}
     * @private
     */
    this.lexer_ = lexer;

    /**
     * @type {Token}
     * @private
     */
    this.token_ = {
      position: 0,
      type: TokenType.START,
    };

    /**
     * @type {import("../geom/Geometry.js").GeometryLayout}
     * @private
     */
    this.layout_ = 'XY';
  }

  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }

  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  isTokenType(type) {
    return this.token_.type == type;
  }

  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  match(type) {
    const isMatch = this.isTokenType(type);
    if (isMatch) {
      this.consume_();
    }
    return isMatch;
  }

  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */
  parse() {
    this.consume_();
    return this.parseGeometry_();
  }

  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/Geometry.js").GeometryLayout} The layout.
   * @private
   */
  parseGeometryLayout_() {
    /** @type {import("../geom/Geometry.js").GeometryLayout} */
    let layout = 'XY';
    const dimToken = this.token_;
    if (this.isTokenType(TokenType.TEXT)) {
      const dimInfo = dimToken.value;
      if (dimInfo === Z) {
        layout = 'XYZ';
      } else if (dimInfo === M) {
        layout = 'XYM';
      } else if (dimInfo === ZM) {
        layout = 'XYZM';
      }
      if (layout !== 'XY') {
        this.consume_();
      }
    }
    return layout;
  }

  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */
  parseGeometryCollectionText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const geometries = [];
      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));
      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<number>} All values in a point.
   * @private
   */
  parsePointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates = this.parsePoint_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */
  parseLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates = this.parsePointList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */
  parsePolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */
  parseMultiPointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      let coordinates;
      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates = this.parsePointTextList_();
      } else {
        coordinates = this.parsePointList_();
      }
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */
  parseMultiLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */
  parseMultiPolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates = this.parsePolygonTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<number>} A point.
   * @private
   */
  parsePoint_() {
    const coordinates = [];
    const dimensions = this.layout_.length;
    for (let i = 0; i < dimensions; ++i) {
      const token = this.token_;
      if (this.match(TokenType.NUMBER)) {
        coordinates.push(/** @type {number} */ (token.value));
      } else {
        break;
      }
    }
    if (coordinates.length == dimensions) {
      return coordinates;
    }
    throw new Error(this.formatErrorMessage_());
  }

  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointList_() {
    const coordinates = [this.parsePoint_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePoint_());
    }
    return coordinates;
  }

  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointTextList_() {
    const coordinates = [this.parsePointText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePointText_());
    }
    return coordinates;
  }

  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */
  parseLineStringTextList_() {
    const coordinates = [this.parseLineStringText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parseLineStringText_());
    }
    return coordinates;
  }

  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */
  parsePolygonTextList_() {
    const coordinates = [this.parsePolygonText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePolygonText_());
    }
    return coordinates;
  }

  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */
  isEmptyGeometry_() {
    const isEmpty =
      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
    if (isEmpty) {
      this.consume_();
    }
    return isEmpty;
  }

  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */
  formatErrorMessage_() {
    return (
      'Unexpected `' +
      this.token_.value +
      '` at position ' +
      this.token_.position +
      ' in `' +
      this.lexer_.wkt +
      '`'
    );
  }

  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */
  parseGeometry_() {
    const token = this.token_;
    if (this.match(TokenType.TEXT)) {
      const geomType = /** @type {string} */ (token.value);
      this.layout_ = this.parseGeometryLayout_();
      const isEmpty = this.isEmptyGeometry_();
      if (geomType == 'GEOMETRYCOLLECTION') {
        if (isEmpty) {
          return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_1__["default"]([]);
        }
        const geometries = this.parseGeometryCollectionText_();
        return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_1__["default"](geometries);
      }
      const ctor = GeometryConstructor[geomType];
      if (!ctor) {
        throw new Error('Invalid geometry type: ' + geomType);
      }

      let coordinates;

      if (isEmpty) {
        if (geomType == 'POINT') {
          coordinates = [NaN, NaN];
        } else {
          coordinates = [];
        }
      } else {
        switch (geomType) {
          case 'POINT': {
            coordinates = this.parsePointText_();
            break;
          }
          case 'LINESTRING': {
            coordinates = this.parseLineStringText_();
            break;
          }
          case 'POLYGON': {
            coordinates = this.parsePolygonText_();
            break;
          }
          case 'MULTIPOINT': {
            coordinates = this.parseMultiPointText_();
            break;
          }
          case 'MULTILINESTRING': {
            coordinates = this.parseMultiLineStringText_();
            break;
          }
          case 'MULTIPOLYGON': {
            coordinates = this.parseMultiPolygonText_();
            break;
          }
          default:
            break;
        }
      }

      return new ctor(coordinates, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
}

/**
 * @classdesc
 * Geometry format for reading and writing data in the `WellKnownText` (WKT)
 * format.
 *
 * @api
 */
class WKT extends _TextFeature_js__WEBPACK_IMPORTED_MODULE_8__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * Split GeometryCollection into multiple features.
     * @type {boolean}
     * @private
     */
    this.splitCollection_ =
      options.splitCollection !== undefined ? options.splitCollection : false;
  }

  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */
  parse_(wkt) {
    const lexer = new Lexer(wkt);
    const parser = new Parser(lexer);
    return parser.parse();
  }

  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(text, options) {
    const geom = this.readGeometryFromText(text, options);
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    feature.setGeometry(geom);
    return feature;
  }

  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(text, options) {
    let geometries = [];
    const geometry = this.readGeometryFromText(text, options);
    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {
      geometries = /** @type {GeometryCollection} */ (
        geometry
      ).getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    const features = [];
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
      feature.setGeometry(geometries[i]);
      features.push(feature);
    }
    return features;
  }

  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(text, options) {
    const geometry = this.parse_(text);
    return Object(_Feature_js__WEBPACK_IMPORTED_MODULE_9__["transformGeometryWithOptions"])(geometry, false, options);
  }

  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    return '';
  }

  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(features, options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], options);
    }
    const geometries = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      geometries.push(features[i].getGeometry());
    }
    const collection = new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_1__["default"](geometries);
    return this.writeGeometryText(collection, options);
  }

  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(geometry, options) {
    return encode(Object(_Feature_js__WEBPACK_IMPORTED_MODULE_9__["transformGeometryWithOptions"])(geometry, true, options));
  }
}

/**
 * @param {Point} geom Point geometry.
 * @return {string} Coordinates part of Point as WKT.
 */
function encodePointGeometry(geom) {
  const coordinates = geom.getCoordinates();
  if (coordinates.length === 0) {
    return '';
  }
  return coordinates.join(' ');
}

/**
 * @param {MultiPoint} geom MultiPoint geometry.
 * @return {string} Coordinates part of MultiPoint as WKT.
 */
function encodeMultiPointGeometry(geom) {
  const array = [];
  const components = geom.getPoints();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodePointGeometry(components[i]) + ')');
  }
  return array.join(',');
}

/**
 * @param {GeometryCollection} geom GeometryCollection geometry.
 * @return {string} Coordinates part of GeometryCollection as WKT.
 */
function encodeGeometryCollectionGeometry(geom) {
  const array = [];
  const geoms = geom.getGeometries();
  for (let i = 0, ii = geoms.length; i < ii; ++i) {
    array.push(encode(geoms[i]));
  }
  return array.join(',');
}

/**
 * @param {LineString|import("../geom/LinearRing.js").default} geom LineString geometry.
 * @return {string} Coordinates part of LineString as WKT.
 */
function encodeLineStringGeometry(geom) {
  const coordinates = geom.getCoordinates();
  const array = [];
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    array.push(coordinates[i].join(' '));
  }
  return array.join(',');
}

/**
 * @param {MultiLineString} geom MultiLineString geometry.
 * @return {string} Coordinates part of MultiLineString as WKT.
 */
function encodeMultiLineStringGeometry(geom) {
  const array = [];
  const components = geom.getLineStrings();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodeLineStringGeometry(components[i]) + ')');
  }
  return array.join(',');
}

/**
 * @param {Polygon} geom Polygon geometry.
 * @return {string} Coordinates part of Polygon as WKT.
 */
function encodePolygonGeometry(geom) {
  const array = [];
  const rings = geom.getLinearRings();
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');
  }
  return array.join(',');
}

/**
 * @param {MultiPolygon} geom MultiPolygon geometry.
 * @return {string} Coordinates part of MultiPolygon as WKT.
 */
function encodeMultiPolygonGeometry(geom) {
  const array = [];
  const components = geom.getPolygons();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push('(' + encodePolygonGeometry(components[i]) + ')');
  }
  return array.join(',');
}

/**
 * @param {import("../geom/SimpleGeometry.js").default} geom SimpleGeometry geometry.
 * @return {string} Potential dimensional information for WKT type.
 */
function encodeGeometryLayout(geom) {
  const layout = geom.getLayout();
  let dimInfo = '';
  if (layout === 'XYZ' || layout === 'XYZM') {
    dimInfo += Z;
  }
  if (layout === 'XYM' || layout === 'XYZM') {
    dimInfo += M;
  }
  return dimInfo;
}

/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default): string>}
 */
const GeometryEncoder = {
  'Point': encodePointGeometry,
  'LineString': encodeLineStringGeometry,
  'Polygon': encodePolygonGeometry,
  'MultiPoint': encodeMultiPointGeometry,
  'MultiLineString': encodeMultiLineStringGeometry,
  'MultiPolygon': encodeMultiPolygonGeometry,
  'GeometryCollection': encodeGeometryCollectionGeometry,
};

/**
 * Encode a geometry as WKT.
 * @param {import("../geom/Geometry.js").default} geom The geometry to encode.
 * @return {string} WKT string for the geometry.
 */
function encode(geom) {
  const type = geom.getType();
  const geometryEncoder = GeometryEncoder[type];
  const enc = geometryEncoder(geom);
  let wktType = wktTypeLookup[type];
  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {
    const dimInfo = encodeGeometryLayout(
      /** @type {import("../geom/SimpleGeometry.js").default} */ (geom)
    );
    if (dimInfo.length > 0) {
      wktType += ' ' + dimInfo;
    }
  }
  if (enc.length === 0) {
    return wktType + ' ' + EMPTY;
  }
  return wktType + '(' + enc + ')';
}

/* harmony default export */ __webpack_exports__["default"] = (WKT);


/***/ }),

/***/ "./node_modules/ol/format/WMSCapabilities.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/format/WMSCapabilities.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XML.js */ "./node_modules/ol/format/XML.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xlink.js */ "./node_modules/ol/format/xlink.js");
/**
 * @module ol/format/WMSCapabilities
 */





/**
 * @const
 * @type {Array<null|string>}
 */
const NAMESPACE_URIS = [null, 'http://www.opengis.net/wms'];

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Service': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readService),
  'Capability': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readCapability),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CAPABILITY_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Request': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readRequest),
  'Exception': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readException),
  'Layer': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readCapabilityLayer),
});

/**
 * @classdesc
 * Format for reading WMS capabilities data
 *
 * @api
 */
class WMSCapabilities extends _XML_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    /**
     * @type {string|undefined}
     */
    this.version = undefined;
  }

  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(node) {
    this.version = node.getAttribute('version').trim();
    const wmsCapabilityObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
      {
        'version': this.version,
      },
      PARSERS,
      node,
      []
    );
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const SERVICE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Abstract': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'KeywordList': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readKeywordList),
  'OnlineResource': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xlink_js__WEBPACK_IMPORTED_MODULE_3__["readHref"]),
  'ContactInformation': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readContactInformation),
  'Fees': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'AccessConstraints': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'LayerLimit': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readPositiveInteger"]),
  'MaxWidth': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readPositiveInteger"]),
  'MaxHeight': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readPositiveInteger"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONTACT_INFORMATION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'ContactPersonPrimary': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readContactPersonPrimary),
  'ContactPosition': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'ContactAddress': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readContactAddress),
  'ContactVoiceTelephone': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'ContactFacsimileTelephone': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'ContactElectronicMailAddress': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONTACT_PERSON_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'ContactPerson': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'ContactOrganization': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONTACT_ADDRESS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'AddressType': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Address': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'City': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'StateOrProvince': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'PostCode': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Country': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const EXCEPTION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Format': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeArrayPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LAYER_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Abstract': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'KeywordList': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readKeywordList),
  'CRS': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'EX_GeographicBoundingBox': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(
    readEXGeographicBoundingBox
  ),
  'BoundingBox': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readBoundingBox),
  'Dimension': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readDimension),
  'Attribution': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readAttribution),
  'AuthorityURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readAuthorityURL),
  'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'MetadataURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readMetadataURL),
  'DataURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readFormatOnlineresource),
  'FeatureListURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readFormatOnlineresource),
  'Style': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readStyle),
  'MinScaleDenominator': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
  'MaxScaleDenominator': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
  'Layer': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readLayer),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const ATTRIBUTION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'OnlineResource': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xlink_js__WEBPACK_IMPORTED_MODULE_3__["readHref"]),
  'LogoURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readSizedFormatOnlineresource),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'westBoundLongitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
  'eastBoundLongitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
  'southBoundLatitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
  'northBoundLatitude': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimal"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const REQUEST_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'GetCapabilities': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readOperationType),
  'GetMap': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readOperationType),
  'GetFeatureInfo': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readOperationType),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const OPERATIONTYPE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Format': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'DCPType': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readDCPType),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const DCPTYPE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'HTTP': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readHTTP),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const HTTP_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Get': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readFormatOnlineresource),
  'Post': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readFormatOnlineresource),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Name': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'Abstract': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'LegendURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertyPusher"])(readSizedFormatOnlineresource),
  'StyleSheetURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readFormatOnlineresource),
  'StyleURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(readFormatOnlineresource),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const FORMAT_ONLINERESOURCE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Format': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
  'OnlineResource': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeObjectPropertySetter"])(_xlink_js__WEBPACK_IMPORTED_MODULE_3__["readHref"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const KEYWORDLIST_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeStructureNS"])(NAMESPACE_URIS, {
  'Keyword': Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["makeArrayPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"]),
});

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */
function readAttribution(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, ATTRIBUTION_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Bounding box object.
 */
function readBoundingBox(node, objectStack) {
  const extent = [
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('minx')),
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('miny')),
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('maxx')),
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('maxy')),
  ];

  const resolutions = [
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('resx')),
    Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('resy')),
  ];

  return {
    'crs': node.getAttribute('CRS'),
    'extent': extent,
    'res': resolutions,
  };
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {import("../extent.js").Extent|undefined} Bounding box object.
 */
function readEXGeographicBoundingBox(node, objectStack) {
  const geographicBoundingBox = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])(
    {},
    EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS,
    node,
    objectStack
  );
  if (!geographicBoundingBox) {
    return undefined;
  }
  const westBoundLongitude =
    /** @type {number|undefined} */
    (geographicBoundingBox['westBoundLongitude']);
  const southBoundLatitude =
    /** @type {number|undefined} */
    (geographicBoundingBox['southBoundLatitude']);
  const eastBoundLongitude =
    /** @type {number|undefined} */
    (geographicBoundingBox['eastBoundLongitude']);
  const northBoundLatitude =
    /** @type {number|undefined} */
    (geographicBoundingBox['northBoundLatitude']);
  if (
    westBoundLongitude === undefined ||
    southBoundLatitude === undefined ||
    eastBoundLongitude === undefined ||
    northBoundLatitude === undefined
  ) {
    return undefined;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude,
  ];
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Capability object.
 */
function readCapability(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, CAPABILITY_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Service object.
 */
function readService(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, SERVICE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact information object.
 */
function readContactInformation(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact person object.
 */
function readContactPersonPrimary(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, CONTACT_PERSON_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Contact address object.
 */
function readContactAddress(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Format array.
 */
function readException(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])([], EXCEPTION_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */
function readCapabilityLayer(node, objectStack) {
  const layerObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, LAYER_PARSERS, node, objectStack);

  if (layerObject['Layer'] === undefined) {
    return Object.assign(layerObject, readLayer(node, objectStack));
  }

  return layerObject;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */
function readLayer(node, objectStack) {
  const parentLayerObject = /**  @type {!Object<string,*>} */ (
    objectStack[objectStack.length - 1]
  );

  const layerObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, LAYER_PARSERS, node, objectStack);

  if (!layerObject) {
    return undefined;
  }
  let queryable = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('queryable'));
  if (queryable === undefined) {
    queryable = parentLayerObject['queryable'];
  }
  layerObject['queryable'] = queryable !== undefined ? queryable : false;

  let cascaded = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readNonNegativeIntegerString"])(node.getAttribute('cascaded'));
  if (cascaded === undefined) {
    cascaded = parentLayerObject['cascaded'];
  }
  layerObject['cascaded'] = cascaded;

  let opaque = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('opaque'));
  if (opaque === undefined) {
    opaque = parentLayerObject['opaque'];
  }
  layerObject['opaque'] = opaque !== undefined ? opaque : false;

  let noSubsets = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('noSubsets'));
  if (noSubsets === undefined) {
    noSubsets = parentLayerObject['noSubsets'];
  }
  layerObject['noSubsets'] = noSubsets !== undefined ? noSubsets : false;

  let fixedWidth = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('fixedWidth'));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject['fixedWidth'];
  }
  layerObject['fixedWidth'] = fixedWidth;

  let fixedHeight = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readDecimalString"])(node.getAttribute('fixedHeight'));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject['fixedHeight'];
  }
  layerObject['fixedHeight'] = fixedHeight;

  // See 7.2.4.8
  const addKeys = ['Style', 'CRS', 'AuthorityURL'];
  addKeys.forEach(function (key) {
    if (key in parentLayerObject) {
      const childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });

  const replaceKeys = [
    'EX_GeographicBoundingBox',
    'BoundingBox',
    'Dimension',
    'Attribution',
    'MinScaleDenominator',
    'MaxScaleDenominator',
  ];
  replaceKeys.forEach(function (key) {
    if (!(key in layerObject)) {
      const parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });

  return layerObject;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object} Dimension object.
 */
function readDimension(node, objectStack) {
  const dimensionObject = {
    'name': node.getAttribute('name'),
    'units': node.getAttribute('units'),
    'unitSymbol': node.getAttribute('unitSymbol'),
    'default': node.getAttribute('default'),
    'multipleValues': Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('multipleValues')),
    'nearestValue': Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('nearestValue')),
    'current': Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readBooleanString"])(node.getAttribute('current')),
    'values': Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readString"])(node),
  };
  return dimensionObject;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
function readFormatOnlineresource(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Request object.
 */
function readRequest(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, REQUEST_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} DCP type object.
 */
function readDCPType(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, DCPTYPE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} HTTP object.
 */
function readHTTP(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, HTTP_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Operation type object.
 */
function readOperationType(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, OPERATIONTYPE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
function readSizedFormatOnlineresource(node, objectStack) {
  const formatOnlineresource = readFormatOnlineresource(node, objectStack);
  if (formatOnlineresource) {
    const size = [
      Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readNonNegativeIntegerString"])(node.getAttribute('width')),
      Object(_xsd_js__WEBPACK_IMPORTED_MODULE_2__["readNonNegativeIntegerString"])(node.getAttribute('height')),
    ];
    formatOnlineresource['size'] = size;
    return formatOnlineresource;
  }
  return undefined;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Authority URL object.
 */
function readAuthorityURL(node, objectStack) {
  const authorityObject = readFormatOnlineresource(node, objectStack);
  if (authorityObject) {
    authorityObject['name'] = node.getAttribute('name');
    return authorityObject;
  }
  return undefined;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Metadata URL object.
 */
function readMetadataURL(node, objectStack) {
  const metadataObject = readFormatOnlineresource(node, objectStack);
  if (metadataObject) {
    metadataObject['type'] = node.getAttribute('type');
    return metadataObject;
  }
  return undefined;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */
function readStyle(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])({}, STYLE_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Keyword list.
 */
function readKeywordList(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_1__["pushParseAndPop"])([], KEYWORDLIST_PARSERS, node, objectStack);
}

/* harmony default export */ __webpack_exports__["default"] = (WMSCapabilities);


/***/ }),

/***/ "./node_modules/ol/format/WMSGetFeatureInfo.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/WMSGetFeatureInfo.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GML2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GML2.js */ "./node_modules/ol/format/GML2.js");
/* harmony import */ var _XMLFeature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XMLFeature.js */ "./node_modules/ol/format/XMLFeature.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/**
 * @module ol/format/WMSGetFeatureInfo
 */





/**
 * @typedef {Object} Options
 * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.
 */

/**
 * @const
 * @type {string}
 */
const featureIdentifier = '_feature';

/**
 * @const
 * @type {string}
 */
const layerIdentifier = '_layer';

/**
 * @classdesc
 * Format for reading WMSGetFeatureInfo format. It uses
 * {@link module:ol/format/GML2~GML2} to read features.
 *
 * @api
 */
class WMSGetFeatureInfo extends _XMLFeature_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {string}
     */
    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';

    /**
     * @private
     * @type {GML2}
     */
    this.gmlFormat_ = new _GML2_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

    /**
     * @private
     * @type {Array<string>|null}
     */
    this.layers_ = options.layers ? options.layers : null;
  }

  /**
   * @return {Array<string>|null} layers
   */
  getLayers() {
    return this.layers_;
  }

  /**
   * @param {Array<string>|null} layers Layers to parse.
   */
  setLayers(layers) {
    this.layers_ = layers;
  }

  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<import("../Feature.js").default>} Features.
   * @private
   */
  readFeatures_(node, objectStack) {
    node.setAttribute('namespaceURI', this.featureNS_);
    const localName = node.localName;
    /** @type {Array<import("../Feature.js").default>} */
    let features = [];
    if (node.childNodes.length === 0) {
      return features;
    }
    if (localName == 'msGMLOutput') {
      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {
        const layer = node.childNodes[i];
        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }

        const layerElement = /** @type {Element} */ (layer);
        const context = objectStack[0];

        const toRemove = layerIdentifier;
        const layerName = layerElement.localName.replace(toRemove, '');

        if (this.layers_ && !this.layers_.includes(layerName)) {
          continue;
        }

        const featureType = layerName + featureIdentifier;

        context['featureType'] = featureType;
        context['featureNS'] = this.featureNS_;

        /** @type {Object<string, import("../xml.js").Parser>} */
        const parsers = {};
        parsers[featureType] = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(
          this.gmlFormat_.readFeatureElement,
          this.gmlFormat_
        );
        const parsersNS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
          [context['featureNS'], null],
          parsers
        );
        layerElement.setAttribute('namespaceURI', this.featureNS_);
        const layerFeatures = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])(
          [],
          // @ts-ignore
          parsersNS,
          layerElement,
          objectStack,
          this.gmlFormat_
        );
        if (layerFeatures) {
          Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(features, layerFeatures);
        }
      }
    }
    if (localName == 'FeatureCollection') {
      const gmlFeatures = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])(
        [],
        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,
        node,
        [{}],
        this.gmlFormat_
      );
      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }
    return features;
  }

  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    const internalOptions = {};
    if (options) {
      Object.assign(internalOptions, this.getReadOptions(node, options));
    }
    return this.readFeatures_(node, [internalOptions]);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WMSGetFeatureInfo);


/***/ }),

/***/ "./node_modules/ol/format/WMTSCapabilities.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/format/WMTSCapabilities.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OWS_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OWS.js */ "./node_modules/ol/format/OWS.js");
/* harmony import */ var _XML_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XML.js */ "./node_modules/ol/format/XML.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _xsd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xsd.js */ "./node_modules/ol/format/xsd.js");
/* harmony import */ var _xlink_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xlink.js */ "./node_modules/ol/format/xlink.js");
/**
 * @module ol/format/WMTSCapabilities
 */







/**
 * @const
 * @type {Array<null|string>}
 */
const NAMESPACE_URIS = [null, 'http://www.opengis.net/wmts/1.0'];

/**
 * @const
 * @type {Array<null|string>}
 */
const OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(NAMESPACE_URIS, {
  'Contents': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(readContents),
});

/**
 * @classdesc
 * Format for reading WMTS capabilities data.
 *
 * @api
 */
class WMTSCapabilities extends _XML_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();

    /**
     * @type {OWS}
     * @private
     */
    this.owsParser_ = new _OWS_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }

  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(node) {
    let version = node.getAttribute('version');
    if (version) {
      version = version.trim();
    }
    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject['version'] = version;
    WMTSCapabilityObject = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])(
      WMTSCapabilityObject,
      PARSERS,
      node,
      []
    );
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  }
}

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const CONTENTS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(NAMESPACE_URIS, {
  'Layer': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readLayer),
  'TileMatrixSet': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readTileMatrixSet),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const LAYER_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'Style': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readStyle),
    'Format': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'TileMatrixSetLink': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readTileMatrixSetLink),
    'Dimension': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readDimensions),
    'ResourceURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readResourceUrl),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
    'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'Abstract': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'WGS84BoundingBox': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(readBoundingBox),
    'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  })
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const STYLE_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'LegendURL': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readLegendUrl),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
    'Title': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  })
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TMS_LINKS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(NAMESPACE_URIS, {
  'TileMatrixSet': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  'TileMatrixSetLimits': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(readTileMatrixLimitsList),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TMS_LIMITS_LIST_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(NAMESPACE_URIS, {
  'TileMatrixLimits': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(readTileMatrixLimits),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TMS_LIMITS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(NAMESPACE_URIS, {
  'TileMatrix': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  'MinTileRow': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
  'MaxTileRow': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
  'MinTileCol': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
  'MaxTileCol': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const DIMENSION_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'Default': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'Value': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
    'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  })
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const WGS84_BBOX_READERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
  'LowerCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(readCoordinates),
  'UpperCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeArrayPusher"])(readCoordinates),
});

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TMS_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'WellKnownScaleSet': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'TileMatrix': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertyPusher"])(readTileMatrix),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
    'SupportedCRS': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
    'BoundingBox': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(readBoundingBox),
  })
);

/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */
// @ts-ignore
const TM_PARSERS = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(
  NAMESPACE_URIS,
  {
    'TopLeftCorner': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(readCoordinates),
    'ScaleDenominator': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readDecimal"]),
    'TileWidth': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
    'TileHeight': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
    'MatrixWidth': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
    'MatrixHeight': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readPositiveInteger"]),
  },
  Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeStructureNS"])(OWS_NAMESPACE_URIS, {
    'Identifier': Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["makeObjectPropertySetter"])(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"]),
  })
);

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */
function readContents(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, CONTENTS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layers object.
 */
function readLayer(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, LAYER_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set object.
 */
function readTileMatrixSet(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, TMS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */
function readStyle(node, objectStack) {
  const style = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, STYLE_PARSERS, node, objectStack);
  if (!style) {
    return undefined;
  }
  const isDefault = node.getAttribute('isDefault') === 'true';
  style['isDefault'] = isDefault;
  return style;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set Link object.
 */
function readTileMatrixSetLink(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, TMS_LINKS_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Dimension object.
 */
function readDimensions(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, DIMENSION_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Resource URL object.
 */
function readResourceUrl(node, objectStack) {
  const format = node.getAttribute('format');
  const template = node.getAttribute('template');
  const resourceType = node.getAttribute('resourceType');
  const resource = {};
  if (format) {
    resource['format'] = format;
  }
  if (template) {
    resource['template'] = template;
  }
  if (resourceType) {
    resource['resourceType'] = resourceType;
  }
  return resource;
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} BBox object.
 */
function readBoundingBox(node, objectStack) {
  const coordinates = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])(
    [],
    WGS84_BBOX_READERS,
    node,
    objectStack
  );
  if (coordinates.length != 2) {
    return undefined;
  }
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["boundingExtent"])(coordinates);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Legend object.
 */
function readLegendUrl(node, objectStack) {
  const legend = {};
  legend['format'] = node.getAttribute('format');
  legend['href'] = Object(_xlink_js__WEBPACK_IMPORTED_MODULE_5__["readHref"])(node);
  return legend;
}

/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Coordinates object.
 */
function readCoordinates(node, objectStack) {
  const coordinates = Object(_xsd_js__WEBPACK_IMPORTED_MODULE_4__["readString"])(node).split(/\s+/);
  if (!coordinates || coordinates.length != 2) {
    return undefined;
  }
  const x = +coordinates[0];
  const y = +coordinates[1];
  if (isNaN(x) || isNaN(y)) {
    return undefined;
  }
  return [x, y];
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrix object.
 */
function readTileMatrix(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, TM_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixSetLimits Object.
 */
function readTileMatrixLimitsList(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}

/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixLimits Array.
 */
function readTileMatrixLimits(node, objectStack) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["pushParseAndPop"])({}, TMS_LIMITS_PARSERS, node, objectStack);
}

/* harmony default export */ __webpack_exports__["default"] = (WMTSCapabilities);


/***/ }),

/***/ "./node_modules/ol/format/XML.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/XML.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/**
 * @module ol/format/XML
 */


/**
 * @classdesc
 * Generic format for reading non-feature XML data
 *
 * @abstract
 */
class XML {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object} An object representing the source.
   * @api
   */
  read(source) {
    if (!source) {
      return null;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["parse"])(source);
      return this.readFromDocument(doc);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["isDocument"])(source)) {
      return this.readFromDocument(/** @type {Document} */ (source));
    }
    return this.readFromNode(/** @type {Element} */ (source));
  }

  /**
   * @param {Document} doc Document.
   * @return {Object} Object
   */
  readFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(/** @type {Element} */ (n));
      }
    }
    return null;
  }

  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(node) {}
}

/* harmony default export */ __webpack_exports__["default"] = (XML);


/***/ }),

/***/ "./node_modules/ol/format/XMLFeature.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/XMLFeature.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../format/Feature.js */ "./node_modules/ol/format/Feature.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/**
 * @module ol/format/XMLFeature
 */





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */
class XMLFeature extends _format_Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    /**
     * @type {XMLSerializer}
     * @private
     */
    this.xmlSerializer_ = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["getXMLSerializer"])();
  }

  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return 'xml';
  }

  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(source, options) {
    if (!source) {
      return null;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["parse"])(source);
      return this.readFeatureFromDocument(doc, options);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["isDocument"])(source)) {
      return this.readFeatureFromDocument(
        /** @type {Document} */ (source),
        options
      );
    }
    return this.readFeatureFromNode(/** @type {Element} */ (source), options);
  }

  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(doc, options) {
    const features = this.readFeaturesFromDocument(doc, options);
    if (features.length > 0) {
      return features[0];
    }
    return null;
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(node, options) {
    return null; // not implemented
  }

  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(source, options) {
    if (!source) {
      return [];
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["parse"])(source);
      return this.readFeaturesFromDocument(doc, options);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["isDocument"])(source)) {
      return this.readFeaturesFromDocument(
        /** @type {Document} */ (source),
        options
      );
    }
    return this.readFeaturesFromNode(/** @type {Element} */ (source), options);
  }

  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(doc, options) {
    /** @type {Array<import("../Feature.js").default>} */
    const features = [];
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(
          features,
          this.readFeaturesFromNode(/** @type {Element} */ (n), options)
        );
      }
    }
    return features;
  }

  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(node, options) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["abstract"])();
  }

  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(source, options) {
    if (!source) {
      return null;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["parse"])(source);
      return this.readGeometryFromDocument(doc, options);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["isDocument"])(source)) {
      return this.readGeometryFromDocument(
        /** @type {Document} */ (source),
        options
      );
    }
    return this.readGeometryFromNode(/** @type {Element} */ (source), options);
  }

  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(doc, options) {
    return null; // not implemented
  }

  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(node, options) {
    return null; // not implemented
  }

  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(source) {
    if (!source) {
      return null;
    }
    if (typeof source === 'string') {
      const doc = Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["parse"])(source);
      return this.readProjectionFromDocument(doc);
    }
    if (Object(_xml_js__WEBPACK_IMPORTED_MODULE_3__["isDocument"])(source)) {
      return this.readProjectionFromDocument(/** @type {Document} */ (source));
    }
    return this.readProjectionFromNode(/** @type {Element} */ (source));
  }

  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(doc) {
    return this.dataProjection;
  }

  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(node) {
    return this.dataProjection;
  }

  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(feature, options) {
    const node = this.writeFeatureNode(feature, options);
    return this.xmlSerializer_.serializeToString(node);
  }

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(feature, options) {
    return null; // not implemented
  }

  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(features, options) {
    const node = this.writeFeaturesNode(features, options);
    return this.xmlSerializer_.serializeToString(node);
  }

  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(features, options) {
    return null; // not implemented
  }

  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(geometry, options) {
    const node = this.writeGeometryNode(geometry, options);
    return this.xmlSerializer_.serializeToString(node);
  }

  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(geometry, options) {
    return null; // not implemented
  }
}

/* harmony default export */ __webpack_exports__["default"] = (XMLFeature);


/***/ }),

/***/ "./node_modules/ol/format/filter.js":
/*!******************************************!*\
  !*** ./node_modules/ol/format/filter.js ***!
  \******************************************/
/*! exports provided: and, or, not, bbox, contains, intersects, disjoint, within, dwithin, equalTo, notEqualTo, lessThan, lessThanOrEqualTo, greaterThan, greaterThanOrEqualTo, isNull, between, like, during, resourceId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "and", function() { return and; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "or", function() { return or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not", function() { return not; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return bbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disjoint", function() { return disjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "within", function() { return within; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dwithin", function() { return dwithin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalTo", function() { return equalTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualTo", function() { return notEqualTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessThan", function() { return lessThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessThanOrEqualTo", function() { return lessThanOrEqualTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterThan", function() { return greaterThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterThanOrEqualTo", function() { return greaterThanOrEqualTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "between", function() { return between; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "like", function() { return like; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "during", function() { return during; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resourceId", function() { return resourceId; });
/* harmony import */ var _filter_And_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter/And.js */ "./node_modules/ol/format/filter/And.js");
/* harmony import */ var _filter_Bbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filter/Bbox.js */ "./node_modules/ol/format/filter/Bbox.js");
/* harmony import */ var _filter_Contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter/Contains.js */ "./node_modules/ol/format/filter/Contains.js");
/* harmony import */ var _filter_DWithin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter/DWithin.js */ "./node_modules/ol/format/filter/DWithin.js");
/* harmony import */ var _filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter/Disjoint.js */ "./node_modules/ol/format/filter/Disjoint.js");
/* harmony import */ var _filter_During_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./filter/During.js */ "./node_modules/ol/format/filter/During.js");
/* harmony import */ var _filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter/EqualTo.js */ "./node_modules/ol/format/filter/EqualTo.js");
/* harmony import */ var _filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter/GreaterThan.js */ "./node_modules/ol/format/filter/GreaterThan.js");
/* harmony import */ var _filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter/GreaterThanOrEqualTo.js */ "./node_modules/ol/format/filter/GreaterThanOrEqualTo.js");
/* harmony import */ var _filter_Intersects_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./filter/Intersects.js */ "./node_modules/ol/format/filter/Intersects.js");
/* harmony import */ var _filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./filter/IsBetween.js */ "./node_modules/ol/format/filter/IsBetween.js");
/* harmony import */ var _filter_IsLike_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./filter/IsLike.js */ "./node_modules/ol/format/filter/IsLike.js");
/* harmony import */ var _filter_IsNull_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./filter/IsNull.js */ "./node_modules/ol/format/filter/IsNull.js");
/* harmony import */ var _filter_LessThan_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./filter/LessThan.js */ "./node_modules/ol/format/filter/LessThan.js");
/* harmony import */ var _filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./filter/LessThanOrEqualTo.js */ "./node_modules/ol/format/filter/LessThanOrEqualTo.js");
/* harmony import */ var _filter_Not_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./filter/Not.js */ "./node_modules/ol/format/filter/Not.js");
/* harmony import */ var _filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./filter/NotEqualTo.js */ "./node_modules/ol/format/filter/NotEqualTo.js");
/* harmony import */ var _filter_Or_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./filter/Or.js */ "./node_modules/ol/format/filter/Or.js");
/* harmony import */ var _filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./filter/ResourceId.js */ "./node_modules/ol/format/filter/ResourceId.js");
/* harmony import */ var _filter_Within_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./filter/Within.js */ "./node_modules/ol/format/filter/Within.js");
/**
 * @module ol/format/filter
 */





















/**
 * Create a logical `<And>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!And} `<And>` operator.
 * @api
 */
function and(conditions) {
  const params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(_filter_And_js__WEBPACK_IMPORTED_MODULE_0__["default"], params))();
}

/**
 * Create a logical `<Or>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!Or} `<Or>` operator.
 * @api
 */
function or(conditions) {
  const params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(_filter_Or_js__WEBPACK_IMPORTED_MODULE_17__["default"], params))();
}

/**
 * Represents a logical `<Not>` operator for a filter condition.
 *
 * @param {!import("./filter/Filter.js").default} condition Filter condition.
 * @return {!Not} `<Not>` operator.
 * @api
 */
function not(condition) {
  return new _filter_Not_js__WEBPACK_IMPORTED_MODULE_15__["default"](condition);
}

/**
 * Create a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../extent.js").Extent} extent Extent.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Bbox} `<BBOX>` operator.
 * @api
 */
function bbox(geometryName, extent, srsName) {
  return new _filter_Bbox_js__WEBPACK_IMPORTED_MODULE_1__["default"](geometryName, extent, srsName);
}

/**
 * Create a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Contains} `<Contains>` operator.
 * @api
 */
function contains(geometryName, geometry, srsName) {
  return new _filter_Contains_js__WEBPACK_IMPORTED_MODULE_2__["default"](geometryName, geometry, srsName);
}

/**
 * Create a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Intersects} `<Intersects>` operator.
 * @api
 */
function intersects(geometryName, geometry, srsName) {
  return new _filter_Intersects_js__WEBPACK_IMPORTED_MODULE_9__["default"](geometryName, geometry, srsName);
}

/**
 * Create a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Disjoint} `<Disjoint>` operator.
 * @api
 */
function disjoint(geometryName, geometry, srsName) {
  return new _filter_Disjoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](geometryName, geometry, srsName);
}

/**
 * Create a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Within} `<Within>` operator.
 * @api
 */
function within(geometryName, geometry, srsName) {
  return new _filter_Within_js__WEBPACK_IMPORTED_MODULE_19__["default"](geometryName, geometry, srsName);
}

/**
 * Create a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {!number} distance Distance.
 * @param {!string} unit Unit.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!DWithin} `<DWithin>` operator.
 * @api
 */
function dwithin(geometryName, geometry, distance, unit, srsName) {
  return new _filter_DWithin_js__WEBPACK_IMPORTED_MODULE_3__["default"](geometryName, geometry, distance, unit, srsName);
}

/**
 * Creates a `<PropertyIsEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!EqualTo} `<PropertyIsEqualTo>` operator.
 * @api
 */
function equalTo(propertyName, expression, matchCase) {
  return new _filter_EqualTo_js__WEBPACK_IMPORTED_MODULE_6__["default"](propertyName, expression, matchCase);
}

/**
 * Creates a `<PropertyIsNotEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.
 * @api
 */
function notEqualTo(propertyName, expression, matchCase) {
  return new _filter_NotEqualTo_js__WEBPACK_IMPORTED_MODULE_16__["default"](propertyName, expression, matchCase);
}

/**
 * Creates a `<PropertyIsLessThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThan} `<PropertyIsLessThan>` operator.
 * @api
 */
function lessThan(propertyName, expression) {
  return new _filter_LessThan_js__WEBPACK_IMPORTED_MODULE_13__["default"](propertyName, expression);
}

/**
 * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.
 * @api
 */
function lessThanOrEqualTo(propertyName, expression) {
  return new _filter_LessThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_14__["default"](propertyName, expression);
}

/**
 * Creates a `<PropertyIsGreaterThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.
 * @api
 */
function greaterThan(propertyName, expression) {
  return new _filter_GreaterThan_js__WEBPACK_IMPORTED_MODULE_7__["default"](propertyName, expression);
}

/**
 * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.
 * @api
 */
function greaterThanOrEqualTo(propertyName, expression) {
  return new _filter_GreaterThanOrEqualTo_js__WEBPACK_IMPORTED_MODULE_8__["default"](propertyName, expression);
}

/**
 * Creates a `<PropertyIsNull>` comparison operator to test whether a property value
 * is null.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @return {!IsNull} `<PropertyIsNull>` operator.
 * @api
 */
function isNull(propertyName) {
  return new _filter_IsNull_js__WEBPACK_IMPORTED_MODULE_12__["default"](propertyName);
}

/**
 * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression
 * value lies within a range given by a lower and upper bound (inclusive).
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} lowerBoundary The lower bound of the range.
 * @param {!number} upperBoundary The upper bound of the range.
 * @return {!IsBetween} `<PropertyIsBetween>` operator.
 * @api
 */
function between(propertyName, lowerBoundary, upperBoundary) {
  return new _filter_IsBetween_js__WEBPACK_IMPORTED_MODULE_10__["default"](propertyName, lowerBoundary, upperBoundary);
}

/**
 * Represents a `<PropertyIsLike>` comparison operator that matches a string property
 * value against a text pattern.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} pattern Text pattern.
 * @param {string} [wildCard] Pattern character which matches any sequence of
 *    zero or more string characters. Default is '*'.
 * @param {string} [singleChar] pattern character which matches any single
 *    string character. Default is '.'.
 * @param {string} [escapeChar] Escape character which can be used to escape
 *    the pattern characters. Default is '!'.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!IsLike} `<PropertyIsLike>` operator.
 * @api
 */
function like(
  propertyName,
  pattern,
  wildCard,
  singleChar,
  escapeChar,
  matchCase
) {
  return new _filter_IsLike_js__WEBPACK_IMPORTED_MODULE_11__["default"](
    propertyName,
    pattern,
    wildCard,
    singleChar,
    escapeChar,
    matchCase
  );
}

/**
 * Create a `<During>` temporal operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} begin The begin date in ISO-8601 format.
 * @param {!string} end The end date in ISO-8601 format.
 * @return {!During} `<During>` operator.
 * @api
 */
function during(propertyName, begin, end) {
  return new _filter_During_js__WEBPACK_IMPORTED_MODULE_5__["default"](propertyName, begin, end);
}

function resourceId(rid) {
  return new _filter_ResourceId_js__WEBPACK_IMPORTED_MODULE_18__["default"](rid);
}


/***/ }),

/***/ "./node_modules/ol/format/filter/And.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/filter/And.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LogicalNary.js */ "./node_modules/ol/format/filter/LogicalNary.js");
/**
 * @module ol/format/filter/And
 */


/**
 * @classdesc
 * Represents a logical `<And>` operator between two or more filter conditions.
 *
 * @abstract
 */
class And extends _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(conditions) {
    super('And', Array.prototype.slice.call(arguments));
  }
}

/* harmony default export */ __webpack_exports__["default"] = (And);


/***/ }),

/***/ "./node_modules/ol/format/filter/Bbox.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/format/filter/Bbox.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/**
 * @module ol/format/filter/Bbox
 */


/**
 * @classdesc
 * Represents a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @api
 */
class Bbox extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(geometryName, extent, srsName) {
    super('BBOX');

    /**
     * @type {!string}
     */
    this.geometryName = geometryName;

    /**
     * @type {import("../../extent.js").Extent}
     */
    this.extent = extent;
    if (extent.length !== 4) {
      throw new Error(
        'Expected an extent with four values ([minX, minY, maxX, maxY])'
      );
    }

    /**
     * @type {string|undefined}
     */
    this.srsName = srsName;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Bbox);


/***/ }),

/***/ "./node_modules/ol/format/filter/Comparison.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/filter/Comparison.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/**
 * @module ol/format/filter/Comparison
 */


/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property comparison filters.
 *
 * @abstract
 */
class Comparison extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   */
  constructor(tagName, propertyName) {
    super(tagName);

    /**
     * @type {!string}
     */
    this.propertyName = propertyName;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Comparison);


/***/ }),

/***/ "./node_modules/ol/format/filter/ComparisonBinary.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/format/filter/ComparisonBinary.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./node_modules/ol/format/filter/Comparison.js");
/**
 * @module ol/format/filter/ComparisonBinary
 */


/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property binary comparison filters.
 *
 * @abstract
 */
class ComparisonBinary extends _Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */
  constructor(tagName, propertyName, expression, matchCase) {
    super(tagName, propertyName);

    /**
     * @type {!(string|number)}
     */
    this.expression = expression;

    /**
     * @type {boolean|undefined}
     */
    this.matchCase = matchCase;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (ComparisonBinary);


/***/ }),

/***/ "./node_modules/ol/format/filter/Contains.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/format/filter/Contains.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./node_modules/ol/format/filter/Spatial.js");
/**
 * @module ol/format/filter/Contains
 */


/**
 * @classdesc
 * Represents a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 * @api
 */
class Contains extends _Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(geometryName, geometry, srsName) {
    super('Contains', geometryName, geometry, srsName);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Contains);


/***/ }),

/***/ "./node_modules/ol/format/filter/DWithin.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/format/filter/DWithin.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./node_modules/ol/format/filter/Spatial.js");
/**
 * @module ol/format/filter/DWithin
 */


/**
 * @classdesc
 * Represents a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 * @api
 */
class DWithin extends _Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {!number} distance Distance.
   * @param {!string} unit Unit.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(geometryName, geometry, distance, unit, srsName) {
    super('DWithin', geometryName, geometry, srsName);

    /**
     * @public
     * @type {!number}
     */
    this.distance = distance;

    /**
     * @public
     * @type {!string}
     */
    this.unit = unit;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (DWithin);


/***/ }),

/***/ "./node_modules/ol/format/filter/Disjoint.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/format/filter/Disjoint.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./node_modules/ol/format/filter/Spatial.js");
/**
 * @module ol/format/filter/Disjoint
 */


/**
 * @classdesc
 * Represents a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 * @api
 */
class Disjoint extends _Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(geometryName, geometry, srsName) {
    super('Disjoint', geometryName, geometry, srsName);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Disjoint);


/***/ }),

/***/ "./node_modules/ol/format/filter/During.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/format/filter/During.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./node_modules/ol/format/filter/Comparison.js");
/**
 * @module ol/format/filter/During
 */


/**
 * @classdesc
 * Represents a `<During>` comparison operator.
 * @api
 */
class During extends _Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} begin The begin date in ISO-8601 format.
   * @param {!string} end The end date in ISO-8601 format.
   */
  constructor(propertyName, begin, end) {
    super('During', propertyName);

    /**
     * @type {!string}
     */
    this.begin = begin;

    /**
     * @type {!string}
     */
    this.end = end;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (During);


/***/ }),

/***/ "./node_modules/ol/format/filter/EqualTo.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/format/filter/EqualTo.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/EqualTo
 */


/**
 * @classdesc
 * Represents a `<PropertyIsEqualTo>` comparison operator.
 * @api
 */
class EqualTo extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */
  constructor(propertyName, expression, matchCase) {
    super('PropertyIsEqualTo', propertyName, expression, matchCase);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (EqualTo);


/***/ }),

/***/ "./node_modules/ol/format/filter/Filter.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/format/filter/Filter.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/format/filter/Filter
 */

/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature filters.
 *
 * @abstract
 */
class Filter {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(tagName) {
    /**
     * @private
     * @type {!string}
     */
    this.tagName_ = tagName;
  }

  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Filter);


/***/ }),

/***/ "./node_modules/ol/format/filter/GreaterThan.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/format/filter/GreaterThan.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/GreaterThan
 */


/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThan>` comparison operator.
 * @api
 */
class GreaterThan extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */
  constructor(propertyName, expression) {
    super('PropertyIsGreaterThan', propertyName, expression);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (GreaterThan);


/***/ }),

/***/ "./node_modules/ol/format/filter/GreaterThanOrEqualTo.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/format/filter/GreaterThanOrEqualTo.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/GreaterThanOrEqualTo
 */


/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 * @api
 */
class GreaterThanOrEqualTo extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */
  constructor(propertyName, expression) {
    super('PropertyIsGreaterThanOrEqualTo', propertyName, expression);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (GreaterThanOrEqualTo);


/***/ }),

/***/ "./node_modules/ol/format/filter/Intersects.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/filter/Intersects.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./node_modules/ol/format/filter/Spatial.js");
/**
 * @module ol/format/filter/Intersects
 */


/**
 * @classdesc
 * Represents a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 * @api
 */
class Intersects extends _Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(geometryName, geometry, srsName) {
    super('Intersects', geometryName, geometry, srsName);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Intersects);


/***/ }),

/***/ "./node_modules/ol/format/filter/IsBetween.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/format/filter/IsBetween.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./node_modules/ol/format/filter/Comparison.js");
/**
 * @module ol/format/filter/IsBetween
 */


/**
 * @classdesc
 * Represents a `<PropertyIsBetween>` comparison operator.
 * @api
 */
class IsBetween extends _Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} lowerBoundary The lower bound of the range.
   * @param {!number} upperBoundary The upper bound of the range.
   */
  constructor(propertyName, lowerBoundary, upperBoundary) {
    super('PropertyIsBetween', propertyName);

    /**
     * @type {!number}
     */
    this.lowerBoundary = lowerBoundary;

    /**
     * @type {!number}
     */
    this.upperBoundary = upperBoundary;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (IsBetween);


/***/ }),

/***/ "./node_modules/ol/format/filter/IsLike.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/format/filter/IsLike.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./node_modules/ol/format/filter/Comparison.js");
/**
 * @module ol/format/filter/IsLike
 */


/**
 * @classdesc
 * Represents a `<PropertyIsLike>` comparison operator.
 * @api
 */
class IsLike extends _Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * [constructor description]
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} pattern Text pattern.
   * @param {string} [wildCard] Pattern character which matches any sequence of
   *    zero or more string characters. Default is '*'.
   * @param {string} [singleChar] pattern character which matches any single
   *    string character. Default is '.'.
   * @param {string} [escapeChar] Escape character which can be used to escape
   *    the pattern characters. Default is '!'.
   * @param {boolean} [matchCase] Case-sensitive?
   */
  constructor(
    propertyName,
    pattern,
    wildCard,
    singleChar,
    escapeChar,
    matchCase
  ) {
    super('PropertyIsLike', propertyName);

    /**
     * @type {!string}
     */
    this.pattern = pattern;

    /**
     * @type {!string}
     */
    this.wildCard = wildCard !== undefined ? wildCard : '*';

    /**
     * @type {!string}
     */
    this.singleChar = singleChar !== undefined ? singleChar : '.';

    /**
     * @type {!string}
     */
    this.escapeChar = escapeChar !== undefined ? escapeChar : '!';

    /**
     * @type {boolean|undefined}
     */
    this.matchCase = matchCase;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (IsLike);


/***/ }),

/***/ "./node_modules/ol/format/filter/IsNull.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/format/filter/IsNull.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Comparison_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Comparison.js */ "./node_modules/ol/format/filter/Comparison.js");
/**
 * @module ol/format/filter/IsNull
 */


/**
 * @classdesc
 * Represents a `<PropertyIsNull>` comparison operator.
 * @api
 */
class IsNull extends _Comparison_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   */
  constructor(propertyName) {
    super('PropertyIsNull', propertyName);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (IsNull);


/***/ }),

/***/ "./node_modules/ol/format/filter/LessThan.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/format/filter/LessThan.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/LessThan
 */


/**
 * @classdesc
 * Represents a `<PropertyIsLessThan>` comparison operator.
 * @api
 */
class LessThan extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */
  constructor(propertyName, expression) {
    super('PropertyIsLessThan', propertyName, expression);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (LessThan);


/***/ }),

/***/ "./node_modules/ol/format/filter/LessThanOrEqualTo.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/format/filter/LessThanOrEqualTo.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/LessThanOrEqualTo
 */


/**
 * @classdesc
 * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 * @api
 */
class LessThanOrEqualTo extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */
  constructor(propertyName, expression) {
    super('PropertyIsLessThanOrEqualTo', propertyName, expression);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (LessThanOrEqualTo);


/***/ }),

/***/ "./node_modules/ol/format/filter/LogicalNary.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/format/filter/LogicalNary.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/format/filter/LogicalNary
 */



/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature n-ary logical filters.
 *
 * @abstract
 */
class LogicalNary extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(tagName, conditions) {
    super(tagName);

    /**
     * @type {Array<import("./Filter.js").default>}
     */
    this.conditions = conditions;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.conditions.length >= 2, 57); // At least 2 conditions are required.
  }
}

/* harmony default export */ __webpack_exports__["default"] = (LogicalNary);


/***/ }),

/***/ "./node_modules/ol/format/filter/Not.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/filter/Not.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/**
 * @module ol/format/filter/Not
 */


/**
 * @classdesc
 * Represents a logical `<Not>` operator for a filter condition.
 * @api
 */
class Not extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!import("./Filter.js").default} condition Filter condition.
   */
  constructor(condition) {
    super('Not');

    /**
     * @type {!import("./Filter.js").default}
     */
    this.condition = condition;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Not);


/***/ }),

/***/ "./node_modules/ol/format/filter/NotEqualTo.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/filter/NotEqualTo.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComparisonBinary.js */ "./node_modules/ol/format/filter/ComparisonBinary.js");
/**
 * @module ol/format/filter/NotEqualTo
 */


/**
 * @classdesc
 * Represents a `<PropertyIsNotEqualTo>` comparison operator.
 * @api
 */
class NotEqualTo extends _ComparisonBinary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */
  constructor(propertyName, expression, matchCase) {
    super('PropertyIsNotEqualTo', propertyName, expression, matchCase);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (NotEqualTo);


/***/ }),

/***/ "./node_modules/ol/format/filter/Or.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/format/filter/Or.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LogicalNary.js */ "./node_modules/ol/format/filter/LogicalNary.js");
/**
 * @module ol/format/filter/Or
 */


/**
 * @classdesc
 * Represents a logical `<Or>` operator between two or more filter conditions.
 * @api
 */
class Or extends _LogicalNary_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(conditions) {
    super('Or', Array.prototype.slice.call(arguments));
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Or);


/***/ }),

/***/ "./node_modules/ol/format/filter/ResourceId.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/format/filter/ResourceId.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/**
 * @module ol/format/filter/ResourceId
 */


/**
 * @classdesc
 *
 * @abstract
 */
class ResourceId extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} rid Resource ID.
   */
  constructor(rid) {
    super('ResourceId');

    /**
     * @type {!string}
     */
    this.rid = rid;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (ResourceId);


/***/ }),

/***/ "./node_modules/ol/format/filter/Spatial.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/format/filter/Spatial.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Filter.js */ "./node_modules/ol/format/filter/Filter.js");
/**
 * @module ol/format/filter/Spatial
 */


/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Represents a spatial operator to test whether a geometry-valued property
 * relates to a given geometry.
 *
 * @abstract
 */
class Spatial extends _Filter_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(tagName, geometryName, geometry, srsName) {
    super(tagName);

    /**
     * @type {!string}
     */
    this.geometryName = geometryName || 'the_geom';

    /**
     * @type {import("../../geom/Geometry.js").default}
     */
    this.geometry = geometry;

    /**
     * @type {string|undefined}
     */
    this.srsName = srsName;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Spatial);


/***/ }),

/***/ "./node_modules/ol/format/filter/Within.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/format/filter/Within.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Spatial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spatial.js */ "./node_modules/ol/format/filter/Spatial.js");
/**
 * @module ol/format/filter/Within
 */


/**
 * @classdesc
 * Represents a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 * @api
 */
class Within extends _Spatial_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */
  constructor(geometryName, geometry, srsName) {
    super('Within', geometryName, geometry, srsName);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Within);


/***/ }),

/***/ "./node_modules/ol/format/xlink.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/format/xlink.js ***!
  \*****************************************/
/*! exports provided: readHref */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readHref", function() { return readHref; });
/**
 * @module ol/format/xlink
 */

/**
 * @const
 * @type {string}
 */
const NAMESPACE_URI = 'http://www.w3.org/1999/xlink';

/**
 * @param {Element} node Node.
 * @return {string|undefined} href.
 */
function readHref(node) {
  return node.getAttributeNS(NAMESPACE_URI, 'href');
}


/***/ }),

/***/ "./node_modules/ol/format/xsd.js":
/*!***************************************!*\
  !*** ./node_modules/ol/format/xsd.js ***!
  \***************************************/
/*! exports provided: readBoolean, readBooleanString, readDateTime, readDecimal, readDecimalString, readPositiveInteger, readNonNegativeIntegerString, readString, writeBooleanTextNode, writeCDATASection, writeDateTimeTextNode, writeDecimalTextNode, writeNonNegativeIntegerTextNode, writeStringTextNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readBoolean", function() { return readBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readBooleanString", function() { return readBooleanString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readDateTime", function() { return readDateTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readDecimal", function() { return readDecimal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readDecimalString", function() { return readDecimalString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readPositiveInteger", function() { return readPositiveInteger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readNonNegativeIntegerString", function() { return readNonNegativeIntegerString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readString", function() { return readString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeBooleanTextNode", function() { return writeBooleanTextNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeCDATASection", function() { return writeCDATASection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeDateTimeTextNode", function() { return writeDateTimeTextNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeDecimalTextNode", function() { return writeDecimalTextNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeNonNegativeIntegerTextNode", function() { return writeNonNegativeIntegerTextNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeStringTextNode", function() { return writeStringTextNode; });
/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../xml.js */ "./node_modules/ol/xml.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/format/xsd
 */



/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */
function readBoolean(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getAllTextContent"])(node, false);
  return readBooleanString(s);
}

/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */
function readBooleanString(string) {
  const m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return m[1] !== undefined || false;
  }
  return undefined;
}

/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */
function readDateTime(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getAllTextContent"])(node, false);
  const dateTime = Date.parse(s);
  return isNaN(dateTime) ? undefined : dateTime / 1000;
}

/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */
function readDecimal(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getAllTextContent"])(node, false);
  return readDecimalString(s);
}

/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */
function readDecimalString(string) {
  // FIXME check spec
  const m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  }
  return undefined;
}

/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */
function readPositiveInteger(node) {
  const s = Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getAllTextContent"])(node, false);
  return readNonNegativeIntegerString(s);
}

/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */
function readNonNegativeIntegerString(string) {
  const m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  }
  return undefined;
}

/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */
function readString(node) {
  return Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getAllTextContent"])(node, false).trim();
}

/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */
function writeBooleanTextNode(node, bool) {
  writeStringTextNode(node, bool ? '1' : '0');
}

/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */
function writeCDATASection(node, string) {
  node.appendChild(Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getDocument"])().createCDATASection(string));
}

/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */
function writeDateTimeTextNode(node, dateTime) {
  const date = new Date(dateTime * 1000);
  const string =
    date.getUTCFullYear() +
    '-' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(date.getUTCMonth() + 1, 2) +
    '-' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(date.getUTCDate(), 2) +
    'T' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(date.getUTCHours(), 2) +
    ':' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(date.getUTCMinutes(), 2) +
    ':' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(date.getUTCSeconds(), 2) +
    'Z';
  node.appendChild(Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getDocument"])().createTextNode(string));
}

/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */
function writeDecimalTextNode(node, decimal) {
  const string = decimal.toPrecision();
  node.appendChild(Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getDocument"])().createTextNode(string));
}

/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
  const string = nonNegativeInteger.toString();
  node.appendChild(Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getDocument"])().createTextNode(string));
}

/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */
function writeStringTextNode(node, string) {
  node.appendChild(Object(_xml_js__WEBPACK_IMPORTED_MODULE_0__["getDocument"])().createTextNode(string));
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/flip.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/flip.js ***!
  \*******************************************/
/*! exports provided: flipXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipXY", function() { return flipXY; });
/**
 * @module ol/geom/flat/flip
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [destOffset] Destination offset.
 * @return {Array<number>} Flat coordinates.
 */
function flipXY(flatCoordinates, offset, end, stride, dest, destOffset) {
  if (dest !== undefined) {
    dest = dest;
    destOffset = destOffset !== undefined ? destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  let j = offset;
  while (j < end) {
    const x = flatCoordinates[j++];
    dest[destOffset++] = flatCoordinates[j++];
    dest[destOffset++] = x;
    for (let k = 2; k < stride; ++k) {
      dest[destOffset++] = flatCoordinates[j++];
    }
  }
  dest.length = destOffset;
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/interaction.js":
/*!****************************************!*\
  !*** ./node_modules/ol/interaction.js ***!
  \****************************************/
/*! exports provided: DoubleClickZoom, DblClickDragZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, Draw, Extent, Interaction, KeyboardPan, KeyboardZoom, Link, Modify, MouseWheelZoom, PinchRotate, PinchZoom, Pointer, Select, Snap, Translate, defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction/DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DoubleClickZoom", function() { return _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _interaction_DblClickDragZoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interaction/DblClickDragZoom.js */ "./node_modules/ol/interaction/DblClickDragZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DblClickDragZoom", function() { return _interaction_DblClickDragZoom_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/DragAndDrop.js */ "./node_modules/ol/interaction/DragAndDrop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragAndDrop", function() { return _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragBox", function() { return _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragPan", function() { return _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotate", function() { return _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/DragRotateAndZoom.js */ "./node_modules/ol/interaction/DragRotateAndZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotateAndZoom", function() { return _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragZoom", function() { return _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/Draw.js */ "./node_modules/ol/interaction/Draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Draw", function() { return _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/Extent.js */ "./node_modules/ol/interaction/Extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interaction", function() { return _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./interaction/KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardPan", function() { return _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./interaction/KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardZoom", function() { return _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _interaction_Link_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./interaction/Link.js */ "./node_modules/ol/interaction/Link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return _interaction_Link_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interaction/Modify.js */ "./node_modules/ol/interaction/Modify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modify", function() { return _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interaction/MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MouseWheelZoom", function() { return _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./interaction/PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchRotate", function() { return _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interaction/PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchZoom", function() { return _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _interaction_Select_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./interaction/Select.js */ "./node_modules/ol/interaction/Select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Select", function() { return _interaction_Select_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./interaction/Snap.js */ "./node_modules/ol/interaction/Snap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snap", function() { return _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./interaction/Translate.js */ "./node_modules/ol/interaction/Translate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Translate", function() { return _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _interaction_defaults_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./interaction/defaults.js */ "./node_modules/ol/interaction/defaults.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return _interaction_defaults_js__WEBPACK_IMPORTED_MODULE_22__["defaults"]; });

/**
 * @module ol/interaction
 */

























/***/ }),

/***/ "./node_modules/ol/interaction/DblClickDragZoom.js":
/*!*********************************************************!*\
  !*** ./node_modules/ol/interaction/DblClickDragZoom.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/**
 * @module ol/interaction/DblClickDragZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds. *
 * @property {number} [delta=1] The zoom delta applied on move of one pixel. *
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Allows the user to zoom the map by double tap/clik then drag up/down
 * with one finger/left mouse.
 * @api
 */
class DblClickDragZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [opt_options] Options.
   */
  constructor(opt_options) {
    const options = opt_options ? opt_options : {};

    super(
      /** @type {import("./Interaction.js").InteractionOptions} */ (options)
    );

    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }

    /**
     * @private
     * @type {number}
     */
    this.scaleDeltaByPixel_ = options.delta ? options.delta : 0.01;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.handlingDownUpSequence_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.handlingDoubleDownSequence_ = false;

    /**
     * @type {!Object<string, PointerEvent>}
     * @private
     */
    this.trackedPointers_ = {};

    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    this.targetPointers = [];
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent  map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence_) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        // prevent page scrolling during dragging
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence_ = handledUp;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
        if (this.handlingDoubleDownSequence_) {
          this.handlingDoubleDownSequence_ = false;
          const handled = this.handleDownEvent(mapBrowserEvent);
          this.handlingDownUpSequence_ = handled;
          stopEvent = this.stopDown(handled);
        } else {
          stopEvent = this.stopDown(false);
          this.waitForDblTap();
        }
      }
    }
    return !stopEvent;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1.0;

    const touch0 = this.targetPointers[0];
    const touch1 = this.down_.originalEvent;
    const distance = touch0.clientY - touch1.clientY;

    if (this.lastDistance_ !== undefined) {
      scaleDelta =
        1 - (this.lastDistance_ - distance) * this.scaleDeltaByPixel_;
    }
    this.lastDistance_ = distance;

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    }

    // scale, bypass the resolution constraint
    const map = mapBrowserEvent.map;
    const view = map.getView();
    map.render();
    view.adjustResolutionInternal(scaleDelta);
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length == 1) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;
      this.down_ = mapBrowserEvent;
      if (!this.handlingDownUpSequence_) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }

  /**
   * Handle pointer up events zooming out.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length == 0) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      this.handlingDownUpSequence_ = false;
      this.handlingDoubleDownSequence_ = false;
      return false;
    }
    return true;
  }

  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      const event = mapBrowserEvent.originalEvent;

      const id = event.pointerId.toString();
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
        this.trackedPointers_[id] = event;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event;
      }
      this.targetPointers = Object.values(this.trackedPointers_);
    }
  }

  /**
   * Wait the second double finger tap.
   */
  waitForDblTap() {
    if (this.doubleTapTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.doubleTapTimeoutId_);
      this.doubleTapTimeoutId_ = undefined;
    } else {
      this.handlingDoubleDownSequence_ = true;
      this.doubleTapTimeoutId_ = setTimeout(
        this.endInteraction.bind(this),
        250
      );
    }
  }

  /**
   * @private
   */
  endInteraction() {
    this.handlingDoubleDownSequence_ = false;
    this.doubleTapTimeoutId_ = undefined;
  }
}

/**
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */
function isPointerDraggingEvent(mapBrowserEvent) {
  const type = mapBrowserEvent.type;
  return (
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP
  );
}

/* harmony default export */ __webpack_exports__["default"] = (DblClickDragZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/DragAndDrop.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/DragAndDrop.js ***!
  \****************************************************/
/*! exports provided: DragAndDropEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragAndDropEvent", function() { return DragAndDropEvent; });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data








/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default|import("../format/Feature.js").default>} [formatConstructors] Format constructors
 * (and/or formats pre-constructed with options).
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */

/**
 * @enum {string}
 */
const DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */
class DragAndDropEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {DragAndDropEventType} type Type.
   * @param {File} file File.
   * @param {Array<import("../Feature.js").default>} [features] Features.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   */
  constructor(type, file, features, projection) {
    super(type);

    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */
    this.features = features;

    /**
     * The dropped file.
     * @type {File}
     * @api
     */
    this.file = file;

    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */
    this.projection = projection;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'addfeatures', DragAndDropEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature
 */

/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 *
 * @api
 *
 * @fires DragAndDropEvent
 */
class DragAndDrop extends _Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      handleEvent: _functions_js__WEBPACK_IMPORTED_MODULE_3__["TRUE"],
    });

    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {DragAndDropOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {DragAndDropOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {boolean}
     */
    this.readAsBuffer_ = false;

    /**
     * @private
     * @type {Array<import("../format/Feature.js").default>}
     */
    this.formats_ = [];
    const formatConstructors = options.formatConstructors
      ? options.formatConstructors
      : [];
    for (let i = 0, ii = formatConstructors.length; i < ii; ++i) {
      let format = formatConstructors[i];
      if (typeof format === 'function') {
        format = new format();
      }
      this.formats_.push(format);
      this.readAsBuffer_ =
        this.readAsBuffer_ || format.getType() === 'arraybuffer';
    }

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = options.projection
      ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(options.projection)
      : null;

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    this.dropListenKeys_ = null;

    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */
    this.source_ = options.source || null;

    /**
     * @private
     * @type {HTMLElement|null}
     */
    this.target = options.target ? options.target : null;
  }

  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */
  handleResult_(file, event) {
    const result = event.target.result;
    const map = this.getMap();
    let projection = this.projection_;
    if (!projection) {
      projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getUserProjection"])();
      if (!projection) {
        const view = map.getView();
        projection = view.getProjection();
      }
    }

    let text;
    const formats = this.formats_;
    for (let i = 0, ii = formats.length; i < ii; ++i) {
      const format = formats[i];
      let input = result;
      if (this.readAsBuffer_ && format.getType() !== 'arraybuffer') {
        if (text === undefined) {
          text = new TextDecoder().decode(result);
        }
        input = text;
      }
      const features = this.tryReadFeatures_(format, input, {
        featureProjection: projection,
      });
      if (features && features.length > 0) {
        if (this.source_) {
          this.source_.clear();
          this.source_.addFeatures(features);
        }
        this.dispatchEvent(
          new DragAndDropEvent(
            DragAndDropEventType.ADD_FEATURES,
            file,
            features,
            projection
          )
        );
        break;
      }
    }
  }

  /**
   * @private
   */
  registerListeners_() {
    const map = this.getMap();
    if (map) {
      const dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DROP, this.handleDrop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAGENTER, this.handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAGOVER, this.handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DROP, this.handleStop, this),
      ];
    }
  }

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    if (!this.getActive() && active) {
      this.registerListeners_();
    }
    if (this.getActive() && !active) {
      this.unregisterListeners_();
    }
    super.setActive(active);
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    this.unregisterListeners_();
    super.setMap(map);
    if (this.getActive()) {
      this.registerListeners_();
    }
  }

  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").default>} Features.
   */
  tryReadFeatures_(format, text, options) {
    try {
      return (
        /** @type {Array<import("../Feature.js").default>} */
        (format.readFeatures(text, options))
      );
    } catch (e) {
      return null;
    }
  }

  /**
   * @private
   */
  unregisterListeners_() {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_5__["unlistenByKey"]);
      this.dropListenKeys_ = null;
    }
  }

  /**
   * @param {DragEvent} event Event.
   */
  handleDrop(event) {
    const files = event.dataTransfer.files;
    for (let i = 0, ii = files.length; i < ii; ++i) {
      const file = files.item(i);
      const reader = new FileReader();
      reader.addEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOAD,
        this.handleResult_.bind(this, file)
      );
      if (this.readAsBuffer_) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsText(file);
      }
    }
  }

  /**
   * @param {DragEvent} event Event.
   */
  handleStop(event) {
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
  }
}

/* harmony default export */ __webpack_exports__["default"] = (DragAndDrop);


/***/ }),

/***/ "./node_modules/ol/interaction/DragRotateAndZoom.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotateAndZoom.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/DragRotateAndZoom
 */



/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
class DragRotateAndZoom extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(/** @type {import("./Pointer.js").Options} */ (options));

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["shiftKeyOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastMagnitude_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    const map = mapBrowserEvent.map;
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const deltaX = offset[0] - size[0] / 2;
    const deltaY = size[1] / 2 - offset[1];
    const theta = Math.atan2(deltaY, deltaX);
    const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const view = map.getView();
    if (this.lastAngle_ !== undefined) {
      const angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== undefined) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }
    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    const map = mapBrowserEvent.map;
    const view = map.getView();
    const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    }
    return false;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (DragRotateAndZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/Draw.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Draw.js ***!
  \*********************************************/
/*! exports provided: DrawEvent, createRegularPolygon, createBox, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawEvent", function() { return DrawEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRegularPolygon", function() { return createRegularPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBox", function() { return createBox; });
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/Circle.js */ "./node_modules/ol/geom/Circle.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/**
 * @module ol/interaction/Draw
 */


























/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */

/**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */

/**
 * @enum {string}
 */
const DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
class DrawEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(type, feature) {
    super(type);

    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    this.feature = feature;
  }
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */
function getTraceTargets(coordinate, features) {
  /**
   * @type {Array<TraceTarget>}
   */
  const targets = [];

  for (let i = 0; i < features.length; ++i) {
    const feature = features[i];
    const geometry = feature.getGeometry();
    appendGeometryTraceTargets(coordinate, geometry, targets);
  }

  return targets;
}

/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */
function getSquaredDistance(a, b) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_20__["squaredDistance"])(a[0], a[1], b[0], b[1]);
}

/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */
function getCoordinate(coordinates, index) {
  const count = coordinates.length;
  if (index < 0) {
    return coordinates[index + count];
  }
  if (index >= count) {
    return coordinates[index - count];
  }
  return coordinates[index];
}

/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */
function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
  let lowIndex, highIndex;
  if (startIndex < endIndex) {
    lowIndex = startIndex;
    highIndex = endIndex;
  } else {
    lowIndex = endIndex;
    highIndex = startIndex;
  }
  const lowWholeIndex = Math.ceil(lowIndex);
  const highWholeIndex = Math.floor(highIndex);

  if (lowWholeIndex > highWholeIndex) {
    // both start and end are on the same segment
    const start = interpolateCoordinate(coordinates, lowIndex);
    const end = interpolateCoordinate(coordinates, highIndex);
    return getSquaredDistance(start, end);
  }

  let sd = 0;

  if (lowIndex < lowWholeIndex) {
    const start = interpolateCoordinate(coordinates, lowIndex);
    const end = getCoordinate(coordinates, lowWholeIndex);
    sd += getSquaredDistance(start, end);
  }

  if (highWholeIndex < highIndex) {
    const start = getCoordinate(coordinates, highWholeIndex);
    const end = interpolateCoordinate(coordinates, highIndex);
    sd += getSquaredDistance(start, end);
  }

  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {
    const start = getCoordinate(coordinates, i);
    const end = getCoordinate(coordinates, i + 1);
    sd += getSquaredDistance(start, end);
  }

  return sd;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendGeometryTraceTargets(coordinate, geometry, targets) {
  if (geometry instanceof _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
    return;
  }
  if (geometry instanceof _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__["default"]) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      appendTraceTarget(coordinate, coordinates[i], false, targets);
    }
    return;
  }
  if (geometry instanceof _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__["default"]) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length; i < ii; ++i) {
      appendTraceTarget(coordinate, coordinates[i], true, targets);
    }
    return;
  }
  if (geometry instanceof _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__["default"]) {
    const polys = geometry.getCoordinates();
    for (let i = 0, ii = polys.length; i < ii; ++i) {
      const coordinates = polys[i];
      for (let j = 0, jj = coordinates.length; j < jj; ++j) {
        appendTraceTarget(coordinate, coordinates[j], true, targets);
      }
    }
    return;
  }
  if (geometry instanceof _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
    const geometries = geometry.getGeometries();
    for (let i = 0; i < geometries.length; ++i) {
      appendGeometryTraceTargets(coordinate, geometries[i], targets);
    }
    return;
  }
  // other types cannot be traced
}

/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */

/**
 * @type {TraceTargetUpdateInfo}
 */
const sharedUpdateInfo = {index: -1, endIndex: NaN};

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */
function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
  const x = coordinate[0];
  const y = coordinate[1];

  let closestTargetDistance = Infinity;

  let newTargetIndex = -1;
  let newEndIndex = NaN;

  for (
    let targetIndex = 0;
    targetIndex < traceState.targets.length;
    ++targetIndex
  ) {
    const target = traceState.targets[targetIndex];
    const coordinates = target.coordinates;

    let minSegmentDistance = Infinity;
    let endIndex;
    for (
      let coordinateIndex = 0;
      coordinateIndex < coordinates.length - 1;
      ++coordinateIndex
    ) {
      const start = coordinates[coordinateIndex];
      const end = coordinates[coordinateIndex + 1];
      const rel = getPointSegmentRelationship(x, y, start, end);
      if (rel.squaredDistance < minSegmentDistance) {
        minSegmentDistance = rel.squaredDistance;
        endIndex = coordinateIndex + rel.along;
      }
    }

    if (minSegmentDistance < closestTargetDistance) {
      closestTargetDistance = minSegmentDistance;
      if (target.ring && traceState.targetIndex === targetIndex) {
        // same target, maintain the same trace direction
        if (target.endIndex > target.startIndex) {
          // forward trace
          if (endIndex < target.startIndex) {
            endIndex += coordinates.length;
          }
        } else if (target.endIndex < target.startIndex) {
          // reverse trace
          if (endIndex > target.startIndex) {
            endIndex -= coordinates.length;
          }
        }
      }
      newEndIndex = endIndex;
      newTargetIndex = targetIndex;
    }
  }

  const newTarget = traceState.targets[newTargetIndex];
  let considerBothDirections = newTarget.ring;
  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
    // only consider switching trace direction if close to the start
    const newCoordinate = interpolateCoordinate(
      newTarget.coordinates,
      newEndIndex
    );
    const pixel = map.getPixelFromCoordinate(newCoordinate);
    if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__["distance"])(pixel, traceState.startPx) > snapTolerance) {
      considerBothDirections = false;
    }
  }

  if (considerBothDirections) {
    const coordinates = newTarget.coordinates;
    const count = coordinates.length;
    const startIndex = newTarget.startIndex;
    const endIndex = newEndIndex;
    if (startIndex < endIndex) {
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex
      );
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex - count
      );
      if (reverseDistance < forwardDistance) {
        newEndIndex -= count;
      }
    } else {
      const reverseDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex
      );
      const forwardDistance = getCumulativeSquaredDistance(
        coordinates,
        startIndex,
        endIndex + count
      );
      if (forwardDistance < reverseDistance) {
        newEndIndex += count;
      }
    }
  }

  sharedUpdateInfo.index = newTargetIndex;
  sharedUpdateInfo.endIndex = newEndIndex;
  return sharedUpdateInfo;
}

/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */
function appendTraceTarget(coordinate, coordinates, ring, targets) {
  const x = coordinate[0];
  const y = coordinate[1];
  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    const start = coordinates[i];
    const end = coordinates[i + 1];
    const rel = getPointSegmentRelationship(x, y, start, end);
    if (rel.squaredDistance === 0) {
      const index = i + rel.along;
      targets.push({
        coordinates: coordinates,
        ring: ring,
        startIndex: index,
        endIndex: index,
      });
      return;
    }
  }
}

/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */

/**
 * @type {PointSegmentRelationship}
 */
const sharedRel = {along: 0, squaredDistance: 0};

/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */
function getPointSegmentRelationship(x, y, start, end) {
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  let along = 0;
  let px = x1;
  let py = y1;
  if (dx !== 0 || dy !== 0) {
    along = Object(_math_js__WEBPACK_IMPORTED_MODULE_20__["clamp"])(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
    px += dx * along;
    py += dy * along;
  }

  sharedRel.along = along;
  sharedRel.squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_20__["toFixed"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_20__["squaredDistance"])(x, y, px, py), 10);
  return sharedRel;
}

/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */
function interpolateCoordinate(coordinates, index) {
  const count = coordinates.length;

  let startIndex = Math.floor(index);
  const along = index - startIndex;
  if (startIndex >= count) {
    startIndex -= count;
  } else if (startIndex < 0) {
    startIndex += count;
  }

  let endIndex = startIndex + 1;
  if (endIndex >= count) {
    endIndex -= count;
  }

  const start = coordinates[startIndex];
  const x0 = start[0];
  const y0 = start[1];
  const end = coordinates[endIndex];
  const dx = end[0] - x0;
  const dy = end[1] - y0;

  return [x0 + dx * along, y0 + dy * along];
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */

/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
class Draw extends _Pointer_js__WEBPACK_IMPORTED_MODULE_13__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_17__["FALSE"];
    }

    super(pointerOptions);

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {DrawOnSignature<void>}
     */
    this.un;

    /**
     * @type {boolean}
     * @private
     */
    this.shouldHandle_ = false;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.downPx_ = null;

    /**
     * @type {?}
     * @private
     */
    this.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    this.lastDragTime_;

    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */
    this.pointerType_;

    /**
     * @type {boolean}
     * @private
     */
    this.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */
    this.type_ = /** @type {import("../geom/Geometry.js").Type} */ (
      options.type
    );

    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    this.mode_ = getMode(this.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    this.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    this.minPoints_ = options.minPoints
      ? options.minPoints
      : this.mode_ === 'Polygon'
      ? 3
      : 2;

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    this.maxPoints_ =
      this.mode_ === 'Circle'
        ? 2
        : options.maxPoints
        ? options.maxPoints
        : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.finishCondition_ = options.finishCondition
      ? options.finishCondition
      : _functions_js__WEBPACK_IMPORTED_MODULE_17__["TRUE"];

    /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */
    this.geometryLayout_ = options.geometryLayout
      ? options.geometryLayout
      : 'XY';

    let geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      const mode = this.mode_;
      if (mode === 'Circle') {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, geometry, projection) {
          const circle = geometry
            ? /** @type {Circle} */ (geometry)
            : new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__["default"]([NaN, NaN]);
          const center = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["fromUserCoordinate"])(coordinates[0], projection);
          const squaredLength = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__["squaredDistance"])(
            center,
            Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["fromUserCoordinate"])(coordinates[coordinates.length - 1], projection)
          );
          circle.setCenterAndRadius(
            center,
            Math.sqrt(squaredLength),
            this.geometryLayout_
          );
          const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["getUserProjection"])();
          if (userProjection) {
            circle.transform(projection, userProjection);
          }
          return circle;
        };
      } else {
        let Constructor;
        if (mode === 'Point') {
          Constructor = _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"];
        } else if (mode === 'LineString') {
          Constructor = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"];
        } else if (mode === 'Polygon') {
          Constructor = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__["default"];
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, geometry, projection) {
          if (geometry) {
            if (mode === 'Polygon') {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates(
                  [coordinates[0].concat([coordinates[0][0]])],
                  this.geometryLayout_
                );
              } else {
                geometry.setCoordinates([], this.geometryLayout_);
              }
            } else {
              geometry.setCoordinates(coordinates, this.geometryLayout_);
            }
          } else {
            geometry = new Constructor(coordinates, this.geometryLayout_);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {GeometryFunction}
     * @private
     */
    this.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    this.dragVertexDelay_ =
      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */
    this.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */
    this.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    this.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */
    this.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    this.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    this.squaredClickTolerance_ = options.clickTolerance
      ? options.clickTolerance * options.clickTolerance
      : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false,
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true,
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_18__["noModifierKeys"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_18__["always"];
    } else {
      this.freehandCondition_ = options.freehandCondition
        ? options.freehandCondition
        : _events_condition_js__WEBPACK_IMPORTED_MODULE_18__["shiftKeyOnly"];
    }

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.traceCondition_;
    this.setTrace(options.trace || false);

    /**
     * @type {TraceState}
     * @private
     */
    this.traceState_ = {active: false};

    /**
     * @type {VectorSource|null}
     * @private
     */
    this.traceSource_ = options.traceSource || options.source || null;

    this.addChangeListener(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].ACTIVE, this.updateState_);
  }

  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(trace) {
    let condition;
    if (!trace) {
      condition = _events_condition_js__WEBPACK_IMPORTED_MODULE_18__["never"];
    } else if (trace === true) {
      condition = _events_condition_js__WEBPACK_IMPORTED_MODULE_18__["always"];
    } else {
      condition = trace;
    }
    this.traceCondition_ = condition;
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    super.setMap(map);
    this.updateState_();
  }

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(event) {
    if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.originalEvent.preventDefault();
    }
    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
    let move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERMOVE;
    let pass = true;
    if (
      !this.freehand_ &&
      this.lastDragTime_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERDRAG
    ) {
      const now = Date.now();
      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }
    if (
      this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERDRAG &&
      this.sketchFeature_ !== null
    ) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (
      this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERDOWN
    ) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERMOVE;
      if (pass && this.freehand_) {
        this.handlePointerMove_(event);
        if (this.shouldHandle_) {
          // Avoid page scrolling when freehand drawing on mobile
          event.originalEvent.preventDefault();
        }
      } else if (
        event.originalEvent.pointerType === 'mouse' ||
        (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERDRAG &&
          this.downTimeout_ === undefined)
      ) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].DBLCLICK) {
      pass = false;
    }

    return super.handleEvent(event) && pass;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }
      return true;
    }

    if (!this.condition_(event)) {
      this.lastDragTime_ = undefined;
      return false;
    }

    this.lastDragTime_ = Date.now();
    this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].POINTERMOVE,
          event.map,
          event.originalEvent,
          false,
          event.frameState
        )
      );
    }, this.dragVertexDelay_);
    this.downPx_ = event.pixel;
    return true;
  }

  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = {active: false};
  }

  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(event) {
    if (!this.traceSource_ || !this.traceCondition_(event)) {
      return;
    }

    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }

    const map = this.getMap();
    const lowerLeft = map.getCoordinateFromPixel([
      event.pixel[0] - this.snapTolerance_,
      event.pixel[1] + this.snapTolerance_,
    ]);
    const upperRight = map.getCoordinateFromPixel([
      event.pixel[0] + this.snapTolerance_,
      event.pixel[1] - this.snapTolerance_,
    ]);
    const extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["boundingExtent"])([lowerLeft, upperRight]);
    const features = this.traceSource_.getFeaturesInExtent(extent);
    if (features.length === 0) {
      return;
    }

    const targets = getTraceTargets(event.coordinate, features);
    if (targets.length) {
      this.traceState_ = {
        active: true,
        startPx: event.pixel.slice(),
        targets: targets,
        targetIndex: -1,
      };
    }
  }

  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(target, endIndex) {
    // three cases to handle:
    //  1. traced in the same direction and points need adding
    //  2. traced in the same direction and points need removing
    //  3. traced in a new direction
    const previouslyForward = target.startIndex <= target.endIndex;
    const currentlyForward = target.startIndex <= endIndex;
    if (previouslyForward === currentlyForward) {
      // same direction
      if (
        (previouslyForward && endIndex > target.endIndex) ||
        (!previouslyForward && endIndex < target.endIndex)
      ) {
        // case 1 - add new points
        this.addTracedCoordinates_(target, target.endIndex, endIndex);
      } else if (
        (previouslyForward && endIndex < target.endIndex) ||
        (!previouslyForward && endIndex > target.endIndex)
      ) {
        // case 2 - remove old points
        this.removeTracedCoordinates_(endIndex, target.endIndex);
      }
    } else {
      // case 3 - remove old points, add new points
      this.removeTracedCoordinates_(target.startIndex, target.endIndex);
      this.addTracedCoordinates_(target, target.startIndex, endIndex);
    }
  }

  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }

    let remove = 0;
    if (fromIndex < toIndex) {
      const start = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        end -= 1;
      }
      remove = end - start + 1;
    } else {
      const start = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      remove = start - end + 1;
    }

    if (remove > 0) {
      this.removeLastPoints_(remove);
    }
  }

  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(target, fromIndex, toIndex) {
    if (fromIndex === toIndex) {
      return;
    }

    const coordinates = [];
    if (fromIndex < toIndex) {
      // forward trace
      const start = Math.ceil(fromIndex);
      let end = Math.floor(toIndex);
      if (end === toIndex) {
        // if end is snapped to a vertex, it will be added later
        end -= 1;
      }
      for (let i = start; i <= end; ++i) {
        coordinates.push(getCoordinate(target.coordinates, i));
      }
    } else {
      // reverse trace
      const start = Math.floor(fromIndex);
      let end = Math.ceil(toIndex);
      if (end === toIndex) {
        end += 1;
      }
      for (let i = start; i >= end; --i) {
        coordinates.push(getCoordinate(target.coordinates, i));
      }
    }
    if (coordinates.length) {
      this.appendCoordinates(coordinates);
    }
  }

  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(event) {
    const traceState = this.traceState_;
    if (!traceState.active) {
      return;
    }

    if (traceState.targetIndex === -1) {
      // check if we are ready to pick a target
      if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__["distance"])(traceState.startPx, event.pixel) < this.snapTolerance_) {
        return;
      }
    }

    const updatedTraceTarget = getTraceTargetUpdate(
      event.coordinate,
      traceState,
      this.getMap(),
      this.snapTolerance_
    );

    if (traceState.targetIndex !== updatedTraceTarget.index) {
      // target changed
      if (traceState.targetIndex !== -1) {
        // remove points added during previous trace
        const oldTarget = traceState.targets[traceState.targetIndex];
        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
      }
      // add points for the new target
      const newTarget = traceState.targets[updatedTraceTarget.index];
      this.addTracedCoordinates_(
        newTarget,
        newTarget.startIndex,
        updatedTraceTarget.endIndex
      );
    } else {
      // target stayed the same
      const target = traceState.targets[traceState.targetIndex];
      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);
    }

    // modify the state with updated info
    traceState.targetIndex = updatedTraceTarget.index;
    const target = traceState.targets[traceState.targetIndex];
    target.endIndex = updatedTraceTarget.endIndex;

    // update event coordinate and pixel to match end point of final segment
    const coordinate = interpolateCoordinate(
      target.coordinates,
      target.endIndex
    );
    const pixel = this.getMap().getPixelFromCoordinate(coordinate);
    event.coordinate = coordinate;
    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(event) {
    let pass = true;

    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }

      this.handlePointerMove_(event);
      const tracing = this.traceState_.active;
      this.toggleTraceState_(event);

      if (this.shouldHandle_) {
        const startingToDraw = !this.finishCoordinate_;
        if (startingToDraw) {
          this.startDrawing_(event.coordinate);
        }
        if (!startingToDraw && this.freehand_) {
          this.finishDrawing();
        } else if (
          !this.freehand_ &&
          (!startingToDraw || this.mode_ === 'Point')
        ) {
          if (this.atFinish_(event.pixel, tracing)) {
            if (this.finishCondition_(event)) {
              this.finishDrawing();
            }
          } else {
            this.addToDrawing_(event.coordinate);
          }
        }
        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }

    if (!pass && this.stopClick_) {
      event.preventDefault();
    }
    return pass;
  }

  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(event) {
    this.pointerType_ = event.originalEvent.pointerType;
    if (
      this.downPx_ &&
      ((!this.freehand_ && this.shouldHandle_) ||
        (this.freehand_ && !this.shouldHandle_))
    ) {
      const downPx = this.downPx_;
      const clickPx = event.pixel;
      const dx = downPx[0] - clickPx[0];
      const dy = downPx[1] - clickPx[1];
      const squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_
        ? squaredDistance > this.squaredClickTolerance_
        : squaredDistance <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return;
      }
    }

    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(event.coordinate.slice());
      return;
    }

    this.updateTrace_(event);
    this.modifyDrawing_(event.coordinate);
  }

  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(pixel, tracing) {
    let at = false;
    if (this.sketchFeature_) {
      let potentiallyDone = false;
      let potentiallyFinishCoordinates = [this.finishCoordinate_];
      const mode = this.mode_;
      if (mode === 'Point') {
        at = true;
      } else if (mode === 'Circle') {
        at = this.sketchCoords_.length === 2;
      } else if (mode === 'LineString') {
        potentiallyDone =
          !tracing && this.sketchCoords_.length > this.minPoints_;
      } else if (mode === 'Polygon') {
        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [
          sketchCoords[0][0],
          sketchCoords[0][sketchCoords[0].length - 2],
        ];
        if (tracing) {
          potentiallyFinishCoordinates = [sketchCoords[0][0]];
        } else {
          potentiallyFinishCoordinates = [
            sketchCoords[0][0],
            sketchCoords[0][sketchCoords[0].length - 2],
          ];
        }
      }
      if (potentiallyDone) {
        const map = this.getMap();
        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          const finishCoordinate = potentiallyFinishCoordinates[i];
          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          const dx = pixel[0] - finishPixel[0];
          const dy = pixel[1] - finishPixel[1];
          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at;
  }

  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(coordinates) {
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates);
    }
  }

  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    }
    const ring = geometry.getLinearRing(0);
    let sketchLineGeom = this.sketchLine_.getGeometry();
    if (!sketchLineGeom) {
      sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        ring.getFlatCoordinates(),
        ring.getLayout()
      );
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(
        ring.getLayout(),
        ring.getFlatCoordinates()
      );
      sketchLineGeom.changed();
    }
  }

  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(start) {
    const projection = this.getMap().getView().getProjection();
    const stride = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_24__["getStrideForLayout"])(this.geometryLayout_);
    while (start.length < stride) {
      start.push(0);
    }
    this.finishCoordinate_ = start;
    if (this.mode_ === 'Point') {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === 'Polygon') {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.sketchLineCoords_));
    }
    const geometry = this.geometryFunction_(
      this.sketchCoords_,
      undefined,
      projection
    );
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(
      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
    );
  }

  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(coordinate) {
    const map = this.getMap();
    const geometry = this.sketchFeature_.getGeometry();
    const projection = map.getView().getProjection();
    const stride = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_24__["getStrideForLayout"])(this.geometryLayout_);
    let coordinates, last;
    while (coordinate.length < stride) {
      coordinate.push(0);
    }
    if (this.mode_ === 'Point') {
      last = this.sketchCoords_;
    } else if (this.mode_ === 'Polygon') {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(
      /** @type {!LineCoordType} */ (this.sketchCoords_),
      geometry,
      projection
    );
    if (this.sketchPoint_) {
      const sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }
    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {
      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));
    } else if (this.sketchLineCoords_) {
      const sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  }

  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(coordinate) {
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    let done;
    let coordinates;
    const mode = this.mode_;
    if (mode === 'LineString' || mode === 'Circle') {
      this.finishCoordinate_ = coordinate.slice();
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (mode === 'Polygon') {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }
    this.createOrUpdateSketchPoint_(coordinate.slice());
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  }

  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(n) {
    if (!this.sketchFeature_) {
      return;
    }
    const geometry = this.sketchFeature_.getGeometry();
    const projection = this.getMap().getView().getProjection();
    const mode = this.mode_;
    for (let i = 0; i < n; ++i) {
      let coordinates;
      if (mode === 'LineString' || mode === 'Circle') {
        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
        coordinates.splice(-2, 1);
        if (coordinates.length >= 2) {
          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
          const finishCoordinate = this.finishCoordinate_.slice();
          coordinates[coordinates.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        this.geometryFunction_(coordinates, geometry, projection);
        if (geometry.getType() === 'Polygon' && this.sketchLine_) {
          this.createOrUpdateCustomSketchLine_(
            /** @type {Polygon} */ (geometry)
          );
        }
      } else if (mode === 'Polygon') {
        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
        coordinates.splice(-2, 1);
        const sketchLineGeom = this.sketchLine_.getGeometry();
        if (coordinates.length >= 2) {
          const finishCoordinate = coordinates[coordinates.length - 2].slice();
          coordinates[coordinates.length - 1] = finishCoordinate;
          this.createOrUpdateSketchPoint_(finishCoordinate);
        }
        sketchLineGeom.setCoordinates(coordinates);
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
      }

      if (coordinates.length === 1) {
        this.abortDrawing();
        break;
      }
    }

    this.updateSketchFeatures_();
  }

  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }

  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    let coordinates = this.sketchCoords_;
    const geometry = sketchFeature.getGeometry();
    const projection = this.getMap().getView().getProjection();
    if (this.mode_ === 'LineString') {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === 'Polygon') {
      // remove the redundant last point in ring
      /** @type {PolyCoordType} */ (coordinates)[0].pop();
      this.geometryFunction_(coordinates, geometry, projection);
      coordinates = geometry.getCoordinates();
    }

    // cast multi-part geometries
    if (this.type_ === 'MultiPoint') {
      sketchFeature.setGeometry(
        new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__["default"]([/** @type {PointCoordType} */ (coordinates)])
      );
    } else if (this.type_ === 'MultiLineString') {
      sketchFeature.setGeometry(
        new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_9__["default"]([/** @type {LineCoordType} */ (coordinates)])
      );
    } else if (this.type_ === 'MultiPolygon') {
      sketchFeature.setGeometry(
        new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_11__["default"]([/** @type {PolyCoordType} */ (coordinates)])
      );
    }

    // First dispatch event to allow full set up of feature
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

    // Then insert feature
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  }

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    this.deactivateTrace_();
    return sketchFeature;
  }

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const sketchFeature = this.abortDrawing_();
    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  }

  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(coordinates) {
    const mode = this.mode_;
    const newDrawing = !this.sketchFeature_;
    if (newDrawing) {
      this.startDrawing_(coordinates[0]);
    }
    /** @type {LineCoordType} */
    let sketchCoords;
    if (mode === 'LineString' || mode === 'Circle') {
      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);
    } else if (mode === 'Polygon') {
      sketchCoords =
        this.sketchCoords_ && this.sketchCoords_.length
          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]
          : [];
    } else {
      return;
    }

    if (newDrawing) {
      sketchCoords.shift();
    }

    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
    sketchCoords.pop();

    // Append coordinate list
    for (let i = 0; i < coordinates.length; i++) {
      this.addToDrawing_(coordinates[i]);
    }

    const ending = coordinates[coordinates.length - 1];
    // Duplicate last coordinate for sketch drawing (cursor position)
    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  }

  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(feature) {
    const geometry = feature.getGeometry();
    const lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    const last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_12__["default"](last));
    this.updateSketchFeatures_();
    this.dispatchEvent(
      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)
    );
  }

  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    const overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  }

  /**
   * @private
   */
  updateState_() {
    const map = this.getMap();
    const active = this.getActive();
    if (!map || !active) {
      this.abortDrawing();
    }
    this.overlay_.setMap(active ? map : null);
  }
}

/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  const styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_21__["createEditingStyle"])();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}

/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */
function createRegularPolygon(sides, angle) {
  return function (coordinates, geometry, projection) {
    const center = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["fromUserCoordinate"])(
      /** @type {LineCoordType} */ (coordinates)[0],
      projection
    );
    const end = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["fromUserCoordinate"])(
      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],
      projection
    );
    const radius = Math.sqrt(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_22__["squaredDistance"])(center, end));
    geometry = geometry || Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__["fromCircle"])(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_0__["default"](center), sides);

    let internalAngle = angle;
    if (!angle && angle !== 0) {
      const x = end[0] - center[0];
      const y = end[1] - center[1];
      internalAngle = Math.atan2(y, x);
    }
    Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__["makeRegular"])(
      /** @type {Polygon} */ (geometry),
      center,
      radius,
      internalAngle
    );

    const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["getUserProjection"])();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return function (coordinates, geometry, projection) {
    const extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["boundingExtent"])(
      /** @type {LineCoordType} */ ([
        coordinates[0],
        coordinates[coordinates.length - 1],
      ]).map(function (coordinate) {
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["fromUserCoordinate"])(coordinate, projection);
      })
    );
    const boxCoordinates = [
      [
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getBottomLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getBottomRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getTopRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getTopLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getBottomLeft"])(extent),
      ],
    ];
    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_14__["default"](boxCoordinates);
    }
    const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_23__["getUserProjection"])();
    if (userProjection) {
      geometry.transform(projection, userProjection);
    }
    return geometry;
  };
}

/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
  switch (type) {
    case 'Point':
    case 'MultiPoint':
      return 'Point';
    case 'LineString':
    case 'MultiLineString':
      return 'LineString';
    case 'Polygon':
    case 'MultiPolygon':
      return 'Polygon';
    case 'Circle':
      return 'Circle';
    default:
      throw new Error('Invalid type: ' + type);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Draw);


/***/ }),

/***/ "./node_modules/ol/interaction/Extent.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Extent.js ***!
  \***********************************************/
/*! exports provided: ExtentEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtentEvent", function() { return ExtentEvent; });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/interaction/Extent
 */














/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.always}.
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to the `Polygon` editing style
 * documented in {@link module:ol/style/Style~Style}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to the `Point` editing style
 * documented in {@link module:ol/style/Style~Style}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */

/**
 * @enum {string}
 */
const ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEvent#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */
class ExtentEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../extent.js").Extent} extent the new extent
   */
  constructor(extent) {
    super(ExtentEventType.EXTENTCHANGED);

    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    this.extent = extent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'extentchanged', ExtentEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'extentchanged', Return>} ExtentOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */
class Extent extends _Pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    super(/** @type {import("./Pointer.js").Options} */ (options));

    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {ExtentOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {ExtentOnSignature<void>}
     */
    this.un;

    /**
     * Condition
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_7__["always"];

    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.extent_ = null;

    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */
    this.pointerHandler_ = null;

    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */
    this.pixelTolerance_ =
      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;

    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */
    this.extentFeature_ = null;

    /**
     * Feature for displaying the visible pointer
     * @type {Feature<Point>}
     * @private
     */
    this.vertexFeature_ = null;

    if (!options) {
      options = {};
    }

    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */
    this.extentOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX,
      }),
      style: options.boxStyle
        ? options.boxStyle
        : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true,
    });

    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */
    this.vertexOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX,
      }),
      style: options.pointerStyle
        ? options.pointerStyle
        : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true,
    });

    if (options.extent) {
      this.setExtent(options.extent);
    }
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../Map.js").default} map map
   * @return {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */
  snapToVertex_(pixel, map) {
    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);
    const sortByDistance = function (a, b) {
      return (
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["squaredDistanceToSegment"])(pixelCoordinate, a) -
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["squaredDistanceToSegment"])(pixelCoordinate, b)
      );
    };
    const extent = this.getExtentInternal();
    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      const segments = getSegments(extent);
      segments.sort(sortByDistance);
      const closestSegment = segments[0];

      let vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["closestOnSegment"])(pixelCoordinate, closestSegment);
      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);

      //if the distance is within tolerance, snap to the segment
      if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
        const squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["squaredDistance"])(vertexPixel, pixel1);
        const squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_9__["squaredDistance"])(vertexPixel, pixel2);
        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex =
            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }
        return vertex;
      }
    }
    return null;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */
  handlePointerMove_(mapBrowserEvent) {
    const pixel = mapBrowserEvent.pixel;
    const map = mapBrowserEvent.map;

    let vertex = this.snapToVertex_(pixel, map);
    if (!vertex) {
      vertex = map.getCoordinateFromPixelInternal(pixel);
    }
    this.createOrUpdatePointerFeature_(vertex);
  }

  /**
   * @param {import("../extent.js").Extent} extent extent
   * @return {Feature} extent as featrue
   * @private
   */
  createOrUpdateExtentFeature_(extent) {
    let extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]({});
      } else {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__["fromExtent"])(extent));
      }
      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry(Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__["fromExtent"])(extent));
      }
    }
    return extentFeature;
  }

  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @return {Feature} vertex as feature
   * @private
   */
  createOrUpdatePointerFeature_(vertex) {
    let vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      const geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(vertex);
    }
    return vertexFeature;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {
      return true;
    }
    //display pointer (if not dragging)
    if (
      mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE &&
      !this.handlingDownUpSequence
    ) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    //call pointer to determine up/down/drag
    super.handleEvent(mapBrowserEvent);
    //return false to stop propagation
    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    const pixel = mapBrowserEvent.pixel;
    const map = mapBrowserEvent.map;

    const extent = this.getExtentInternal();
    let vertex = this.snapToVertex_(pixel, map);

    //find the extent corner opposite the passed corner
    const getOpposingPoint = function (point) {
      let x_ = null;
      let y_ = null;
      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }
      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }
      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }
      return null;
    };
    if (vertex && extent) {
      const x =
        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
      const y =
        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;

      //snap to point
      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
        //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([x, extent[1]]),
          getOpposingPoint([x, extent[3]])
        );
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([extent[0], y]),
          getOpposingPoint([extent[2], y])
        );
      }
      //no snap - new bbox
    } else {
      vertex = map.getCoordinateFromPixelInternal(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }
    return true; //event handled; start downup sequence
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (this.pointerHandler_) {
      const pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    this.pointerHandler_ = null;
    //If bbox is zero area, set to null;
    const extent = this.getExtentInternal();
    if (!extent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getArea"])(extent) === 0) {
      this.setExtent(null);
    }
    return false; //Stop handling downup sequence
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);
    super.setMap(map);
  }

  /**
   * Returns the current drawn extent in the view projection (or user projection if set)
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */
  getExtent() {
    return Object(_proj_js__WEBPACK_IMPORTED_MODULE_12__["toUserExtent"])(
      this.getExtentInternal(),
      this.getMap().getView().getProjection()
    );
  }

  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */
  getExtentInternal() {
    return this.extent_;
  }

  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */
  setExtent(extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentEvent(this.extent_));
  }
}

/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */
function getDefaultExtentStyleFunction() {
  const style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_10__["createEditingStyle"])();
  return function (feature, resolution) {
    return style['Polygon'];
  };
}

/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */
function getDefaultPointerStyleFunction() {
  const style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_10__["createEditingStyle"])();
  return function (feature, resolution) {
    return style['Point'];
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */
function getPointHandler(fixedPoint) {
  return function (point) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["boundingExtent"])([fixedPoint, point]);
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */
function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function (point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["boundingExtent"])([fixedP1, [point[0], fixedP2[1]]]);
    };
  }
  if (fixedP1[1] == fixedP2[1]) {
    return function (point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["boundingExtent"])([fixedP1, [fixedP2[0], point[1]]]);
    };
  }
  return null;
}

/**
 * @param {import("../extent.js").Extent} extent extent
 * @return {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */
function getSegments(extent) {
  return [
    [
      [extent[0], extent[1]],
      [extent[0], extent[3]],
    ],
    [
      [extent[0], extent[3]],
      [extent[2], extent[3]],
    ],
    [
      [extent[2], extent[3]],
      [extent[2], extent[1]],
    ],
    [
      [extent[2], extent[1]],
      [extent[0], extent[1]],
    ],
  ];
}

/* harmony default export */ __webpack_exports__["default"] = (Extent);


/***/ }),

/***/ "./node_modules/ol/interaction/Link.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Link.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/Link
 */






/**
 * @param {number} number A number.
 * @return {number} A number with at most 5 decimal places.
 */
function to5(number) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["toFixed"])(number, 5);
}

/**
 * @param {string} string A string.
 * @return {number} A number representing the string.
 */
function readNumber(string) {
  return parseFloat(string);
}

/**
 * @param {number} number A number.
 * @return {string} A string representing the number.
 */
function writeNumber(number) {
  return to5(number).toString();
}

/**
 * @param {number} a A number.
 * @param {number} b A number.
 * @return {boolean} The numbers are different.
 */
function differentNumber(a, b) {
  if (isNaN(a)) {
    return false;
  }
  return a !== readNumber(writeNumber(b));
}

/**
 * @param {Array<number>} a An array of two numbers.
 * @param {Array<number>} b An array of two numbers.
 * @return {boolean} The arrays are different.
 */
function differentArray(a, b) {
  return differentNumber(a[0], b[0]) || differentNumber(a[1], b[1]);
}

/** @typedef {'x'|'y'|'z'|'r'|'l'} Params */

/**
 * @typedef {Object} Options
 * @property {boolean|import('../View.js').AnimationOptions} [animate=true] Animate view transitions.
 * @property {Array<Params>} [params=['x', 'y', 'z', 'r', 'l']] Properties to track. Default is to track
 * `x` (center x), `y` (center y), `z` (zoom), `r` (rotation) and `l` (layers).
 * @property {boolean} [replace=false] Replace the current URL without creating the new entry in browser history.
 * By default, changes in the map state result in a new entry being added to the browser history.
 * @property {string} [prefix=''] By default, the URL will be updated with search parameters x, y, z, and r.  To
 * avoid collisions with existing search parameters that your application uses, you can supply a custom prefix for
 * the ones used by this interaction (e.g. 'ol:').
 */

/**
 * @classdesc
 * An interaction that synchronizes the map state with the URL.
 *
 * @api
 */
class Link extends _Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Link options.
   */
  constructor(options) {
    super();

    options = Object.assign(
      {
        animate: true,
        params: ['x', 'y', 'z', 'r', 'l'],
        replace: false,
        prefix: '',
      },
      options || {}
    );

    let animationOptions;
    if (options.animate === true) {
      animationOptions = {duration: 250};
    } else if (!options.animate) {
      animationOptions = null;
    } else {
      animationOptions = options.animate;
    }

    /**
     * @type {import('../View.js').AnimationOptions|null}
     * @private
     */
    this.animationOptions_ = animationOptions;

    /**
     * @type {Object<Params, boolean>}
     * @private
     */
    this.params_ = options.params.reduce((acc, value) => {
      acc[value] = true;
      return acc;
    }, {});

    /**
     * @private
     * @type {boolean}
     */
    this.replace_ = options.replace;

    /**
     * @private
     * @type {string}
     */
    this.prefix_ = options.prefix;

    /**
     * @private
     * @type {!Array<import("../events.js").EventsKey>}
     */
    this.listenerKeys_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.initial_ = true;

    this.updateState_ = this.updateState_.bind(this);
  }

  /**
   * @private
   * @param {string} name A parameter name.
   * @return {string} A name with the prefix applied.
   */
  getParamName_(name) {
    if (!this.prefix_) {
      return name;
    }
    return this.prefix_ + name;
  }

  /**
   * @private
   * @param {URLSearchParams} params The search params.
   * @param {string} name The unprefixed parameter name.
   * @return {string|null} The parameter value.
   */
  get_(params, name) {
    return params.get(this.getParamName_(name));
  }

  /**
   * @private
   * @param {URLSearchParams} params The search params.
   * @param {string} name The unprefixed parameter name.
   * @param {string} value The param value.
   */
  set_(params, name, value) {
    if (!(name in this.params_)) {
      return;
    }
    params.set(this.getParamName_(name), value);
  }

  /**
   * @private
   * @param {URLSearchParams} params The search params.
   * @param {string} name The unprefixed parameter name.
   */
  delete_(params, name) {
    if (!(name in this.params_)) {
      return;
    }
    params.delete(this.getParamName_(name));
  }

  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    const oldMap = this.getMap();
    super.setMap(map);
    if (map === oldMap) {
      return;
    }
    if (oldMap) {
      this.unregisterListeners_(oldMap);
    }
    if (map) {
      this.initial_ = true;
      this.updateState_();
      this.registerListeners_(map);
    }
  }

  /**
   * @param {import("../Map.js").default} map Map.
   * @private
   */
  registerListeners_(map) {
    this.listenerKeys_.push(
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MOVEEND, this.updateUrl_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(map.getLayerGroup(), _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CHANGE, this.updateUrl_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(map, 'change:layergroup', this.handleChangeLayerGroup_, this)
    );

    if (!this.replace_) {
      addEventListener('popstate', this.updateState_);
    }
  }

  /**
   * @param {import("../Map.js").default} map Map.
   * @private
   */
  unregisterListeners_(map) {
    for (let i = 0, ii = this.listenerKeys_.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.listenerKeys_[i]);
    }
    this.listenerKeys_.length = 0;

    if (!this.replace_) {
      removeEventListener('popstate', this.updateState_);
    }

    const url = new URL(window.location.href);
    const params = url.searchParams;
    this.delete_(params, 'x');
    this.delete_(params, 'y');
    this.delete_(params, 'z');
    this.delete_(params, 'r');
    this.delete_(params, 'l');
    window.history.replaceState(null, '', url);
  }

  /**
   * @private
   */
  handleChangeLayerGroup_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    this.unregisterListeners_(map);
    this.registerListeners_(map);
    this.initial_ = true;
    this.updateUrl_();
  }

  /**
   * @private
   */
  updateState_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    if (!view) {
      return;
    }
    const url = new URL(window.location.href);
    const params = url.searchParams;

    let updateView = false;

    /**
     * @type {import('../View.js').AnimationOptions}
     */
    const viewProperties = {};

    const zoom = readNumber(this.get_(params, 'z'));
    if ('z' in this.params_ && differentNumber(zoom, view.getZoom())) {
      updateView = true;
      viewProperties.zoom = zoom;
    }

    const rotation = readNumber(this.get_(params, 'r'));
    if ('r' in this.params_ && differentNumber(rotation, view.getRotation())) {
      updateView = true;
      viewProperties.rotation = rotation;
    }

    const center = [
      readNumber(this.get_(params, 'x')),
      readNumber(this.get_(params, 'y')),
    ];
    if (
      ('x' in this.params_ || 'y' in this.params_) &&
      differentArray(center, view.getCenter())
    ) {
      updateView = true;
      viewProperties.center = center;
    }

    if (updateView) {
      if (!this.initial_ && this.animationOptions_) {
        view.animate(Object.assign(viewProperties, this.animationOptions_));
      } else {
        if (viewProperties.center) {
          view.setCenter(viewProperties.center);
        }
        if ('zoom' in viewProperties) {
          view.setZoom(viewProperties.zoom);
        }
        if ('rotation' in viewProperties) {
          view.setRotation(viewProperties.rotation);
        }
      }
    }

    const layers = map.getAllLayers();
    const layersParam = this.get_(params, 'l');
    if (
      'l' in this.params_ &&
      layersParam &&
      layersParam.length === layers.length
    ) {
      for (let i = 0, ii = layers.length; i < ii; ++i) {
        const value = parseInt(layersParam[i]);
        if (!isNaN(value)) {
          const visible = Boolean(value);
          const layer = layers[i];
          if (layer.getVisible() !== visible) {
            layer.setVisible(visible);
          }
        }
      }
    }
  }

  /**
   * @private
   */
  updateUrl_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    if (!view) {
      return;
    }
    const initial = this.initial_;
    this.initial_ = false;

    const center = view.getCenter();
    const zoom = view.getZoom();
    const rotation = view.getRotation();

    const layers = map.getAllLayers();
    const visibilities = new Array(layers.length);
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      visibilities[i] = layers[i].getVisible() ? '1' : '0';
    }

    const url = new URL(window.location.href);
    const params = url.searchParams;

    this.set_(params, 'x', writeNumber(center[0]));
    this.set_(params, 'y', writeNumber(center[1]));
    this.set_(params, 'z', writeNumber(zoom));
    this.set_(params, 'r', writeNumber(rotation));
    this.set_(params, 'l', visibilities.join(''));

    if (url.href !== window.location.href) {
      if (initial || this.replace_) {
        window.history.replaceState(history.state, '', url);
      } else {
        window.history.pushState(null, '', url);
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Link);


/***/ }),

/***/ "./node_modules/ol/interaction/Modify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Modify.js ***!
  \***********************************************/
/*! exports provided: ModifyEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModifyEvent", function() { return ModifyEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/interaction/Modify
 */





















/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
const CIRCLE_CENTER_INDEX = 0;

/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
const CIRCLE_CIRCUMFERENCE_INDEX = 1;

const tempExtent = [0, 0, 0, 0];
const tempSegment = [];

/**
 * @enum {string}
 */
const ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend',
};

/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {Feature} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
class ModifyEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(type, features, mapBrowserEvent) {
    super(type);

    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */
    this.features = features;

    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */

/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
class Modify extends _Pointer_js__WEBPACK_IMPORTED_MODULE_7__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super(/** @type {import("./Pointer.js").Options} */ (options));

    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {ModifyOnSignature<void>}
     */
    this.un;

    /** @private */
    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_12__["primaryAction"];

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultDeleteCondition_ = function (mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_12__["altKeyOnly"])(mapBrowserEvent) && Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_12__["singleClick"])(mapBrowserEvent);
    };

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.deleteCondition_ = options.deleteCondition
      ? options.deleteCondition
      : this.defaultDeleteCondition_;

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.insertVertexCondition_ = options.insertVertexCondition
      ? options.insertVertexCondition
      : _events_condition_js__WEBPACK_IMPORTED_MODULE_12__["always"];

    /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */
    this.vertexFeature_ = null;

    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */
    this.vertexSegments_ = null;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.lastPixel_ = [0, 0];

    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    this.ignoreNextSingleClick_ = false;

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.featuresBeingModified_ = null;

    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_8__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ =
      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;

    /**
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    this.changingFeature_ = false;

    /**
     * @type {Array}
     * @private
     */
    this.dragSegments_ = [];

    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX,
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true,
    });

    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_.bind(this),
      'LineString': this.writeLineStringGeometry_.bind(this),
      'LinearRing': this.writeLineStringGeometry_.bind(this),
      'Polygon': this.writePolygonGeometry_.bind(this),
      'MultiPoint': this.writeMultiPointGeometry_.bind(this),
      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),
      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),
      'Circle': this.writeCircleGeometry_.bind(this),
      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),
    };

    /**
     * @type {VectorSource}
     * @private
     */
    this.source_ = null;

    /**
     * @type {boolean|import("../layer/BaseVector").default}
     */
    this.hitDetection_ = null;

    /** @type {Collection<Feature>} */
    let features;
    if (options.features) {
      features = options.features;
    } else if (options.source) {
      this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.source_.getFeatures());
      this.source_.addEventListener(
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE,
        this.handleSourceAdd_.bind(this)
      );
      this.source_.addEventListener(
        _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE,
        this.handleSourceRemove_.bind(this)
      );
    }
    if (!features) {
      throw new Error(
        'The modify interaction requires features, a source or a layer'
      );
    }
    if (options.hitDetection) {
      this.hitDetection_ = options.hitDetection;
    }

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.features_ = features;

    this.features_.forEach(this.addFeature_.bind(this));
    this.features_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
      this.handleFeatureAdd_.bind(this)
    );
    this.features_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
      this.handleFeatureRemove_.bind(this)
    );

    /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */
    this.lastPointerEvent_ = null;

    /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */
    this.delta_ = [0, 0];

    /**
     * @private
     */
    this.snapToPointer_ =
      options.snapToPointer === undefined
        ? !this.hitDetection_
        : options.snapToPointer;
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(feature) {
    const geometry = feature.getGeometry();
    if (geometry) {
      const writer = this.SEGMENT_WRITERS_[geometry.getType()];
      if (writer) {
        writer(feature, geometry);
      }
    }
    const map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    feature.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.boundHandleFeatureChange_);
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
      const features = this.featuresBeingModified_.getArray();
      for (let i = 0, ii = segments.length; i < ii; ++i) {
        const segment = segments[i];
        for (let s = 0, ss = segment.length; s < ss; ++s) {
          const feature = segment[s].feature;
          if (feature && !features.includes(feature)) {
            this.featuresBeingModified_.push(feature);
          }
        }
      }
      if (this.featuresBeingModified_.getLength() === 0) {
        this.featuresBeingModified_ = null;
      } else {
        this.dispatchEvent(
          new ModifyEvent(
            ModifyEventType.MODIFYSTART,
            this.featuresBeingModified_,
            evt
          )
        );
      }
    }
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(feature) {
    this.removeFeatureSegmentData_(feature);
    // Remove the vertex feature if the collection of candidate features is empty.
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    feature.removeEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE,
      this.boundHandleFeatureChange_
    );
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(feature) {
    const rBush = this.rBush_;
    /** @type {Array<SegmentData>} */
    const nodesToRemove = [];
    rBush.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function (node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      }
    );
    for (let i = nodesToRemove.length - 1; i >= 0; --i) {
      const nodeToRemove = nodesToRemove[i];
      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }
      rBush.remove(nodeToRemove);
    }
  }

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    super.setActive(active);
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    this.overlay_.setMap(map);
    super.setMap(map);
  }

  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(evt) {
    this.addFeature_(evt.element);
  }

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(evt) {
    if (!this.changingFeature_) {
      const feature = /** @type {Feature} */ (evt.target);
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(evt) {
    this.removeFeature_(evt.element);
  }

  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(feature, geometry) {
    const coordinates = geometry.getCoordinates();

    /** @type {SegmentData} */
    const segmentData = {
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates],
    };

    this.rBush_.insert(geometry.getExtent(), segmentData);
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(feature, geometry) {
    const points = geometry.getCoordinates();
    for (let i = 0, ii = points.length; i < ii; ++i) {
      const coordinates = points[i];

      /** @type {SegmentData} */
      const segmentData = {
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates],
      };

      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(feature, geometry) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      const segment = coordinates.slice(i, i + 2);

      /** @type {SegmentData} */
      const segmentData = {
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment,
      };

      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(segment), segmentData);
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(feature, geometry) {
    const lines = geometry.getCoordinates();
    for (let j = 0, jj = lines.length; j < jj; ++j) {
      const coordinates = lines[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        const segment = coordinates.slice(i, i + 2);

        /** @type {SegmentData} */
        const segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment,
        };

        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(segment), segmentData);
      }
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(feature, geometry) {
    const rings = geometry.getCoordinates();
    for (let j = 0, jj = rings.length; j < jj; ++j) {
      const coordinates = rings[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        const segment = coordinates.slice(i, i + 2);

        /** @type {SegmentData} */
        const segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment,
        };

        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(segment), segmentData);
      }
    }
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(feature, geometry) {
    const polygons = geometry.getCoordinates();
    for (let k = 0, kk = polygons.length; k < kk; ++k) {
      const rings = polygons[k];
      for (let j = 0, jj = rings.length; j < jj; ++j) {
        const coordinates = rings[j];
        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          const segment = coordinates.slice(i, i + 2);

          /** @type {SegmentData} */
          const segmentData = {
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment,
          };

          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  }

  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(feature, geometry) {
    const coordinates = geometry.getCenter();

    /** @type {SegmentData} */
    const centerSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates],
    };

    /** @type {SegmentData} */
    const circumferenceSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates],
    };

    const featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
    let circleGeometry = /** @type {import("../geom/Geometry.js").default} */ (
      geometry
    );
    const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["getUserProjection"])();
    if (userProjection && this.getMap()) {
      const projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry
        .clone()
        .transform(userProjection, projection);
      circleGeometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_17__["fromCircle"])(
        /** @type {import("../geom/Circle.js").default} */ (circleGeometry)
      ).transform(projection, userProjection);
    }
    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  }

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(feature, geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0; i < geometries.length; ++i) {
      const geometry = geometries[i];
      const writer = this.SEGMENT_WRITERS_[geometry.getType()];
      writer(feature, geometry);
    }
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(coordinates, features, geometries) {
    let vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_4__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      const geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }
    vertexFeature.set('features', features);
    vertexFeature.set('geometries', geometries);
    return vertexFeature;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;

    let handled;
    if (
      !mapBrowserEvent.map.getView().getInteracting() &&
      mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERMOVE &&
      !this.handlingDownUpSequence
    ) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (
        mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].SINGLECLICK ||
        !this.ignoreNextSingleClick_
      ) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return super.handleEvent(mapBrowserEvent) && !handled;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);

    const vertex = [
      evt.coordinate[0] + this.delta_[0],
      evt.coordinate[1] + this.delta_[1],
    ];
    const features = [];
    const geometries = [];
    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      const dragSegment = this.dragSegments_[i];
      const segmentData = dragSegment[0];
      const feature = segmentData.feature;
      if (!features.includes(feature)) {
        features.push(feature);
      }
      const geometry = segmentData.geometry;
      if (!geometries.includes(geometry)) {
        geometries.push(geometry);
      }
      const depth = segmentData.depth;
      let coordinates;
      const segment = segmentData.segment;
      const index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case 'Point':
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case 'MultiPoint':
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;
        case 'LineString':
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'MultiLineString':
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'Polygon':
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'MultiPolygon':
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case 'Circle':
          segment[0] = vertex;
          segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            const projection = evt.map.getView().getProjection();
            let radius = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["distance"])(
              Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(geometry.getCenter(), projection),
              Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(vertex, projection)
            );
            const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["getUserProjection"])();
            if (userProjection) {
              const circleGeometry = geometry
                .clone()
                .transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry
                .transform(projection, userProjection)
                .getRadius();
            }
            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }
          break;
        default:
        // pass
      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }
    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    const pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    const vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      const projection = evt.map.getView().getProjection();
      const insertVertices = [];
      const vertex = vertexFeature.getGeometry().getCoordinates();
      const vertexExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])([vertex]);
      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      const componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        const segmentDataMatch = segmentDataMatches[i];
        const segment = segmentDataMatch.segment;
        let uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(segmentDataMatch.geometry);
        const depth = segmentDataMatch.depth;
        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }
        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }

        if (
          segmentDataMatch.geometry.getType() === 'Circle' &&
          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX
        ) {
          const closestVertex = closestOnSegmentData(
            pixelCoordinate,
            segmentDataMatch,
            projection
          );
          if (
            Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(closestVertex, vertex) &&
            !componentSegments[uid][0]
          ) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }
          continue;
        }

        if (
          Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(segment[0], vertex) &&
          !componentSegments[uid][0]
        ) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }

        if (
          Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(segment[1], vertex) &&
          !componentSegments[uid][1]
        ) {
          if (
            componentSegments[uid][0] &&
            componentSegments[uid][0].index === 0
          ) {
            let coordinates = segmentDataMatch.geometry.getCoordinates();
            switch (segmentDataMatch.geometry.getType()) {
              // prevent dragging closed linestrings by the connecting node
              case 'LineString':
              case 'MultiLineString':
                continue;
              // if dragging the first vertex of a polygon, ensure the other segment
              // belongs to the closing vertex of the linear ring
              case 'MultiPolygon':
                coordinates = coordinates[depth[1]];
              /* falls through */
              case 'Polygon':
                if (
                  segmentDataMatch.index !==
                  coordinates[depth[0]].length - 2
                ) {
                  continue;
                }
                break;
              default:
              // pass
            }
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }

        if (
          Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(segment) in this.vertexSegments_ &&
          !componentSegments[uid][0] &&
          !componentSegments[uid][1] &&
          this.insertVertexCondition_(evt)
        ) {
          insertVertices.push(segmentDataMatch);
        }
      }

      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }

      for (let j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_(insertVertices[j], vertex);
      }
    }
    return !!this.vertexFeature_;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(evt) {
    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {
      const segmentData = this.dragSegments_[i][0];
      const geometry = segmentData.geometry;
      if (geometry.getType() === 'Circle') {
        // Update a circle object in the R* bush:
        const coordinates = geometry.getCenter();
        const centerSegmentData = segmentData.featureSegments[0];
        const circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
        let circleGeometry = geometry;
        const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["getUserProjection"])();
        if (userProjection) {
          const projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry
            .clone()
            .transform(userProjection, projection);
          circleGeometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_17__["fromCircle"])(circleGeometry).transform(
            projection,
            userProjection
          );
        }
        this.rBush_.update(
          circleGeometry.getExtent(),
          circumferenceSegmentData
        );
      } else {
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(segmentData.segment), segmentData);
      }
    }
    if (this.featuresBeingModified_) {
      this.dispatchEvent(
        new ModifyEvent(
          ModifyEventType.MODIFYEND,
          this.featuresBeingModified_,
          evt
        )
      );
      this.featuresBeingModified_ = null;
    }
    return false;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(pixel, map, coordinate) {
    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);
    const projection = map.getView().getProjection();
    const sortByDistance = function (a, b) {
      return (
        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -
        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)
      );
    };

    /** @type {Array<SegmentData>|undefined} */
    let nodes;
    /** @type {Point|undefined} */
    let hitPointGeometry;
    if (this.hitDetection_) {
      const layerFilter =
        typeof this.hitDetection_ === 'object'
          ? (layer) => layer === this.hitDetection_
          : undefined;
      map.forEachFeatureAtPixel(
        pixel,
        (feature, layer, geometry) => {
          if (geometry) {
            geometry = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](
              Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["toUserCoordinate"])(geometry.getCoordinates(), projection)
            );
          }
          const geom = geometry || feature.getGeometry();
          if (
            geom.getType() === 'Point' &&
            feature instanceof _Feature_js__WEBPACK_IMPORTED_MODULE_4__["default"] &&
            this.features_.getArray().includes(feature)
          ) {
            hitPointGeometry = /** @type {Point} */ (geom);
            const coordinate = /** @type {Point} */ (feature.getGeometry())
              .getFlatCoordinates()
              .slice(0, 2);
            nodes = [
              {
                feature,
                geometry: hitPointGeometry,
                segment: [coordinate, coordinate],
              },
            ];
          }
          return true;
        },
        {layerFilter}
      );
    }
    if (!nodes) {
      const viewExtent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserExtent"])(
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["createOrUpdateFromCoordinate"])(pixelCoordinate, tempExtent),
        projection
      );
      const buffer = map.getView().getResolution() * this.pixelTolerance_;
      const box = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["toUserExtent"])(
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["buffer"])(viewExtent, buffer, tempExtent),
        projection
      );
      nodes = this.rBush_.getInExtent(box);
    }

    if (nodes && nodes.length > 0) {
      const node = nodes.sort(sortByDistance)[0];
      const closestSegment = node.segment;
      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      const vertexPixel = map.getPixelFromCoordinate(vertex);
      let dist = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["distance"])(pixel, vertexPixel);
      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        const vertexSegments = {};
        vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(closestSegment)] = true;

        if (!this.snapToPointer_) {
          this.delta_[0] = vertex[0] - pixelCoordinate[0];
          this.delta_[1] = vertex[1] - pixelCoordinate[1];
        }
        if (
          node.geometry.getType() === 'Circle' &&
          node.index === CIRCLE_CIRCUMFERENCE_INDEX
        ) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(
            vertex,
            [node.feature],
            [node.geometry]
          );
        } else {
          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          const squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["squaredDistance"])(vertexPixel, pixel1);
          const squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["squaredDistance"])(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex =
              squaredDist1 > squaredDist2
                ? closestSegment[1]
                : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(
            vertex,
            [node.feature],
            [node.geometry]
          );
          const geometries = {};
          geometries[Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(node.geometry)] = true;
          for (let i = 1, ii = nodes.length; i < ii; ++i) {
            const segment = nodes[i].segment;
            if (
              (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(closestSegment[0], segment[0]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(closestSegment[1], segment[1])) ||
              (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(closestSegment[0], segment[1]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["equals"])(closestSegment[1], segment[0]))
            ) {
              const geometryUid = Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(nodes[i].geometry);
              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(segment)] = true;
              }
            } else {
              break;
            }
          }
        }

        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  }

  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(segmentData, vertex) {
    const segment = segmentData.segment;
    const feature = segmentData.feature;
    const geometry = segmentData.geometry;
    const depth = segmentData.depth;
    const index = segmentData.index;
    let coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case 'MultiLineString':
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'Polygon':
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'MultiPolygon':
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case 'LineString':
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    const rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);

    /** @type {SegmentData} */
    const newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index,
    };

    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);

    /** @type {SegmentData} */
    const newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1,
    };

    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  }

  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (
      this.lastPointerEvent_ &&
      this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDRAG
    ) {
      const evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      const removed = this.removeVertex_();
      if (this.featuresBeingModified_) {
        this.dispatchEvent(
          new ModifyEvent(
            ModifyEventType.MODIFYEND,
            this.featuresBeingModified_,
            evt
          )
        );
      }

      this.featuresBeingModified_ = null;
      return removed;
    }
    return false;
  }

  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const dragSegments = this.dragSegments_;
    const segmentsByFeature = {};
    let deleted = false;
    let component, coordinates, dragSegment, geometry, i, index, left;
    let newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_19__["getUid"])(segmentData.feature);
      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case 'MultiLineString':
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case 'LineString':
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case 'MultiPolygon':
          component = component[segmentData.depth[1]];
        /* falls through */
        case 'Polygon':
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
        // pass
      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        const segments = [];
        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== undefined && right !== undefined) {
          /** @type {SegmentData} */
          const newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments,
          };

          this.rBush_.insert(
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["boundingExtent"])(newSegmentData.segment),
            newSegmentData
          );
        }
        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }
    }
    return deleted;
  }

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  }

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(
      geometry.getExtent(),
      function (segmentDataMatch) {
        if (
          segmentDataMatch.geometry === geometry &&
          (depth === undefined ||
            segmentDataMatch.depth === undefined ||
            Object(_array_js__WEBPACK_IMPORTED_MODULE_16__["equals"])(segmentDataMatch.depth, depth)) &&
          segmentDataMatch.index > index
        ) {
          segmentDataMatch.index += delta;
        }
      }
    );
  }
}

/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
  return a.index - b.index;
}

/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */
function projectedDistanceToSegmentDataSquared(
  pointCoordinates,
  segmentData,
  projection
) {
  const geometry = segmentData.geometry;

  if (geometry.getType() === 'Circle') {
    let circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
      geometry
    );

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["getUserProjection"])();
      if (userProjection) {
        circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
          circleGeometry.clone().transform(userProjection, projection)
        );
      }
      const distanceToCenterSquared = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["squaredDistance"])(
        circleGeometry.getCenter(),
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(pointCoordinates, projection)
      );
      const distanceToCircumference =
        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }

  const coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(pointCoordinates, projection);
  tempSegment[0] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(segmentData.segment[0], projection);
  tempSegment[1] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(segmentData.segment[1], projection);
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["squaredDistanceToSegment"])(coordinate, tempSegment);
}

/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  const geometry = segmentData.geometry;

  if (
    geometry.getType() === 'Circle' &&
    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX
  ) {
    let circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
      geometry
    );
    const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["getUserProjection"])();
    if (userProjection) {
      circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
        circleGeometry.clone().transform(userProjection, projection)
      );
    }
    return Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["toUserCoordinate"])(
      circleGeometry.getClosestPoint(
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(pointCoordinates, projection)
      ),
      projection
    );
  }
  const coordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(pointCoordinates, projection);
  tempSegment[0] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(segmentData.segment[0], projection);
  tempSegment[1] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["fromUserCoordinate"])(segmentData.segment[1], projection);
  return Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["toUserCoordinate"])(
    Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_14__["closestOnSegment"])(coordinate, tempSegment),
    projection
  );
}

/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  const style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_15__["createEditingStyle"])();
  return function (feature, resolution) {
    return style['Point'];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Modify);


/***/ }),

/***/ "./node_modules/ol/interaction/Select.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Select.js ***!
  \***********************************************/
/*! exports provided: SelectEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectEvent", function() { return SelectEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/Select
 */













/**
 * @enum {string}
 */
const SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select',
};

/**
 * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").default, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {Collection<Feature>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature~Feature} and an
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */
class SelectEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(type, selected, deselected, mapBrowserEvent) {
    super(type);

    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.selected = selected;

    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.deselected = deselected;

    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object<number, import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */
const originalFeatureStyles = {};

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */

/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */
class Select extends _Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {SelectOnSignature<void>}
     */
    this.un;

    options = options ? options : {};

    /**
     * @private
     */
    this.boundAddFeature_ = this.addFeature_.bind(this);

    /**
     * @private
     */
    this.boundRemoveFeature_ = this.removeFeature_.bind(this);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["singleClick"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.addCondition_ = options.addCondition ? options.addCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.removeCondition_ = options.removeCondition
      ? options.removeCondition
      : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.toggleCondition_ = options.toggleCondition
      ? options.toggleCondition
      : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["shiftKeyOnly"];

    /**
     * @private
     * @type {boolean}
     */
    this.multi_ = options.multi ? options.multi : false;

    /**
     * @private
     * @type {FilterFunction}
     */
    this.filter_ = options.filter ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    /**
     * @private
     * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */
    this.style_ =
      options.style !== undefined ? options.style : getDefaultStyleFunction();

    /**
     * @private
     * @type {Collection<Feature>}
     */
    this.features_ = options.features || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

    /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */
    let layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        const layers = options.layers;
        layerFilter = function (layer) {
          return layers.includes(layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */
    this.featureLayerAssociation_ = {};
  }

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(feature, layer) {
    this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature)] = layer;
  }

  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }

  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }

  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(feature) {
    return /** @type {import('../layer/Vector.js').default} */ (
      this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature)]
    );
  }

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  }

  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    const currentMap = this.getMap();
    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }
    super.setMap(map);
    if (map) {
      this.features_.addEventListener(
        _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
        this.boundAddFeature_
      );
      this.features_.addEventListener(
        _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
        this.boundRemoveFeature_
      );

      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(
        _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
        this.boundAddFeature_
      );
      this.features_.removeEventListener(
        _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
        this.boundRemoveFeature_
      );
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(evt) {
    const feature = evt.element;
    if (this.style_) {
      this.applySelectedStyle_(feature);
    }
    if (!this.getLayer(feature)) {
      const layer = /** @type {VectorLayer} */ (
        this.getMap()
          .getAllLayers()
          .find(function (layer) {
            if (
              layer instanceof _layer_Vector_js__WEBPACK_IMPORTED_MODULE_5__["default"] &&
              layer.getSource() &&
              layer.getSource().hasFeature(feature)
            ) {
              return layer;
            }
          })
      );
      if (layer) {
        this.addFeatureLayerAssociation_(feature, layer);
      }
    }
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(evt) {
    if (this.style_) {
      this.restorePreviousStyle_(evt.element);
    }
  }

  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }

  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(feature) {
    const key = Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature);
    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }
    feature.setStyle(this.style_);
  }

  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(feature) {
    const interactions = this.getMap().getInteractions().getArray();
    for (let i = interactions.length - 1; i >= 0; --i) {
      const interaction = interactions[i];
      if (
        interaction !== this &&
        interaction instanceof Select &&
        interaction.getStyle() &&
        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1
      ) {
        feature.setStyle(interaction.getStyle());
        return;
      }
    }

    const key = Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature);
    feature.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  }

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(feature) {
    delete this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature)];
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const add = this.addCondition_(mapBrowserEvent);
    const remove = this.removeCondition_(mapBrowserEvent);
    const toggle = this.toggleCondition_(mapBrowserEvent);
    const set = !add && !remove && !toggle;
    const map = mapBrowserEvent.map;
    const features = this.getFeatures();

    /**
     * @type {Array<Feature>}
     */
    const deselected = [];

    /**
     * @type {Array<Feature>}
     */
    const selected = [];

    if (set) {
      // Replace the currently selected feature(s) with the feature(s) at the
      // pixel, or clear the selected feature(s) if there is no feature at
      // the pixel.
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["clear"])(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(
        mapBrowserEvent.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (feature, layer) => {
          if (!(feature instanceof _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]) || !this.filter_(feature, layer)) {
            return;
          }
          this.addFeatureLayerAssociation_(feature, layer);
          selected.push(feature);
          return !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_,
        }
      );
      for (let i = features.getLength() - 1; i >= 0; --i) {
        const feature = features.item(i);
        const index = selected.indexOf(feature);
        if (index > -1) {
          // feature is already selected
          selected.splice(index, 1);
        } else {
          features.remove(feature);
          deselected.push(feature);
        }
      }
      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      // Modify the currently selected feature(s).
      map.forEachFeatureAtPixel(
        mapBrowserEvent.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (feature, layer) => {
          if (!(feature instanceof _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"]) || !this.filter_(feature, layer)) {
            return;
          }
          if ((add || toggle) && !features.getArray().includes(feature)) {
            this.addFeatureLayerAssociation_(feature, layer);
            selected.push(feature);
          } else if (
            (remove || toggle) &&
            features.getArray().includes(feature)
          ) {
            deselected.push(feature);
            this.removeFeatureLayerAssociation_(feature);
          }
          return !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_,
        }
      );
      for (let j = deselected.length - 1; j >= 0; --j) {
        features.remove(deselected[j]);
      }
      features.extend(selected);
    }
    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(
        new SelectEvent(
          SelectEventType.SELECT,
          selected,
          deselected,
          mapBrowserEvent
        )
      );
    }
    return true;
  }
}

/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  const styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_8__["createEditingStyle"])();
  Object(_array_js__WEBPACK_IMPORTED_MODULE_9__["extend"])(styles['Polygon'], styles['LineString']);
  Object(_array_js__WEBPACK_IMPORTED_MODULE_9__["extend"])(styles['GeometryCollection'], styles['LineString']);

  return function (feature) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Select);


/***/ }),

/***/ "./node_modules/ol/interaction/Snap.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Snap.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/interaction/Snap
 */













/**
 * @typedef {Object} Result
 * @property {import("../coordinate.js").Coordinate|null} vertex Vertex.
 * @property {import("../pixel.js").Pixel|null} vertexPixel VertexPixel.
 */

/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>} segment Segment.
 */

/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */

/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
 * @return {import("../Feature.js").default|null} Feature.
 */
function getFeatureFromEvent(evt) {
  if (
    /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature
  ) {
    return /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt)
      .feature;
  }
  if (
    /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ (
      evt
    ).element
  ) {
    return /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ (
      evt
    ).element;
  }
  return null;
}

const tempSegment = [];

/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap.js';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @api
 */
class Snap extends _Pointer_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"];
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_5__["FALSE"];
    }

    super(pointerOptions);

    /**
     * @type {import("../source/Vector.js").default|null}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * @private
     * @type {boolean}
     */
    this.vertex_ = options.vertex !== undefined ? options.vertex : true;

    /**
     * @private
     * @type {boolean}
     */
    this.edge_ = options.edge !== undefined ? options.edge : true;

    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>|null}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */
    this.featuresListenerKeys_ = [];

    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */
    this.featureChangeListenerKeys_ = {};

    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */
    this.indexedFeaturesExtents_ = {};

    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */
    this.pendingFeatures_ = {};

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ =
      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;

    /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_3__["default"]();

    /**
     * @const
     * @private
     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import("../geom/Geometry.js").default): void>}
     */
    this.GEOMETRY_SEGMENTERS_ = {
      'Point': this.segmentPointGeometry_.bind(this),
      'LineString': this.segmentLineStringGeometry_.bind(this),
      'LinearRing': this.segmentLineStringGeometry_.bind(this),
      'Polygon': this.segmentPolygonGeometry_.bind(this),
      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),
      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),
      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),
      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),
      'Circle': this.segmentCircleGeometry_.bind(this),
    };
  }

  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  addFeature(feature, register) {
    register = register !== undefined ? register : true;
    const feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature);
    const geometry = feature.getGeometry();
    if (geometry) {
      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];
      if (segmenter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])()
        );
        const segments =
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);
        segmenter(segments, geometry);
        if (segments.length === 1) {
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segments[0]), {
            feature: feature,
            segment: segments[0],
          });
        } else if (segments.length > 1) {
          const extents = segments.map((s) => Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(s));
          const segmentsData = segments.map((segment) => ({
            feature: feature,
            segment: segment,
          }));
          this.rBush_.load(extents, segmentsData);
        }
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["listen"])(
        feature,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE,
        this.handleFeatureChange_,
        this
      );
    }
  }

  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  getFeatures_() {
    /** @type {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} */
    let features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return features;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(evt) {
    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
    if (result) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }
    return super.handleEvent(evt);
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureAdd_(evt) {
    const feature = getFeatureFromEvent(evt);
    if (feature) {
      this.addFeature(feature);
    }
  }

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureRemove_(evt) {
    const feature = getFeatureFromEvent(evt);
    if (feature) {
      this.removeFeature(feature);
    }
  }

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(evt) {
    const feature = /** @type {import("../Feature.js").default} */ (evt.target);
    if (this.handlingDownUpSequence) {
      const uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature);
      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(evt) {
    const featuresToUpdate = Object.values(this.pendingFeatures_);
    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }
    return false;
  }

  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  removeFeature(feature, unlisten) {
    const unregister = unlisten !== undefined ? unlisten : true;
    const feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_10__["getUid"])(feature);
    const extent = this.indexedFeaturesExtents_[feature_uid];
    if (extent) {
      const rBush = this.rBush_;
      const nodesToRemove = [];
      rBush.forEachInExtent(extent, function (node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
      for (let i = nodesToRemove.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove[i]);
      }
    }

    if (unregister) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["unlistenByKey"])(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    const currentMap = this.getMap();
    const keys = this.featuresListenerKeys_;
    const features = /** @type {Array<import("../Feature.js").default>} */ (
      this.getFeatures_()
    );

    if (currentMap) {
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_11__["unlistenByKey"]);
      keys.length = 0;
      this.rBush_.clear();
      Object.values(this.featureChangeListenerKeys_).forEach(_events_js__WEBPACK_IMPORTED_MODULE_11__["unlistenByKey"]);
      this.featureChangeListenerKeys_ = {};
    }
    super.setMap(map);

    if (map) {
      if (this.features_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["listen"])(
            this.features_,
            _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].ADD,
            this.handleFeatureAdd_,
            this
          ),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["listen"])(
            this.features_,
            _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].REMOVE,
            this.handleFeatureRemove_,
            this
          )
        );
      } else if (this.source_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["listen"])(
            this.source_,
            _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ADDFEATURE,
            this.handleFeatureAdd_,
            this
          ),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_11__["listen"])(
            this.source_,
            _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].REMOVEFEATURE,
            this.handleFeatureRemove_,
            this
          )
        );
      }
      features.forEach((feature) => this.addFeature(feature));
    }
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */
  snapTo(pixel, pixelCoordinate, map) {
    const projection = map.getView().getProjection();
    const projectedCoordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["fromUserCoordinate"])(pixelCoordinate, projection);

    const box = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["toUserExtent"])(
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["buffer"])(
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])([projectedCoordinate]),
        map.getView().getResolution() * this.pixelTolerance_
      ),
      projection
    );

    const segments = this.rBush_.getInExtent(box);

    const segmentsLength = segments.length;
    if (segmentsLength === 0) {
      return null;
    }

    let closestVertex;
    let minSquaredDistance = Infinity;

    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;
    const getResult = () => {
      if (closestVertex) {
        const vertexPixel = map.getPixelFromCoordinate(closestVertex);
        const squaredPixelDistance = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(pixel, vertexPixel);
        if (squaredPixelDistance <= squaredPixelTolerance) {
          return {
            vertex: closestVertex,
            vertexPixel: [
              Math.round(vertexPixel[0]),
              Math.round(vertexPixel[1]),
            ],
          };
        }
      }
      return null;
    };

    if (this.vertex_) {
      for (let i = 0; i < segmentsLength; ++i) {
        const segmentData = segments[i];
        if (segmentData.feature.getGeometry().getType() !== 'Circle') {
          segmentData.segment.forEach((vertex) => {
            const tempVertexCoord = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["fromUserCoordinate"])(vertex, projection);
            const delta = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(projectedCoordinate, tempVertexCoord);
            if (delta < minSquaredDistance) {
              closestVertex = vertex;
              minSquaredDistance = delta;
            }
          });
        }
      }
      const result = getResult();
      if (result) {
        return result;
      }
    }

    if (this.edge_) {
      for (let i = 0; i < segmentsLength; ++i) {
        let vertex = null;
        const segmentData = segments[i];
        if (segmentData.feature.getGeometry().getType() === 'Circle') {
          let circleGeometry = segmentData.feature.getGeometry();
          const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["getUserProjection"])();
          if (userProjection) {
            circleGeometry = circleGeometry
              .clone()
              .transform(userProjection, projection);
          }
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["closestOnCircle"])(
            projectedCoordinate,
            /** @type {import("../geom/Circle.js").default} */ (circleGeometry)
          );
        } else {
          const [segmentStart, segmentEnd] = segmentData.segment;
          // points have only one coordinate
          if (segmentEnd) {
            tempSegment[0] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["fromUserCoordinate"])(segmentStart, projection);
            tempSegment[1] = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["fromUserCoordinate"])(segmentEnd, projection);
            vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["closestOnSegment"])(projectedCoordinate, tempSegment);
          }
        }
        if (vertex) {
          const delta = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(projectedCoordinate, vertex);
          if (delta < minSquaredDistance) {
            closestVertex = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["toUserCoordinate"])(vertex, projection);
            minSquaredDistance = delta;
          }
        }
      }

      const result = getResult();
      if (result) {
        return result;
      }
    }

    return null;
  }

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  updateFeature_(feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  segmentCircleGeometry_(segments, geometry) {
    const projection = this.getMap().getView().getProjection();
    let circleGeometry = geometry;
    const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["getUserProjection"])();
    if (userProjection) {
      circleGeometry = /** @type {import("../geom/Circle.js").default} */ (
        circleGeometry.clone().transform(userProjection, projection)
      );
    }
    const polygon = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["fromCircle"])(circleGeometry);
    if (userProjection) {
      polygon.transform(projection, userProjection);
    }
    const coordinates = polygon.getCoordinates()[0];
    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segments.push(coordinates.slice(i, i + 2));
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  segmentGeometryCollectionGeometry_(segments, geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0; i < geometries.length; ++i) {
      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];
      if (segmenter) {
        segmenter(segments, geometries[i]);
      }
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  segmentLineStringGeometry_(segments, geometry) {
    const coordinates = geometry.getCoordinates();
    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segments.push(coordinates.slice(i, i + 2));
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  segmentMultiLineStringGeometry_(segments, geometry) {
    const lines = geometry.getCoordinates();
    for (let j = 0, jj = lines.length; j < jj; ++j) {
      const coordinates = lines[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        segments.push(coordinates.slice(i, i + 2));
      }
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPointGeometry_(segments, geometry) {
    geometry.getCoordinates().forEach((point) => {
      segments.push([point]);
    });
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPolygonGeometry_(segments, geometry) {
    const polygons = geometry.getCoordinates();
    for (let k = 0, kk = polygons.length; k < kk; ++k) {
      const rings = polygons[k];
      for (let j = 0, jj = rings.length; j < jj; ++j) {
        const coordinates = rings[j];
        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          segments.push(coordinates.slice(i, i + 2));
        }
      }
    }
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  segmentPointGeometry_(segments, geometry) {
    segments.push([geometry.getCoordinates()]);
  }

  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  segmentPolygonGeometry_(segments, geometry) {
    const rings = geometry.getCoordinates();
    for (let j = 0, jj = rings.length; j < jj; ++j) {
      const coordinates = rings[j];
      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        segments.push(coordinates.slice(i, i + 2));
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Snap);


/***/ }),

/***/ "./node_modules/ol/interaction/Translate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/Translate.js ***!
  \**************************************************/
/*! exports provided: TranslateEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TranslateEvent", function() { return TranslateEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/interaction/Translate
 */









/**
 * @enum {string}
 */
const TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend',
};

/**
 * A function that takes an {@link module:ol/Feature~Feature} or
 * {@link module:ol/render/Feature~RenderFeature} and an
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(Feature, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.always}.
 * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * Not used if `features` is provided.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature~Feature} and an
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * translated or `false` otherwise. Not used if `features` is provided.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */
class TranslateEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<Feature>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */
  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {
    super(type);

    /**
     * The features being translated.
     * @type {Collection<Feature>}
     * @api
     */
    this.features = features;

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * The coordinate of the start position before translation started.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.startCoordinate = startCoordinate;

    /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature
 */

/**
 * @classdesc
 * Interaction for translating (moving) features.
 * If you want to translate multiple features in a single action (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.
 *
 * @fires TranslateEvent
 * @api
 */
class Translate extends _Pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(/** @type {import("./Pointer.js").Options} */ (options));

    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {TranslateOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {TranslateOnSignature<void>}
     */
    this.un;

    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.lastCoordinate_ = null;

    /**
     * The start position before translation started.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.startCoordinate_ = null;

    /**
     * @type {Collection<Feature>|null}
     * @private
     */
    this.features_ = options.features !== undefined ? options.features : null;

    /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */
    let layerFilter;
    if (options.layers && !this.features_) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        const layers = options.layers;
        layerFilter = function (layer) {
          return layers.includes(layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * @private
     * @type {FilterFunction}
     */
    this.filter_ = options.filter && !this.features_ ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"];

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_6__["always"];

    /**
     * @type {Feature}
     * @private
     */
    this.lastFeature_ = null;

    this.addChangeListener(
      _Property_js__WEBPACK_IMPORTED_MODULE_3__["default"].ACTIVE,
      this.handleActiveChanged_
    );
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(event) {
    if (!event.originalEvent || !this.condition_(event)) {
      return false;
    }
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = event.coordinate;
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);

      const features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATESTART,
          features,
          event.coordinate,
          this.startCoordinate_,
          event
        )
      );
      return true;
    }
    return false;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);

      const features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATEEND,
          features,
          event.coordinate,
          this.startCoordinate_,
          event
        )
      );
      // cleanup
      this.startCoordinate_ = null;
      return true;
    }
    return false;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleDragEvent(event) {
    if (this.lastCoordinate_) {
      const newCoordinate = event.coordinate;
      const projection = event.map.getView().getProjection();

      const newViewCoordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["fromUserCoordinate"])(newCoordinate, projection);
      const lastViewCoordinate = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["fromUserCoordinate"])(
        this.lastCoordinate_,
        projection
      );
      const deltaX = newViewCoordinate[0] - lastViewCoordinate[0];
      const deltaY = newViewCoordinate[1] - lastViewCoordinate[1];

      const features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);
      const userProjection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["getUserProjection"])();

      features.forEach(function (feature) {
        const geom = feature.getGeometry();
        if (userProjection) {
          geom.transform(userProjection, projection);
          geom.translate(deltaX, deltaY);
          geom.transform(projection, userProjection);
        } else {
          geom.translate(deltaX, deltaY);
        }
        feature.setGeometry(geom);
      });

      this.lastCoordinate_ = newCoordinate;

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATING,
          features,
          newCoordinate,
          this.startCoordinate_,
          event
        )
      );
    }
  }

  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleMoveEvent(event) {
    const elem = event.map.getViewport();

    // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction
    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
    } else {
      elem.classList.remove('ol-grab', 'ol-grabbing');
    }
  }

  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../Map.js").default} map Map to test the intersection on.
   * @return {Feature} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  featuresAtPixel_(pixel, map) {
    return map.forEachFeatureAtPixel(
      pixel,
      (feature, layer) => {
        if (!(feature instanceof _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]) || !this.filter_(feature, layer)) {
          return undefined;
        }
        if (this.features_ && !this.features_.getArray().includes(feature)) {
          return undefined;
        }
        return feature;
      },
      {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_,
      }
    );
  }

  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(map) {
    const oldMap = this.getMap();
    super.setMap(map);
    this.updateState_(oldMap);
  }

  /**
   * @private
   */
  handleActiveChanged_() {
    this.updateState_(null);
  }

  /**
   * @param {import("../Map.js").default} oldMap Old map.
   * @private
   */
  updateState_(oldMap) {
    let map = this.getMap();
    const active = this.getActive();
    if (!map || !active) {
      map = map || oldMap;
      if (map) {
        const elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Translate);


/***/ }),

/***/ "./node_modules/ol/ol.css":
/*!********************************!*\
  !*** ./node_modules/ol/ol.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../css-loader/dist/cjs.js??ref--7-oneOf-3-1!../postcss-loader/src??ref--7-oneOf-3-2!./ol.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/ol/ol.css");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("1b8cf993", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/ol/xml.js":
/*!********************************!*\
  !*** ./node_modules/ol/xml.js ***!
  \********************************/
/*! exports provided: XML_SCHEMA_INSTANCE_URI, createElementNS, getAllTextContent, getAllTextContent_, isDocument, getAttributeNS, parse, makeArrayExtender, makeArrayPusher, makeReplacer, makeObjectPropertyPusher, makeObjectPropertySetter, makeChildAppender, makeArraySerializer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, makeSequence, makeStructureNS, parseNode, pushParseAndPop, serialize, pushSerializeAndPop, registerXMLSerializer, getXMLSerializer, registerDocument, getDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XML_SCHEMA_INSTANCE_URI", function() { return XML_SCHEMA_INSTANCE_URI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElementNS", function() { return createElementNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllTextContent", function() { return getAllTextContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllTextContent_", function() { return getAllTextContent_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDocument", function() { return isDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAttributeNS", function() { return getAttributeNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeArrayExtender", function() { return makeArrayExtender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeArrayPusher", function() { return makeArrayPusher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeReplacer", function() { return makeReplacer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeObjectPropertyPusher", function() { return makeObjectPropertyPusher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeObjectPropertySetter", function() { return makeObjectPropertySetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeChildAppender", function() { return makeChildAppender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeArraySerializer", function() { return makeArraySerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeSimpleNodeFactory", function() { return makeSimpleNodeFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBJECT_PROPERTY_NODE_FACTORY", function() { return OBJECT_PROPERTY_NODE_FACTORY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeSequence", function() { return makeSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeStructureNS", function() { return makeStructureNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseNode", function() { return parseNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushParseAndPop", function() { return pushParseAndPop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialize", function() { return serialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushSerializeAndPop", function() { return pushSerializeAndPop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerXMLSerializer", function() { return registerXMLSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getXMLSerializer", function() { return getXMLSerializer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerDocument", function() { return registerDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDocument", function() { return getDocument; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/xml
 */


/**
 * When using {@link module:ol/xml.makeChildAppender} or
 * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs
 * to have this structure.
 * @typedef {Object} NodeStackItem
 * @property {Element} node Node.
 */

/**
 * @typedef {function(Element, Array<*>): void} Parser
 */

/**
 * @typedef {function(Element, *, Array<*>): void} Serializer
 */

/**
 * @type {string}
 */
const XML_SCHEMA_INSTANCE_URI =
  'http://www.w3.org/2001/XMLSchema-instance';

/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
function getAllTextContent(node, normalizeWhitespace) {
  return getAllTextContent_(node, normalizeWhitespace, []).join('');
}

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
  if (
    node.nodeType == Node.CDATA_SECTION_NODE ||
    node.nodeType == Node.TEXT_NODE
  ) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    let n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
}

/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */
function isDocument(object) {
  return 'documentElement' in object;
}

/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */
function getAttributeNS(node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
}

/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */
function parse(xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
}

/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeArrayExtender(valueReader, thisArg) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      const value = valueReader.call(
        thisArg !== undefined ? thisArg : this,
        node,
        objectStack
      );
      if (value !== undefined) {
        const array = /** @type {Array<*>} */ (
          objectStack[objectStack.length - 1]
        );
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(array, value);
      }
    }
  );
}

/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeArrayPusher(valueReader, thisArg) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      const value = valueReader.call(
        thisArg !== undefined ? thisArg : this,
        node,
        objectStack
      );
      if (value !== undefined) {
        const array = /** @type {Array<*>} */ (
          objectStack[objectStack.length - 1]
        );
        array.push(value);
      }
    }
  );
}

/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeReplacer(valueReader, thisArg) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      const value = valueReader.call(
        thisArg !== undefined ? thisArg : this,
        node,
        objectStack
      );
      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
}

/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeObjectPropertyPusher(valueReader, property, thisArg) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      const value = valueReader.call(
        thisArg !== undefined ? thisArg : this,
        node,
        objectStack
      );
      if (value !== undefined) {
        const object = /** @type {!Object} */ (
          objectStack[objectStack.length - 1]
        );
        const name = property !== undefined ? property : node.localName;
        let array;
        if (name in object) {
          array = object[name];
        } else {
          array = [];
          object[name] = array;
        }
        array.push(value);
      }
    }
  );
}

/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */
function makeObjectPropertySetter(valueReader, property, thisArg) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      const value = valueReader.call(
        thisArg !== undefined ? thisArg : this,
        node,
        objectStack
      );
      if (value !== undefined) {
        const object = /** @type {!Object} */ (
          objectStack[objectStack.length - 1]
        );
        const name = property !== undefined ? property : node.localName;
        object[name] = value;
      }
    }
  );
}

/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
function makeChildAppender(nodeWriter, thisArg) {
  return function (node, value, objectStack) {
    nodeWriter.call(
      thisArg !== undefined ? thisArg : this,
      node,
      value,
      objectStack
    );
    const parent = /** @type {NodeStackItem} */ (
      objectStack[objectStack.length - 1]
    );
    const parentNode = parent.node;
    parentNode.appendChild(node);
  };
}

/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */
function makeArraySerializer(nodeWriter, thisArg) {
  let serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      const serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node.localName);
    }
    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}

/**
 * Create a node factory which can use the `keys` passed to
 * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [fixedNodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */
function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, newNodeName) {
      const context = /** @type {NodeStackItem} */ (
        objectStack[objectStack.length - 1]
      );
      const node = context.node;
      let nodeName = fixedNodeName;
      if (nodeName === undefined) {
        nodeName = newNodeName;
      }

      const namespaceURI =
        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;
      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));
    }
  );
}

/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array<*>, string=): (Node|undefined)}
 */
const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();

/**
 * Create an array of `values` to be used with {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */
function makeSequence(object, orderedKeys) {
  const length = orderedKeys.length;
  const sequence = new Array(length);
  for (let i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
}

/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */
function makeStructureNS(namespaceURIs, structure, structureNS) {
  structureNS = structureNS !== undefined ? structureNS : {};
  let i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
}

/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 */
function parseNode(parsersNS, node, objectStack, thisArg) {
  let n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    const parsers = parsersNS[n.namespaceURI];
    if (parsers !== undefined) {
      const parser = parsers[n.localName];
      if (parser !== undefined) {
        parser.call(thisArg, n, objectStack);
      }
    }
  }
}

/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */
function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {
  objectStack.push(object);
  parseNode(parsersNS, node, objectStack, thisArg);
  return /** @type {T} */ (objectStack.pop());
}

/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */
function serialize(
  serializersNS,
  nodeFactory,
  values,
  objectStack,
  keys,
  thisArg
) {
  const length = (keys !== undefined ? keys : values).length;
  let value, node;
  for (let i = 0; i < length; ++i) {
    value = values[i];
    if (value !== undefined) {
      node = nodeFactory.call(
        thisArg !== undefined ? thisArg : this,
        value,
        objectStack,
        keys !== undefined ? keys[i] : undefined
      );
      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(
          thisArg,
          node,
          value,
          objectStack
        );
      }
    }
  }
}

/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */
function pushSerializeAndPop(
  object,
  serializersNS,
  nodeFactory,
  values,
  objectStack,
  keys,
  thisArg
) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);
  return /** @type {O|undefined} */ (objectStack.pop());
}

let xmlSerializer_ = undefined;

/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */
function registerXMLSerializer(xmlSerializer) {
  xmlSerializer_ = xmlSerializer;
}

/**
 * @return {XMLSerializer} The XMLSerializer.
 */
function getXMLSerializer() {
  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {
    xmlSerializer_ = new XMLSerializer();
  }
  return xmlSerializer_;
}

let document_ = undefined;

/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */
function registerDocument(document) {
  document_ = document;
}

/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */
function getDocument() {
  if (document_ === undefined && typeof document !== 'undefined') {
    document_ = document.implementation.createDocument('', '', null);
  }
  return document_;
}


/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--9-oneOf-1-0!./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("6ce86516", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! exports provided: querySupervision, queryHbmTrend, queryHbmAnalysis, queryHbmCodeAnalysis, queryApprovalList, submitDeptApproval, queryClueTypes, queryWRYList, queryAreas, getTaskInfo, getEvaluateInfo, getRiskType, queryRuleList, queryHbmDepartment, checkRules, editRules, queryWRYMap, queryStatistics, complaintProportion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "querySupervision", function() { return querySupervision; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryHbmTrend", function() { return queryHbmTrend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryHbmAnalysis", function() { return queryHbmAnalysis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryHbmCodeAnalysis", function() { return queryHbmCodeAnalysis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryApprovalList", function() { return queryApprovalList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "submitDeptApproval", function() { return submitDeptApproval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryClueTypes", function() { return queryClueTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryWRYList", function() { return queryWRYList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAreas", function() { return queryAreas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTaskInfo", function() { return getTaskInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEvaluateInfo", function() { return getEvaluateInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRiskType", function() { return getRiskType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryRuleList", function() { return queryRuleList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryHbmDepartment", function() { return queryHbmDepartment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkRules", function() { return checkRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editRules", function() { return editRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryWRYMap", function() { return queryWRYMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryStatistics", function() { return queryStatistics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complaintProportion", function() { return complaintProportion; });
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./src/api/request.js");
 // ======================================== 首页 =====================================
//环保码

var querySupervision = function querySupervision() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/supervision',
    method: 'get',
    params: {}
  });
}; //环保码变化趋势

var queryHbmTrend = function queryHbmTrend(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/changing_trends',
    method: 'get',
    params: params
  });
}; //环保码原因分析

var queryHbmAnalysis = function queryHbmAnalysis(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/cause_analysis',
    method: 'get',
    params: params
  });
}; //环保码原因详情

var queryHbmCodeAnalysis = function queryHbmCodeAnalysis(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/pollution_detail',
    method: 'get',
    params: params
  });
}; //待审核列表

var queryApprovalList = function queryApprovalList(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/examine/pending_review_list',
    method: 'get',
    params: params
  });
}; //审核

var submitDeptApproval = function submitDeptApproval(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/examine/department_approval',
    method: 'post',
    data: params
  });
}; // 赋码类型下拉框

var queryClueTypes = function queryClueTypes() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/examine/type_list',
    method: 'get',
    params: {}
  });
}; //污染源列表

var queryWRYList = function queryWRYList(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/pollution_list',
    method: 'get',
    params: params
  });
}; //区域下拉框

var queryAreas = function queryAreas() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/division_list',
    method: 'get',
    params: {}
  });
}; //任务概括

var getTaskInfo = function getTaskInfo() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/law/task_summarize',
    method: 'get',
    params: {}
  });
}; //风险总览

var getEvaluateInfo = function getEvaluateInfo(data) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/evaluate/region_map',
    method: 'get',
    params: data
  });
}; // 风险问题类型

var getRiskType = function getRiskType() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/evaluate/top_info',
    method: 'get',
    params: {}
  });
}; // ==================================== 赋码规则 ====================================
//环保码规则查询

var queryRuleList = function queryRuleList(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/evaluate/rule_list',
    method: 'get',
    params: params
  });
}; //部门下拉框

var queryHbmDepartment = function queryHbmDepartment() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/interface/dept/dept_tree',
    method: 'GET',
    params: {}
  });
}; //校验

var checkRules = function checkRules(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/evaluate/check',
    method: 'get',
    params: params
  });
}; // 修改规则

var editRules = function editRules(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/evaluate/update',
    method: 'post',
    data: params
  });
}; // ====================================== 地图 ===================================
// 地图点位

var queryWRYMap = function queryWRYMap(params) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/health/home/pollution_map',
    method: 'get',
    params: params
  });
}; // ====================================== 统计报表 ===================================

var queryStatistics = function queryStatistics() {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/app/statistics/division_pie',
    method: 'get',
    params: {}
  });
}; // ====================================== 动态评价 ===================================
//各区域投诉占比

var complaintProportion = function complaintProportion(data) {
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: '/cluster/airQuality/complaintProportion',
    method: 'get',
    params: data
  });
};

/***/ }),

/***/ "./src/assets/code/地址.png":
/*!********************************!*\
  !*** ./src/assets/code/地址.png ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOCAYAAAAbvf3sAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAADKADAAQAAAABAAAADgAAAABpzKk9AAABj0lEQVQoFV2Sv0tCURTH77nqUGJFSxY01KBDky2Fm9BupAiRJq39EBtam9oaArW2kH4RiA7+BW5RU5ODUTYU1VQkpIM/Tuf7Xi9fXXj3fs/3fM59514uqZ9RKFwNvDVfdphVhJinYTNRnUiVvIMT+7FYsAWPMGVOigHu8qVIP2KBGlileAirjBo5aDmVjN7Scbns+XpvV5l5UtCOdqi1zdXIBajcaWml11V5KXUS0ZN71DWjmx/tXRMWgtThVjJ6LknphhgaHorBgNU95gUYGNLKjan6s90DqyVl9G0grAJ91FRyyFnLk//6tFzFg2UoVqlsvrhoxdCya8qKWak6ZfKlNHPvwDKNlejVWJnH7b4mSmuveykr3f/tHeA/GMyYO5LTsRh1nS5XHNdm382ukQMDFodWG4nwvXJRUBJVOwhteJIzGImNAiRS8cjziMMzR1rtyd238EHDQw4MhvE0TGnOlUrFWXv89CHyTw3fhUKhjj3/W3B0VvZ32u0DRTwvgPWGGnLt19L/9noiXEPhN4CJkld619HlAAAAAElFTkSuQmCC"

/***/ }),

/***/ "./src/utils/olMap.js":
/*!****************************!*\
  !*** ./src/utils/olMap.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.map.js */ "./node_modules/core-js/modules/es.array.map.js");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_ol_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol */ "./node_modules/ol/index.js");
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/sphere */ "./node_modules/ol/sphere.js");
/* harmony import */ var ol_source__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/source */ "./node_modules/ol/source.js");
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/tilegrid/WMTS */ "./node_modules/ol/tilegrid/WMTS.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/style */ "./node_modules/ol/style.js");
/* harmony import */ var ol_control__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/control */ "./node_modules/ol/control.js");
/* harmony import */ var ol_layer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/layer */ "./node_modules/ol/layer.js");
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/style/Circle */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/geom */ "./node_modules/ol/geom.js");
/* harmony import */ var ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ol/events/condition */ "./node_modules/ol/events/condition.js");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ol/interaction */ "./node_modules/ol/interaction.js");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ol/Observable */ "./node_modules/ol/Observable.js");
/* harmony import */ var ol_easing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ol/easing */ "./node_modules/ol/easing.js");
/* harmony import */ var ol_render__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ol/render */ "./node_modules/ol/render.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
/* harmony import */ var ol_format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ol/format */ "./node_modules/ol/format.js");
/* harmony import */ var ol_tilegrid_TileGrid__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ol/tilegrid/TileGrid */ "./node_modules/ol/tilegrid/TileGrid.js");








 // Circle,



 //最好单独引用不然都是Circle会冲突geom与style














var arcgisMapServer = "http://10.221.29.4:8080/OneMapServer/rest/services/X_KmWryDasjgjfw_V4/MapServer"; // const token = 'ggGVFw_Bdndn9VS1V0_mwBss3wYyvA0QIBTcncp1-KQmYJiEYlw1aNG9vMlmBYNB'

var token = localStorage.getItem("map_token");
/* harmony default export */ __webpack_exports__["default"] = ({
  data: function data() {
    return {
      map: null,
      layers: {
        baseLayer: null,
        // 线上地图
        vectorLayer: null,
        // 矢量地图
        portraitLayer: null,
        // 影像地图
        annotationLayer: null,
        //标注层
        provinceLayer: null,
        boundary_layer: null,
        streetLayer: null,
        pointLayer: null,
        pointLayerGj: null,
        pointLayerZbfx: null,
        pointLayerWry: null,
        circleLayer: null //周边分析画圆

      },
      overlay: null,
      center: [102.85028229687498, 25.168007229879326],
      token: "469cfd9c133f30baaf3f94a9cd848c47",
      pointInfo: null,
      resolutions: [0.002746582031854997, 0.0013732910159274985, 0.0006866454960783415, 0.00034332275992457847, 0.00017166136807926098, 0.00008583068403963049, 0.00004291534201862551, 0.000021457682893530753, 0.000010728841446765377, 0.000005364420724572418, 0.0000026822103610964784, 0.0000013411051805482392],
      matrixIds: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    };
  },
  methods: {
    initMap: function initMap(server, target, location) {
      var fullExtent = [server.fullExtent.xmin, server.fullExtent.ymin, server.fullExtent.xmax, server.fullExtent.ymax];
      var origin = [server.tileInfo.origin.x, server.tileInfo.origin.y];
      var resolutions = server.tileInfo.lods.map(function (item) {
        return item.resolution;
      });
      this.map = new ol__WEBPACK_IMPORTED_MODULE_4__["Map"]({
        target: target,
        layers: [this.getArcgisLayer(fullExtent, resolutions, origin)],
        //视图，这里设置坐标系
        view: new ol__WEBPACK_IMPORTED_MODULE_4__["View"]({
          // projection: 'EPSG:4326',
          // center: [this.location[0], this.location[1]],
          resolutions: resolutions,
          resolution: resolutions[9],
          projection: Object(ol_proj__WEBPACK_IMPORTED_MODULE_19__["get"])("EPSG:4326"),
          extent: fullExtent
        }),
        //控制组件
        controls: Object(ol_control__WEBPACK_IMPORTED_MODULE_9__["defaults"])({
          attribution: false,
          zoom: false,
          rotate: false
        }).extend([])
      });
      this.map.getView().setCenter([location[0], location[1]]); // 标注层

      var annotationLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Tile"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["XYZ"]({
          url: "http://t1.tianditu.com/DataServer?T=cia_w&x={x}&y={y}&l={z}&tk=".concat(this.token)
        })
      });
      annotationLayer.setVisible(true);
      annotationLayer.set("id", "annotation");
      this.layers.annotationLayer = annotationLayer; //圆形范围图层

      this.layers.circleLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"](),
        style: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
            color: '#4654f7',
            width: 2,
            lineDash: [5, 5] //虚线

          }),
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
            color: 'rgba(255, 255, 255, 0.5)'
          })
        })
      });
      this.map.addLayer(this.layers.circleLayer); //行政区划边界图层

      this.layers.provinceLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        renderMode: "vector",
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"](),
        zIndex: 0
      });
      this.map.addLayer(this.layers.provinceLayer);
      annotationLayer.setVisible(true); //行政区划街道图层

      this.layers.streetLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        renderMode: "vector",
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"](),
        zIndex: 0
      });
      this.map.addLayer(this.layers.streetLayer); //点位图层

      this.layers.pointLayer = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"]()
      });
      this.map.addLayer(this.layers.pointLayer); //污染源详情

      this.layers.pointLayerWry = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"]()
      });
      this.map.addLayer(this.layers.pointLayerWry); //周边分析

      this.layers.pointLayerZbfx = new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Vector"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["Vector"]()
      });
      this.map.addLayer(this.layers.pointLayerZbfx); //添加当前定位的点

      this.addCurrentPoint(location); //图层监听事件

      this.layerEvent(); // this.addStreet();
      //地图点击
      // this.map.on('click', this.clickInMapEvent);
      //
      // //地图缩放
      // this.map.on('moveend', this.mouseInMapEvent);
    },
    getArcgisLayer: function getArcgisLayer(fullExtent, resolutions, origin) {
      var projection = Object(ol_proj__WEBPACK_IMPORTED_MODULE_19__["get"])("EPSG:4326");
      return new ol_layer__WEBPACK_IMPORTED_MODULE_10__["Tile"]({
        source: new ol_source__WEBPACK_IMPORTED_MODULE_6__["XYZ"]({
          url: "".concat(arcgisMapServer, "/tile/{z}/{y}/{x}?token=").concat(token),
          projection: projection,
          tileGrid: new ol_tilegrid_TileGrid__WEBPACK_IMPORTED_MODULE_21__["default"]({
            tileSize: 256,
            origin: origin,
            resolutions: resolutions,
            extent: fullExtent
          }),
          style: "default",
          wrapX: true
        }),
        visible: true,
        crossOrigin: "anonymous"
      });
    },
    //图层监听事件
    layerEvent: function layerEvent() {
      var _this = this;

      this.clickSelect = new ol_interaction__WEBPACK_IMPORTED_MODULE_15__["Select"]({
        condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_14__["click"],
        style: null,
        layers: [this.layers.pointLayer, this.layers.pointLayerZbfx]
      });
      this.clickSelect.on('select', function (e) {
        var features = e.selected;
        features.forEach(function (feature) {
          if (feature === _this.selectedByAttrFeature) {}

          _this.mapPointClick(feature);
        });
      });
      this.map.addInteraction(this.clickSelect); //图层移入移出事件

      var pointerMoveSelect = new ol_interaction__WEBPACK_IMPORTED_MODULE_15__["Select"]({
        condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_14__["pointerMove"],
        layers: [this.layers.pointLayer, this.layers.pointLayerZbfx]
      });
      pointerMoveSelect.on('select', function (e) {
        var features = e.selected;
        var desFeatures = e.deselected;
        var scale = 1.2; //添加文字标注以及icon

        features.forEach(function (feature) {
          feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
            zIndex: 999,
            text: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Text"]({
              text: feature.get('name'),
              offsetX: 0,
              offsetY: 25,
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: '#fff'
              }),
              backgroundFill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: '#000'
              }),
              font: '14px serif',
              fontWeight: 600,
              overflow: true,
              padding: [1, 5, 0, 5]
            }),
            image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"]({
              src: _this.$utils.getPointImg(feature.get('type'), feature.get('level')),
              anchor: [0.5, 0.5],
              //锚点
              scale: scale
            })
          }));
        }); //去除文字标注

        desFeatures.forEach(function (desFeature) {
          desFeature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
            text: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Text"]({
              text: null
            }),
            image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"]({
              src: _this.$utils.getPointImg(desFeature.get('type'), desFeature.get('level')),
              anchor: [0.5, 0.5],
              scale: scale
            })
          }));
        });
      });
      this.map.addInteraction(pointerMoveSelect);
    },
    //获取点位
    getPoints: function getPoints(data, type) {
      var _this2 = this;

      var points = [];
      this.layers.pointLayer.getSource().clear();
      points = data;
      points.forEach(function (point) {
        if (point.jd === "-" && point.wd === "-") {
          point.jd = "";
          point.wd = "";
        }

        point.type = type;

        _this2.addPoint(point);
      });
    },
    //加载点位
    addPoint: function addPoint(attributes) {
      var point = new ol__WEBPACK_IMPORTED_MODULE_4__["Feature"]({
        geometry: new ol_geom__WEBPACK_IMPORTED_MODULE_12__["Point"]([attributes.jd, attributes.wd]),
        type: "point"
      });
      var scale = 1.2;

      if (attributes.type === '环保码') {
        attributes.level = attributes.qr_code_color;
      }

      point.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"]({
          src: this.$utils.getPointImg(attributes.type, attributes.level),
          anchor: [0.5, 0.5],
          //锚点
          scale: scale
        }),
        zIndex: 11
      }));
      point.setProperties(attributes); //设置点位id，这样可以用source.getFeatureById 找到

      point.setId(attributes.id);
      this.layers.pointLayer.getSource().addFeature(point);
    },
    addCurrentPoint: function addCurrentPoint(attributes) {
      var point = new ol__WEBPACK_IMPORTED_MODULE_4__["Feature"]({
        geometry: new ol_geom__WEBPACK_IMPORTED_MODULE_12__["Point"]([attributes.jd, attributes.wd]),
        type: "point"
      });
      var scale = 1.2;
      point.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
        image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Icon"]({
          src: this.$utils.getPointImg(),
          anchor: [0.5, 0.5],
          //锚点
          scale: scale
        }),
        zIndex: 11
      }));
      point.setProperties(attributes);
      this.layers.pointLayer.getSource().addFeature(point);
    },
    //点击地图上的点
    mapPointClick: function mapPointClick(feature) {
      this.$store.state.pointName = feature.values_.wrymc;

      if (!feature) {
        return;
      }

      var attributes = feature.getProperties();

      if (attributes.jd !== "") {
        //高亮动画
        this.highLight(feature); //设置清除上一个点（注意顺序）

        this.clearSelectByAttribute();
        this.selectedByAttrFeature = feature; //地图中心移动

        this.info = attributes;
        var center = [this.info.jd, this.info.wd];
        this.panToCoordinate(center, 13);
      } else {
        this.$message("该站点暂无经纬度！");
      }
    },
    //高亮点位
    highLight: function highLight(clickedFeature) {
      var _this3 = this;

      var duration = 2000;
      var start = new Date().getTime();
      var highLightedFeature; //点击事件传入点击的feature，首先与上一个点对比，如果是同一个点，则不执行

      if (clickedFeature === this.selectedByAttrFeature) {
        return;
      }

      if (clickedFeature.getProperties().activeType === '污染源详情') {
        var listenerKey = this.layers.pointLayerWry.on("postrender", function (event) {
          var feature = _this3.selectedByAttrFeature; //如果当前没有点选的点位，则取消事件

          if (!feature) {
            Object(ol_Observable__WEBPACK_IMPORTED_MODULE_16__["unByKey"])(listenerKey);
            return;
          } //如果点选了其他点位，则取消事件


          if (highLightedFeature && highLightedFeature !== feature) {
            Object(ol_Observable__WEBPACK_IMPORTED_MODULE_16__["unByKey"])(listenerKey);
            return;
          }

          if (!highLightedFeature) {
            highLightedFeature = feature;
          } //style生成


          var vectorContext = Object(ol_render__WEBPACK_IMPORTED_MODULE_18__["getVectorContext"])(event);
          var frameState = event.frameState;
          var flashGeom = feature.getGeometry().clone();
          flashGeom.flatCoordinates = [flashGeom.flatCoordinates[0], flashGeom.flatCoordinates[1] - 0.00009];
          var elapsed = frameState.time - start;
          var elapsedRatio = elapsed / duration; // radius will be 5 at start and 30 at end.

          var radius = Object(ol_easing__WEBPACK_IMPORTED_MODULE_17__["easeOut"])(elapsedRatio) * 25;
          var opacity = Object(ol_easing__WEBPACK_IMPORTED_MODULE_17__["easeOut"])(1 - elapsedRatio);
          var style = new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
            image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
              radius: radius,
              stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                color: "rgba(35, 220, 43, " + opacity + ")",
                width: 0.25 + opacity
              }),
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: "rgba(35 ,220 ,43, " + opacity / 3 + ")"
              })
            })
          });
          vectorContext.setStyle(style);
          vectorContext.drawGeometry(flashGeom); //设置重复运行

          if (elapsed > duration) {
            start = new Date().getTime();
          }

          _this3.map.render();
        });
      } else {
        var _listenerKey = this.layers.pointLayer.on("postrender", function (event) {
          var feature = _this3.selectedByAttrFeature; //如果当前没有点选的点位，则取消事件

          if (!feature) {
            Object(ol_Observable__WEBPACK_IMPORTED_MODULE_16__["unByKey"])(_listenerKey);
            return;
          } //如果点选了其他点位，则取消事件


          if (highLightedFeature && highLightedFeature !== feature) {
            Object(ol_Observable__WEBPACK_IMPORTED_MODULE_16__["unByKey"])(_listenerKey);
            return;
          }

          if (!highLightedFeature) {
            highLightedFeature = feature;
          } //style生成


          var vectorContext = Object(ol_render__WEBPACK_IMPORTED_MODULE_18__["getVectorContext"])(event);
          var frameState = event.frameState;
          var flashGeom = feature.getGeometry().clone();
          flashGeom.flatCoordinates = [flashGeom.flatCoordinates[0], flashGeom.flatCoordinates[1] - 0.00009];
          var elapsed = frameState.time - start;
          var elapsedRatio = elapsed / duration; // radius will be 5 at start and 30 at end.

          var radius = Object(ol_easing__WEBPACK_IMPORTED_MODULE_17__["easeOut"])(elapsedRatio) * 25;
          var opacity = Object(ol_easing__WEBPACK_IMPORTED_MODULE_17__["easeOut"])(1 - elapsedRatio);
          var style = new ol_style__WEBPACK_IMPORTED_MODULE_8__["Style"]({
            image: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Circle"]({
              radius: radius,
              stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Stroke"]({
                color: "rgba(35, 220, 43, " + opacity + ")",
                width: 0.25 + opacity
              }),
              fill: new ol_style__WEBPACK_IMPORTED_MODULE_8__["Fill"]({
                color: "rgba(35 ,220 ,43, " + opacity / 3 + ")"
              })
            })
          });
          vectorContext.setStyle(style);
          vectorContext.drawGeometry(flashGeom); //设置重复运行

          if (elapsed > duration) {
            start = new Date().getTime();
          }

          _this3.map.render();
        });
      }
    },

    /**
     * 根据经纬度画圆
     * @param pointArr 经纬度
     * @param circleRadius 半径
     * */
    drawCircle: function drawCircle(pointArr, circleRadius) {
      this.layers.circleLayer.getSource().clear();
      var radius = circleRadius * 1000;
      var circle = Object(ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_13__["circular"])(pointArr, radius);
      var circleFeature = new ol__WEBPACK_IMPORTED_MODULE_4__["Feature"]({
        geometry: circle
      });
      this.layers.circleLayer.getSource().addFeature(circleFeature);
    },
    //地图移动，缩放
    panToCoordinate: function panToCoordinate(coordinate, zoom) {
      this.map.getView().animate({
        center: coordinate,
        duration: 500,
        zoom: zoom
      });
    },
    //清除点
    clearSelectByAttribute: function clearSelectByAttribute() {
      if (this.selectedByAttrFeature) {
        this.selectedByAttrFeature = null;
      }

      this.clickSelect.getFeatures().clear();
    },
    //定位点
    findFeatureById: function findFeatureById(id) {
      var feature = this.layers.pointLayer.getSource().getFeatureById(id);

      if (feature === null) {
        this.$message("暂无对应点位！");
      } else {
        this.mapPointClick(feature);
      }
    }
  }
});

/***/ }),

/***/ "./src/views/environmentCode/mapMng/index.vue":
/*!****************************************************!*\
  !*** ./src/views/environmentCode/mapMng/index.vue ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=a9ba7ed4&scoped=true& */ "./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true&");
/* harmony import */ var _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js& */ "./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& */ "./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "a9ba7ed4",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/views/environmentCode/mapMng/index.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js&":
/*!*****************************************************************************!*\
  !*** ./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js& ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../node_modules/babel-loader/lib!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&":
/*!**************************************************************************************************************!*\
  !*** ./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-style-loader??ref--9-oneOf-1-0!../../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=style&index=0&id=a9ba7ed4&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_a9ba7ed4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),

/***/ "./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true&":
/*!***********************************************************************************************!*\
  !*** ./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true& ***!
  \***********************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=a9ba7ed4&scoped=true& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/environmentCode/mapMng/index.vue?vue&type=template&id=a9ba7ed4&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_a9ba7ed4_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3ZpZXdzL2Vudmlyb25tZW50Q29kZS9tYXBNbmcvaW5kZXgudnVlIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9lbnZpcm9ubWVudENvZGUvbWFwTW5nL2luZGV4LnZ1ZT81MjEzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9vbC5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2Vudmlyb25tZW50Q29kZS9tYXBNbmcvaW5kZXgudnVlP2E0MmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L0dNTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L0dNTDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9HTUwzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvR01MMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9HTUxCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvR1BYLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvSUdDLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvS01MLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvT1dTLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9UZXh0RmVhdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L1RvcG9KU09OLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvV0ZTLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvV0tCLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvV0tULmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvV01TQ2FwYWJpbGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvV01TR2V0RmVhdHVyZUluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9XTVRTQ2FwYWJpbGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvWE1MLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvWE1MRmVhdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9BbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvQmJveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9Db21wYXJpc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvZmlsdGVyL0NvbXBhcmlzb25CaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvRFdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9EaXNqb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9EdXJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvRXF1YWxUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9GaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvR3JlYXRlclRoYW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvR3JlYXRlclRoYW5PckVxdWFsVG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvSW50ZXJzZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9Jc0JldHdlZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvSXNMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvZmlsdGVyL0lzTnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9MZXNzVGhhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9MZXNzVGhhbk9yRXF1YWxUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9Mb2dpY2FsTmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9Ob3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvTm90RXF1YWxUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9Pci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L2ZpbHRlci9SZXNvdXJjZUlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvZmlsdGVyL1NwYXRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9maWx0ZXIvV2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQveGxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC94c2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9mbGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRGJsQ2xpY2tEcmFnWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9FeHRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL01vZGlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9TbmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL29sLmNzcz81ODExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC94bWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2Vudmlyb25tZW50Q29kZS9tYXBNbmcvaW5kZXgudnVlP2M2ZmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2NvZGUv5Zyw5Z2ALnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvb2xNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2Vudmlyb25tZW50Q29kZS9tYXBNbmcvaW5kZXgudnVlIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9lbnZpcm9ubWVudENvZGUvbWFwTW5nL2luZGV4LnZ1ZT9mMzk3Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9lbnZpcm9ubWVudENvZGUvbWFwTW5nL2luZGV4LnZ1ZT8xNDMwIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9lbnZpcm9ubWVudENvZGUvbWFwTW5nL2luZGV4LnZ1ZT80MWVhIl0sIm5hbWVzIjpbInF1ZXJ5U3VwZXJ2aXNpb24iLCJyZXF1ZXN0IiwidXJsIiwibWV0aG9kIiwicGFyYW1zIiwicXVlcnlIYm1UcmVuZCIsInF1ZXJ5SGJtQW5hbHlzaXMiLCJxdWVyeUhibUNvZGVBbmFseXNpcyIsInF1ZXJ5QXBwcm92YWxMaXN0Iiwic3VibWl0RGVwdEFwcHJvdmFsIiwiZGF0YSIsInF1ZXJ5Q2x1ZVR5cGVzIiwicXVlcnlXUllMaXN0IiwicXVlcnlBcmVhcyIsImdldFRhc2tJbmZvIiwiZ2V0RXZhbHVhdGVJbmZvIiwiZ2V0Umlza1R5cGUiLCJxdWVyeVJ1bGVMaXN0IiwicXVlcnlIYm1EZXBhcnRtZW50IiwiY2hlY2tSdWxlcyIsImVkaXRSdWxlcyIsInF1ZXJ5V1JZTWFwIiwicXVlcnlTdGF0aXN0aWNzIiwiY29tcGxhaW50UHJvcG9ydGlvbiIsImFyY2dpc01hcFNlcnZlciIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm1hcCIsImxheWVycyIsImJhc2VMYXllciIsInZlY3RvckxheWVyIiwicG9ydHJhaXRMYXllciIsImFubm90YXRpb25MYXllciIsInByb3ZpbmNlTGF5ZXIiLCJib3VuZGFyeV9sYXllciIsInN0cmVldExheWVyIiwicG9pbnRMYXllciIsInBvaW50TGF5ZXJHaiIsInBvaW50TGF5ZXJaYmZ4IiwicG9pbnRMYXllcldyeSIsImNpcmNsZUxheWVyIiwib3ZlcmxheSIsImNlbnRlciIsInBvaW50SW5mbyIsInJlc29sdXRpb25zIiwibWF0cml4SWRzIiwibWV0aG9kcyIsImluaXRNYXAiLCJzZXJ2ZXIiLCJ0YXJnZXQiLCJsb2NhdGlvbiIsImZ1bGxFeHRlbnQiLCJ4bWluIiwieW1pbiIsInhtYXgiLCJ5bWF4Iiwib3JpZ2luIiwidGlsZUluZm8iLCJ4IiwieSIsImxvZHMiLCJpdGVtIiwicmVzb2x1dGlvbiIsIk1hcCIsImdldEFyY2dpc0xheWVyIiwidmlldyIsIlZpZXciLCJwcm9qZWN0aW9uIiwiZ2V0UHJvamVjdGlvbiIsImV4dGVudCIsImNvbnRyb2xzIiwiZGVmYXVsdENvbnRyb2xzIiwiYXR0cmlidXRpb24iLCJ6b29tIiwicm90YXRlIiwiZXh0ZW5kIiwiZ2V0VmlldyIsInNldENlbnRlciIsIlRpbGVMYXllciIsInNvdXJjZSIsIlhZWiIsInNldFZpc2libGUiLCJzZXQiLCJWZWN0b3JMYXllciIsIlZlY3RvclNvdXJjZSIsInN0eWxlIiwiU3R5bGUiLCJzdHJva2UiLCJTdHJva2UiLCJjb2xvciIsIndpZHRoIiwibGluZURhc2giLCJmaWxsIiwiRmlsbCIsImFkZExheWVyIiwicmVuZGVyTW9kZSIsInpJbmRleCIsImFkZEN1cnJlbnRQb2ludCIsImxheWVyRXZlbnQiLCJ0aWxlR3JpZCIsIlRpbGVHcmlkIiwidGlsZVNpemUiLCJ3cmFwWCIsInZpc2libGUiLCJjcm9zc09yaWdpbiIsImNsaWNrU2VsZWN0IiwiU2VsZWN0IiwiY29uZGl0aW9uIiwiY2xpY2siLCJvbiIsImUiLCJmZWF0dXJlcyIsInNlbGVjdGVkIiwiZm9yRWFjaCIsImZlYXR1cmUiLCJzZWxlY3RlZEJ5QXR0ckZlYXR1cmUiLCJtYXBQb2ludENsaWNrIiwiYWRkSW50ZXJhY3Rpb24iLCJwb2ludGVyTW92ZVNlbGVjdCIsInBvaW50ZXJNb3ZlIiwiZGVzRmVhdHVyZXMiLCJkZXNlbGVjdGVkIiwic2NhbGUiLCJzZXRTdHlsZSIsInRleHQiLCJUZXh0IiwiZ2V0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJiYWNrZ3JvdW5kRmlsbCIsImZvbnQiLCJmb250V2VpZ2h0Iiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwiaW1hZ2UiLCJJY29uIiwic3JjIiwiJHV0aWxzIiwiZ2V0UG9pbnRJbWciLCJhbmNob3IiLCJkZXNGZWF0dXJlIiwiZ2V0UG9pbnRzIiwidHlwZSIsInBvaW50cyIsImdldFNvdXJjZSIsImNsZWFyIiwicG9pbnQiLCJqZCIsIndkIiwiYWRkUG9pbnQiLCJhdHRyaWJ1dGVzIiwiRmVhdHVyZSIsImdlb21ldHJ5IiwiUG9pbnQiLCJsZXZlbCIsInFyX2NvZGVfY29sb3IiLCJzZXRQcm9wZXJ0aWVzIiwic2V0SWQiLCJpZCIsImFkZEZlYXR1cmUiLCIkc3RvcmUiLCJzdGF0ZSIsInBvaW50TmFtZSIsInZhbHVlc18iLCJ3cnltYyIsImdldFByb3BlcnRpZXMiLCJoaWdoTGlnaHQiLCJjbGVhclNlbGVjdEJ5QXR0cmlidXRlIiwiaW5mbyIsInBhblRvQ29vcmRpbmF0ZSIsIiRtZXNzYWdlIiwiY2xpY2tlZEZlYXR1cmUiLCJkdXJhdGlvbiIsInN0YXJ0IiwiRGF0ZSIsImdldFRpbWUiLCJoaWdoTGlnaHRlZEZlYXR1cmUiLCJhY3RpdmVUeXBlIiwibGlzdGVuZXJLZXkiLCJldmVudCIsInVuQnlLZXkiLCJ2ZWN0b3JDb250ZXh0IiwiZ2V0VmVjdG9yQ29udGV4dCIsImZyYW1lU3RhdGUiLCJmbGFzaEdlb20iLCJnZXRHZW9tZXRyeSIsImNsb25lIiwiZmxhdENvb3JkaW5hdGVzIiwiZWxhcHNlZCIsInRpbWUiLCJlbGFwc2VkUmF0aW8iLCJyYWRpdXMiLCJlYXNlT3V0Iiwib3BhY2l0eSIsImdlb21DaXJjbGUiLCJkcmF3R2VvbWV0cnkiLCJyZW5kZXIiLCJkcmF3Q2lyY2xlIiwicG9pbnRBcnIiLCJjaXJjbGVSYWRpdXMiLCJjaXJjbGUiLCJjaXJjdWxhciIsImNpcmNsZUZlYXR1cmUiLCJjb29yZGluYXRlIiwiYW5pbWF0ZSIsImdldEZlYXR1cmVzIiwiZmluZEZlYXR1cmVCeUlkIiwiZ2V0RmVhdHVyZUJ5SWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFEQTtBQUVBLGdFQUZBO0FBR0EsTUFIQSxrQkFHQTtBQUNBO0FBQ0EsY0FEQTtBQUVBLHFCQUZBO0FBR0Esa0JBSEE7QUFJQSxrQkFKQTtBQUtBLG9CQUxBO0FBTUE7QUFOQTtBQVFBLEdBWkE7QUFhQTtBQUNBLDRCQURBLGtDQUNBO0FBQ0E7QUFDQTtBQUNBLEtBSkE7QUFLQSxTQUxBLGlCQUtBO0FBQ0E7QUFDQSxLQVBBO0FBUUEsVUFSQSxrQkFRQTtBQUNBO0FBQ0E7QUFDQSxPQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFkQSxHQWJBO0FBNkJBLFNBN0JBLHFCQTZCQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxnQ0FDQSw0QkFEQSxFQUVBLDJCQUZBOztBQUlBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBLGlCQUpBLEVBSUEsR0FKQTtBQU1BLGVBUEE7O0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhQSxHQTFDQTtBQTJDQTtBQUNBLGdCQURBLDBCQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQURBO0FBRUEsOEJBRkE7QUFHQTtBQUNBLHNCQURBO0FBRUE7QUFGQTtBQUhBLFdBT0EsSUFQQSxDQU9BO0FBQ0E7QUFDQSxTQVRBO0FBVUEsT0FYQTtBQVlBLEtBZEE7QUFlQSxZQWZBLG9CQWVBLElBZkEsRUFlQTtBQUNBO0FBQ0E7QUFDQSxPQUZBLE1BRUE7QUFDQTtBQUNBLE9BRkEsTUFFQTtBQUNBO0FBQ0EsT0FGQSxNQUVBO0FBQ0E7QUFDQTtBQUNBLEtBekJBO0FBMEJBLGVBMUJBLHVCQTBCQSxJQTFCQSxFQTBCQTtBQUNBO0FBQ0EsNkJBREE7QUFFQTtBQUNBLHFCQURBO0FBRUE7QUFGQTtBQUZBO0FBT0EsS0FsQ0E7QUFtQ0EsZUFuQ0EseUJBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQXhDQTtBQXlDQSxrQkF6Q0EsNEJBeUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBLHVCQURBO0FBRUEseUJBRkE7QUFHQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsT0FYQSxFQVdBLE9BWEEsQ0FXQTtBQUNBO0FBQ0EsT0FiQTtBQWNBLEtBOURBO0FBK0RBLGFBL0RBLHFCQStEQSxJQS9EQSxFQStEQTtBQUNBO0FBQ0EsS0FqRUE7QUFrRUE7QUFDQSxrQkFuRUEsNEJBbUVBO0FBQ0E7QUFDQTtBQXJFQTtBQTNDQSxHOzs7Ozs7Ozs7Ozs7QUMzREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0QkFBNEI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtDQUErQztBQUNyRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFrRDtBQUM5RSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBa0Q7QUFDOUUsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRCxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQixnQ0FBZ0MsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQSwwQkFBMEIsTUFBTSxtQkFBTyxDQUFDLHNEQUFzQixHQUFHO0FBQ2pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBLG1CQUFtQixTQUFTLE1BQU0sbUJBQU8sQ0FBQyxzREFBc0IsR0FBRyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLE1BQU0sbUJBQU8sQ0FBQyxzREFBc0IsR0FBRyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLE1BQU0sbUJBQU8sQ0FBQyxzREFBc0IsR0FBRyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakxBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsd0ZBQW1DO0FBQzdFO0FBQ0E7QUFDQSxjQUFjLFFBQVMsa0JBQWtCLGlDQUFpQywwQ0FBMEMsNERBQTRELDZEQUE2RCxtQ0FBbUMsMENBQTBDLDhCQUE4QixHQUFHLGFBQWEsMkJBQTJCLHVCQUF1QixtREFBbUQseURBQXlELEdBQUcsd0JBQXdCLGFBQWEsZUFBZSx1QkFBdUIsR0FBRyxvQkFBb0IsbURBQW1ELHVCQUF1QixnQkFBZ0IsY0FBYyxpQkFBaUIsdUJBQXVCLEdBQUcsMEJBQTBCLHdEQUF3RCxxQkFBcUIsc0NBQXNDLG9CQUFvQix1QkFBdUIsZ0JBQWdCLGlDQUFpQywwQkFBMEIsR0FBRyxtQkFBbUIsdUJBQXVCLGdCQUFnQixjQUFjLEdBQUcseUJBQXlCLGtCQUFrQixHQUFHLDJCQUEyQixlQUFlLGlCQUFpQixpREFBaUQsaUJBQWlCLGdCQUFnQixHQUFHLHlCQUF5Qix1QkFBdUIsaUJBQWlCLG9CQUFvQixnQkFBZ0Isc0NBQXNDLGtNQUFrTSxHQUFHLG9CQUFvQix1QkFBdUIsb0JBQW9CLHVCQUF1QixpQkFBaUIsc0NBQXNDLGtNQUFrTSxHQUFHLHlCQUF5Qix1QkFBdUIsaUJBQWlCLGVBQWUsMkJBQTJCLGlEQUFpRCxHQUFHLDhCQUE4Qix3REFBd0QsR0FBRyw2QkFBNkIsaURBQWlELEdBQUcscUJBQXFCLGtCQUFrQixHQUFHLHFDQUFxQyxnQ0FBZ0MsOEJBQThCLDJCQUEyQiwwQkFBMEIsMEJBQTBCLDZDQUE2QyxHQUFHLHlCQUF5QixlQUFlLEdBQUcsb0JBQW9CLG1DQUFtQyw4QkFBOEIsMkJBQTJCLDBCQUEwQiwwQkFBMEIsR0FBRyxrQkFBa0IsNkJBQTZCLHFCQUFxQixHQUFHLGNBQWMsaUJBQWlCLHlCQUF5QixpQkFBaUIsR0FBRyxpQkFBaUIsdUJBQXVCLHdEQUF3RCx1QkFBdUIsR0FBRyxjQUFjLGNBQWMsZUFBZSxHQUFHLGdCQUFnQixjQUFjLGdCQUFnQiwwREFBMEQsR0FBRywwQkFBMEIsZUFBZSx1QkFBdUIsK0RBQStELEdBQUcscUJBQXFCLGlCQUFpQixlQUFlLEdBQUcscUJBQXFCLGdCQUFnQixjQUFjLEdBQUcsd0JBQXdCLG1CQUFtQixnQkFBZ0IsZUFBZSw2Q0FBNkMsc0JBQXNCLDBCQUEwQix1QkFBdUIsdUJBQXVCLG9CQUFvQixtQkFBbUIsc0JBQXNCLGlEQUFpRCxpQkFBaUIsdUJBQXVCLEdBQUcsMENBQTBDLGlCQUFpQixlQUFlLEdBQUcsNEJBQTRCLHVCQUF1QixHQUFHLGlCQUFpQixtQkFBbUIsd0JBQXdCLDJCQUEyQixHQUFHLGtDQUFrQyxxQkFBcUIsR0FBRywrQkFBK0IsZUFBZSxHQUFHLHlEQUF5RCwwQkFBMEIseURBQXlELHNDQUFzQyxHQUFHLDBCQUEwQiwrQkFBK0IsR0FBRywyQkFBMkIsK0JBQStCLEdBQUcscUJBQXFCLHNCQUFzQixpQkFBaUIsZ0JBQWdCLGtDQUFrQyxrQkFBa0IsMkJBQTJCLHdCQUF3QixHQUFHLHVCQUF1Qiw2Q0FBNkMsMEJBQTBCLEdBQUcsd0JBQXdCLGNBQWMsc0JBQXNCLHNDQUFzQyxvREFBb0Qsb0JBQW9CLEdBQUcsd0JBQXdCLG9CQUFvQixxQkFBcUIsR0FBRywrQ0FBK0MsbUJBQW1CLEdBQUcseUJBQXlCLG9CQUFvQix1QkFBdUIsMkJBQTJCLEdBQUcsNEJBQTRCLG1CQUFtQixHQUFHLHFDQUFxQyxrQkFBa0IsR0FBRyx3Q0FBd0MsbURBQW1ELEdBQUcsc0NBQXNDLGNBQWMsYUFBYSwyQkFBMkIsR0FBRywwQ0FBMEMsc0JBQXNCLHNCQUFzQixHQUFHLDZDQUE2QyxrQkFBa0IsR0FBRyxvQkFBb0IsZUFBZSxlQUFlLGtCQUFrQixHQUFHLDJCQUEyQix1QkFBdUIsaUJBQWlCLEdBQUcsOEJBQThCLGVBQWUsR0FBRyxxQkFBcUIsZ0JBQWdCLGtCQUFrQixHQUFHLHNDQUFzQyxjQUFjLFlBQVksNkJBQTZCLEdBQUcsa0VBQWtFLG1CQUFtQixHQUFHLHlDQUF5Qyx3REFBd0Qsa0JBQWtCLGlCQUFpQixHQUFHLCtDQUErQyxjQUFjLFlBQVksdUJBQXVCLEdBQUcsZ0dBQWdHLGtCQUFrQixHQUFHLHdDQUF3QyxrREFBa0QsR0FBRyx5QkFBeUIsMkRBQTJELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHO0FBQ3g4TTtBQUNBOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDhHQUF5RDtBQUNuRztBQUNBO0FBQ0EsY0FBYyxRQUFTLGlDQUFpQywrQkFBK0IscUJBQXFCLHNCQUFzQixHQUFHLCtDQUErQyxnQkFBZ0IsaUJBQWlCLHNCQUFzQixHQUFHLDBEQUEwRCxnQkFBZ0IsbUJBQW1CLDJCQUEyQixpQkFBaUIsa0JBQWtCLHdCQUF3QixvQkFBb0IsR0FBRyxrRUFBa0UsZUFBZSxpQkFBaUIsbUJBQW1CLGtCQUFrQixxQkFBcUIsb0NBQW9DLHFCQUFxQix1QkFBdUIsc0JBQXNCLDhCQUE4QixHQUFHLCtDQUErQyxnQkFBZ0IsOEJBQThCLDJCQUEyQixHQUFHLHVEQUF1RCxrQkFBa0IsMkJBQTJCLEdBQUcsK0RBQStELDJCQUEyQixvQkFBb0IsaUJBQWlCLGVBQWUsdUJBQXVCLGVBQWUsaUJBQWlCLGVBQWUsa0JBQWtCLHdCQUF3QixtQ0FBbUMsb0JBQW9CLGdEQUFnRCxHQUFHLG1FQUFtRSx3QkFBd0Isa0JBQWtCLEdBQUcsbUVBQW1FLHNCQUFzQixHQUFHLHdEQUF3RCwrQkFBK0IscUJBQXFCLEdBQUcsa0VBQWtFLGVBQWUsa0JBQWtCLDJDQUEyQyxxQkFBcUIsc0JBQXNCLGlDQUFpQyxzQkFBc0Isa0JBQWtCLHdCQUF3QixHQUFHLHlFQUF5RSxrQkFBa0IsaUJBQWlCLHdCQUF3QixHQUFHLGdGQUFnRixzQkFBc0Isb0JBQW9CLEdBQUcsK0VBQStFLHNCQUFzQixpQkFBaUIsR0FBRztBQUMxdkU7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUV5RDtBQUNGO0FBQ1I7QUFDQTtBQUNBO0FBQ1U7QUFDVjtBQUNBO0FBQ0E7QUFDVTtBQUNBO0FBQ1Y7QUFDQTtBQUNBO0FBQ3dCO0FBQ0k7QUFDRjs7Ozs7Ozs7Ozs7OztBQ3BCekU7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUM2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBSTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxXQUFXLG9DQUFvQztBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxvQ0FBb0M7QUFDL0MsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFZSxrRUFBRyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDdkNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUM0QztBQVd6QjtBQUN5QjtBQUNJO0FBSTFCO0FBQ3VCOztBQUU3QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxFQUFFLGlEQUFLOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQU87QUFDMUI7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLGlEQUFLLHFCQUFxQiwrREFBZTtBQUM3RTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLGlFQUFpQjtBQUMvQiwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsNEJBQTRCLCtEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUVBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsMkJBQTJCLCtEQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsMkJBQTJCLCtEQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsK0RBQWU7QUFDMUI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlFQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpQixDQUFDLDJEQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0EsTUFBTSxxRUFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsK0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsT0FBTyx1REFBdUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLG9FQUFvRTtBQUNqRixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkU7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDhFQUEwQjtBQUN4QyxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxnRkFBNEI7QUFDMUMsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQW1CO0FBQ3ZCLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxnRkFBZ0Y7QUFDN0YsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSx3Q0FBd0M7QUFDckQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBZTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUI7QUFDekIsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLCtEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHFDQUFxQztBQUNsRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHVCQUF1QiwrREFBZTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFtQjtBQUN2Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsT0FBTyx5Q0FBeUM7QUFDaEQ7QUFDQSxNQUFNLHFFQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQW1CO0FBQ3ZCLE9BQU8sMkRBQTJEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQW1CO0FBQ3ZCLGlCQUFpQixrQ0FBa0M7QUFDbkQsUUFBUSxXQUFXO0FBQ25CO0FBQ0EsTUFBTSxvRUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBWTtBQUMvQixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFlO0FBQ2xDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQVksQ0FBQyxtREFBTztBQUNqQyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0QyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0Qyx1QkFBdUIsNERBQVksQ0FBQyxtREFBTztBQUMzQyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0QyxlQUFlLDREQUFZLENBQUMsbURBQU87QUFDbkMsb0JBQW9CLDREQUFZLENBQUMsbURBQU87QUFDeEMsV0FBVyw0REFBWTtBQUN2QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpQjtBQUM5QixrQkFBa0IsaUVBQWlCO0FBQ25DLGFBQWEsaUVBQWlCO0FBQzlCLGtCQUFrQixpRUFBaUI7QUFDbkMsa0JBQWtCLGlFQUFpQjtBQUNuQyx1QkFBdUIsaUVBQWlCO0FBQ3hDO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWlCO0FBQ25DLGVBQWUsaUVBQWlCO0FBQ2hDLG9CQUFvQixpRUFBaUI7QUFDckM7QUFDQTtBQUNBLGVBQWUsaUVBQWlCO0FBQ2hDLG9CQUFvQixpRUFBaUI7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBaUI7QUFDekM7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUI7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQWlCO0FBQ3hDLHVCQUF1QixpRUFBaUI7QUFDeEMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUI7QUFDcEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFpQjtBQUN0QztBQUNBO0FBQ0EscUJBQXFCLGlFQUFpQjtBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUIsQ0FBQywyREFBbUI7QUFDeEQsbUJBQW1CLGlFQUFpQixDQUFDLDJEQUFtQjtBQUN4RCxHQUFHO0FBQ0g7O0FBRWUsbUVBQUksRUFBQzs7Ozs7Ozs7Ozs7OztBQy93QnBCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQzZCO0FBQ2U7QUFDRztBQUNVO0FBQ047QUFDVjtBQWN0QjtBQUN5QjtBQUNUO0FBQ2E7QUFDMkI7QUFJckQ7O0FBRXRCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpREFBSztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFPO0FBQzFCO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyx3QkFBd0IsK0RBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0VBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyx3QkFBd0IsK0RBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCxNQUFNLHdEQUFNO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLHFCQUFxQiwrREFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSx5REFBUztBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSx5REFBUztBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0EsV0FBVywrREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBLFdBQVcsK0RBQWU7QUFDMUI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQSxXQUFXLCtEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0EsV0FBVywrREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLDJCQUEyQiwrREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLDJCQUEyQiwrREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLDRCQUE0QiwrREFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3RELFFBQVEsd0RBQU07QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3Qiw0QkFBNEIsK0RBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsNEJBQTRCLCtEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUVBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsU0FBUztBQUN0QixjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0EsWUFBWSxpRUFBaUI7QUFDN0I7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLGlFQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkVBQTRCO0FBQ3hDLEtBQUs7QUFDTCxZQUFZLDZFQUE0QjtBQUN4QyxLQUFLO0FBQ0wsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxZQUFZLDZFQUE0QjtBQUN4QyxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLEtBQUs7QUFDTCxZQUFZLDZFQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0VBQW1CO0FBQ3ZCOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1EQUFtRDtBQUNoRSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9FQUFtQjtBQUN2Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1DQUFtQztBQUNoRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWU7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsOEJBQThCO0FBQzNDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFtQjtBQUN2QixpQkFBaUIsa0NBQWtDO0FBQ25ELFFBQVEsV0FBVztBQUNuQjtBQUNBLE1BQU0sb0VBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWU7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUI7QUFDekIsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLCtEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBZTtBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QiwrREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsT0FBTywyREFBMkQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsT0FBTyx5Q0FBeUM7QUFDaEQ7QUFDQSxNQUFNLHFFQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkIsT0FBTyx1REFBdUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHVCQUF1QiwrREFBZTtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFdBQVc7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQWU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLG9FQUFvRTtBQUNqRixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLCtCQUErQixvQ0FBb0M7QUFDbkU7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFjLCtFQUEwQjtBQUN4QyxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxpRkFBNEI7QUFDMUMsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQW1CO0FBQ3ZCLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpRUFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUIsQ0FBQyw0REFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLElBQUksbUVBQW1CO0FBQ3ZCLGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBLE1BQU0scUVBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLCtEQUErRDtBQUM5RTtBQUNBO0FBQ0EsMENBQTBDLGlFQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxJQUFJLG1FQUFtQjtBQUN2QixpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQSxNQUFNLHFFQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVywrREFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLG9DQUFvQztBQUNqRCxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsb0NBQW9DO0FBQ2pELGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBZTtBQUNoQztBQUNBLE1BQU0sK0RBQXVCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFZO0FBQ3ZCLGVBQWUsNERBQVk7QUFDM0IsbUJBQW1CLDREQUFZLENBQUMsZ0RBQUk7QUFDcEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQVksQ0FBQyxtREFBTztBQUNqQyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0QyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0Qyx1QkFBdUIsNERBQVksQ0FBQyxtREFBTztBQUMzQyxrQkFBa0IsNERBQVksQ0FBQyxtREFBTztBQUN0QyxlQUFlLDREQUFZLENBQUMsbURBQU87QUFDbkMsb0JBQW9CLDREQUFZLENBQUMsbURBQU87QUFDeEMsZUFBZSw0REFBWTtBQUMzQixvQkFBb0IsNERBQVk7QUFDaEMsYUFBYSw0REFBWTtBQUN6QixrQkFBa0IsNERBQVk7QUFDOUIsZ0JBQWdCLDREQUFZO0FBQzVCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZTtBQUNsQyxvQkFBb0IsK0RBQWU7QUFDbkMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUFlO0FBQ3BDLHNCQUFzQiwrREFBZTtBQUNyQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQWUsQ0FBQyxtREFBTztBQUN6QyxhQUFhLCtEQUFlO0FBQzVCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWUsQ0FBQyxtREFBTztBQUN0QyxlQUFlLCtEQUFlO0FBQzlCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVk7QUFDM0IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFZO0FBQzVCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZTtBQUNsQyxtQkFBbUIsK0RBQWU7QUFDbEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFZO0FBQ2hDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpRUFBaUI7QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsbURBQU87QUFDUDtBQUNBLGtCQUFrQiw0REFBWSxDQUFDLG1EQUFPO0FBQ3RDLFlBQVksNERBQVk7QUFDeEIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxvQ0FBb0M7QUFDL0MsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlCO0FBQ2pDLGdCQUFnQixpRUFBaUI7QUFDakMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUIsQ0FBQyw0REFBbUI7QUFDeEQsbUJBQW1CLGlFQUFpQixDQUFDLDREQUFtQjtBQUN4RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFpQjtBQUN0QztBQUNBO0FBQ0EscUJBQXFCLGlFQUFpQjtBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUI7QUFDcEMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBaUI7QUFDekM7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUI7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpQjtBQUM5QixrQkFBa0IsaUVBQWlCO0FBQ25DLGFBQWEsaUVBQWlCO0FBQzlCLGtCQUFrQixpRUFBaUI7QUFDbkMsa0JBQWtCLGlFQUFpQjtBQUNuQyx1QkFBdUIsaUVBQWlCO0FBQ3hDO0FBQ0E7QUFDQSxrQkFBa0IsaUVBQWlCO0FBQ25DLGVBQWUsaUVBQWlCO0FBQ2hDLG9CQUFvQixpRUFBaUI7QUFDckM7QUFDQTtBQUNBLGVBQWUsaUVBQWlCO0FBQ2hDLG9CQUFvQixpRUFBaUI7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUI7QUFDakMsR0FBRztBQUNIOztBQUVlLG1FQUFJLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUNsd0NwQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDNkI7QUFDQTtBQUNNO0FBTWhCO0FBQ2tDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFJO0FBQ3hCO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxvRUFBb0U7QUFDakYsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQVksQ0FBQyxnREFBSTtBQUM1QixlQUFlLDREQUFZLENBQUMsZ0RBQUk7QUFDaEMsbUJBQW1CLDREQUFZLENBQUMsZ0RBQUk7QUFDcEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFJO0FBQ3BCLGdCQUFnQixnREFBSTtBQUNwQixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFZLENBQUMsbURBQU87QUFDakMsa0JBQWtCLDREQUFZLENBQUMsbURBQU87QUFDdEMsa0JBQWtCLDREQUFZLENBQUMsbURBQU87QUFDdEMsdUJBQXVCLDREQUFZLENBQUMsbURBQU87QUFDM0Msa0JBQWtCLDREQUFZLENBQUMsbURBQU87QUFDdEMsZUFBZSw0REFBWSxDQUFDLG1EQUFPO0FBQ25DLG9CQUFvQiw0REFBWSxDQUFDLG1EQUFPO0FBQ3hDLGVBQWUsNERBQVk7QUFDM0Isb0JBQW9CLDREQUFZLENBQUMsZ0RBQUk7QUFDckMsYUFBYSw0REFBWTtBQUN6QixrQkFBa0IsNERBQVksQ0FBQyxnREFBSTtBQUNuQyxnQkFBZ0IsNERBQVk7QUFDNUIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFlLENBQUMsZ0RBQUk7QUFDdkMsb0JBQW9CLCtEQUFlLENBQUMsZ0RBQUk7QUFDeEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUFlLENBQUMsZ0RBQUk7QUFDekMsc0JBQXNCLCtEQUFlLENBQUMsZ0RBQUk7QUFDMUMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFlLENBQUMsbURBQU87QUFDekMsYUFBYSwrREFBZSxDQUFDLGdEQUFJO0FBQ2pDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWUsQ0FBQyxtREFBTztBQUN0QyxlQUFlLCtEQUFlLENBQUMsZ0RBQUk7QUFDbkMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBWSxDQUFDLGdEQUFJO0FBQ2hDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBWSxDQUFDLGdEQUFJO0FBQ2pDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZSxDQUFDLGdEQUFJO0FBQ3ZDLG1CQUFtQiwrREFBZSxDQUFDLGdEQUFJO0FBQ3ZDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0REFBWSxDQUFDLGdEQUFJO0FBQ3JDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpRUFBaUI7QUFDMUMsTUFBTSxnREFBSTtBQUNWO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFlLENBQUMsbURBQU87QUFDMUMsb0JBQW9CLCtEQUFlLENBQUMsbURBQU87QUFDM0MsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFlO0FBQ3ZDLE1BQU0sbURBQU87QUFDYjtBQUNBLHlCQUF5QiwrREFBZTtBQUN4QyxNQUFNLG1EQUFPO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWUsQ0FBQyxtREFBTztBQUM1QyxzQkFBc0IsK0RBQWUsQ0FBQyxtREFBTztBQUM3QyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUFlLENBQUMsbURBQU87QUFDcEMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFlLENBQUMsbURBQU87QUFDekMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBZSxDQUFDLG1EQUFPO0FBQ3RDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBWSxDQUFDLG1EQUFPO0FBQ3RDLFlBQVksNERBQVk7QUFDeEIsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUIsQ0FBQyxnREFBSTtBQUN0QyxnQkFBZ0IsaUVBQWlCLENBQUMsZ0RBQUk7QUFDdEMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBaUIsQ0FBQyxrRUFBbUI7QUFDeEQsbUJBQW1CLGlFQUFpQixDQUFDLGtFQUFtQjtBQUN4RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFpQjtBQUN0QyxNQUFNLGdEQUFJO0FBQ1Y7QUFDQSxxQkFBcUIsaUVBQWlCO0FBQ3RDLE1BQU0sZ0RBQUk7QUFDVjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWlCLENBQUMsZ0RBQUk7QUFDekMsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBaUI7QUFDekMsTUFBTSxnREFBSTtBQUNWO0FBQ0EsbUJBQW1CLGlFQUFpQjtBQUNwQyxNQUFNLGdEQUFJO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBaUIsQ0FBQyxnREFBSTtBQUNuQyxrQkFBa0IsaUVBQWlCLENBQUMsZ0RBQUk7QUFDeEMsYUFBYSxpRUFBaUI7QUFDOUIsa0JBQWtCLGlFQUFpQixDQUFDLGdEQUFJO0FBQ3hDLGtCQUFrQixpRUFBaUIsQ0FBQyxnREFBSTtBQUN4Qyx1QkFBdUIsaUVBQWlCO0FBQ3hDLE1BQU0sZ0RBQUk7QUFDVjtBQUNBLGtCQUFrQixpRUFBaUIsQ0FBQyxnREFBSTtBQUN4QyxlQUFlLGlFQUFpQixDQUFDLGdEQUFJO0FBQ3JDLG9CQUFvQixpRUFBaUI7QUFDckMsTUFBTSxnREFBSTtBQUNWO0FBQ0EsZUFBZSxpRUFBaUIsQ0FBQyxnREFBSTtBQUNyQyxvQkFBb0IsaUVBQWlCO0FBQ3JDLE1BQU0sZ0RBQUk7QUFDVjtBQUNBLGdCQUFnQixpRUFBaUIsQ0FBQyxnREFBSTtBQUN0QyxHQUFHO0FBQ0g7O0FBRWUsb0VBQUssRUFBQzs7Ozs7Ozs7Ozs7OztBQ25XckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDTztBQUNJO0FBQ0E7QUFDVTtBQUNWO0FBQ0k7QUFDZDtBQUNJO0FBQ0E7QUFDTjtBQVFoQjtBQUM2QjtBQUkxQjs7QUFFdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVU7QUFDaEM7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEMsd0JBQXdCLDZEQUFZO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLG9EQUFvRCxRQUFRO0FBQzVELG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQTJEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlEO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFlO0FBQ2pDLGtCQUFrQiw2REFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFlO0FBQ2xDLE9BQU87QUFDUCxtQkFBbUIsZ0VBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsOEVBQThFO0FBQzVGO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEMsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0Esb0JBQW9CLCtFQUEwQjtBQUM5Qzs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxnREFBZ0Q7QUFDOUQ7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDLGdDQUFnQyxzQ0FBc0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRkFBNEI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qyx5REFBUTtBQUNoRCxpQkFBaUI7QUFDakIsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0RBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBSztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsd0JBQXdCLGdFQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLHdCQUF3QixnRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnRUFBZTtBQUNoQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLHFCQUFxQixnRUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSwwREFBUztBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSwwREFBUztBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSwwREFBUztBQUNiOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQixnRUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBVTtBQUMzQjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsNEJBQTRCLGdFQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQsUUFBUSx5REFBTTtBQUNkO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBLFdBQVcsZ0VBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hELGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHdDQUF3QztBQUN0RDtBQUNBO0FBQ0EsV0FBVyxxREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWU7QUFDbEMsb0JBQW9CLGdFQUFlO0FBQ25DLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBZTtBQUN2QztBQUNBO0FBQ0EseUJBQXlCLGdFQUFlO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEMsc0JBQXNCLGdFQUFlO0FBQ3JDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWU7QUFDNUIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFlO0FBQ2pDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0VBQWU7QUFDOUIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUFZO0FBQzlCLEdBQUc7QUFDSDs7QUFFZSxzRUFBTyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDNXFCdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDb0M7QUFDVztBQUNVO0FBQ3BCO0FBQ0k7QUFldEI7QUFDNkI7QUFVOUI7QUFDd0M7O0FBRTFEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFlO0FBQ25DLFNBQVMsK0RBQWU7QUFDeEIsU0FBUywrREFBZTtBQUN4QixTQUFTLCtEQUFlO0FBQ3hCLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUJBQXFCLCtEQUFlO0FBQ3BDLFVBQVUsd0VBQXdCLENBQUMsa0RBQVU7QUFDN0MsVUFBVSx3RUFBd0IsQ0FBQyxrREFBVTtBQUM3QyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QiwrREFBZTtBQUN2QyxTQUFTLGlFQUFpQjtBQUMxQixTQUFTLGlFQUFpQjtBQUMxQixTQUFTLGlFQUFpQjtBQUMxQixDQUFDOztBQUVEO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVTtBQUM1QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwwQkFBMEIsb0RBQWE7O0FBRXZDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsdUJBQXVCLCtEQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxvQ0FBb0M7QUFDakQsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWU7QUFDL0I7QUFDQSw4Q0FBOEMsK0RBQXVCO0FBQ3JFO0FBQ0EsTUFBTSwrREFBdUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG1FQUFtQjtBQUN2QixpQkFBaUIsa0NBQWtDO0FBQ25ELFFBQVEsVUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQiwrREFBZTtBQUNuQyxVQUFVLHdFQUF3QixDQUFDLGtEQUFVO0FBQzdDLFNBQVMsd0VBQXdCLENBQUMsa0RBQVU7QUFDNUMsVUFBVSx3RUFBd0IsQ0FBQyxrREFBVTtBQUM3QyxTQUFTLHdFQUF3QixDQUFDLGtEQUFVO0FBQzVDO0FBQ0EsWUFBWSx3RUFBd0IsQ0FBQywyREFBbUI7QUFDeEQ7QUFDQSxVQUFVLHdFQUF3QixDQUFDLGtEQUFVO0FBQzdDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQWU7QUFDckMsU0FBUyx3RUFBd0IsQ0FBQyxtREFBVztBQUM3QyxVQUFVLHdFQUF3QixDQUFDLG9EQUFZO0FBQy9DLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFlO0FBQ25DLFVBQVUsd0VBQXdCLENBQUMsa0RBQVU7QUFDN0MsU0FBUyx3RUFBd0IsQ0FBQyxrREFBVTtBQUM1QyxVQUFVLHdFQUF3QixDQUFDLGtEQUFVO0FBQzdDLFNBQVMsd0VBQXdCLENBQUMsa0RBQVU7QUFDNUM7QUFDQSxZQUFZLHdFQUF3QixDQUFDLDJEQUFtQjtBQUN4RCxVQUFVLHdFQUF3QixDQUFDLGtEQUFVO0FBQzdDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVCQUF1QiwrREFBZTtBQUN0QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFlO0FBQ3JDLFNBQVMsd0VBQXdCLENBQUMsbURBQVc7QUFDN0MsVUFBVSx3RUFBd0IsQ0FBQyxvREFBWTtBQUMvQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQiwrREFBZTtBQUNuQyxTQUFTLHdFQUF3QixDQUFDLG1EQUFXO0FBQzdDLFVBQVUsd0VBQXdCLENBQUMsb0RBQVk7QUFDL0MsWUFBWSx3RUFBd0IsQ0FBQyxtREFBVztBQUNoRCxpQkFBaUIsd0VBQXdCLENBQUMsbURBQVc7QUFDckQsVUFBVSx3RUFBd0IsQ0FBQyxrREFBVTtBQUM3QyxTQUFTLHdFQUF3QixDQUFDLGtEQUFVO0FBQzVDLFVBQVUsd0VBQXdCLENBQUMsa0RBQVU7QUFDN0MsU0FBUyx3RUFBd0IsQ0FBQyxrREFBVTtBQUM1QztBQUNBLFNBQVMsd0VBQXdCLENBQUMsa0RBQVU7QUFDNUMsVUFBVSx3RUFBd0IsQ0FBQyxrREFBVTtBQUM3QyxTQUFTLHdFQUF3QixDQUFDLGtEQUFVO0FBQzVDLFNBQVMsd0VBQXdCLENBQUMsMkRBQW1CO0FBQ3JELFVBQVUsd0VBQXdCLENBQUMsbURBQVc7QUFDOUMsVUFBVSx3RUFBd0IsQ0FBQyxtREFBVztBQUM5QyxVQUFVLHdFQUF3QixDQUFDLG1EQUFXO0FBQzlDLG1CQUFtQix3RUFBd0IsQ0FBQyxtREFBVztBQUN2RCxZQUFZLHdFQUF3QixDQUFDLDJEQUFtQjtBQUN4RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHlCQUF5QiwrREFBZTtBQUN4QyxVQUFVLGlFQUFpQixDQUFDLDJEQUFtQjtBQUMvQyxVQUFVLGlFQUFpQixDQUFDLDJEQUFtQjtBQUMvQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFxQiwrREFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFlO0FBQ3ZDLFVBQVUsaUVBQWlCLENBQUMsMkRBQW1CO0FBQy9DLFNBQVMsaUVBQWlCLENBQUMsMkRBQW1CO0FBQzlDLFVBQVUsaUVBQWlCLENBQUMsMkRBQW1CO0FBQy9DLFNBQVMsaUVBQWlCLENBQUMsMkRBQW1CO0FBQzlDLFVBQVUsaUVBQWlCO0FBQzNCLFlBQVksaUVBQWlCLENBQUMsdUVBQStCO0FBQzdELFVBQVUsaUVBQWlCLENBQUMsMkRBQW1CO0FBQy9DLFdBQVcsbUVBQW1CLENBQUMsaUVBQWlCO0FBQ2hELENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFlOztBQUUzQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QiwrREFBZTtBQUN2QyxVQUFVLGlFQUFpQixDQUFDLDJEQUFtQjtBQUMvQyxTQUFTLGlFQUFpQixDQUFDLDJEQUFtQjtBQUM5QyxVQUFVLGlFQUFpQixDQUFDLDJEQUFtQjtBQUMvQyxTQUFTLGlFQUFpQixDQUFDLDJEQUFtQjtBQUM5QyxVQUFVLGlFQUFpQjtBQUMzQixZQUFZLGlFQUFpQixDQUFDLHVFQUErQjtBQUM3RCxVQUFVLGlFQUFpQixDQUFDLDJEQUFtQjtBQUMvQyxZQUFZLG1FQUFtQixDQUFDLGlFQUFpQjtBQUNqRCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0QkFBNEIscUVBQXFCOztBQUVqRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQWU7QUFDMUMsV0FBVyxpRUFBaUI7QUFDNUIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNkJBQTZCLCtEQUFlO0FBQzVDLFNBQVMsaUVBQWlCLENBQUMsNERBQW9CO0FBQy9DLFVBQVUsaUVBQWlCLENBQUMsNkRBQXFCO0FBQ2pELFlBQVksaUVBQWlCLENBQUMsNERBQW9CO0FBQ2xELGlCQUFpQixpRUFBaUIsQ0FBQyw0REFBb0I7QUFDdkQsVUFBVSxpRUFBaUIsQ0FBQywyREFBbUI7QUFDL0MsU0FBUyxpRUFBaUIsQ0FBQywyREFBbUI7QUFDOUMsVUFBVSxpRUFBaUIsQ0FBQywyREFBbUI7QUFDL0MsU0FBUyxpRUFBaUIsQ0FBQywyREFBbUI7QUFDOUMsVUFBVSxpRUFBaUI7QUFDM0IsU0FBUyxpRUFBaUIsQ0FBQywyREFBbUI7QUFDOUMsVUFBVSxpRUFBaUIsQ0FBQywyREFBbUI7QUFDL0MsU0FBUyxpRUFBaUIsQ0FBQywyREFBbUI7QUFDOUMsU0FBUyxpRUFBaUIsQ0FBQyx1RUFBK0I7QUFDMUQsVUFBVSxpRUFBaUIsQ0FBQyw0REFBb0I7QUFDaEQsVUFBVSxpRUFBaUIsQ0FBQyw0REFBb0I7QUFDaEQsVUFBVSxpRUFBaUIsQ0FBQyw0REFBb0I7QUFDaEQsbUJBQW1CLGlFQUFpQixDQUFDLDREQUFvQjtBQUN6RCxZQUFZLGlFQUFpQixDQUFDLHVFQUErQjtBQUM3RCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrREFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUseURBQVM7QUFDWDs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWUsR0FBRztBQUNuQztBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQiwrREFBZSxHQUFHO0FBQ25DO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsRUFBRSx5REFBUztBQUNYO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBLGlCQUFpQiwrREFBZTtBQUNoQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0EsdUJBQXVCLDJEQUFVO0FBQ2pDLEVBQUUsZ0ZBQTRCO0FBQzlCLHNCQUFzQixtREFBTztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEMsRUFBRSxnRkFBNEI7QUFDOUIsc0JBQXNCLG1EQUFPO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBLGlCQUFpQiwrREFBZSxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLE9BQU87QUFDeEQ7QUFDQTtBQUNBLHVCQUF1QixzREFBSztBQUM1QixFQUFFLGdGQUE0QjtBQUM5QixzQkFBc0IsbURBQU87QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtRUFBbUI7QUFDckIsZUFBZSxrQ0FBa0MsTUFBTSxXQUFXO0FBQ2xFO0FBQ0EsSUFBSSxvRUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHNDQUFzQztBQUNqRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFZO0FBQzdCLEVBQUUsbUVBQW1CO0FBQ3JCLGVBQWUsa0NBQWtDO0FBQ2pELE1BQU0scUNBQXFDO0FBQzNDO0FBQ0EsSUFBSSxvRUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QyxNQUFNLGdGQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQVk7QUFDN0IsRUFBRSxtRUFBbUI7QUFDckI7QUFDQTtBQUNBLElBQUksb0VBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RCxNQUFNLGdGQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFZO0FBQzdCLEVBQUUsbUVBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLG9FQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsRUFBRSxtRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQyxNQUFNLGdGQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLGtFQUFHLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUMxNkJuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDb0M7QUFDVztBQUNKO0FBQ0s7QUFDVTs7QUFFMUQ7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUU7O0FBRXJGO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwrQkFBK0IsRUFBRTs7QUFFakM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1DQUFtQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNENBQTRDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFXO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQixvREFBYTs7QUFFdkM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLG1DQUFtQztBQUNoRCxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQVU7QUFDckMsd0JBQXdCLG1EQUFPO0FBQy9CLE1BQU0sZ0ZBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxrRUFBRyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDN0tuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNvQztBQUNBO0FBQzJCO0FBQzNCO0FBQ007QUFDSztBQUNVO0FBQ1Y7QUFDSTtBQUNkO0FBQ0k7QUFDRDtBQUNGO0FBQ0Y7QUFDSztBQW1CdEI7QUFDaUI7QUFDQztBQUNGO0FBQ2E7QUFTOUI7QUFDbUI7QUFDcUI7O0FBRTFEO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLDJDQUEyQztBQUN6RCxjQUFjLE9BQU87QUFDckIsY0FBYywyQ0FBMkM7QUFDekQsY0FBYyxzQ0FBc0M7QUFDcEQ7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlFQUF3QjtBQUM3QyxrQkFBa0IseUVBQXdCO0FBQzFDLGtCQUFrQix5RUFBd0I7QUFDMUMsYUFBYSx5RUFBd0I7QUFDckMsZUFBZSx5RUFBd0I7QUFDdkMsYUFBYSx5RUFBd0I7QUFDckM7QUFDQSxlQUFlLHlFQUF3QixDQUFDLG1EQUFVO0FBQ2xELG1CQUFtQix5RUFBd0IsQ0FBQyxtREFBVTtBQUN0RCxZQUFZLHlFQUF3QixDQUFDLG1EQUFVO0FBQy9DLFlBQVkseUVBQXdCLENBQUMsb0RBQVc7QUFDaEQsbUJBQW1CLHlFQUF3QixDQUFDLG1EQUFVO0FBQ3RELGdCQUFnQix5RUFBd0I7QUFDeEMsa0JBQWtCLHlFQUF3QixDQUFDLG9EQUFXO0FBQ3RELEdBQUc7QUFDSCxFQUFFLGdFQUFlO0FBQ2pCLGtCQUFrQix5RUFBd0I7QUFDMUMsYUFBYSx5RUFBd0I7QUFDckMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZCQUE2QixnRUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhLHlFQUF3QixDQUFDLG1EQUFVO0FBQ2hELGlCQUFpQix5RUFBd0IsQ0FBQyxtREFBVTtBQUNwRCxVQUFVLHlFQUF3QixDQUFDLG1EQUFVO0FBQzdDLFVBQVUseUVBQXdCLENBQUMsb0RBQVc7QUFDOUMsaUJBQWlCLHlFQUF3QixDQUFDLG1EQUFVO0FBQ3BELGdCQUFnQix5RUFBd0IsQ0FBQyxvREFBVztBQUNwRCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFxQixnRUFBZTtBQUNwQyxVQUFVLHlFQUF3QjtBQUNsQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVCQUF1QixnRUFBZTtBQUN0QyxZQUFZLHlFQUF3QixDQUFDLG9EQUFXO0FBQ2hELGFBQWEseUVBQXdCLENBQUMsb0RBQVc7QUFDakQsWUFBWSx5RUFBd0IsQ0FBQyxvREFBVztBQUNoRCxRQUFRLHlFQUF3QixDQUFDLG9EQUFXO0FBQzVDLGdCQUFnQix5RUFBd0IsQ0FBQyxtREFBVTtBQUNuRCxXQUFXLHlFQUF3QixDQUFDLG9EQUFXO0FBQy9DLFFBQVEseUVBQXdCLENBQUMsb0RBQVc7QUFDNUMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUJBQXFCLGdFQUFlOztBQUVwQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWU7QUFDdkMsY0FBYyxrRUFBaUI7QUFDL0IsZUFBZSxrRUFBaUI7QUFDaEMsQ0FBQzs7QUFFRDtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsc0RBQUk7QUFDL0I7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLHNEQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsNkJBQTZCLHlEQUFNO0FBQ25DO0FBQ0E7QUFDQSxHQUFHOztBQUVILGtDQUFrQyx5REFBTTtBQUN4QztBQUNBO0FBQ0EsR0FBRzs7QUFFSCwyQkFBMkIsdURBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHNCQUFzQix3REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsT0FBTyxzQkFBc0IsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUEyQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFVO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwwQkFBMEIscURBQWE7O0FBRXZDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQWU7QUFDckMsa0JBQWtCLGtFQUFpQjtBQUNuQyxnQkFBZ0Isa0VBQWlCO0FBQ2pDLG1CQUFtQixnRUFBZTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZUFBZTtBQUM5QjtBQUNBLHFCQUFxQixnRUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWU7QUFDbEMsT0FBTyxpQkFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxpRkFBNEI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1DQUFtQztBQUNoRCxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hELGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0E7QUFDQSxVQUFVLHlEQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBSztBQUN2QjtBQUNBO0FBQ0EsUUFBUSwyREFBVTtBQUNsQixrREFBa0QsU0FBUztBQUMzRDtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxxQkFBcUIsR0FBRztBQUN6RDtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBLGVBQWUsMkRBQVU7QUFDekI7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFLO0FBQ3ZCLE1BQU0seURBQU07QUFDWixLQUFLLFVBQVUsMkRBQVU7QUFDekIsTUFBTSx5REFBTTtBQUNaO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQSxLQUFLO0FBQ0wsTUFBTSx5REFBTTtBQUNaO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLHFCQUFxQixHQUFHO0FBQ3pEO0FBQ0EsUUFBUSx5REFBTTtBQUNkO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWUsR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFLO0FBQ3ZCLE1BQU0seURBQU07QUFDWixLQUFLLFVBQVUsMkRBQVU7QUFDekIsTUFBTSx5REFBTTtBQUNaO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsTUFBTSx5REFBTSw2Q0FBNkMsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLHFCQUFxQixHQUFHO0FBQ3pEO0FBQ0EsUUFBUSx5REFBTSw2Q0FBNkMsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBLG9CQUFvQixnRUFBZSxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBSztBQUN2QixNQUFNLHlEQUFNO0FBQ1osS0FBSyxVQUFVLDJEQUFVO0FBQ3pCLE1BQU0seURBQU07QUFDWjtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0EsS0FBSztBQUNMLE1BQU0seURBQU0sNkNBQTZDLFFBQVE7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLHFCQUFxQixHQUFHO0FBQ3pEO0FBQ0EsUUFBUSx5REFBTSw2Q0FBNkMsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0Esb0JBQW9CLGdFQUFlLEdBQUc7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLG9DQUFvQztBQUNqRCxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWU7QUFDL0I7QUFDQTtBQUNBLDhDQUE4QyxnRUFBdUI7QUFDckU7QUFDQSxNQUFNLGdFQUF1QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0EsZUFBZSxvREFBb0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWTtBQUMvQixJQUFJLG9FQUFtQjtBQUN2QjtBQUNBO0FBQ0EsTUFBTSxxRUFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHdEQUFLO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixXQUFXLGFBQWE7QUFDeEIsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtRUFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtRUFBa0I7QUFDdEQsZ0NBQWdDLHdEQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsYUFBYTtBQUN4QixXQUFXLHVDQUF1QztBQUNsRDtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0EsWUFBWSxrRUFBaUI7QUFDN0I7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDTztBQUNQLFVBQVUsa0VBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxrRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLDREQUFXO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQixnRUFBZTtBQUN6QztBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0EsU0FBUyxnRUFBZTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQWU7QUFDMUMsVUFBVSx5RUFBd0I7QUFDbEMsV0FBVyx5RUFBd0I7QUFDbkMsYUFBYSx5RUFBd0IsQ0FBQyxvREFBVztBQUNqRCxhQUFhLHlFQUF3QjtBQUNyQyxXQUFXLHlFQUF3QjtBQUNuQyxDQUFDOztBQUVEO0FBQ0EsVUFBVTtBQUNWLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnRUFBZSxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4Qyx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EsZUFBZSwyREFBUztBQUN4Qjs7QUFFQSwyQkFBMkIsaUJBQWlCOztBQUU1QywyQkFBMkIsd0JBQXdCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsc0RBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBVSx3QkFBd0Isc0RBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVU7QUFDdkMsNkJBQTZCLHNEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRCQUE0QixnRUFBZTtBQUMzQyxXQUFXLHlFQUF3QjtBQUNuQyxXQUFXLHlFQUF3QjtBQUNuQyxDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWUsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBSTtBQUM1QixjQUFjLHNEQUFJO0FBQ2xCO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBLEtBQUs7QUFDTCxzQkFBc0IsaUJBQWlCO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJCQUEyQixnRUFBZTtBQUMxQyxXQUFXLHlFQUF3QjtBQUNuQyxXQUFXLHlFQUF3QixDQUFDLG9EQUFXO0FBQy9DLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdFQUFlLEdBQUc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQU07QUFDaEM7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0IsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFlO0FBQzFDLFdBQVcseUVBQXdCO0FBQ25DLFVBQVUseUVBQXdCLENBQUMsb0RBQVc7QUFDOUMsYUFBYSx5RUFBd0IsQ0FBQyxvREFBVztBQUNqRCxDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWUsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsaUNBQWlDLGdFQUFlO0FBQ2hELGlCQUFpQiw2REFBWTtBQUM3QixDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLFNBQVMsZ0VBQWU7QUFDeEI7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0EsWUFBWSxrRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsdUNBQXVDLGdFQUFlO0FBQ3RELFdBQVcsZ0VBQWU7QUFDMUIsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBLHNCQUFzQixnRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0VBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWU7QUFDdkMsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEM7QUFDQTtBQUNBLFlBQVkseUVBQXdCO0FBQ3BDLEdBQUc7QUFDSCxFQUFFLGdFQUFlO0FBQ2pCLFNBQVMseUVBQXdCLENBQUMsb0RBQVc7QUFDN0MsU0FBUyx5RUFBd0IsQ0FBQyxvREFBVztBQUM3QyxTQUFTLHlFQUF3QixDQUFDLG9EQUFXO0FBQzdDLFNBQVMseUVBQXdCLENBQUMsb0RBQVc7QUFDN0MsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLHFCQUFxQixnRUFBZSxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMENBQTBDLGdFQUFlO0FBQ3pELGlCQUFpQiw2REFBWTtBQUM3QixDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLFNBQVMsZ0VBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBDQUEwQyxnRUFBZTtBQUN6RCxhQUFhLHlFQUF3QixDQUFDLG9EQUFXO0FBQ2pELGdCQUFnQix5RUFBd0IsQ0FBQyxvREFBVztBQUNwRCxrQkFBa0IseUVBQXdCLENBQUMsbURBQVU7QUFDckQsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLHFCQUFxQixnRUFBZTtBQUNwQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWU7QUFDOUMsZ0JBQWdCLGdFQUFlO0FBQy9CLGdCQUFnQixnRUFBZTtBQUMvQixtQkFBbUIsZ0VBQWU7QUFDbEMsV0FBVyxnRUFBZTtBQUMxQixhQUFhLGdFQUFlO0FBQzVCLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtRUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQSxRQUFRLHlEQUFNO0FBQ2Q7QUFDQSwwQkFBMEIsMkRBQVU7QUFDcEM7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLGdFQUFlO0FBQ3pDO0FBQ0EsS0FBSztBQUNMLDBCQUEwQiw2REFBWTtBQUN0QztBQUNBLEtBQUs7QUFDTCwwQkFBMEIsbUVBQWtCO0FBQzVDLEtBQUs7QUFDTCxNQUFNLDJEQUFNLFlBQVk7QUFDeEI7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLG1FQUFrQjtBQUMxQztBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtDQUFrQyxnRUFBZTtBQUNqRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLHFCQUFxQixnRUFBZTtBQUNwQyxlQUFlLGlCQUFpQixPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxNQUFNLHlEQUFNO0FBQ1o7QUFDQTtBQUNBLHdCQUF3Qix5REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNCQUFzQixnRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQixnRUFBZTtBQUNyQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBNkM7QUFDdEU7QUFDQTtBQUNBLHVCQUF1QixtRUFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsVUFBVSx3REFBSztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQTZDO0FBQ3RFO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxXQUFXLDZDQUE2QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWU7QUFDcEMsaUJBQWlCLHlFQUF3QixDQUFDLG1EQUFVO0FBQ3BELFdBQVcseUVBQXdCLENBQUMsbURBQVU7QUFDOUMsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBUztBQUNYLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLGdFQUFlO0FBQzdDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsRUFBRSwwREFBUztBQUNYOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsRUFBRSwwREFBUztBQUNYOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFxQixnRUFBZTtBQUNwQyxXQUFXLHlFQUF3QjtBQUNuQyxTQUFTLHlFQUF3QixDQUFDLG1EQUFVO0FBQzVDLGNBQWMseUVBQXdCO0FBQ3RDLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQWUsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILElBQUksMkRBQU0sWUFBWTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRCQUE0QixnRUFBZTtBQUMzQztBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxFQUFFLDBEQUFTO0FBQ1g7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFVO0FBQzNCLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFlO0FBQy9DLGtCQUFrQix5RUFBd0IsQ0FBQyxtREFBVTtBQUNyRCxpQkFBaUIseUVBQXdCLENBQUMsb0RBQVc7QUFDckQsaUJBQWlCLHlFQUF3QixDQUFDLG9EQUFXO0FBQ3JELFdBQVcseUVBQXdCLENBQUMsb0RBQVc7QUFDL0MsV0FBVyx5RUFBd0IsQ0FBQyxvREFBVztBQUMvQyxVQUFVLHlFQUF3QixDQUFDLG9EQUFXO0FBQzlDLFVBQVUseUVBQXdCLENBQUMsb0RBQVc7QUFDOUMsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQixnRUFBZTtBQUNoQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWU7QUFDbkMsa0JBQWtCLHlFQUF3QixDQUFDLG9EQUFXO0FBQ3RELGtCQUFrQix5RUFBd0IsQ0FBQyxvREFBVztBQUN0RCxtQkFBbUIseUVBQXdCLENBQUMsb0RBQVc7QUFDdkQsbUJBQW1CLHlFQUF3QixDQUFDLG9EQUFXO0FBQ3ZELENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWUsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtDQUFrQyxnRUFBZTtBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFlO0FBQy9CLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSx1Q0FBdUMsZ0VBQWU7QUFDdEQsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0MsZ0VBQWU7QUFDakQsZ0JBQWdCLDZEQUFZO0FBQzVCLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyx5QkFBeUIsZ0VBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsRUFBRSwwREFBUztBQUNYOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLFlBQVksa0VBQWlCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLG1DQUFtQztBQUM5QztBQUNBO0FBQ0EsZUFBZSwwREFBTztBQUN0QjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLEVBQUUsb0VBQW1CO0FBQ3JCOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsY0FBYztBQUN6QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILElBQUksMkRBQU0sWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0NBQXNDLGdFQUFlO0FBQ3JELFVBQVUsa0VBQWlCO0FBQzNCLFdBQVcsa0VBQWlCO0FBQzVCLGlCQUFpQixrRUFBaUI7QUFDbEMsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLG1CQUFtQjtBQUMvQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG9FQUFtQjtBQUN6QjtBQUNBO0FBQ0EsUUFBUSxxRUFBNEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sb0VBQW1CO0FBQ3pCO0FBQ0E7QUFDQSxRQUFRLHFFQUE0QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksb0VBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSxNQUFNLHFFQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxFQUFFLGtFQUFpQjtBQUNuQjs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLEVBQUUsb0VBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZCQUE2QixnRUFBZTtBQUM1QyxlQUFlLGtFQUFpQjtBQUNoQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdFQUFlO0FBQ3hCOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDLGVBQWU7QUFDcEUsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQixzRUFBcUI7O0FBRS9DO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksMENBQTBDO0FBQ3RELFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3QixJQUFJLG9FQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQWU7QUFDckM7QUFDQTtBQUNBLEVBQUUsZ0VBQWU7QUFDakI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUJBQXlCLGdFQUFlO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZLGtFQUFpQixDQUFDLDREQUFtQjtBQUNqRCxHQUFHO0FBQ0gsRUFBRSxnRUFBZTtBQUNqQixTQUFTLGtFQUFpQixDQUFDLDZEQUFvQjtBQUMvQyxTQUFTLGtFQUFpQixDQUFDLDZEQUFvQjtBQUMvQyxTQUFTLGtFQUFpQixDQUFDLDZEQUFvQjtBQUMvQyxTQUFTLGtFQUFpQixDQUFDLDZEQUFvQjtBQUMvQyxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxTQUFTLGdFQUFlO0FBQ3hCOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0MsZUFBZTtBQUNwRTtBQUNBO0FBQ0EsZUFBZSw2REFBWTtBQUMzQixFQUFFLG9FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVk7QUFDdkIsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQixnRUFBZTtBQUM5QyxVQUFVLGtFQUFpQjtBQUMzQixXQUFXLGtFQUFpQjtBQUM1QixhQUFhLGtFQUFpQixDQUFDLDZEQUFvQjtBQUNuRCxhQUFhLGtFQUFpQjtBQUM5QixXQUFXLGtFQUFpQjtBQUM1QixDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUNBQW1DO0FBQzlDLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFZO0FBQzdCLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHFFQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZCQUE2QixnRUFBZTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFlO0FBQy9DLFdBQVcsa0VBQWlCO0FBQzVCLFdBQVcsa0VBQWlCO0FBQzVCLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVk7QUFDN0IsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBLElBQUkscUVBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFlOztBQUUzQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWU7QUFDOUMsV0FBVyxrRUFBaUI7QUFDNUIsV0FBVyxrRUFBaUIsQ0FBQyw2REFBb0I7QUFDakQsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFZO0FBQzdCLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHFFQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFlO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJCQUEyQixzRUFBcUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlDQUFpQyxzRUFBcUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlDQUFpQyxzRUFBcUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZCQUE2QixzRUFBcUI7O0FBRWxEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1DQUFtQyxnRUFBZTtBQUNsRCxnQkFBZ0Isa0VBQWlCO0FBQ2pDLFdBQVcsa0VBQWlCO0FBQzVCLGFBQWEsa0VBQWlCO0FBQzlCLHdCQUF3QixrRUFBaUI7QUFDekMsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHNDQUFzQztBQUNqRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLG1CQUFtQjtBQUNuQjtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0EsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsMkRBQU0sWUFBWTtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsV0FBVztBQUN2QztBQUNBLEdBQUc7QUFDSCw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsR0FBRztBQUNILDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0EsR0FBRztBQUNILElBQUksMkRBQU0sWUFBWTtBQUN0QjtBQUNBLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGdDQUFnQyxnRUFBZTtBQUMvQyxnQkFBZ0Isa0VBQWlCO0FBQ2pDLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx3Q0FBd0M7QUFDbkQsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDLGVBQWU7QUFDcEUsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLGdFQUFlO0FBQzdDLGtCQUFrQixrRUFBaUI7QUFDbkMsbUJBQW1CLGtFQUFpQjtBQUNwQyxnQkFBZ0Isa0VBQWlCO0FBQ2pDLGdCQUFnQixrRUFBaUI7QUFDakMsV0FBVyxrRUFBaUI7QUFDNUIsYUFBYSxrRUFBaUI7QUFDOUIsV0FBVyxrRUFBaUI7QUFDNUIsYUFBYSxrRUFBaUIsQ0FBQyw0REFBbUI7QUFDbEQsaUJBQWlCLGtFQUFpQixDQUFDLDREQUFtQjtBQUN0RCxVQUFVLGtFQUFpQixDQUFDLDREQUFtQjtBQUMvQyxVQUFVLGtFQUFpQixDQUFDLDZEQUFvQjtBQUNoRCxpQkFBaUIsa0VBQWlCLENBQUMsNERBQW1CO0FBQ3RELGNBQWMsa0VBQWlCLENBQUMsNERBQW1CO0FBQ25ELGdCQUFnQixrRUFBaUIsQ0FBQyw2REFBb0I7QUFDdEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQkFBMkIsZ0VBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtDQUFrQyxzRUFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlOztBQUVwRTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QixFQUFFLG9FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsNkRBQVk7QUFDakMsNEJBQTRCO0FBQzVCLElBQUksb0VBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUZBQTRCO0FBQzNDO0FBQ0EsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsdUNBQXVDLGdFQUFlO0FBQ3RELGFBQWEsa0VBQWlCLENBQUMsNkRBQW9CO0FBQ25ELGdCQUFnQixrRUFBaUIsQ0FBQyw2REFBb0I7QUFDdEQsa0JBQWtCLGtFQUFpQixDQUFDLDREQUFtQjtBQUN2RCxpQkFBaUIsa0VBQWlCO0FBQ2xDLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyw0Q0FBNEM7QUFDdkQsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0MsZUFBZTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFZO0FBQzdCLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHFFQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDRCQUE0QixnRUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWU7QUFDM0MscUJBQXFCLGtFQUFpQjtBQUN0QyxxQkFBcUIsa0VBQWlCO0FBQ3RDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esb0NBQW9DLHNFQUFxQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esb0NBQW9DLHNFQUFxQjs7QUFFekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0MsZUFBZTtBQUNwRTtBQUNBLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQStCLGdFQUFlO0FBQzlDLFdBQVcsa0VBQWlCO0FBQzVCLFVBQVUsa0VBQWlCLENBQUMsNkRBQW9CO0FBQ2hELGFBQWEsa0VBQWlCLENBQUMsNkRBQW9CO0FBQ25ELENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBWTtBQUM3QixFQUFFLG9FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHFFQUFvQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsZ0VBQWU7QUFDekMsZUFBZSxrRUFBaUI7QUFDaEMsZ0JBQWdCLGtFQUFpQjtBQUNqQyxlQUFlLGtFQUFpQjtBQUNoQyxlQUFlLGtFQUFpQjtBQUNoQyxDQUFDOztBQUVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQyxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFZO0FBQzdCLEVBQUUsb0VBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHFFQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxrRUFBRyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDejNHbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUMyQjtBQU1SO0FBQ2lCO0FBQ0E7O0FBRXBDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWU7QUFDL0IsMkJBQTJCLHdFQUF3QjtBQUNuRCxxQkFBcUIsd0VBQXdCO0FBQzdDLHdCQUF3Qix3RUFBd0I7QUFDaEQsQ0FBQzs7QUFFRCxrQkFBa0IsK0NBQUc7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFlLEdBQUc7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QiwrREFBZTtBQUN2QyxtQkFBbUIsd0VBQXdCLENBQUMsa0RBQVU7QUFDdEQsVUFBVSx3RUFBd0IsQ0FBQyxrREFBVTtBQUM3Qyx3QkFBd0Isd0VBQXdCLENBQUMsa0RBQVU7QUFDM0QsZ0JBQWdCLHdFQUF3QixDQUFDLGtEQUFVO0FBQ25ELGFBQWEsd0VBQXdCLENBQUMsa0RBQVU7QUFDaEQsMkJBQTJCLHdFQUF3QixDQUFDLGtEQUFVO0FBQzlELENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQStCLCtEQUFlO0FBQzlDLFdBQVcsd0VBQXdCO0FBQ25DLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFlO0FBQzFDLG1CQUFtQix3RUFBd0I7QUFDM0MsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQWU7QUFDNUMsV0FBVyx3RUFBd0I7QUFDbkMsYUFBYSx3RUFBd0I7QUFDckMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWU7QUFDbkMsVUFBVSx3RUFBd0I7QUFDbEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWU7QUFDcEMsU0FBUyx3RUFBd0I7QUFDakM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQiwrREFBZTtBQUN6QyxTQUFTLHdFQUF3QjtBQUNqQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9DQUFvQywrREFBZTtBQUNuRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFlO0FBQ3JDLFdBQVcsd0VBQXdCLENBQUMsa0RBQVU7QUFDOUMsZUFBZSx3RUFBd0IsQ0FBQyxrREFBVTtBQUNsRCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQiwrREFBZTtBQUM5QyxnQkFBZ0Isd0VBQXdCO0FBQ3hDLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFlO0FBQy9DLG9CQUFvQix3RUFBd0IsQ0FBQyxrREFBVTtBQUN2RCxrQkFBa0Isd0VBQXdCLENBQUMsa0RBQVU7QUFDckQsaUJBQWlCLHdFQUF3QjtBQUN6QyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVDQUF1QywrREFBZTtBQUN0RCxjQUFjLHdFQUF3QixDQUFDLGtEQUFVO0FBQ2pELHVCQUF1Qix3RUFBd0IsQ0FBQyxrREFBVTtBQUMxRCxVQUFVLHdFQUF3QixDQUFDLGtEQUFVO0FBQzdDLFdBQVcsd0VBQXdCLENBQUMsa0RBQVU7QUFDOUMsd0JBQXdCLHdFQUF3QixDQUFDLGtEQUFVO0FBQzNELGlCQUFpQix3RUFBd0IsQ0FBQyxrREFBVTtBQUNwRCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlDQUFpQywrREFBZTtBQUNoRCxrQkFBa0Isd0VBQXdCLENBQUMsa0RBQVU7QUFDckQsa0JBQWtCLHdFQUF3QixDQUFDLGtEQUFRO0FBQ25ELG9CQUFvQix3RUFBd0I7QUFDNUMsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBLFNBQVMsK0RBQWUsR0FBRztBQUMzQjs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBLFNBQVMsK0RBQWUsR0FBRztBQUMzQjs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrREFBZSxFQUFFLGFBQWE7QUFDdkM7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxlQUFlLDBEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0RBQWU7QUFDeEIsS0FBSyxhQUFhO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBZSxHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLDBEQUFVO0FBQ25COztBQUVlLGtFQUFHLEVBQUM7Ozs7Ozs7Ozs7Ozs7QUNwVW5CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ29DO0FBQ1c7QUFDSjtBQUNOO0FBQ087QUFDSTtBQUNhO0FBQ0Y7QUFDRDs7QUFFMUQ7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBc0Q7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVc7QUFDbEM7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMEJBQTBCLG9EQUFhOztBQUV2QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBTztBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLG1DQUFtQztBQUNoRDtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBLG1CQUFtQixrRkFBa0I7QUFDckM7QUFDQSxJQUFJLGlFQUFNO0FBQ1Ysd0JBQXdCLGdGQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFVOztBQUVyQyxXQUFXLGdGQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0Q0FBNEM7QUFDekQsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBTSxZQUFZO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBLFFBQVEsZ0ZBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQU07QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDLGVBQWUsWUFBWTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUCxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGNBQWM7QUFDMUI7QUFDTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGNBQWM7QUFDMUI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsdUVBQVEsRUFBQzs7Ozs7Ozs7Ozs7OztBQzlWeEI7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ2lEO0FBQ2I7O0FBRXBDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG1DQUFtQztBQUNoRCxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0EsV0FBVyx5REFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG1DQUFtQztBQUNoRCxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0EsV0FBVyx5REFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLG1DQUFtQztBQUNoRCxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0EsV0FBVyx5REFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxjQUFjLGtEQUFrRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxrREFBa0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxvQ0FBb0M7QUFDakQsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLHlEQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsb0NBQW9DO0FBQ2pELGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRCxhQUFhLG9DQUFvQztBQUNqRDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsV0FBVyx5REFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLG9DQUFvQztBQUNqRCxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLFdBQVcseURBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwwRUFBVyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDN00zQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ29DO0FBQ087QUFDSTtBQUNVO0FBQ1Y7QUFDSTtBQUNkO0FBQ0k7QUFDTztBQUNVOztBQUUxRDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsb0RBQW9EO0FBQ2pFLGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEsNENBQTRDO0FBQ3pELGFBQWEsNENBQTRDO0FBQ3pELGFBQWEsaURBQWlEO0FBQzlELGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsOENBQThDO0FBQzNEOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsb0NBQW9DO0FBQ2xELGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBVztBQUNsQztBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQixvREFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsd0NBQXdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLG9EQUFvRDtBQUMvRCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLG9EQUFvRDtBQUMvRCxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EsYUFBYSxnRUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLG9EQUFvRDtBQUMvRCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBLGFBQWEsd0RBQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxvREFBb0Q7QUFDL0QsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLG1DQUFtQztBQUM5QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsb0RBQW9EO0FBQy9ELFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxtQ0FBbUM7QUFDOUMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLGdGQUE0QjtBQUMzQztBQUNBLHNCQUFzQixtREFBTyxFQUFFLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFvRDtBQUMvRCxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBNkM7QUFDeEQsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRCxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsdUVBQVEsRUFBQzs7Ozs7Ozs7Ozs7OztBQzdieEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQzZCO0FBQ0E7QUFDRTtBQUNhO0FBQ0g7QUFhdEI7QUFDa0Q7QUFDaEM7QUFDVztBQUs5Qjs7QUFFbEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0VBQXdCO0FBQ3pDLE1BQU0sbURBQU87QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYywrREFBZSxDQUFDLG1EQUFPO0FBQ3JDLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3RUFBd0IsQ0FBQywyREFBbUI7QUFDakUsb0JBQW9CLHdFQUF3QixDQUFDLDJEQUFtQjtBQUNoRSxvQkFBb0Isd0VBQXdCLENBQUMsMkRBQW1CO0FBQ2hFLEdBQUc7QUFDSDtBQUNBLHFCQUFxQix3RUFBd0IsQ0FBQywyREFBbUI7QUFDakUsb0JBQW9CLHdFQUF3QixDQUFDLDJEQUFtQjtBQUNoRSxvQkFBb0Isd0VBQXdCLENBQUMsMkRBQW1CO0FBQ2hFLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3RUFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdFQUF3QjtBQUM3QyxHQUFHO0FBQ0g7QUFDQSwwQkFBMEIsd0VBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3RUFBd0I7QUFDN0MsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpRUFBaUIsQ0FBQywyREFBbUI7QUFDekQsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLGlFQUFpQixDQUFDLDJEQUFtQjtBQUN6RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUI7QUFDL0IsY0FBYyxpRUFBaUI7QUFDL0IsY0FBYyxpRUFBaUI7QUFDL0IsZ0JBQWdCLGlFQUFpQjtBQUNqQyxjQUFjLGlFQUFpQjtBQUMvQixHQUFHO0FBQ0g7QUFDQSxjQUFjLGlFQUFpQjtBQUMvQixjQUFjLGlFQUFpQjtBQUMvQixjQUFjLGlFQUFpQjtBQUMvQixnQkFBZ0IsaUVBQWlCO0FBQ2pDLGNBQWMsaUVBQWlCO0FBQy9CLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLGNBQWM7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxjQUFjLHFDQUFxQztBQUNuRCxJQUFJLDhCQUE4QjtBQUNsQyxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEIsY0FBYywrQkFBK0I7QUFDN0MsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYywrQkFBK0I7QUFDN0MsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyw4QkFBOEI7QUFDNUM7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCLGVBQWU7QUFDaEQsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsY0FBYztBQUM1Qjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXLGlEQUFLO0FBQ2hCLFdBQVcsZ0RBQUk7QUFDZixXQUFXLGdEQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVU7QUFDNUI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hELGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBLFFBQVEsMERBQVU7QUFDbEI7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLDBEQUFVO0FBQ2xCO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUsscUJBQXFCLEdBQUc7QUFDekQ7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRFQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFlO0FBQzFCLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxxQkFBcUIsR0FBRztBQUN6RDtBQUNBLCtEQUErRCxRQUFRO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLCtEQUFlO0FBQzFCLGlCQUFpQixvQkFBb0IsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrREFBdUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMERBQU0sMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQU0sMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsY0FBYyxxQ0FBcUM7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1Qix1REFBWTtBQUNuQztBQUNBO0FBQ0EsYUFBYSxzREFBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSx3QkFBd0I7QUFDckMsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrREFBdUI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpQkFBaUIsb0RBQWE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHVDQUF1QztBQUNsRCxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLEdBQUc7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7QUFDaEM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLCtEQUFlO0FBQ2hDO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLEVBQUUseURBQVM7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTLCtEQUFlO0FBQ3hCOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWU7QUFDL0I7QUFDQTtBQUNBLElBQUksZ0RBQUk7QUFDUixHQUFHO0FBQ0gsSUFBSSxnREFBSTtBQUNSLEdBQUc7QUFDSCxJQUFJLGlEQUFLO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGNBQWM7QUFDekIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQWU7QUFDaEMsZ0JBQWdCLCtEQUFlO0FBQy9CO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMERBQU0sb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMERBQU0sb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJLG1FQUFtQjtBQUN2QixpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNLHFFQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBZTtBQUM5QjtBQUNBO0FBQ0EsRUFBRSxtRUFBbUI7QUFDckI7QUFDQSxrQkFBa0IsK0RBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSTtBQUNaLE9BQU87QUFDUCxRQUFRLGdEQUFJO0FBQ1osT0FBTztBQUNQLFFBQVEsaURBQUs7QUFDYjtBQUNBLEtBQUs7QUFDTCxNQUFNLG1FQUFtQjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSx3REFBd0Q7QUFDcEUsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQW1CO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBaUI7QUFDOUIsR0FBRztBQUNIO0FBQ0EsYUFBYSxpRUFBaUI7QUFDOUIsR0FBRztBQUNIO0FBQ0EsY0FBYyxpRUFBaUI7QUFDL0IsV0FBVyxpRUFBaUI7QUFDNUIsVUFBVSxpRUFBaUI7QUFDM0IsV0FBVyxpRUFBaUI7QUFDNUIsWUFBWSxpRUFBaUI7QUFDN0IsZ0JBQWdCLGlFQUFpQjtBQUNqQyxrQkFBa0IsaUVBQWlCO0FBQ25DLGNBQWMsaUVBQWlCO0FBQy9CLGVBQWUsaUVBQWlCO0FBQ2hDLHlCQUF5QixpRUFBaUI7QUFDMUMsNEJBQTRCLGlFQUFpQjtBQUM3QywwQkFBMEIsaUVBQWlCO0FBQzNDLG1DQUFtQyxpRUFBaUI7QUFDcEQsNkJBQTZCLGlFQUFpQjtBQUM5QyxzQ0FBc0MsaUVBQWlCO0FBQ3ZELHNCQUFzQixpRUFBaUI7QUFDdkMseUJBQXlCLGlFQUFpQjtBQUMxQyxzQkFBc0IsaUVBQWlCO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBLGNBQWMsaUVBQWlCO0FBQy9CLFdBQVcsaUVBQWlCO0FBQzVCLFVBQVUsaUVBQWlCO0FBQzNCLFdBQVcsaUVBQWlCO0FBQzVCLFlBQVksaUVBQWlCO0FBQzdCLGdCQUFnQixpRUFBaUI7QUFDakMsZ0JBQWdCLGlFQUFpQjtBQUNqQyxrQkFBa0IsaUVBQWlCO0FBQ25DLGtCQUFrQixpRUFBaUI7QUFDbkMsY0FBYyxpRUFBaUI7QUFDL0IsZUFBZSxpRUFBaUI7QUFDaEMseUJBQXlCLGlFQUFpQjtBQUMxQyw0QkFBNEIsaUVBQWlCO0FBQzdDLDBCQUEwQixpRUFBaUI7QUFDM0MsbUNBQW1DLGlFQUFpQjtBQUNwRCw2QkFBNkIsaUVBQWlCO0FBQzlDLHNDQUFzQyxpRUFBaUI7QUFDdkQsc0JBQXNCLGlFQUFpQjtBQUN2Qyx5QkFBeUIsaUVBQWlCO0FBQzFDLHNCQUFzQixpRUFBaUI7QUFDdkMsR0FBRztBQUNIOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFDQUFxQztBQUNoRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDLGFBQWEsa0NBQWtDO0FBQy9DLGdCQUFnQjtBQUNoQix1QkFBdUIsUUFBUTtBQUMvQixFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx5Q0FBeUM7QUFDcEQsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3Qzs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLHNDQUFzQztBQUNqRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLHNDQUFzQztBQUNqRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBZTtBQUNsQyxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrREFBZSxDQUFDLGlEQUFLOztBQUUxQzs7QUFFQSxnQkFBZ0IsK0RBQWUsQ0FBQyxpREFBSztBQUNyQztBQUNBOztBQUVBLGNBQWMsK0RBQWUsQ0FBQyxpREFBSztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywwQ0FBMEM7QUFDckQsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGdCQUFnQjtBQUNoQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0EsSUFBSSxtRUFBbUI7QUFDdkI7QUFDQTtBQUNBLE1BQU0scUVBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGdCQUFnQjtBQUNoQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBLEVBQUUsbUVBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLHFFQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLCtDQUErQztBQUMxRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLHdDQUF3QztBQUNuRCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsK0RBQWU7QUFDdkM7QUFDQTs7QUFFQSx3QkFBd0IsK0RBQWU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFlO0FBQ2xDLEVBQUUsbUVBQW1CO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLHNCQUFzQiwrREFBZSxDQUFDLGlEQUFLO0FBQzNDOztBQUVBLHVCQUF1QiwrREFBZSxDQUFDLGlEQUFLO0FBQzVDO0FBQ0EsRUFBRSxtRUFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxPQUFPO0FBQ2xCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQiwrREFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDLDBCQUEwQixrQ0FBa0M7QUFDNUQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxFQUFFLG1FQUFtQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSSxxRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsa0VBQUcsRUFBQzs7Ozs7Ozs7Ozs7OztBQzUxQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNvQztBQUNxQztBQUNWO0FBQ2hCO0FBQ1U7QUFDVjtBQUNJO0FBQ2Q7QUFDSTtBQUNPOztBQUVPOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywyREFBMkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQUs7QUFDeEIscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDJEQUFVO0FBQzdCLHFCQUFxQiw2Q0FBNkM7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFPO0FBQzFCLHFCQUFxQixvREFBb0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMkRBQVU7QUFDN0IscUJBQXFCLDZDQUE2QztBQUNsRTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdFQUFlO0FBQ2xDLHFCQUFxQixvREFBb0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFZO0FBQy9CLHFCQUFxQiwyREFBMkQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUVBQWtCO0FBQ3JDLHFCQUFxQiw2Q0FBNkM7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxxQkFBcUI7QUFDcEM7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsb0RBQW9EO0FBQ2pFLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUJBQW1CLGtCQUFrQjtBQUNyQyw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxvREFBb0Q7QUFDakUsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwyREFBMkQ7QUFDeEUsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLDZDQUE2QztBQUMxRCxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RCxlQUFlLDZDQUE2QztBQUM1RCxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdFQUFjO0FBQ3RDO0FBQ0E7O0FBRUEsd0JBQXdCLG1FQUFrQjtBQUMxQztBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLGdFQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMEJBQTBCLG1FQUFrQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFhO0FBQy9CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsbUNBQW1DO0FBQ2hELGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQU87QUFDdEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtRUFBa0I7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxtREFBTyxFQUFFLFNBQVM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQsYUFBYSxtQ0FBbUM7QUFDaEQsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7O0FBRTNCLFdBQVcsZ0ZBQTRCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hELGNBQWMsa0RBQWtEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsb0RBQWE7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsb0NBQW9DO0FBQ2pELGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSxvQ0FBb0M7QUFDakQsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1FQUFrQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSxvQ0FBb0M7QUFDakQsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGdGQUE0QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxrRUFBRyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDNzVCbkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNvQztBQUMyQjtBQUNoQjtBQUNVO0FBQ1Y7QUFDSTtBQUNkO0FBQ0k7QUFDRTtBQUNlOztBQUUxRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXLHNEQUFLO0FBQ2hCLGdCQUFnQiwyREFBVTtBQUMxQixhQUFhLHdEQUFPO0FBQ3BCLGdCQUFnQiwyREFBVTtBQUMxQixxQkFBcUIsZ0VBQWU7QUFDcEMsa0JBQWtCLDZEQUFZO0FBQzlCOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLGNBQWM7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztB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VUFBSTVDLE9BQU8sR0FBRyxLQUFLdEYsTUFBTCxDQUFZUSxVQUFaLENBQXVCNEcsU0FBdkIsR0FBbUMrRCxjQUFuQyxDQUFrRGpELEVBQWxELENBQWQ7O0FBQ0EsVUFBRzVDLE9BQU8sS0FBSyxJQUFmLEVBQW9CO0FBQ2hCLGFBQUt3RCxRQUFMLENBQWMsU0FBZDtBQUNILE9BRkQsTUFFSztBQUNELGFBQUt0RCxhQUFMLENBQW1CRixPQUFuQjtBQUNIO0FBQ0o7QUExYUc7QUF2Q0csQ0FBZixFOzs7Ozs7Ozs7Ozs7QUN4RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFnRztBQUN2QztBQUNMO0FBQ3NDOzs7QUFHMUY7QUFDZ0c7QUFDaEcsZ0JBQWdCLDJHQUFVO0FBQzFCLEVBQUUsMkVBQU07QUFDUixFQUFFLDRGQUFNO0FBQ1IsRUFBRSxxR0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDZSxnRjs7Ozs7Ozs7Ozs7O0FDdkNmO0FBQUE7QUFBQSx3Q0FBMFMsQ0FBZ0Isc1VBQUcsRUFBQyxDOzs7Ozs7Ozs7Ozs7QUNBOVQ7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJmaWxlIjoianMvNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiaW5kZXgtcGFnZVwiPlxyXG4gICAgICAgIDx2YW4tbmF2LWJhciB0aXRsZT1cIueOr+S/neeggeWcsOWbvlwiIGxlZnQtYXJyb3cgZml4ZWQgQGNsaWNrLWxlZnQ9XCIkcm91dGVyLmdvKC0xKVwiIHJpZ2h0LXRleHQ9XCLlm57liLDlrprkvY1cIiBAY2xpY2stcmlnaHQ9XCJvbkJhY2tMb2FjdGlvblwiPjwvdmFuLW5hdi1iYXI+XHJcbiAgICAgICAgPHZhbi1sb2FkaW5nIHYtaWY9XCJsb2FkaW5nXCIgc2l6ZT1cIjI0cHhcIiBjb2xvcj1cIiMwMDk0ZmZcIiB2ZXJ0aWNhbCBjbGFzcz1cIm1hc2tcIj7mlbDmja7liqDovb3kuK0uLi48L3Zhbi1sb2FkaW5nPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJXcmFwcGVyXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYXBIZWFkZXIgc2VhcmNoSW5wdXRcIj5cclxuICAgICAgICAgICAgICAgIDx2YW4tY2hlY2tib3gtZ3JvdXAgdi1tb2RlbD1cImhibVwiIHN0eWxlPVwibWFyZ2luLWxlZnQ6IDEwcHg7d2lkdGg6Y2FsYyg1MCUgLSAxMHB4KTtcIiBkaXJlY3Rpb249XCJob3Jpem9udGFsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHZhbi1jaGVja2JveCBuYW1lPVwiMVwiIHNoYXBlPVwic3F1YXJlXCIgaWNvbi1zaXplPVwiMTJweFwiPue7v+eggTwvdmFuLWNoZWNrYm94PlxyXG4gICAgICAgICAgICAgICAgICAgIDx2YW4tY2hlY2tib3ggbmFtZT1cIjJcIiBzaGFwZT1cInNxdWFyZVwiIGljb24tc2l6ZT1cIjEycHhcIj7pu4TnoIE8L3Zhbi1jaGVja2JveD5cclxuICAgICAgICAgICAgICAgICAgICA8dmFuLWNoZWNrYm94IG5hbWU9XCIzXCIgc2hhcGU9XCJzcXVhcmVcIiBpY29uLXNpemU9XCIxMnB4XCI+57qi56CBPC92YW4tY2hlY2tib3g+XHJcbiAgICAgICAgICAgICAgICA8L3Zhbi1jaGVja2JveC1ncm91cD5cclxuICAgICAgICAgICAgICAgIDx2YW4tc2VhcmNoIHYtbW9kZWw9XCJuYW1lXCIgc2l6ZT1cInNtYWxsXCIgc2hhcGU9XCJyb3VuZFwiICBpbnB1dC1hbGlnbj1cImNlbnRlclwiIHBsYWNlaG9sZGVyPVwi6K+36L6T5YWl5YWz6ZSu5a2XL+agh+etvlwiIHN0eWxlPVwid2lkdGg6NTAlO1wiIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZXRhaWxDb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYXBEaXZcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPVwibWFwXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtoZWlnaHQ6IDEwMCU7XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxlZ2VuZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJAL2Fzc2V0cy9jb2RlL+e7v+eggS5wbmdcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPue7v+eggTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIkAvYXNzZXRzL2NvZGUv6buE56CBLnBuZ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+6buE56CBPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiQC9hc3NldHMvY29kZS/nuqLnoIEucG5nXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj7nuqLnoIE8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWFwQ2FyZFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbWFwSXRlbXMnIHYtZm9yPVwiaXRlbSBpbiBsaXN0RGF0YVwiID5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSd0aXRsZSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPSdAL2Fzc2V0cy9jb2RlL+WcsOWdgC5wbmcnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBAY2xpY2s9XCJzaG93RGV0YWlscyhpdGVtKVwiPnt7aXRlbS53cnltY319PC9zcGFuPlxyXG48IS0tICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9J0AvYXNzZXRzL2NvZGUv5a+86IiqLnBuZycgc3R5bGU9J21hcmdpbi1sZWZ0OiAyMHB4O2N1cnNvcjogcG9pbnRlcjsnIEBjbGljaz1cInNob3dQb2ludChpdGVtKVwiPi0tPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPueOr+S/neegge+8mjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gOnN0eWxlPVwiZ2V0Q29sb3IoaXRlbS5xcl9jb2RlX2NvbG9yKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tpdGVtLnFyX2NvZGVfY29sb3IgPT09ICfnu7/oibInID8gJ+e7v+eggScgOiBpdGVtLnFyX2NvZGVfY29sb3IgPT09ICfpu4ToibInID8gJ+m7hOeggScgOiBpdGVtLnFyX2NvZGVfY29sb3IgPT09ICfnuqLoibInID8gJ+e6oueggScgOiAnLSd9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+6IGU57O75pa55byP77yae3tpdGVtLmx4cmRofX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+5Zyw5Z2A77yae3tpdGVtLnN6ZHp9fTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuICAgIGltcG9ydCB7IHF1ZXJ5V1JZTWFwIH0gZnJvbSAnQC9hcGkvaW5kZXgnO1xyXG4gICAgaW1wb3J0IG9sTWFwIGZyb20gXCJAL3V0aWxzL29sTWFwXCI7XHJcbiAgICBpbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XHJcbiAgICBjb25zdCBhcmNnaXNNYXBTZXJ2ZXIgPSBcImh0dHA6Ly8xMC4yMjEuMjkuNDo4MDgwL09uZU1hcFNlcnZlci9yZXN0L3NlcnZpY2VzL1hfS21XcnlEYXNqZ2pmd19WNC9NYXBTZXJ2ZXJcIjtcclxuICAgIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgICAgICBuYW1lOiBcIm1hcE1uZ1wiLFxyXG4gICAgICAgIG1peGluczogW29sTWFwXSxcclxuICAgICAgICBkYXRhICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxyXG4gICAgICAgICAgICAgICAgaGJtOiBbJzInLCczJ10sXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6ICd1cCcsXHJcbiAgICAgICAgICAgICAgICBsaXN0RGF0YTogW10sXHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXRjaDoge1xyXG4gICAgICAgICAgICAnJHN0b3JlLnN0YXRlLnBvaW50TmFtZScoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLiRzdG9yZS5zdGF0ZS5wb2ludE5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5TWFwUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdoYm0nKCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5TWFwUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICduYW1lJygpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5uYW1lID09PSAnJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlYXJjaCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5TWFwUG9pbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzeW5jIG1vdW50ZWQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBbXHJcbiAgICAgICAgICAgICAgICB0aGlzLiRyb3V0ZS5xdWVyeS5sb25naXR1ZGUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLiRyb3V0ZS5xdWVyeS5sYXRpdHVkZSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgdGhpcy5nZXRNYXBTZXJ2ZXIoKS50aGVuKChzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT57XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0TWFwKHNlcnZlcix0aGlzLiRyZWZzLm1hcCx0aGlzLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDaXJjbGUodGhpcy5sb2NhdGlvbiwgNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeU1hcFBvaW50cygpO1xyXG4gICAgICAgICAgICAgICAgfSwzMDApO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICAgIGdldE1hcFNlcnZlcigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aW9zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFyY2dpc01hcFNlcnZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmOiBcInBqc29uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtYXBfdG9rZW5cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldENvbG9yKHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZSA9PT0gJ+e6ouiJsicpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnY29sb3I6cmVkJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlID09PSAn6buE6ImyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvcjojRkZDNDIwJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlID09PSAn57u/6ImyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvcjojM0ZDNzVGJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjb2xvcjogI2VlZWVlZSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2hvd0RldGFpbHMoZGF0YSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTonY29tcGFueURldGFpbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGRhdGEucXJfY29kZV9jb2xvciA9PT0gJ+e6ouiJsicgPyAncmVkJyA6IGRhdGEucXJfY29kZV9jb2xvciA9PT0gJ+m7hOiJsicgPyAneWVsbG93JyA6IGRhdGEucXJfY29kZV9jb2xvciA9PT0gJ+e7v+iJsicgPyAnZ3JlZW4nIDogJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbGVhclNlYXJjaCgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0QnlBdHRyaWJ1dGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFuVG9Db29yZGluYXRlKFsxMDIuODI3OTc3ODY5MzMxNDIsIDI0Ljg5MTA2Nzc3NDM3Mjc5XSxmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5TWFwUG9pbnRzKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHF1ZXJ5TWFwUG9pbnRzKCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aXNpb25fY29kZTogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5oYm0udG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5V1JZTWFwKHBhcmFtcykudGhlbihyZXMgPT57XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmVzLmNvZGUgPT09ICcyMDAnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0RGF0YSA9IHJlcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8cmVzLmRhdGEubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXMuZGF0YVtpXS5xcl9jb2RlX2NvbG9yICE9PSAnJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocmVzLmRhdGFbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQb2ludHMocG9pbnRzLCfnjq/kv53noIEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5maW5hbGx5KGEgPT57XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaG93UG9pbnQoaW5mbyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRGZWF0dXJlQnlJZChpbmZvLmlkKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL+WbnuWIsOWumuS9jVxyXG4gICAgICAgICAgICBvbkJhY2tMb2FjdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYW5Ub0Nvb3JkaW5hdGUodGhpcy5sb2NhdGlvbiw5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XHJcbiAgICAuaW5kZXgtcGFnZSB7XHJcbiAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNTBweCk7XHJcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcclxuICAgICAgICBwYWRkaW5nLXRvcDogNTBweDtcclxuXHJcbiAgICAgICAgLmhlYWRlcldyYXBwZXIge1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgaGVpZ2h0OiA1NXB4O1xyXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogNDVweDtcclxuXHJcbiAgICAgICAgICAgIC5tYXBIZWFkZXIge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAgYXV0bztcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDU1cHg7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLm1hcEhlYWRlciA+IGlucHV0IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4MCU7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDM1cHg7XHJcbiAgICAgICAgICAgICAgICBib3JkZXItbGVmdDogMDtcclxuICAgICAgICAgICAgICAgIGJvcmRlci10b3A6IDA7XHJcbiAgICAgICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2VlZWVlZTtcclxuICAgICAgICAgICAgICAgIHRleHQtaW5kZW50OiA4cHg7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3ZjdcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLmRldGFpbENvbnRlbnQge1xyXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA1NXB4KTtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcclxuICAgICAgICAgICAgLm1hcERpdiB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwMHB4O1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuICAgICAgICAgICAgICAgIC5sZWdlbmQge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMzVweDtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IDExMHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgICAgICB6LWluZGV4OiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxODBweDtcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogNXB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMCAxMHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCA2cHggMnB4IHJnYmEoMCwwLDAsMC4wOSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC5tYXBDYXJkIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY2FsYygxMDAlIC0gMzAwcHgpO1xyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcclxuICAgICAgICAgICAgICAgIC5tYXBJdGVtcyB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDg1JTtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDExNXB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAycHggcmdiYSgwLCAwLCAwLCAwLjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICNmZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAxMHB4IGF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTBweCAyMHB4IDE1cHggMjBweDtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBncmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgLnRpdGxlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAzNXB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAudGl0bGU+c3BhbiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC50aXRsZT5pbWcge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDVweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxNXB4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbjwvc3R5bGU+XHJcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJpbmRleC1wYWdlXCIgfSxcbiAgICBbXG4gICAgICBfYyhcInZhbi1uYXYtYmFyXCIsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB0aXRsZTogXCLnjq/kv53noIHlnLDlm75cIixcbiAgICAgICAgICBcImxlZnQtYXJyb3dcIjogXCJcIixcbiAgICAgICAgICBmaXhlZDogXCJcIixcbiAgICAgICAgICBcInJpZ2h0LXRleHRcIjogXCLlm57liLDlrprkvY1cIixcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcImNsaWNrLWxlZnRcIjogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF92bS4kcm91dGVyLmdvKC0xKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjbGljay1yaWdodFwiOiBfdm0ub25CYWNrTG9hY3Rpb24sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIF92bS5sb2FkaW5nXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcInZhbi1sb2FkaW5nXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1hc2tcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgc2l6ZTogXCIyNHB4XCIsIGNvbG9yOiBcIiMwMDk0ZmZcIiwgdmVydGljYWw6IFwiXCIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl92KFwi5pWw5o2u5Yqg6L295LitLi4uXCIpXVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiaGVhZGVyV3JhcHBlclwiIH0sIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1hcEhlYWRlciBzZWFyY2hJbnB1dFwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwidmFuLWNoZWNrYm94LWdyb3VwXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNTdHlsZToge1xuICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjEwcHhcIixcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBcImNhbGMoNTAlIC0gMTBweClcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIgfSxcbiAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5oYm0sXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCQkdikge1xuICAgICAgICAgICAgICAgICAgICBfdm0uaGJtID0gJCR2XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJoYm1cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcInZhbi1jaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBuYW1lOiBcIjFcIiwgc2hhcGU6IFwic3F1YXJlXCIsIFwiaWNvbi1zaXplXCI6IFwiMTJweFwiIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW192bS5fdihcIue7v+eggVwiKV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJ2YW4tY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgbmFtZTogXCIyXCIsIHNoYXBlOiBcInNxdWFyZVwiLCBcImljb24tc2l6ZVwiOiBcIjEycHhcIiB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCLpu4TnoIFcIildXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwidmFuLWNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IG5hbWU6IFwiM1wiLCBzaGFwZTogXCJzcXVhcmVcIiwgXCJpY29uLXNpemVcIjogXCIxMnB4XCIgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl92KFwi57qi56CBXCIpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfYyhcInZhbi1zZWFyY2hcIiwge1xuICAgICAgICAgICAgICBzdGF0aWNTdHlsZTogeyB3aWR0aDogXCI1MCVcIiB9LFxuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgICAgICAgICAgICBzaGFwZTogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIFwiaW5wdXQtYWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCLor7fovpPlhaXlhbPplK7lrZcv5qCH562+XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IF92bS5uYW1lLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoJCR2KSB7XG4gICAgICAgICAgICAgICAgICBfdm0ubmFtZSA9ICQkdlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJuYW1lXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkZXRhaWxDb250ZW50XCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1hcERpdlwiIH0sIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHJlZjogXCJtYXBcIiwgc3RhdGljU3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0gfSxcbiAgICAgICAgICAgIFtfdm0uX20oMCldXG4gICAgICAgICAgKSxcbiAgICAgICAgXSksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtYXBDYXJkXCIgfSxcbiAgICAgICAgICBfdm0uX2woX3ZtLmxpc3REYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWFwSXRlbXNcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGl0bGVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgc3JjOiByZXF1aXJlKFwiQC9hc3NldHMvY29kZS/lnLDlnYAucG5nXCIpIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5zaG93RGV0YWlscyhpdGVtKVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MoaXRlbS53cnltYykpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCBbXG4gICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIFtfdm0uX3YoXCLnjq/kv53noIHvvJpcIildKSxcbiAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdHlsZTogX3ZtLmdldENvbG9yKGl0ZW0ucXJfY29kZV9jb2xvcikgfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5xcl9jb2RlX2NvbG9yID09PSBcIue7v+iJslwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gXCLnu7/noIFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0ucXJfY29kZV9jb2xvciA9PT0gXCLpu4ToibJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwi6buE56CBXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLnFyX2NvZGVfY29sb3IgPT09IFwi57qi6ImyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIue6oueggVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogXCItXCJcbiAgICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCBbX3ZtLl92KFwi6IGU57O75pa55byP77yaXCIgKyBfdm0uX3MoaXRlbS5seHJkaCkpXSksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCBbX3ZtLl92KFwi5Zyw5Z2A77yaXCIgKyBfdm0uX3MoaXRlbS5zemR6KSldKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgMFxuICAgICAgICApLFxuICAgICAgXSksXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImxlZ2VuZFwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIFtcbiAgICAgICAgX2MoXCJpbWdcIiwgeyBhdHRyczogeyBzcmM6IHJlcXVpcmUoXCJAL2Fzc2V0cy9jb2RlL+e7v+eggS5wbmdcIikgfSB9KSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIFtfdm0uX3YoXCLnu7/noIFcIildKSxcbiAgICAgIF0pLFxuICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICBfYyhcImltZ1wiLCB7IGF0dHJzOiB7IHNyYzogcmVxdWlyZShcIkAvYXNzZXRzL2NvZGUv6buE56CBLnBuZ1wiKSB9IH0pLFxuICAgICAgICBfYyhcInNwYW5cIiwgW192bS5fdihcIum7hOeggVwiKV0pLFxuICAgICAgXSksXG4gICAgICBfYyhcImRpdlwiLCBbXG4gICAgICAgIF9jKFwiaW1nXCIsIHsgYXR0cnM6IHsgc3JjOiByZXF1aXJlKFwiQC9hc3NldHMvY29kZS/nuqLnoIEucG5nXCIpIH0gfSksXG4gICAgICAgIF9jKFwic3BhblwiLCBbX3ZtLl92KFwi57qi56CBXCIpXSksXG4gICAgICBdKSxcbiAgICBdKVxuICB9LFxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCxcXG46aG9zdCB7XFxuICAtLW9sLWJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgLS1vbC1hY2NlbnQtYmFja2dyb3VuZC1jb2xvcjogI0Y1RjVGNTtcXG4gIC0tb2wtc3VidGxlLWJhY2tncm91bmQtY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC4yNSk7XFxuICAtLW9sLXBhcnRpYWwtYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcXG4gIC0tb2wtZm9yZWdyb3VuZC1jb2xvcjogIzMzMzMzMztcXG4gIC0tb2wtc3VidGxlLWZvcmVncm91bmQtY29sb3I6ICM2NjY2NjY7XFxuICAtLW9sLWJyYW5kLWNvbG9yOiAjMDBBQUZGO1xcbn1cXG5cXG4ub2wtYm94IHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBib3JkZXI6IDEuNXB4IHNvbGlkIHZhcigtLW9sLWJhY2tncm91bmQtY29sb3IpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tb2wtcGFydGlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcXG59XFxuXFxuLm9sLW1vdXNlLXBvc2l0aW9uIHtcXG4gIHRvcDogOHB4O1xcbiAgcmlnaHQ6IDhweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLm9sLXNjYWxlLWxpbmUge1xcbiAgYmFja2dyb3VuZDogdmFyKC0tb2wtcGFydGlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJvdHRvbTogOHB4O1xcbiAgbGVmdDogOHB4O1xcbiAgcGFkZGluZzogMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4ub2wtc2NhbGUtbGluZS1pbm5lciB7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1vbC1zdWJ0bGUtZm9yZWdyb3VuZC1jb2xvcik7XFxuICBib3JkZXItdG9wOiBub25lO1xcbiAgY29sb3I6IHZhcigtLW9sLWZvcmVncm91bmQtY29sb3IpO1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbWFyZ2luOiAxcHg7XFxuICB3aWxsLWNoYW5nZTogY29udGVudHMsIHdpZHRoO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuMjVzO1xcbn1cXG5cXG4ub2wtc2NhbGUtYmFyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogOHB4O1xcbiAgbGVmdDogOHB4O1xcbn1cXG5cXG4ub2wtc2NhbGUtYmFyLWlubmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5vbC1zY2FsZS1zdGVwLW1hcmtlciB7XFxuICB3aWR0aDogMXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tb2wtZm9yZWdyb3VuZC1jb2xvcik7XFxuICBmbG9hdDogcmlnaHQ7XFxuICB6LWluZGV4OiAxMDtcXG59XFxuXFxuLm9sLXNjYWxlLXN0ZXAtdGV4dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IC01cHg7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICB6LWluZGV4OiAxMTtcXG4gIGNvbG9yOiB2YXIoLS1vbC1mb3JlZ3JvdW5kLWNvbG9yKTtcXG4gIHRleHQtc2hhZG93OiAtMS41cHggMCB2YXIoLS1vbC1wYXJ0aWFsLWJhY2tncm91bmQtY29sb3IpLCAwIDEuNXB4IHZhcigtLW9sLXBhcnRpYWwtYmFja2dyb3VuZC1jb2xvciksIDEuNXB4IDAgdmFyKC0tb2wtcGFydGlhbC1iYWNrZ3JvdW5kLWNvbG9yKSwgMCAtMS41cHggdmFyKC0tb2wtcGFydGlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcXG59XFxuXFxuLm9sLXNjYWxlLXRleHQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm90dG9tOiAyNXB4O1xcbiAgY29sb3I6IHZhcigtLW9sLWZvcmVncm91bmQtY29sb3IpO1xcbiAgdGV4dC1zaGFkb3c6IC0xLjVweCAwIHZhcigtLW9sLXBhcnRpYWwtYmFja2dyb3VuZC1jb2xvciksIDAgMS41cHggdmFyKC0tb2wtcGFydGlhbC1iYWNrZ3JvdW5kLWNvbG9yKSwgMS41cHggMCB2YXIoLS1vbC1wYXJ0aWFsLWJhY2tncm91bmQtY29sb3IpLCAwIC0xLjVweCB2YXIoLS1vbC1wYXJ0aWFsLWJhY2tncm91bmQtY29sb3IpO1xcbn1cXG5cXG4ub2wtc2NhbGUtc2luZ2xlYmFyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMTBweDtcXG4gIHotaW5kZXg6IDk7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tb2wtZm9yZWdyb3VuZC1jb2xvcik7XFxufVxcblxcbi5vbC1zY2FsZS1zaW5nbGViYXItZXZlbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1vbC1zdWJ0bGUtZm9yZWdyb3VuZC1jb2xvcik7XFxufVxcblxcbi5vbC1zY2FsZS1zaW5nbGViYXItb2RkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW9sLWJhY2tncm91bmQtY29sb3IpO1xcbn1cXG5cXG4ub2wtdW5zdXBwb3J0ZWQge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLm9sLXZpZXdwb3J0LFxcbi5vbC11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4ub2wtdmlld3BvcnQgY2FudmFzIHtcXG4gIGFsbDogdW5zZXQ7XFxufVxcblxcbi5vbC1zZWxlY3RhYmxlIHtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogZGVmYXVsdDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAtbW96LXVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgLW1zLXVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbn1cXG5cXG4ub2wtZ3JhYmJpbmcge1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcbiAgY3Vyc29yOiBncmFiYmluZztcXG59XFxuXFxuLm9sLWdyYWIge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxuICBjdXJzb3I6IGdyYWI7XFxufVxcblxcbi5vbC1jb250cm9sIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW9sLXN1YnRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG59XFxuXFxuLm9sLXpvb20ge1xcbiAgdG9wOiAuNWVtO1xcbiAgbGVmdDogLjVlbTtcXG59XFxuXFxuLm9sLXJvdGF0ZSB7XFxuICB0b3A6IC41ZW07XFxuICByaWdodDogLjVlbTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjI1cyBsaW5lYXIsIHZpc2liaWxpdHkgMHMgbGluZWFyO1xcbn1cXG5cXG4ub2wtcm90YXRlLm9sLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMjVzIGxpbmVhciwgdmlzaWJpbGl0eSAwcyBsaW5lYXIgLjI1cztcXG59XFxuXFxuLm9sLXpvb20tZXh0ZW50IHtcXG4gIHRvcDogNC42NDNlbTtcXG4gIGxlZnQ6IC41ZW07XFxufVxcblxcbi5vbC1mdWxsLXNjcmVlbiB7XFxuICByaWdodDogLjVlbTtcXG4gIHRvcDogLjVlbTtcXG59XFxuXFxuLm9sLWNvbnRyb2wgYnV0dG9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luOiAxcHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgY29sb3I6IHZhcigtLW9sLXN1YnRsZS1mb3JlZ3JvdW5kLWNvbG9yKTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgaGVpZ2h0OiAxLjM3NWVtO1xcbiAgd2lkdGg6IDEuMzc1ZW07XFxuICBsaW5lLWhlaWdodDogLjRlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW9sLWJhY2tncm91bmQtY29sb3IpO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbn1cXG5cXG4ub2wtY29udHJvbCBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLm9sLXpvb20tZXh0ZW50IGJ1dHRvbiB7XFxuICBsaW5lLWhlaWdodDogMS40ZW07XFxufVxcblxcbi5vbC1jb21wYXNzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxufVxcblxcbi5vbC10b3VjaCAub2wtY29udHJvbCBidXR0b24ge1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuXFxuLm9sLXRvdWNoIC5vbC16b29tLWV4dGVudCB7XFxuICB0b3A6IDUuNWVtO1xcbn1cXG5cXG4ub2wtY29udHJvbCBidXR0b246aG92ZXIsXFxuLm9sLWNvbnRyb2wgYnV0dG9uOmZvY3VzIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS1vbC1zdWJ0bGUtZm9yZWdyb3VuZC1jb2xvcik7XFxuICBjb2xvcjogdmFyKC0tb2wtZm9yZWdyb3VuZC1jb2xvcik7XFxufVxcblxcbi5vbC16b29tIC5vbC16b29tLWluIHtcXG4gIGJvcmRlci1yYWRpdXM6IDJweCAycHggMCAwO1xcbn1cXG5cXG4ub2wtem9vbSAub2wtem9vbS1vdXQge1xcbiAgYm9yZGVyLXJhZGl1czogMCAwIDJweCAycHg7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbiB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvdHRvbTogLjVlbTtcXG4gIHJpZ2h0OiAuNWVtO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSAxLjNlbSk7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1mbG93OiByb3ctcmV2ZXJzZTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbiBhIHtcXG4gIGNvbG9yOiB2YXIoLS1vbC1zdWJ0bGUtZm9yZWdyb3VuZC1jb2xvcik7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbiB1bCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAxcHggLjVlbTtcXG4gIGNvbG9yOiB2YXIoLS1vbC1mb3JlZ3JvdW5kLWNvbG9yKTtcXG4gIHRleHQtc2hhZG93OiAwIDAgMnB4IHZhcigtLW9sLWJhY2tncm91bmQtY29sb3IpO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbn1cXG5cXG4ub2wtYXR0cmlidXRpb24gbGkge1xcbiAgZGlzcGxheTogaW5saW5lO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLm9sLWF0dHJpYnV0aW9uIGxpOm5vdCg6bGFzdC1jaGlsZCk6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbn1cXG5cXG4ub2wtYXR0cmlidXRpb24gaW1nIHtcXG4gIG1heC1oZWlnaHQ6IDJlbTtcXG4gIG1heC13aWR0aDogaW5oZXJpdDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbiBidXR0b24ge1xcbiAgZmxleC1zaHJpbms6IDA7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbi5vbC1jb2xsYXBzZWQgdWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLm9sLWF0dHJpYnV0aW9uOm5vdCgub2wtY29sbGFwc2VkKSB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1vbC1wYXJ0aWFsLWJhY2tncm91bmQtY29sb3IpO1xcbn1cXG5cXG4ub2wtYXR0cmlidXRpb24ub2wtdW5jb2xsYXBzaWJsZSB7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweCAwIDA7XFxufVxcblxcbi5vbC1hdHRyaWJ1dGlvbi5vbC11bmNvbGxhcHNpYmxlIGltZyB7XFxuICBtYXJnaW4tdG9wOiAtLjJlbTtcXG4gIG1heC1oZWlnaHQ6IDEuNmVtO1xcbn1cXG5cXG4ub2wtYXR0cmlidXRpb24ub2wtdW5jb2xsYXBzaWJsZSBidXR0b24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLm9sLXpvb21zbGlkZXIge1xcbiAgdG9wOiA0LjVlbTtcXG4gIGxlZnQ6IC41ZW07XFxuICBoZWlnaHQ6IDIwMHB4O1xcbn1cXG5cXG4ub2wtem9vbXNsaWRlciBidXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbn1cXG5cXG4ub2wtdG91Y2ggLm9sLXpvb21zbGlkZXIge1xcbiAgdG9wOiA1LjVlbTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwIHtcXG4gIGxlZnQ6IDAuNWVtO1xcbiAgYm90dG9tOiAwLjVlbTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwLm9sLXVuY29sbGFwc2libGUge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDAgNHB4IDAgMDtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwIC5vbC1vdmVydmlld21hcC1tYXAsXFxuLm9sLW92ZXJ2aWV3bWFwIGJ1dHRvbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwIC5vbC1vdmVydmlld21hcC1tYXAge1xcbiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tb2wtc3VidGxlLWZvcmVncm91bmQtY29sb3IpO1xcbiAgaGVpZ2h0OiAxNTBweDtcXG4gIHdpZHRoOiAxNTBweDtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwOm5vdCgub2wtY29sbGFwc2VkKSBidXR0b24ge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwLm9sLWNvbGxhcHNlZCAub2wtb3ZlcnZpZXdtYXAtbWFwLFxcbi5vbC1vdmVydmlld21hcC5vbC11bmNvbGxhcHNpYmxlIGJ1dHRvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4ub2wtb3ZlcnZpZXdtYXA6bm90KC5vbC1jb2xsYXBzZWQpIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLW9sLXN1YnRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwLWJveCB7XFxuICBib3JkZXI6IDEuNXB4IGRvdHRlZCB2YXIoLS1vbC1zdWJ0bGUtZm9yZWdyb3VuZC1jb2xvcik7XFxufVxcblxcbi5vbC1vdmVydmlld21hcCAub2wtb3ZlcnZpZXdtYXAtYm94OmhvdmVyIHtcXG4gIGN1cnNvcjogbW92ZTtcXG59XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaW5kZXgtcGFnZVtkYXRhLXYtYTliYTdlZDRdIHtcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDUwcHgpO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIHBhZGRpbmctdG9wOiA1MHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuaGVhZGVyV3JhcHBlcltkYXRhLXYtYTliYTdlZDRdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiA1NXB4O1xcbiAgbGluZS1oZWlnaHQ6IDQ1cHg7XFxufVxcbi5pbmRleC1wYWdlIC5oZWFkZXJXcmFwcGVyIC5tYXBIZWFkZXJbZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGhlaWdodDogNTVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uaW5kZXgtcGFnZSAuaGVhZGVyV3JhcHBlciAubWFwSGVhZGVyID4gaW5wdXRbZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICB3aWR0aDogODAlO1xcbiAgaGVpZ2h0OiAzNXB4O1xcbiAgYm9yZGVyLWxlZnQ6IDA7XFxuICBib3JkZXItdG9wOiAwO1xcbiAgYm9yZGVyLWJvdHRvbTogMDtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNlZWVlZWU7XFxuICB0ZXh0LWluZGVudDogOHB4O1xcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjdmN2Y3O1xcbn1cXG4uaW5kZXgtcGFnZSAuZGV0YWlsQ29udGVudFtkYXRhLXYtYTliYTdlZDRdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSA1NXB4KTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxufVxcbi5pbmRleC1wYWdlIC5kZXRhaWxDb250ZW50IC5tYXBEaXZbZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICBoZWlnaHQ6IDMwMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG59XFxuLmluZGV4LXBhZ2UgLmRldGFpbENvbnRlbnQgLm1hcERpdiAubGVnZW5kW2RhdGEtdi1hOWJhN2VkNF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGhlaWdodDogMzVweDtcXG4gIHRvcDogMTEwcHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAxO1xcbiAgd2lkdGg6IDE4MHB4O1xcbiAgcmlnaHQ6IDVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgcGFkZGluZzogMCAxMHB4O1xcbiAgYm94LXNoYWRvdzogMCAwIDZweCAycHggcmdiYSgwLCAwLCAwLCAwLjA5KTtcXG59XFxuLmluZGV4LXBhZ2UgLmRldGFpbENvbnRlbnQgLm1hcERpdiAubGVnZW5kIGRpdltkYXRhLXYtYTliYTdlZDRdIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4uaW5kZXgtcGFnZSAuZGV0YWlsQ29udGVudCAubWFwRGl2IC5sZWdlbmQgaW1nW2RhdGEtdi1hOWJhN2VkNF0ge1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxufVxcbi5pbmRleC1wYWdlIC5kZXRhaWxDb250ZW50IC5tYXBDYXJkW2RhdGEtdi1hOWJhN2VkNF0ge1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgLSAzMDBweCk7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG4uaW5kZXgtcGFnZSAuZGV0YWlsQ29udGVudCAubWFwQ2FyZCAubWFwSXRlbXNbZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICB3aWR0aDogODUlO1xcbiAgaGVpZ2h0OiAxMTVweDtcXG4gIGJveC1zaGFkb3c6IDAgMCAycHggcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIG1hcmdpbjogMTBweCBhdXRvO1xcbiAgcGFkZGluZzogMTBweCAyMHB4IDE1cHggMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgZGlzcGxheTogZ3JpZDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxufVxcbi5pbmRleC1wYWdlIC5kZXRhaWxDb250ZW50IC5tYXBDYXJkIC5tYXBJdGVtcyAudGl0bGVbZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgaGVpZ2h0OiAzNXB4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLmluZGV4LXBhZ2UgLmRldGFpbENvbnRlbnQgLm1hcENhcmQgLm1hcEl0ZW1zIC50aXRsZSA+IHNwYW5bZGF0YS12LWE5YmE3ZWQ0XSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmluZGV4LXBhZ2UgLmRldGFpbENvbnRlbnQgLm1hcENhcmQgLm1hcEl0ZW1zIC50aXRsZSA+IGltZ1tkYXRhLXYtYTliYTdlZDRdIHtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbn1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdFxuICovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBFc3JpSlNPTn0gZnJvbSAnLi9mb3JtYXQvRXNyaUpTT04uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdlb0pTT059IGZyb20gJy4vZm9ybWF0L0dlb0pTT04uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdNTH0gZnJvbSAnLi9mb3JtYXQvR01MLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBHUFh9IGZyb20gJy4vZm9ybWF0L0dQWC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgSUdDfSBmcm9tICcuL2Zvcm1hdC9JR0MuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIElJSUZJbmZvfSBmcm9tICcuL2Zvcm1hdC9JSUlGSW5mby5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS01MfSBmcm9tICcuL2Zvcm1hdC9LTUwuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1WVH0gZnJvbSAnLi9mb3JtYXQvTVZULmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBPV1N9IGZyb20gJy4vZm9ybWF0L09XUy5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUG9seWxpbmV9IGZyb20gJy4vZm9ybWF0L1BvbHlsaW5lLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBUb3BvSlNPTn0gZnJvbSAnLi9mb3JtYXQvVG9wb0pTT04uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdGU30gZnJvbSAnLi9mb3JtYXQvV0ZTLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXS0J9IGZyb20gJy4vZm9ybWF0L1dLQi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgV0tUfSBmcm9tICcuL2Zvcm1hdC9XS1QuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdNU0NhcGFiaWxpdGllc30gZnJvbSAnLi9mb3JtYXQvV01TQ2FwYWJpbGl0aWVzLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBXTVNHZXRGZWF0dXJlSW5mb30gZnJvbSAnLi9mb3JtYXQvV01TR2V0RmVhdHVyZUluZm8uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdNVFNDYXBhYmlsaXRpZXN9IGZyb20gJy4vZm9ybWF0L1dNVFNDYXBhYmlsaXRpZXMuanMnO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9HTUxcbiAqL1xuaW1wb3J0IEdNTDMgZnJvbSAnLi9HTUwzLmpzJztcblxuLyoqXG4gKiBGZWF0dXJlIGZvcm1hdCBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBkYXRhIGluIHRoZSBHTUwgZm9ybWF0XG4gKiB2ZXJzaW9uIDMuMS4xLlxuICogQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgR01MIDMuMS4xIFNpbXBsZSBGZWF0dXJlcyBwcm9maWxlLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtpbXBvcnQoXCIuL0dNTEJhc2UuanNcIikuT3B0aW9uc30gW29wdGlvbnNdXG4gKiAgICAgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAYXBpXG4gKi9cbmNvbnN0IEdNTCA9IEdNTDM7XG5cbi8qKlxuICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIEdNTCAzLjEuMSBTaW1wbGUgRmVhdHVyZXMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0LlxuICogQGFwaVxuICovXG5HTUwucHJvdG90eXBlLndyaXRlRmVhdHVyZXM7XG5cbi8qKlxuICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIHRoZSBHTUwgMy4xLjEgZm9ybWF0IGFzIGFuIFhNTCBub2RlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gKiBAcmV0dXJuIHtOb2RlfSBOb2RlLlxuICogQGFwaVxuICovXG5HTUwucHJvdG90eXBlLndyaXRlRmVhdHVyZXNOb2RlO1xuXG5leHBvcnQgZGVmYXVsdCBHTUw7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0dNTDJcbiAqL1xuaW1wb3J0IEdNTEJhc2UsIHtHTUxOU30gZnJvbSAnLi9HTUxCYXNlLmpzJztcbmltcG9ydCB7XG4gIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gIGNyZWF0ZUVsZW1lbnROUyxcbiAgZ2V0QWxsVGV4dENvbnRlbnQsXG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZUNoaWxkQXBwZW5kZXIsXG4gIG1ha2VSZXBsYWNlcixcbiAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5LFxuICBwdXNoUGFyc2VBbmRQb3AsXG4gIHB1c2hTZXJpYWxpemVBbmRQb3AsXG59IGZyb20gJy4uL3htbC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge1xuICB0cmFuc2Zvcm1FeHRlbnRXaXRoT3B0aW9ucyxcbiAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyxcbn0gZnJvbSAnLi9GZWF0dXJlLmpzJztcbmltcG9ydCB7d3JpdGVTdHJpbmdUZXh0Tm9kZX0gZnJvbSAnLi94c2QuanMnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3Qgc2NoZW1hTG9jYXRpb24gPVxuICBHTUxOUyArICcgaHR0cDovL3NjaGVtYXMub3Blbmdpcy5uZXQvZ21sLzIuMS4yL2ZlYXR1cmUueHNkJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBNVUxUSUdFT01FVFJZX1RPX01FTUJFUl9OT0RFTkFNRSA9IHtcbiAgJ011bHRpTGluZVN0cmluZyc6ICdsaW5lU3RyaW5nTWVtYmVyJyxcbiAgJ011bHRpQ3VydmUnOiAnY3VydmVNZW1iZXInLFxuICAnTXVsdGlQb2x5Z29uJzogJ3BvbHlnb25NZW1iZXInLFxuICAnTXVsdGlTdXJmYWNlJzogJ3N1cmZhY2VNZW1iZXInLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGZWF0dXJlIGZvcm1hdCBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBkYXRhIGluIHRoZSBHTUwgZm9ybWF0LFxuICogdmVyc2lvbiAyLjEuMi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdNTDIgZXh0ZW5kcyBHTUxCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HTUxCYXNlLmpzXCIpLk9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5GRUFUVVJFX0NPTExFQ1RJT05fUEFSU0VSU1tHTUxOU11bJ2ZlYXR1cmVNZW1iZXInXSA9IG1ha2VBcnJheVB1c2hlcihcbiAgICAgIHRoaXMucmVhZEZlYXR1cmVzSW50ZXJuYWxcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNjaGVtYUxvY2F0aW9uID0gb3B0aW9ucy5zY2hlbWFMb2NhdGlvblxuICAgICAgPyBvcHRpb25zLnNjaGVtYUxvY2F0aW9uXG4gICAgICA6IHNjaGVtYUxvY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcmVhZEZsYXRDb29yZGluYXRlcyhub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IHMgPSBnZXRBbGxUZXh0Q29udGVudChub2RlLCBmYWxzZSkucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuICAgIGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqLyAoXG4gICAgICBvYmplY3RTdGFja1swXVxuICAgICk7XG4gICAgY29uc3QgY29udGFpbmVyU3JzID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGxldCBheGlzT3JpZW50YXRpb24gPSAnZW51JztcbiAgICBpZiAoY29udGFpbmVyU3JzKSB7XG4gICAgICBjb25zdCBwcm9qID0gZ2V0UHJvamVjdGlvbihjb250YWluZXJTcnMpO1xuICAgICAgaWYgKHByb2opIHtcbiAgICAgICAgYXhpc09yaWVudGF0aW9uID0gcHJvai5nZXRBeGlzT3JpZW50YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29vcmRzR3JvdXBzID0gcy50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHNHcm91cHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgY29vcmRzID0gY29vcmRzR3JvdXBzW2ldLnNwbGl0KC8sKy8pO1xuICAgICAgY29uc3QgeCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICBjb25zdCB6ID0gY29vcmRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlRmxvYXQoY29vcmRzWzJdKSA6IDA7XG4gICAgICBpZiAoYXhpc09yaWVudGF0aW9uLnN1YnN0cigwLCAyKSA9PT0gJ2VuJykge1xuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaCh4LCB5LCB6KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKHksIHgsIHopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBFbnZlbG9wZS5cbiAgICovXG4gIHJlYWRCb3gobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW251bGxdLFxuICAgICAgdGhpcy5CT1hfUEFSU0VSU18sXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMV1bMF0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMV1bMV0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMV1bM10sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMV1bNF1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqL1xuICBpbm5lckJvdW5kYXJ5SXNQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSAqL1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5nID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5SSU5HX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBpZiAoZmxhdExpbmVhclJpbmcpIHtcbiAgICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59ICovXG4gICAgICAgIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICBmbGF0TGluZWFyUmluZ3MucHVzaChmbGF0TGluZWFyUmluZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqL1xuICBvdXRlckJvdW5kYXJ5SXNQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSAqL1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5nID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5SSU5HX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBpZiAoZmxhdExpbmVhclJpbmcpIHtcbiAgICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59ICovXG4gICAgICAgIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICBmbGF0TGluZWFyUmluZ3NbMF0gPSBmbGF0TGluZWFyUmluZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGNvbnN0XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub2RlTmFtZV0gTm9kZSBuYW1lLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH0gTm9kZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEdFT01FVFJZX05PREVfRkFDVE9SWV8odmFsdWUsIG9iamVjdFN0YWNrLCBub2RlTmFtZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBtdWx0aVN1cmZhY2UgPSBjb250ZXh0WydtdWx0aVN1cmZhY2UnXTtcbiAgICBjb25zdCBzdXJmYWNlID0gY29udGV4dFsnc3VyZmFjZSddO1xuICAgIGNvbnN0IG11bHRpQ3VydmUgPSBjb250ZXh0WydtdWx0aUN1cnZlJ107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbm9kZU5hbWUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICB2YWx1ZVxuICAgICAgKS5nZXRUeXBlKCk7XG4gICAgICBpZiAobm9kZU5hbWUgPT09ICdNdWx0aVBvbHlnb24nICYmIG11bHRpU3VyZmFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlTmFtZSA9ICdNdWx0aVN1cmZhY2UnO1xuICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ1BvbHlnb24nICYmIHN1cmZhY2UgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZU5hbWUgPSAnU3VyZmFjZSc7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnTXVsdGlMaW5lU3RyaW5nJyAmJiBtdWx0aUN1cnZlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGVOYW1lID0gJ011bHRpQ3VydmUnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlTmFtZSA9ICdFbnZlbG9wZSc7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJywgbm9kZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlRWxlbWVudChub2RlLCBmZWF0dXJlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGZpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoZmlkKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZmlkJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovIChmaWQpKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGZlYXR1cmVOUyA9IGNvbnRleHRbJ2ZlYXR1cmVOUyddO1xuICAgIGNvbnN0IGdlb21ldHJ5TmFtZSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnlOYW1lKCk7XG4gICAgaWYgKCFjb250ZXh0LnNlcmlhbGl6ZXJzKSB7XG4gICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzID0ge307XG4gICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzW2ZlYXR1cmVOU10gPSB7fTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGlmIChmZWF0dXJlLmhhc1Byb3BlcnRpZXMoKSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllcygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGtleSA9PSBnZW9tZXRyeU5hbWUgfHxcbiAgICAgICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpLmdldFNpbXBsaWZpZWRHZW9tZXRyeSkgPT09XG4gICAgICAgICAgICAgICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0LnNlcmlhbGl6ZXJzW2ZlYXR1cmVOU10pKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc2VyaWFsaXplcnNbZmVhdHVyZU5TXVtrZXldID0gbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUdlb21ldHJ5RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0LnNlcmlhbGl6ZXJzW2ZlYXR1cmVOU10pKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc2VyaWFsaXplcnNbZmVhdHVyZU5TXVtrZXldID1cbiAgICAgICAgICAgICAgICBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGl0ZW0ubm9kZSA9IG5vZGU7XG4gICAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovXG4gICAgICAoaXRlbSksXG4gICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzLFxuICAgICAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5KHVuZGVmaW5lZCwgZmVhdHVyZU5TKSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9iamVjdFN0YWNrLFxuICAgICAga2V5c1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IExpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZUN1cnZlT3JMaW5lU3RyaW5nKG5vZGUsIGdlb21ldHJ5LCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBzcnNOYW1lID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGlmIChub2RlLm5vZGVOYW1lICE9PSAnTGluZVN0cmluZ1NlZ21lbnQnICYmIHNyc05hbWUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNOYW1lJywgc3JzTmFtZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIG5vZGUubm9kZU5hbWUgPT09ICdMaW5lU3RyaW5nJyB8fFxuICAgICAgbm9kZS5ub2RlTmFtZSA9PT0gJ0xpbmVTdHJpbmdTZWdtZW50J1xuICAgICkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVzTm9kZV8obm9kZS5uYW1lc3BhY2VVUkkpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChjb29yZGluYXRlcyk7XG4gICAgICB0aGlzLndyaXRlQ29vcmRpbmF0ZXNfKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0N1cnZlJykge1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBjcmVhdGVFbGVtZW50TlMobm9kZS5uYW1lc3BhY2VVUkksICdzZWdtZW50cycpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzZWdtZW50cyk7XG4gICAgICB0aGlzLndyaXRlQ3VydmVTZWdtZW50c18oc2VnbWVudHMsIGdlb21ldHJ5LCBvYmplY3RTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSBsaW5lIExpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZUxpbmVTdHJpbmdPckN1cnZlTWVtYmVyKG5vZGUsIGxpbmUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLkdFT01FVFJZX05PREVfRkFDVE9SWV8obGluZSwgb2JqZWN0U3RhY2spO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB0aGlzLndyaXRlQ3VydmVPckxpbmVTdHJpbmcoY2hpbGQsIGxpbmUsIG9iamVjdFN0YWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVNdWx0aUN1cnZlT3JMaW5lU3RyaW5nKG5vZGUsIGdlb21ldHJ5LCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBoYXNaID0gY29udGV4dFsnaGFzWiddO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgY29uc3QgY3VydmUgPSBjb250ZXh0WydjdXJ2ZSddO1xuICAgIGlmIChzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IGdlb21ldHJ5LmdldExpbmVTdHJpbmdzKCk7XG4gICAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICAgIHtub2RlOiBub2RlLCBoYXNaOiBoYXNaLCBzcnNOYW1lOiBzcnNOYW1lLCBjdXJ2ZTogY3VydmV9LFxuICAgICAgdGhpcy5MSU5FU1RSSU5HT1JDVVJWRU1FTUJFUl9TRVJJQUxJWkVSUyxcbiAgICAgIHRoaXMuTVVMVElHRU9NRVRSWV9NRU1CRVJfTk9ERV9GQUNUT1JZXyxcbiAgICAgIGxpbmVzLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5RWxlbWVudChub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSAqLyAoXG4gICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICk7XG4gICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGl0ZW1bJ25vZGUnXSA9IG5vZGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdlb21ldHJ5KSkge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1FeHRlbnRXaXRoT3B0aW9ucyhcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICAgIChpdGVtKSxcbiAgICAgIHRoaXMuR0VPTUVUUllfU0VSSUFMSVpFUlMsXG4gICAgICB0aGlzLkdFT01FVFJZX05PREVfRkFDVE9SWV8sXG4gICAgICBbdmFsdWVdLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlVVJJIFhNTCBuYW1lc3BhY2UuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IGNvb3JkaW5hdGVzIG5vZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDb29yZGluYXRlc05vZGVfKG5hbWVzcGFjZVVSSSkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgJ2Nvb3JkaW5hdGVzJyk7XG4gICAgY29vcmRpbmF0ZXMuc2V0QXR0cmlidXRlKCdkZWNpbWFsJywgJy4nKTtcbiAgICBjb29yZGluYXRlcy5zZXRBdHRyaWJ1dGUoJ2NzJywgJywnKTtcbiAgICBjb29yZGluYXRlcy5zZXRBdHRyaWJ1dGUoJ3RzJywgJyAnKTtcblxuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9nZW9tL0xpbmVhclJpbmcuanNcIikuZGVmYXVsdH0gdmFsdWUgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZUNvb3JkaW5hdGVzXyhub2RlLCB2YWx1ZSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaGFzWiA9IGNvbnRleHRbJ2hhc1onXTtcbiAgICBjb25zdCBzcnNOYW1lID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIC8vIG9ubHkgMmQgZm9yIHNpbXBsZSBmZWF0dXJlcyBwcm9maWxlXG4gICAgY29uc3QgcG9pbnRzID0gdmFsdWUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBwYXJ0c1tpXSA9IHRoaXMuZ2V0Q29vcmRzXyhwb2ludCwgc3JzTmFtZSwgaGFzWik7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nVGV4dE5vZGUobm9kZSwgcGFydHMuam9pbignICcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gbGluZSBMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVDdXJ2ZVNlZ21lbnRzXyhub2RlLCBsaW5lLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAnTGluZVN0cmluZ1NlZ21lbnQnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB0aGlzLndyaXRlQ3VydmVPckxpbmVTdHJpbmcoY2hpbGQsIGxpbmUsIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlU3VyZmFjZU9yUG9seWdvbihub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaGFzWiA9IGNvbnRleHRbJ2hhc1onXTtcbiAgICBjb25zdCBzcnNOYW1lID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGlmIChub2RlLm5vZGVOYW1lICE9PSAnUG9seWdvblBhdGNoJyAmJiBzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1BvbHlnb24nIHx8IG5vZGUubm9kZU5hbWUgPT09ICdQb2x5Z29uUGF0Y2gnKSB7XG4gICAgICBjb25zdCByaW5ncyA9IGdlb21ldHJ5LmdldExpbmVhclJpbmdzKCk7XG4gICAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgICB7bm9kZTogbm9kZSwgaGFzWjogaGFzWiwgc3JzTmFtZTogc3JzTmFtZX0sXG4gICAgICAgIHRoaXMuUklOR19TRVJJQUxJWkVSUyxcbiAgICAgICAgdGhpcy5SSU5HX05PREVfRkFDVE9SWV8sXG4gICAgICAgIHJpbmdzLFxuICAgICAgICBvYmplY3RTdGFjayxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1N1cmZhY2UnKSB7XG4gICAgICBjb25zdCBwYXRjaGVzID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAncGF0Y2hlcycpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChwYXRjaGVzKTtcbiAgICAgIHRoaXMud3JpdGVTdXJmYWNlUGF0Y2hlc18ocGF0Y2hlcywgZ2VvbWV0cnksIG9iamVjdFN0YWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vZGVOYW1lXSBOb2RlIG5hbWUuXG4gICAqIEByZXR1cm4ge05vZGV9IE5vZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSSU5HX05PREVfRkFDVE9SWV8odmFsdWUsIG9iamVjdFN0YWNrLCBub2RlTmFtZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gY29udGV4dC5ub2RlO1xuICAgIGNvbnN0IGV4dGVyaW9yV3JpdHRlbiA9IGNvbnRleHRbJ2V4dGVyaW9yV3JpdHRlbiddO1xuICAgIGlmIChleHRlcmlvcldyaXR0ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGV4dFsnZXh0ZXJpb3JXcml0dGVuJ10gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudE5TKFxuICAgICAgcGFyZW50Tm9kZS5uYW1lc3BhY2VVUkksXG4gICAgICBleHRlcmlvcldyaXR0ZW4gIT09IHVuZGVmaW5lZCA/ICdpbm5lckJvdW5kYXJ5SXMnIDogJ291dGVyQm91bmRhcnlJcydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBwb2x5Z29uIFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZVN1cmZhY2VQYXRjaGVzXyhub2RlLCBwb2x5Z29uLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAnUG9seWdvblBhdGNoJyk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgdGhpcy53cml0ZVN1cmZhY2VPclBvbHlnb24oY2hpbGQsIHBvbHlnb24sIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVhclJpbmcuanNcIikuZGVmYXVsdH0gcmluZyBMaW5lYXJSaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVSaW5nKG5vZGUsIHJpbmcsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgbGluZWFyUmluZyA9IGNyZWF0ZUVsZW1lbnROUyhub2RlLm5hbWVzcGFjZVVSSSwgJ0xpbmVhclJpbmcnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGxpbmVhclJpbmcpO1xuICAgIHRoaXMud3JpdGVMaW5lYXJSaW5nKGxpbmVhclJpbmcsIHJpbmcsIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIE9wdGlvbmFsIHNyc05hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbaGFzWl0gd2hldGhlciB0aGUgZ2VvbWV0cnkgaGFzIGEgWiBjb29yZGluYXRlIChpcyAzRCkgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb29yZHMgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29vcmRzXyhwb2ludCwgc3JzTmFtZSwgaGFzWikge1xuICAgIGxldCBheGlzT3JpZW50YXRpb24gPSAnZW51JztcbiAgICBpZiAoc3JzTmFtZSkge1xuICAgICAgYXhpc09yaWVudGF0aW9uID0gZ2V0UHJvamVjdGlvbihzcnNOYW1lKS5nZXRBeGlzT3JpZW50YXRpb24oKTtcbiAgICB9XG4gICAgbGV0IGNvb3JkcyA9XG4gICAgICBheGlzT3JpZW50YXRpb24uc3Vic3RyKDAsIDIpID09PSAnZW4nXG4gICAgICAgID8gcG9pbnRbMF0gKyAnLCcgKyBwb2ludFsxXVxuICAgICAgICA6IHBvaW50WzFdICsgJywnICsgcG9pbnRbMF07XG4gICAgaWYgKGhhc1opIHtcbiAgICAgIC8vIEZvciBuZXdseSBjcmVhdGVkIHBvaW50cywgWiBjYW4gYmUgdW5kZWZpbmVkLlxuICAgICAgY29uc3QgeiA9IHBvaW50WzJdIHx8IDA7XG4gICAgICBjb29yZHMgKz0gJywnICsgejtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZVBvaW50KG5vZGUsIGdlb21ldHJ5LCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBoYXNaID0gY29udGV4dFsnaGFzWiddO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgaWYgKHNyc05hbWUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNOYW1lJywgc3JzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5jcmVhdGVDb29yZGluYXRlc05vZGVfKG5vZGUubmFtZXNwYWNlVVJJKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNvb3JkaW5hdGVzKTtcbiAgICBjb25zdCBwb2ludCA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3QgY29vcmQgPSB0aGlzLmdldENvb3Jkc18ocG9pbnQsIHNyc05hbWUsIGhhc1opO1xuICAgIHdyaXRlU3RyaW5nVGV4dE5vZGUoY29vcmRpbmF0ZXMsIGNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlTXVsdGlQb2ludChub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaGFzWiA9IGNvbnRleHRbJ2hhc1onXTtcbiAgICBjb25zdCBzcnNOYW1lID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGlmIChzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSBnZW9tZXRyeS5nZXRQb2ludHMoKTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAge25vZGU6IG5vZGUsIGhhc1o6IGhhc1osIHNyc05hbWU6IHNyc05hbWV9LFxuICAgICAgdGhpcy5QT0lOVE1FTUJFUl9TRVJJQUxJWkVSUyxcbiAgICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeSgncG9pbnRNZW1iZXInKSxcbiAgICAgIHBvaW50cyxcbiAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fSBwb2ludCBQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlUG9pbnRNZW1iZXIobm9kZSwgcG9pbnQsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGVFbGVtZW50TlMobm9kZS5uYW1lc3BhY2VVUkksICdQb2ludCcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHRoaXMud3JpdGVQb2ludChjaGlsZCwgcG9pbnQsIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVhclJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTGluZWFyUmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlTGluZWFyUmluZyhub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBpZiAoc3JzTmFtZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3Nyc05hbWUnLCBzcnNOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVzTm9kZV8obm9kZS5uYW1lc3BhY2VVUkkpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29vcmRpbmF0ZXMpO1xuICAgIHRoaXMud3JpdGVDb29yZGluYXRlc18oY29vcmRpbmF0ZXMsIGdlb21ldHJ5LCBvYmplY3RTdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVNdWx0aVN1cmZhY2VPclBvbHlnb24obm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGhhc1ogPSBjb250ZXh0WydoYXNaJ107XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBjb25zdCBzdXJmYWNlID0gY29udGV4dFsnc3VyZmFjZSddO1xuICAgIGlmIChzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBwb2x5Z29ucyA9IGdlb21ldHJ5LmdldFBvbHlnb25zKCk7XG4gICAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICAgIHtub2RlOiBub2RlLCBoYXNaOiBoYXNaLCBzcnNOYW1lOiBzcnNOYW1lLCBzdXJmYWNlOiBzdXJmYWNlfSxcbiAgICAgIHRoaXMuU1VSRkFDRU9SUE9MWUdPTk1FTUJFUl9TRVJJQUxJWkVSUyxcbiAgICAgIHRoaXMuTVVMVElHRU9NRVRSWV9NRU1CRVJfTk9ERV9GQUNUT1JZXyxcbiAgICAgIHBvbHlnb25zLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVTdXJmYWNlT3JQb2x5Z29uTWVtYmVyKG5vZGUsIHBvbHlnb24sIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLkdFT01FVFJZX05PREVfRkFDVE9SWV8ocG9seWdvbiwgb2JqZWN0U3RhY2spO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB0aGlzLndyaXRlU3VyZmFjZU9yUG9seWdvbihjaGlsZCwgcG9seWdvbiwgb2JqZWN0U3RhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVFbnZlbG9wZShub2RlLCBleHRlbnQsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgaWYgKHNyc05hbWUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNOYW1lJywgc3JzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBbJ2xvd2VyQ29ybmVyJywgJ3VwcGVyQ29ybmVyJ107XG4gICAgY29uc3QgdmFsdWVzID0gW2V4dGVudFswXSArICcgJyArIGV4dGVudFsxXSwgZXh0ZW50WzJdICsgJyAnICsgZXh0ZW50WzNdXTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICAgICh7bm9kZTogbm9kZX0pLFxuICAgICAgdGhpcy5FTlZFTE9QRV9TRVJJQUxJWkVSUyxcbiAgICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgICB2YWx1ZXMsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIGtleXMsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vZGVOYW1lXSBOb2RlIG5hbWUuXG4gICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBOb2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTVVMVElHRU9NRVRSWV9NRU1CRVJfTk9ERV9GQUNUT1JZXyh2YWx1ZSwgb2JqZWN0U3RhY2ssIG5vZGVOYW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCcsXG4gICAgICBNVUxUSUdFT01FVFJZX1RPX01FTUJFUl9OT0RFTkFNRVtwYXJlbnROb2RlLm5vZGVOYW1lXVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDIucHJvdG90eXBlLkdFT01FVFJZX0ZMQVRfQ09PUkRJTkFURVNfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdjb29yZGluYXRlcyc6IG1ha2VSZXBsYWNlcihHTUwyLnByb3RvdHlwZS5yZWFkRmxhdENvb3JkaW5hdGVzKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwyLnByb3RvdHlwZS5GTEFUX0xJTkVBUl9SSU5HU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ2lubmVyQm91bmRhcnlJcyc6IEdNTDIucHJvdG90eXBlLmlubmVyQm91bmRhcnlJc1BhcnNlcixcbiAgICAnb3V0ZXJCb3VuZGFyeUlzJzogR01MMi5wcm90b3R5cGUub3V0ZXJCb3VuZGFyeUlzUGFyc2VyLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDIucHJvdG90eXBlLkJPWF9QQVJTRVJTXyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdjb29yZGluYXRlcyc6IG1ha2VBcnJheVB1c2hlcihHTUwyLnByb3RvdHlwZS5yZWFkRmxhdENvb3JkaW5hdGVzKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwyLnByb3RvdHlwZS5HRU9NRVRSWV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ1BvaW50JzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2ludCksXG4gICAgJ011bHRpUG9pbnQnOiBtYWtlUmVwbGFjZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZE11bHRpUG9pbnQpLFxuICAgICdMaW5lU3RyaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lU3RyaW5nKSxcbiAgICAnTXVsdGlMaW5lU3RyaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRNdWx0aUxpbmVTdHJpbmcpLFxuICAgICdMaW5lYXJSaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lYXJSaW5nKSxcbiAgICAnUG9seWdvbic6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkUG9seWdvbiksXG4gICAgJ011bHRpUG9seWdvbic6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkTXVsdGlQb2x5Z29uKSxcbiAgICAnQm94JzogbWFrZVJlcGxhY2VyKEdNTDIucHJvdG90eXBlLnJlYWRCb3gpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG5HTUwyLnByb3RvdHlwZS5HRU9NRVRSWV9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdDdXJ2ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDIucHJvdG90eXBlLndyaXRlQ3VydmVPckxpbmVTdHJpbmcpLFxuICAgICdNdWx0aUN1cnZlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMi5wcm90b3R5cGUud3JpdGVNdWx0aUN1cnZlT3JMaW5lU3RyaW5nKSxcbiAgICAnUG9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwyLnByb3RvdHlwZS53cml0ZVBvaW50KSxcbiAgICAnTXVsdGlQb2ludCc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDIucHJvdG90eXBlLndyaXRlTXVsdGlQb2ludCksXG4gICAgJ0xpbmVTdHJpbmcnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwyLnByb3RvdHlwZS53cml0ZUN1cnZlT3JMaW5lU3RyaW5nKSxcbiAgICAnTXVsdGlMaW5lU3RyaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwyLnByb3RvdHlwZS53cml0ZU11bHRpQ3VydmVPckxpbmVTdHJpbmdcbiAgICApLFxuICAgICdMaW5lYXJSaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMi5wcm90b3R5cGUud3JpdGVMaW5lYXJSaW5nKSxcbiAgICAnUG9seWdvbic6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDIucHJvdG90eXBlLndyaXRlU3VyZmFjZU9yUG9seWdvbiksXG4gICAgJ011bHRpUG9seWdvbic6IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgR01MMi5wcm90b3R5cGUud3JpdGVNdWx0aVN1cmZhY2VPclBvbHlnb25cbiAgICApLFxuICAgICdTdXJmYWNlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMi5wcm90b3R5cGUud3JpdGVTdXJmYWNlT3JQb2x5Z29uKSxcbiAgICAnTXVsdGlTdXJmYWNlJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwyLnByb3RvdHlwZS53cml0ZU11bHRpU3VyZmFjZU9yUG9seWdvblxuICAgICksXG4gICAgJ0VudmVsb3BlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMi5wcm90b3R5cGUud3JpdGVFbnZlbG9wZSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG5HTUwyLnByb3RvdHlwZS5MSU5FU1RSSU5HT1JDVVJWRU1FTUJFUl9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdsaW5lU3RyaW5nTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwyLnByb3RvdHlwZS53cml0ZUxpbmVTdHJpbmdPckN1cnZlTWVtYmVyXG4gICAgKSxcbiAgICAnY3VydmVNZW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcihcbiAgICAgIEdNTDIucHJvdG90eXBlLndyaXRlTGluZVN0cmluZ09yQ3VydmVNZW1iZXJcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMi5wcm90b3R5cGUuUklOR19TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdvdXRlckJvdW5kYXJ5SXMnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwyLnByb3RvdHlwZS53cml0ZVJpbmcpLFxuICAgICdpbm5lckJvdW5kYXJ5SXMnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwyLnByb3RvdHlwZS53cml0ZVJpbmcpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMi5wcm90b3R5cGUuUE9JTlRNRU1CRVJfU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAncG9pbnRNZW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwyLnByb3RvdHlwZS53cml0ZVBvaW50TWVtYmVyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMi5wcm90b3R5cGUuU1VSRkFDRU9SUE9MWUdPTk1FTUJFUl9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdzdXJmYWNlTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwyLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICAgICdwb2x5Z29uTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwyLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMi5wcm90b3R5cGUuRU5WRUxPUEVfU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAnbG93ZXJDb3JuZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgICAndXBwZXJDb3JuZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdNTDI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0dNTDNcbiAqL1xuaW1wb3J0IEdNTDIgZnJvbSAnLi9HTUwyLmpzJztcbmltcG9ydCBHTUxCYXNlLCB7R01MTlN9IGZyb20gJy4vR01MQmFzZS5qcyc7XG5pbXBvcnQgTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL0xpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL011bHRpTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlQb2x5Z29uIGZyb20gJy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQge1xuICBPQkpFQ1RfUFJPUEVSVFlfTk9ERV9GQUNUT1JZLFxuICBYTUxfU0NIRU1BX0lOU1RBTkNFX1VSSSxcbiAgY3JlYXRlRWxlbWVudE5TLFxuICBnZXRBbGxUZXh0Q29udGVudCxcbiAgbWFrZUFycmF5RXh0ZW5kZXIsXG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZUNoaWxkQXBwZW5kZXIsXG4gIG1ha2VSZXBsYWNlcixcbiAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5LFxuICBwYXJzZU5vZGUsXG4gIHB1c2hQYXJzZUFuZFBvcCxcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcCxcbn0gZnJvbSAnLi4veG1sLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGV9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge3JlYWROb25OZWdhdGl2ZUludGVnZXJTdHJpbmcsIHdyaXRlU3RyaW5nVGV4dE5vZGV9IGZyb20gJy4veHNkLmpzJztcbmltcG9ydCB7XG4gIHRyYW5zZm9ybUV4dGVudFdpdGhPcHRpb25zLFxuICB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zLFxufSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNjaGVtYUxvY2F0aW9uID1cbiAgR01MTlMgK1xuICAnIGh0dHA6Ly9zY2hlbWFzLm9wZW5naXMubmV0L2dtbC8zLjEuMS9wcm9maWxlcy9nbWxzZlByb2ZpbGUvJyArXG4gICcxLjAuMC9nbWxzZi54c2QnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmNvbnN0IE1VTFRJR0VPTUVUUllfVE9fTUVNQkVSX05PREVOQU1FID0ge1xuICAnTXVsdGlMaW5lU3RyaW5nJzogJ2xpbmVTdHJpbmdNZW1iZXInLFxuICAnTXVsdGlDdXJ2ZSc6ICdjdXJ2ZU1lbWJlcicsXG4gICdNdWx0aVBvbHlnb24nOiAncG9seWdvbk1lbWJlcicsXG4gICdNdWx0aVN1cmZhY2UnOiAnc3VyZmFjZU1lbWJlcicsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEdNTCBmb3JtYXRcbiAqIHZlcnNpb24gMy4xLjEuXG4gKiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBHTUwgMy4xLjEgU2ltcGxlIEZlYXR1cmVzIHByb2ZpbGUuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBHTUwzIGV4dGVuZHMgR01MQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR01MQmFzZS5qc1wiKS5PcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zdXJmYWNlXyA9IG9wdGlvbnMuc3VyZmFjZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdXJmYWNlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY3VydmVfID0gb3B0aW9ucy5jdXJ2ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpQ3VydmVfID1cbiAgICAgIG9wdGlvbnMubXVsdGlDdXJ2ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tdWx0aUN1cnZlIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tdWx0aVN1cmZhY2VfID1cbiAgICAgIG9wdGlvbnMubXVsdGlTdXJmYWNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm11bHRpU3VyZmFjZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2NoZW1hTG9jYXRpb24gPSBvcHRpb25zLnNjaGVtYUxvY2F0aW9uXG4gICAgICA/IG9wdGlvbnMuc2NoZW1hTG9jYXRpb25cbiAgICAgIDogc2NoZW1hTG9jYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaGFzWiA9IG9wdGlvbnMuaGFzWiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5oYXNaIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfHVuZGVmaW5lZH0gTXVsdGlMaW5lU3RyaW5nLlxuICAgKi9cbiAgcmVhZE11bHRpQ3VydmUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PExpbmVTdHJpbmc+fSAqL1xuICAgIGNvbnN0IGxpbmVTdHJpbmdzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW10sXG4gICAgICB0aGlzLk1VTFRJQ1VSVkVfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChsaW5lU3RyaW5ncykge1xuICAgICAgY29uc3QgbXVsdGlMaW5lU3RyaW5nID0gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncyk7XG4gICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBQb2x5Z29uLlxuICAgKi9cbiAgcmVhZEZsYXRDdXJ2ZVJpbmcobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PExpbmVTdHJpbmc+fSAqL1xuICAgIGNvbnN0IGxpbmVTdHJpbmdzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW10sXG4gICAgICB0aGlzLk1VTFRJQ1VSVkVfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIGxpbmVTdHJpbmdzW2ldLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvbHlnb258dW5kZWZpbmVkfSBNdWx0aVBvbHlnb24uXG4gICAqL1xuICByZWFkTXVsdGlTdXJmYWNlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxQb2x5Z29uPn0gKi9cbiAgICBjb25zdCBwb2x5Z29ucyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgIFtdLFxuICAgICAgdGhpcy5NVUxUSVNVUkZBQ0VfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChwb2x5Z29ucykge1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKi9cbiAgY3VydmVNZW1iZXJQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBwYXJzZU5vZGUodGhpcy5DVVJWRU1FTUJFUl9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjaywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICovXG4gIHN1cmZhY2VNZW1iZXJQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBwYXJzZU5vZGUodGhpcy5TVVJGQUNFTUVNQkVSX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtBcnJheTwoQXJyYXk8bnVtYmVyPik+fHVuZGVmaW5lZH0gZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIHJlYWRQYXRjaChub2RlLCBvYmplY3RTdGFjaykge1xuICAgIHJldHVybiBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBbbnVsbF0sXG4gICAgICB0aGlzLlBBVENIRVNfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBmbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcmVhZFNlZ21lbnQobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFtdLCB0aGlzLlNFR01FTlRTX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtBcnJheTwoQXJyYXk8bnVtYmVyPik+fHVuZGVmaW5lZH0gZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIHJlYWRQb2x5Z29uUGF0Y2gobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW251bGxdLFxuICAgICAgdGhpcy5GTEFUX0xJTkVBUl9SSU5HU19QQVJTRVJTLFxuICAgICAgbm9kZSxcbiAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IGZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICByZWFkTGluZVN0cmluZ1NlZ21lbnQobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW251bGxdLFxuICAgICAgdGhpcy5HRU9NRVRSWV9GTEFUX0NPT1JESU5BVEVTX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKi9cbiAgaW50ZXJpb3JQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSAqL1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5nID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5SSU5HX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBpZiAoZmxhdExpbmVhclJpbmcpIHtcbiAgICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59ICovXG4gICAgICAgIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICBmbGF0TGluZWFyUmluZ3MucHVzaChmbGF0TGluZWFyUmluZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqL1xuICBleHRlcmlvclBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9ICovXG4gICAgY29uc3QgZmxhdExpbmVhclJpbmcgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLlJJTkdfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChmbGF0TGluZWFyUmluZykge1xuICAgICAgY29uc3QgZmxhdExpbmVhclJpbmdzID1cbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gKi9cbiAgICAgICAgKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgIGZsYXRMaW5lYXJSaW5nc1swXSA9IGZsYXRMaW5lYXJSaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtQb2x5Z29ufHVuZGVmaW5lZH0gUG9seWdvbi5cbiAgICovXG4gIHJlYWRTdXJmYWNlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gKi9cbiAgICBjb25zdCBmbGF0TGluZWFyUmluZ3MgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBbbnVsbF0sXG4gICAgICB0aGlzLlNVUkZBQ0VfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChmbGF0TGluZWFyUmluZ3MgJiYgZmxhdExpbmVhclJpbmdzWzBdKSB7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBmbGF0TGluZWFyUmluZ3NbMF07XG4gICAgICBjb25zdCBlbmRzID0gW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICAgICAgbGV0IGksIGlpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBmbGF0TGluZWFyUmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBleHRlbmQoZmxhdENvb3JkaW5hdGVzLCBmbGF0TGluZWFyUmluZ3NbaV0pO1xuICAgICAgICBlbmRzLnB1c2goZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFlaJywgZW5kcyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7TGluZVN0cmluZ3x1bmRlZmluZWR9IExpbmVTdHJpbmcuXG4gICAqL1xuICByZWFkQ3VydmUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW251bGxdLFxuICAgICAgdGhpcy5DVVJWRV9QQVJTRVJTLFxuICAgICAgbm9kZSxcbiAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgY29uc3QgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgJ1hZWicpO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IEVudmVsb3BlLlxuICAgKi9cbiAgcmVhZEVudmVsb3BlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgIFtudWxsXSxcbiAgICAgIHRoaXMuRU5WRUxPUEVfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXVswXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXVsxXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1syXVswXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1syXVsxXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICByZWFkRmxhdFBvcyhub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGxldCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpO1xuICAgIGNvbnN0IHJlID0gL15cXHMqKFsrXFwtXT9cXGQqXFwuP1xcZCsoPzpbZUVdWytcXC1dP1xcZCspPylcXHMqLztcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyhzKSkpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKHBhcnNlRmxvYXQobVsxXSkpO1xuICAgICAgcyA9IHMuc3Vic3RyKG1bMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHMgIT09ICcnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbMF07XG4gICAgY29uc3QgY29udGFpbmVyU3JzID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGxldCBheGlzT3JpZW50YXRpb24gPSAnZW51JztcbiAgICBpZiAoY29udGFpbmVyU3JzKSB7XG4gICAgICBjb25zdCBwcm9qID0gZ2V0UHJvamVjdGlvbihjb250YWluZXJTcnMpO1xuICAgICAgYXhpc09yaWVudGF0aW9uID0gcHJvai5nZXRBeGlzT3JpZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKGF4aXNPcmllbnRhdGlvbiA9PT0gJ25ldScpIHtcbiAgICAgIGxldCBpLCBpaTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgeSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IHg7XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tpICsgMV0gPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsZW4gPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goMCk7XG4gICAgfVxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbGF0Q29vcmRpbmF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICByZWFkRmxhdFBvc0xpc3Qobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbMF07XG4gICAgY29uc3QgY29udGFpbmVyU3JzID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGNvbnN0IGNvbnRleHREaW1lbnNpb24gPSBjb250ZXh0WydzcnNEaW1lbnNpb24nXTtcbiAgICBsZXQgYXhpc09yaWVudGF0aW9uID0gJ2VudSc7XG4gICAgaWYgKGNvbnRhaW5lclNycykge1xuICAgICAgY29uc3QgcHJvaiA9IGdldFByb2plY3Rpb24oY29udGFpbmVyU3JzKTtcbiAgICAgIGF4aXNPcmllbnRhdGlvbiA9IHByb2ouZ2V0QXhpc09yaWVudGF0aW9uKCk7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkcyA9IHMuc3BsaXQoL1xccysvKTtcbiAgICAvLyBUaGUgXCJkaW1lbnNpb25cIiBhdHRyaWJ1dGUgaXMgZnJvbSB0aGUgR01MIDMuMC4xIHNwZWMuXG4gICAgbGV0IGRpbSA9IDI7XG4gICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdzcnNEaW1lbnNpb24nKSkge1xuICAgICAgZGltID0gcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnc3JzRGltZW5zaW9uJykpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2RpbWVuc2lvbicpKSB7XG4gICAgICBkaW0gPSByZWFkTm9uTmVnYXRpdmVJbnRlZ2VyU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdkaW1lbnNpb24nKSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUucGFyZW50Tm9kZSkuZ2V0QXR0cmlidXRlKCdzcnNEaW1lbnNpb24nKVxuICAgICkge1xuICAgICAgZGltID0gcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyhcbiAgICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZS5wYXJlbnROb2RlKS5nZXRBdHRyaWJ1dGUoJ3Nyc0RpbWVuc2lvbicpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dERpbWVuc2lvbikge1xuICAgICAgZGltID0gcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyhjb250ZXh0RGltZW5zaW9uKTtcbiAgICB9XG4gICAgbGV0IHgsIHksIHo7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IGRpbSkge1xuICAgICAgeCA9IHBhcnNlRmxvYXQoY29vcmRzW2ldKTtcbiAgICAgIHkgPSBwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pO1xuICAgICAgeiA9IGRpbSA9PT0gMyA/IHBhcnNlRmxvYXQoY29vcmRzW2kgKyAyXSkgOiAwO1xuICAgICAgaWYgKGF4aXNPcmllbnRhdGlvbi5zdWJzdHIoMCwgMikgPT09ICdlbicpIHtcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goeCwgeSwgeik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaCh5LCB4LCB6KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9IHZhbHVlIFBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVQb3NfKG5vZGUsIHZhbHVlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBoYXNaID0gY29udGV4dFsnaGFzWiddO1xuICAgIGNvbnN0IHNyc0RpbWVuc2lvbiA9IGhhc1ogPyAnMycgOiAnMic7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3Nyc0RpbWVuc2lvbicsIHNyc0RpbWVuc2lvbik7XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBsZXQgYXhpc09yaWVudGF0aW9uID0gJ2VudSc7XG4gICAgaWYgKHNyc05hbWUpIHtcbiAgICAgIGF4aXNPcmllbnRhdGlvbiA9IGdldFByb2plY3Rpb24oc3JzTmFtZSkuZ2V0QXhpc09yaWVudGF0aW9uKCk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gdmFsdWUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBsZXQgY29vcmRzO1xuICAgIC8vIG9ubHkgMmQgZm9yIHNpbXBsZSBmZWF0dXJlcyBwcm9maWxlXG4gICAgaWYgKGF4aXNPcmllbnRhdGlvbi5zdWJzdHIoMCwgMikgPT09ICdlbicpIHtcbiAgICAgIGNvb3JkcyA9IHBvaW50WzBdICsgJyAnICsgcG9pbnRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkcyA9IHBvaW50WzFdICsgJyAnICsgcG9pbnRbMF07XG4gICAgfVxuICAgIGlmIChoYXNaKSB7XG4gICAgICAvLyBGb3IgbmV3bHkgY3JlYXRlZCBwb2ludHMsIFogY2FuIGJlIHVuZGVmaW5lZC5cbiAgICAgIGNvbnN0IHogPSBwb2ludFsyXSB8fCAwO1xuICAgICAgY29vcmRzICs9ICcgJyArIHo7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nVGV4dE5vZGUobm9kZSwgY29vcmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIE9wdGlvbmFsIHNyc05hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbaGFzWl0gd2hldGhlciB0aGUgZ2VvbWV0cnkgaGFzIGEgWiBjb29yZGluYXRlIChpcyAzRCkgb3Igbm90LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb29yZHMgc3RyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29vcmRzXyhwb2ludCwgc3JzTmFtZSwgaGFzWikge1xuICAgIGxldCBheGlzT3JpZW50YXRpb24gPSAnZW51JztcbiAgICBpZiAoc3JzTmFtZSkge1xuICAgICAgYXhpc09yaWVudGF0aW9uID0gZ2V0UHJvamVjdGlvbihzcnNOYW1lKS5nZXRBeGlzT3JpZW50YXRpb24oKTtcbiAgICB9XG4gICAgbGV0IGNvb3JkcyA9XG4gICAgICBheGlzT3JpZW50YXRpb24uc3Vic3RyKDAsIDIpID09PSAnZW4nXG4gICAgICAgID8gcG9pbnRbMF0gKyAnICcgKyBwb2ludFsxXVxuICAgICAgICA6IHBvaW50WzFdICsgJyAnICsgcG9pbnRbMF07XG4gICAgaWYgKGhhc1opIHtcbiAgICAgIC8vIEZvciBuZXdseSBjcmVhdGVkIHBvaW50cywgWiBjYW4gYmUgdW5kZWZpbmVkLlxuICAgICAgY29uc3QgeiA9IHBvaW50WzJdIHx8IDA7XG4gICAgICBjb29yZHMgKz0gJyAnICsgejtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0xpbmVTdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9MaW5lYXJSaW5nLmpzXCIpLmRlZmF1bHR9IHZhbHVlIEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVQb3NMaXN0Xyhub2RlLCB2YWx1ZSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaGFzWiA9IGNvbnRleHRbJ2hhc1onXTtcbiAgICBjb25zdCBzcnNEaW1lbnNpb24gPSBoYXNaID8gJzMnIDogJzInO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNEaW1lbnNpb24nLCBzcnNEaW1lbnNpb24pO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgLy8gb25seSAyZCBmb3Igc2ltcGxlIGZlYXR1cmVzIHByb2ZpbGVcbiAgICBjb25zdCBwb2ludHMgPSB2YWx1ZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgcGFydHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBsZXQgcG9pbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBwYXJ0c1tpXSA9IHRoaXMuZ2V0Q29vcmRzXyhwb2ludCwgc3JzTmFtZSwgaGFzWik7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nVGV4dE5vZGUobm9kZSwgcGFydHMuam9pbignICcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVQb2ludChub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBpZiAoc3JzTmFtZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3Nyc05hbWUnLCBzcnNOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAncG9zJyk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChwb3MpO1xuICAgIHRoaXMud3JpdGVQb3NfKHBvcywgZ2VvbWV0cnksIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVFbnZlbG9wZShub2RlLCBleHRlbnQsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgaWYgKHNyc05hbWUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNOYW1lJywgc3JzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBbJ2xvd2VyQ29ybmVyJywgJ3VwcGVyQ29ybmVyJ107XG4gICAgY29uc3QgdmFsdWVzID0gW2V4dGVudFswXSArICcgJyArIGV4dGVudFsxXSwgZXh0ZW50WzJdICsgJyAnICsgZXh0ZW50WzNdXTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICAgICh7bm9kZTogbm9kZX0pLFxuICAgICAgdGhpcy5FTlZFTE9QRV9TRVJJQUxJWkVSUyxcbiAgICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgICB2YWx1ZXMsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIGtleXMsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVhclJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTGluZWFyUmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlTGluZWFyUmluZyhub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBpZiAoc3JzTmFtZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3Nyc05hbWUnLCBzcnNOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgcG9zTGlzdCA9IGNyZWF0ZUVsZW1lbnROUyhub2RlLm5hbWVzcGFjZVVSSSwgJ3Bvc0xpc3QnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKHBvc0xpc3QpO1xuICAgIHRoaXMud3JpdGVQb3NMaXN0Xyhwb3NMaXN0LCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub2RlTmFtZV0gTm9kZSBuYW1lLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUklOR19OT0RFX0ZBQ1RPUllfKHZhbHVlLCBvYmplY3RTdGFjaywgbm9kZU5hbWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQubm9kZTtcbiAgICBjb25zdCBleHRlcmlvcldyaXR0ZW4gPSBjb250ZXh0WydleHRlcmlvcldyaXR0ZW4nXTtcbiAgICBpZiAoZXh0ZXJpb3JXcml0dGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRleHRbJ2V4dGVyaW9yV3JpdHRlbiddID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnROUyhcbiAgICAgIHBhcmVudE5vZGUubmFtZXNwYWNlVVJJLFxuICAgICAgZXh0ZXJpb3JXcml0dGVuICE9PSB1bmRlZmluZWQgPyAnaW50ZXJpb3InIDogJ2V4dGVyaW9yJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7UG9seWdvbn0gZ2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlU3VyZmFjZU9yUG9seWdvbihub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaGFzWiA9IGNvbnRleHRbJ2hhc1onXTtcbiAgICBjb25zdCBzcnNOYW1lID0gY29udGV4dFsnc3JzTmFtZSddO1xuICAgIGlmIChub2RlLm5vZGVOYW1lICE9PSAnUG9seWdvblBhdGNoJyAmJiBzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1BvbHlnb24nIHx8IG5vZGUubm9kZU5hbWUgPT09ICdQb2x5Z29uUGF0Y2gnKSB7XG4gICAgICBjb25zdCByaW5ncyA9IGdlb21ldHJ5LmdldExpbmVhclJpbmdzKCk7XG4gICAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgICB7bm9kZTogbm9kZSwgaGFzWjogaGFzWiwgc3JzTmFtZTogc3JzTmFtZX0sXG4gICAgICAgIHRoaXMuUklOR19TRVJJQUxJWkVSUyxcbiAgICAgICAgdGhpcy5SSU5HX05PREVfRkFDVE9SWV8sXG4gICAgICAgIHJpbmdzLFxuICAgICAgICBvYmplY3RTdGFjayxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1N1cmZhY2UnKSB7XG4gICAgICBjb25zdCBwYXRjaGVzID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAncGF0Y2hlcycpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChwYXRjaGVzKTtcbiAgICAgIHRoaXMud3JpdGVTdXJmYWNlUGF0Y2hlc18ocGF0Y2hlcywgZ2VvbWV0cnksIG9iamVjdFN0YWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gZ2VvbWV0cnkgTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlQ3VydmVPckxpbmVTdHJpbmcobm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNyc05hbWUgPSBjb250ZXh0WydzcnNOYW1lJ107XG4gICAgaWYgKG5vZGUubm9kZU5hbWUgIT09ICdMaW5lU3RyaW5nU2VnbWVudCcgJiYgc3JzTmFtZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3Nyc05hbWUnLCBzcnNOYW1lKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgbm9kZS5ub2RlTmFtZSA9PT0gJ0xpbmVTdHJpbmcnIHx8XG4gICAgICBub2RlLm5vZGVOYW1lID09PSAnTGluZVN0cmluZ1NlZ21lbnQnXG4gICAgKSB7XG4gICAgICBjb25zdCBwb3NMaXN0ID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAncG9zTGlzdCcpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChwb3NMaXN0KTtcbiAgICAgIHRoaXMud3JpdGVQb3NMaXN0Xyhwb3NMaXN0LCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0N1cnZlJykge1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBjcmVhdGVFbGVtZW50TlMobm9kZS5uYW1lc3BhY2VVUkksICdzZWdtZW50cycpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzZWdtZW50cyk7XG4gICAgICB0aGlzLndyaXRlQ3VydmVTZWdtZW50c18oc2VnbWVudHMsIGdlb21ldHJ5LCBvYmplY3RTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge011bHRpUG9seWdvbn0gZ2VvbWV0cnkgTXVsdGlQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVNdWx0aVN1cmZhY2VPclBvbHlnb24obm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGhhc1ogPSBjb250ZXh0WydoYXNaJ107XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBjb25zdCBzdXJmYWNlID0gY29udGV4dFsnc3VyZmFjZSddO1xuICAgIGlmIChzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBwb2x5Z29ucyA9IGdlb21ldHJ5LmdldFBvbHlnb25zKCk7XG4gICAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICAgIHtub2RlOiBub2RlLCBoYXNaOiBoYXNaLCBzcnNOYW1lOiBzcnNOYW1lLCBzdXJmYWNlOiBzdXJmYWNlfSxcbiAgICAgIHRoaXMuU1VSRkFDRU9SUE9MWUdPTk1FTUJFUl9TRVJJQUxJWkVSUyxcbiAgICAgIHRoaXMuTVVMVElHRU9NRVRSWV9NRU1CRVJfTk9ERV9GQUNUT1JZXyxcbiAgICAgIHBvbHlnb25zLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlTXVsdGlQb2ludChub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBjb25zdCBoYXNaID0gY29udGV4dFsnaGFzWiddO1xuICAgIGlmIChzcnNOYW1lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSBnZW9tZXRyeS5nZXRQb2ludHMoKTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAge25vZGU6IG5vZGUsIGhhc1o6IGhhc1osIHNyc05hbWU6IHNyc05hbWV9LFxuICAgICAgdGhpcy5QT0lOVE1FTUJFUl9TRVJJQUxJWkVSUyxcbiAgICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeSgncG9pbnRNZW1iZXInKSxcbiAgICAgIHBvaW50cyxcbiAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7TXVsdGlMaW5lU3RyaW5nfSBnZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZU11bHRpQ3VydmVPckxpbmVTdHJpbmcobm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGhhc1ogPSBjb250ZXh0WydoYXNaJ107XG4gICAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgICBjb25zdCBjdXJ2ZSA9IGNvbnRleHRbJ2N1cnZlJ107XG4gICAgaWYgKHNyc05hbWUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcnNOYW1lJywgc3JzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gZ2VvbWV0cnkuZ2V0TGluZVN0cmluZ3MoKTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAge25vZGU6IG5vZGUsIGhhc1o6IGhhc1osIHNyc05hbWU6IHNyc05hbWUsIGN1cnZlOiBjdXJ2ZX0sXG4gICAgICB0aGlzLkxJTkVTVFJJTkdPUkNVUlZFTUVNQkVSX1NFUklBTElaRVJTLFxuICAgICAgdGhpcy5NVUxUSUdFT01FVFJZX01FTUJFUl9OT0RFX0ZBQ1RPUllfLFxuICAgICAgbGluZXMsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZWFyUmluZy5qc1wiKS5kZWZhdWx0fSByaW5nIExpbmVhclJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZVJpbmcobm9kZSwgcmluZywgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBsaW5lYXJSaW5nID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAnTGluZWFyUmluZycpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQobGluZWFyUmluZyk7XG4gICAgdGhpcy53cml0ZUxpbmVhclJpbmcobGluZWFyUmluZywgcmluZywgb2JqZWN0U3RhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge1BvbHlnb259IHBvbHlnb24gUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlU3VyZmFjZU9yUG9seWdvbk1lbWJlcihub2RlLCBwb2x5Z29uLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5HRU9NRVRSWV9OT0RFX0ZBQ1RPUllfKHBvbHlnb24sIG9iamVjdFN0YWNrKTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgdGhpcy53cml0ZVN1cmZhY2VPclBvbHlnb24oY2hpbGQsIHBvbHlnb24sIG9iamVjdFN0YWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fSBwb2ludCBQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlUG9pbnRNZW1iZXIobm9kZSwgcG9pbnQsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGVFbGVtZW50TlMobm9kZS5uYW1lc3BhY2VVUkksICdQb2ludCcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHRoaXMud3JpdGVQb2ludChjaGlsZCwgcG9pbnQsIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtMaW5lU3RyaW5nfSBsaW5lIExpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZUxpbmVTdHJpbmdPckN1cnZlTWVtYmVyKG5vZGUsIGxpbmUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLkdFT01FVFJZX05PREVfRkFDVE9SWV8obGluZSwgb2JqZWN0U3RhY2spO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB0aGlzLndyaXRlQ3VydmVPckxpbmVTdHJpbmcoY2hpbGQsIGxpbmUsIG9iamVjdFN0YWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVTdXJmYWNlUGF0Y2hlc18obm9kZSwgcG9seWdvbiwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0ZUVsZW1lbnROUyhub2RlLm5hbWVzcGFjZVVSSSwgJ1BvbHlnb25QYXRjaCcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHRoaXMud3JpdGVTdXJmYWNlT3JQb2x5Z29uKGNoaWxkLCBwb2x5Z29uLCBvYmplY3RTdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZSBMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVDdXJ2ZVNlZ21lbnRzXyhub2RlLCBsaW5lLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAnTGluZVN0cmluZ1NlZ21lbnQnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB0aGlzLndyaXRlQ3VydmVPckxpbmVTdHJpbmcoY2hpbGQsIGxpbmUsIG9iamVjdFN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5RWxlbWVudChub2RlLCBnZW9tZXRyeSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSAqLyAoXG4gICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICk7XG4gICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGl0ZW1bJ25vZGUnXSA9IG5vZGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdlb21ldHJ5KSkge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1FeHRlbnRXaXRoT3B0aW9ucyhcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICAgIChpdGVtKSxcbiAgICAgIHRoaXMuR0VPTUVUUllfU0VSSUFMSVpFUlMsXG4gICAgICB0aGlzLkdFT01FVFJZX05PREVfRkFDVE9SWV8sXG4gICAgICBbdmFsdWVdLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAgICovXG4gIHdyaXRlRmVhdHVyZUVsZW1lbnQobm9kZSwgZmVhdHVyZSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBmaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGZpZCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpZCcsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZmlkKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBmZWF0dXJlTlMgPSBjb250ZXh0WydmZWF0dXJlTlMnXTtcbiAgICBjb25zdCBnZW9tZXRyeU5hbWUgPSBmZWF0dXJlLmdldEdlb21ldHJ5TmFtZSgpO1xuICAgIGlmICghY29udGV4dC5zZXJpYWxpemVycykge1xuICAgICAgY29udGV4dC5zZXJpYWxpemVycyA9IHt9O1xuICAgICAgY29udGV4dC5zZXJpYWxpemVyc1tmZWF0dXJlTlNdID0ge307XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBpZiAoZmVhdHVyZS5oYXNQcm9wZXJ0aWVzKCkpIHtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgPT0gZ2VvbWV0cnlOYW1lIHx8XG4gICAgICAgICAgICB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkpID09PVxuICAgICAgICAgICAgICAnZnVuY3Rpb24nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dC5zZXJpYWxpemVyc1tmZWF0dXJlTlNdKSkge1xuICAgICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzW2ZlYXR1cmVOU11ba2V5XSA9IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVHZW9tZXRyeUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dC5zZXJpYWxpemVyc1tmZWF0dXJlTlNdKSkge1xuICAgICAgICAgICAgICBjb250ZXh0LnNlcmlhbGl6ZXJzW2ZlYXR1cmVOU11ba2V5XSA9XG4gICAgICAgICAgICAgICAgbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBpdGVtLm5vZGUgPSBub2RlO1xuICAgIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICAgICAgKGl0ZW0pLFxuICAgICAgY29udGV4dC5zZXJpYWxpemVycyxcbiAgICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeSh1bmRlZmluZWQsIGZlYXR1cmVOUyksXG4gICAgICB2YWx1ZXMsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIGtleXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlTWVtYmVyc18obm9kZSwgZmVhdHVyZXMsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGZlYXR1cmVUeXBlID0gY29udGV4dFsnZmVhdHVyZVR5cGUnXTtcbiAgICBjb25zdCBmZWF0dXJlTlMgPSBjb250ZXh0WydmZWF0dXJlTlMnXTtcbiAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59ICovXG4gICAgY29uc3Qgc2VyaWFsaXplcnMgPSB7fTtcbiAgICBzZXJpYWxpemVyc1tmZWF0dXJlTlNdID0ge307XG4gICAgc2VyaWFsaXplcnNbZmVhdHVyZU5TXVtmZWF0dXJlVHlwZV0gPSBtYWtlQ2hpbGRBcHBlbmRlcihcbiAgICAgIHRoaXMud3JpdGVGZWF0dXJlRWxlbWVudCxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGNvbnN0IGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBpdGVtLm5vZGUgPSBub2RlO1xuICAgIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICAgICAgKGl0ZW0pLFxuICAgICAgc2VyaWFsaXplcnMsXG4gICAgICBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoZmVhdHVyZVR5cGUsIGZlYXR1cmVOUyksXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIG9iamVjdFN0YWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vZGVOYW1lXSBOb2RlIG5hbWUuXG4gICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBOb2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTVVMVElHRU9NRVRSWV9NRU1CRVJfTk9ERV9GQUNUT1JZXyh2YWx1ZSwgb2JqZWN0U3RhY2ssIG5vZGVOYW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnROUyhcbiAgICAgIHRoaXMubmFtZXNwYWNlLFxuICAgICAgTVVMVElHRU9NRVRSWV9UT19NRU1CRVJfTk9ERU5BTUVbcGFyZW50Tm9kZS5ub2RlTmFtZV1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZU5hbWVdIE5vZGUgbmFtZS5cbiAgICogQHJldHVybiB7RWxlbWVudHx1bmRlZmluZWR9IE5vZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBHRU9NRVRSWV9OT0RFX0ZBQ1RPUllfKHZhbHVlLCBvYmplY3RTdGFjaywgbm9kZU5hbWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbXVsdGlTdXJmYWNlID0gY29udGV4dFsnbXVsdGlTdXJmYWNlJ107XG4gICAgY29uc3Qgc3VyZmFjZSA9IGNvbnRleHRbJ3N1cmZhY2UnXTtcbiAgICBjb25zdCBjdXJ2ZSA9IGNvbnRleHRbJ2N1cnZlJ107XG4gICAgY29uc3QgbXVsdGlDdXJ2ZSA9IGNvbnRleHRbJ211bHRpQ3VydmUnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBub2RlTmFtZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIHZhbHVlXG4gICAgICApLmdldFR5cGUoKTtcbiAgICAgIGlmIChub2RlTmFtZSA9PT0gJ011bHRpUG9seWdvbicgJiYgbXVsdGlTdXJmYWNlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGVOYW1lID0gJ011bHRpU3VyZmFjZSc7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnUG9seWdvbicgJiYgc3VyZmFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlTmFtZSA9ICdTdXJmYWNlJztcbiAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICdMaW5lU3RyaW5nJyAmJiBjdXJ2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlTmFtZSA9ICdDdXJ2ZSc7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnTXVsdGlMaW5lU3RyaW5nJyAmJiBtdWx0aUN1cnZlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGVOYW1lID0gJ011bHRpQ3VydmUnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlTmFtZSA9ICdFbnZlbG9wZSc7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2UsIG5vZGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBnZW9tZXRyeSBpbiBHTUwgMy4xLjEgU2ltcGxlIEZlYXR1cmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqIEByZXR1cm4ge05vZGV9IE5vZGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlR2VvbWV0cnlOb2RlKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuYWRhcHRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGdlb20gPSBjcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2UsICdnZW9tJyk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5vZGU6IGdlb20sXG4gICAgICBoYXNaOiB0aGlzLmhhc1osXG4gICAgICBzcnNOYW1lOiB0aGlzLnNyc05hbWUsXG4gICAgICBjdXJ2ZTogdGhpcy5jdXJ2ZV8sXG4gICAgICBzdXJmYWNlOiB0aGlzLnN1cmZhY2VfLFxuICAgICAgbXVsdGlTdXJmYWNlOiB0aGlzLm11bHRpU3VyZmFjZV8sXG4gICAgICBtdWx0aUN1cnZlOiB0aGlzLm11bHRpQ3VydmVfLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMud3JpdGVHZW9tZXRyeUVsZW1lbnQoZ2VvbSwgZ2VvbWV0cnksIFtjb250ZXh0XSk7XG4gICAgcmV0dXJuIGdlb207XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIHRoZSBHTUwgMy4xLjEgZm9ybWF0IGFzIGFuIFhNTCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBOb2RlLlxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzTm9kZShmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBub2RlID0gY3JlYXRlRWxlbWVudE5TKHRoaXMubmFtZXNwYWNlLCAnZmVhdHVyZU1lbWJlcnMnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgWE1MX1NDSEVNQV9JTlNUQU5DRV9VUkksXG4gICAgICAneHNpOnNjaGVtYUxvY2F0aW9uJyxcbiAgICAgIHRoaXMuc2NoZW1hTG9jYXRpb25cbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzcnNOYW1lOiB0aGlzLnNyc05hbWUsXG4gICAgICBoYXNaOiB0aGlzLmhhc1osXG4gICAgICBjdXJ2ZTogdGhpcy5jdXJ2ZV8sXG4gICAgICBzdXJmYWNlOiB0aGlzLnN1cmZhY2VfLFxuICAgICAgbXVsdGlTdXJmYWNlOiB0aGlzLm11bHRpU3VyZmFjZV8sXG4gICAgICBtdWx0aUN1cnZlOiB0aGlzLm11bHRpQ3VydmVfLFxuICAgICAgZmVhdHVyZU5TOiB0aGlzLmZlYXR1cmVOUyxcbiAgICAgIGZlYXR1cmVUeXBlOiB0aGlzLmZlYXR1cmVUeXBlLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMud3JpdGVGZWF0dXJlTWVtYmVyc18obm9kZSwgZmVhdHVyZXMsIFtjb250ZXh0XSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMucHJvdG90eXBlLkdFT01FVFJZX0ZMQVRfQ09PUkRJTkFURVNfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdwb3MnOiBtYWtlUmVwbGFjZXIoR01MMy5wcm90b3R5cGUucmVhZEZsYXRQb3MpLFxuICAgICdwb3NMaXN0JzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gICAgJ2Nvb3JkaW5hdGVzJzogbWFrZVJlcGxhY2VyKEdNTDIucHJvdG90eXBlLnJlYWRGbGF0Q29vcmRpbmF0ZXMpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMucHJvdG90eXBlLkZMQVRfTElORUFSX1JJTkdTX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAnaW50ZXJpb3InOiBHTUwzLnByb3RvdHlwZS5pbnRlcmlvclBhcnNlcixcbiAgICAnZXh0ZXJpb3InOiBHTUwzLnByb3RvdHlwZS5leHRlcmlvclBhcnNlcixcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5HRU9NRVRSWV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ1BvaW50JzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2ludCksXG4gICAgJ011bHRpUG9pbnQnOiBtYWtlUmVwbGFjZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZE11bHRpUG9pbnQpLFxuICAgICdMaW5lU3RyaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lU3RyaW5nKSxcbiAgICAnTXVsdGlMaW5lU3RyaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRNdWx0aUxpbmVTdHJpbmcpLFxuICAgICdMaW5lYXJSaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lYXJSaW5nKSxcbiAgICAnUG9seWdvbic6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkUG9seWdvbiksXG4gICAgJ011bHRpUG9seWdvbic6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkTXVsdGlQb2x5Z29uKSxcbiAgICAnU3VyZmFjZSc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkU3VyZmFjZSksXG4gICAgJ011bHRpU3VyZmFjZSc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkTXVsdGlTdXJmYWNlKSxcbiAgICAnQ3VydmUnOiBtYWtlUmVwbGFjZXIoR01MMy5wcm90b3R5cGUucmVhZEN1cnZlKSxcbiAgICAnTXVsdGlDdXJ2ZSc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkTXVsdGlDdXJ2ZSksXG4gICAgJ0VudmVsb3BlJzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRFbnZlbG9wZSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMy5wcm90b3R5cGUuTVVMVElDVVJWRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ2N1cnZlTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLmN1cnZlTWVtYmVyUGFyc2VyKSxcbiAgICAnY3VydmVNZW1iZXJzJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLmN1cnZlTWVtYmVyUGFyc2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5NVUxUSVNVUkZBQ0VfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdzdXJmYWNlTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnN1cmZhY2VNZW1iZXJQYXJzZXIpLFxuICAgICdzdXJmYWNlTWVtYmVycyc6IG1ha2VBcnJheVB1c2hlcihHTUwzLnByb3RvdHlwZS5zdXJmYWNlTWVtYmVyUGFyc2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5DVVJWRU1FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ0xpbmVTdHJpbmcnOiBtYWtlQXJyYXlQdXNoZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZExpbmVTdHJpbmcpLFxuICAgICdDdXJ2ZSc6IG1ha2VBcnJheVB1c2hlcihHTUwzLnByb3RvdHlwZS5yZWFkQ3VydmUpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMucHJvdG90eXBlLlNVUkZBQ0VNRU1CRVJfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdQb2x5Z29uJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2x5Z29uKSxcbiAgICAnU3VyZmFjZSc6IG1ha2VBcnJheVB1c2hlcihHTUwzLnByb3RvdHlwZS5yZWFkU3VyZmFjZSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMy5wcm90b3R5cGUuU1VSRkFDRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ3BhdGNoZXMnOiBtYWtlUmVwbGFjZXIoR01MMy5wcm90b3R5cGUucmVhZFBhdGNoKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5DVVJWRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ3NlZ21lbnRzJzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRTZWdtZW50KSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5FTlZFTE9QRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ2xvd2VyQ29ybmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gICAgJ3VwcGVyQ29ybmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMy5wcm90b3R5cGUuUEFUQ0hFU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ1BvbHlnb25QYXRjaCc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkUG9seWdvblBhdGNoKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5TRUdNRU5UU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ0xpbmVTdHJpbmdTZWdtZW50JzogbWFrZUFycmF5RXh0ZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS5yZWFkTGluZVN0cmluZ1NlZ21lbnRcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTEJhc2UucHJvdG90eXBlLlJJTkdfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdMaW5lYXJSaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRGbGF0TGluZWFyUmluZyksXG4gICAgJ1JpbmcnOiBtYWtlUmVwbGFjZXIoR01MMy5wcm90b3R5cGUucmVhZEZsYXRDdXJ2ZVJpbmcpLFxuICB9LFxufTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gYXJyYXkgb2YgZmVhdHVyZXMgaW4gR01MIDMuMS4xIFNpbXBsZSBGZWF0dXJlcy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQuXG4gKiBAYXBpXG4gKi9cbkdNTDMucHJvdG90eXBlLndyaXRlRmVhdHVyZXM7XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbkdNTDMucHJvdG90eXBlLlJJTkdfU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAnZXh0ZXJpb3InOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZVJpbmcpLFxuICAgICdpbnRlcmlvcic6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlUmluZyksXG4gIH0sXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5FTlZFTE9QRV9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdsb3dlckNvcm5lcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAgICd1cHBlckNvcm5lcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMy5wcm90b3R5cGUuU1VSRkFDRU9SUE9MWUdPTk1FTUJFUl9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdzdXJmYWNlTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICAgICdwb2x5Z29uTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMy5wcm90b3R5cGUuUE9JTlRNRU1CRVJfU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAncG9pbnRNZW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZVBvaW50TWVtYmVyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbkdNTDMucHJvdG90eXBlLkxJTkVTVFJJTkdPUkNVUlZFTUVNQkVSX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ2xpbmVTdHJpbmdNZW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcihcbiAgICAgIEdNTDMucHJvdG90eXBlLndyaXRlTGluZVN0cmluZ09yQ3VydmVNZW1iZXJcbiAgICApLFxuICAgICdjdXJ2ZU1lbWJlcic6IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgR01MMy5wcm90b3R5cGUud3JpdGVMaW5lU3RyaW5nT3JDdXJ2ZU1lbWJlclxuICAgICksXG4gIH0sXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG5HTUwzLnByb3RvdHlwZS5HRU9NRVRSWV9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdDdXJ2ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlQ3VydmVPckxpbmVTdHJpbmcpLFxuICAgICdNdWx0aUN1cnZlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVNdWx0aUN1cnZlT3JMaW5lU3RyaW5nKSxcbiAgICAnUG9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZVBvaW50KSxcbiAgICAnTXVsdGlQb2ludCc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlTXVsdGlQb2ludCksXG4gICAgJ0xpbmVTdHJpbmcnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZUN1cnZlT3JMaW5lU3RyaW5nKSxcbiAgICAnTXVsdGlMaW5lU3RyaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZU11bHRpQ3VydmVPckxpbmVTdHJpbmdcbiAgICApLFxuICAgICdMaW5lYXJSaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVMaW5lYXJSaW5nKSxcbiAgICAnUG9seWdvbic6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlU3VyZmFjZU9yUG9seWdvbiksXG4gICAgJ011bHRpUG9seWdvbic6IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgR01MMy5wcm90b3R5cGUud3JpdGVNdWx0aVN1cmZhY2VPclBvbHlnb25cbiAgICApLFxuICAgICdTdXJmYWNlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVTdXJmYWNlT3JQb2x5Z29uKSxcbiAgICAnTXVsdGlTdXJmYWNlJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZU11bHRpU3VyZmFjZU9yUG9seWdvblxuICAgICksXG4gICAgJ0VudmVsb3BlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVFbnZlbG9wZSksXG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBHTUwzO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9HTUwzMlxuICovXG5pbXBvcnQgR01MMiBmcm9tICcuL0dNTDIuanMnO1xuaW1wb3J0IEdNTDMgZnJvbSAnLi9HTUwzLmpzJztcbmltcG9ydCBHTUxCYXNlIGZyb20gJy4vR01MQmFzZS5qcyc7XG5pbXBvcnQge1xuICBtYWtlQXJyYXlFeHRlbmRlcixcbiAgbWFrZUFycmF5UHVzaGVyLFxuICBtYWtlQ2hpbGRBcHBlbmRlcixcbiAgbWFrZVJlcGxhY2VyLFxufSBmcm9tICcuLi94bWwuanMnO1xuaW1wb3J0IHt3cml0ZVN0cmluZ1RleHROb2RlfSBmcm9tICcuLi9mb3JtYXQveHNkLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEdNTCBmb3JtYXRcbiAqICAgICAgICAgICAgdmVyc2lvbiAzLjIuMS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgR01MMzIgZXh0ZW5kcyBHTUwzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HTUxCYXNlLmpzXCIpLk9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNjaGVtYUxvY2F0aW9uID0gb3B0aW9ucy5zY2hlbWFMb2NhdGlvblxuICAgICAgPyBvcHRpb25zLnNjaGVtYUxvY2F0aW9uXG4gICAgICA6IHRoaXMubmFtZXNwYWNlICsgJyBodHRwOi8vc2NoZW1hcy5vcGVuZ2lzLm5ldC9nbWwvMy4yLjEvZ21sLnhzZCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeUVsZW1lbnQobm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHttdWx0aUN1cnZlOiB0cnVlLCBtdWx0aVN1cmZhY2U6IHRydWV9LFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgc3VwZXIud3JpdGVHZW9tZXRyeUVsZW1lbnQobm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKTtcbiAgfVxufVxuXG5HTUwzMi5wcm90b3R5cGUubmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sLzMuMic7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuR0VPTUVUUllfRkxBVF9DT09SRElOQVRFU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdwb3MnOiBtYWtlUmVwbGFjZXIoR01MMy5wcm90b3R5cGUucmVhZEZsYXRQb3MpLFxuICAgICdwb3NMaXN0JzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gICAgJ2Nvb3JkaW5hdGVzJzogbWFrZVJlcGxhY2VyKEdNTDIucHJvdG90eXBlLnJlYWRGbGF0Q29vcmRpbmF0ZXMpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5GTEFUX0xJTkVBUl9SSU5HU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdpbnRlcmlvcic6IEdNTDMucHJvdG90eXBlLmludGVyaW9yUGFyc2VyLFxuICAgICdleHRlcmlvcic6IEdNTDMucHJvdG90eXBlLmV4dGVyaW9yUGFyc2VyLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5HRU9NRVRSWV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdQb2ludCc6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkUG9pbnQpLFxuICAgICdNdWx0aVBvaW50JzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRNdWx0aVBvaW50KSxcbiAgICAnTGluZVN0cmluZyc6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkTGluZVN0cmluZyksXG4gICAgJ011bHRpTGluZVN0cmluZyc6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkTXVsdGlMaW5lU3RyaW5nKSxcbiAgICAnTGluZWFyUmluZyc6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkTGluZWFyUmluZyksXG4gICAgJ1BvbHlnb24nOiBtYWtlUmVwbGFjZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZFBvbHlnb24pLFxuICAgICdNdWx0aVBvbHlnb24nOiBtYWtlUmVwbGFjZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZE11bHRpUG9seWdvbiksXG4gICAgJ1N1cmZhY2UnOiBtYWtlUmVwbGFjZXIoR01MMzIucHJvdG90eXBlLnJlYWRTdXJmYWNlKSxcbiAgICAnTXVsdGlTdXJmYWNlJzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRNdWx0aVN1cmZhY2UpLFxuICAgICdDdXJ2ZSc6IG1ha2VSZXBsYWNlcihHTUwzMi5wcm90b3R5cGUucmVhZEN1cnZlKSxcbiAgICAnTXVsdGlDdXJ2ZSc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkTXVsdGlDdXJ2ZSksXG4gICAgJ0VudmVsb3BlJzogbWFrZVJlcGxhY2VyKEdNTDMyLnByb3RvdHlwZS5yZWFkRW52ZWxvcGUpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5NVUxUSUNVUlZFX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC8zLjInOiB7XG4gICAgJ2N1cnZlTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLmN1cnZlTWVtYmVyUGFyc2VyKSxcbiAgICAnY3VydmVNZW1iZXJzJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLmN1cnZlTWVtYmVyUGFyc2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuTVVMVElTVVJGQUNFX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC8zLjInOiB7XG4gICAgJ3N1cmZhY2VNZW1iZXInOiBtYWtlQXJyYXlQdXNoZXIoR01MMy5wcm90b3R5cGUuc3VyZmFjZU1lbWJlclBhcnNlciksXG4gICAgJ3N1cmZhY2VNZW1iZXJzJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnN1cmZhY2VNZW1iZXJQYXJzZXIpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5DVVJWRU1FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdMaW5lU3RyaW5nJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lU3RyaW5nKSxcbiAgICAnQ3VydmUnOiBtYWtlQXJyYXlQdXNoZXIoR01MMy5wcm90b3R5cGUucmVhZEN1cnZlKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuU1VSRkFDRU1FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdQb2x5Z29uJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2x5Z29uKSxcbiAgICAnU3VyZmFjZSc6IG1ha2VBcnJheVB1c2hlcihHTUwzLnByb3RvdHlwZS5yZWFkU3VyZmFjZSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLlNVUkZBQ0VfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sLzMuMic6IHtcbiAgICAncGF0Y2hlcyc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkUGF0Y2gpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5DVVJWRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdzZWdtZW50cyc6IG1ha2VSZXBsYWNlcihHTUwzLnByb3RvdHlwZS5yZWFkU2VnbWVudCksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLkVOVkVMT1BFX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC8zLjInOiB7XG4gICAgJ2xvd2VyQ29ybmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gICAgJ3VwcGVyQ29ybmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTDMucHJvdG90eXBlLnJlYWRGbGF0UG9zTGlzdCksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLlBBVENIRVNfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sLzMuMic6IHtcbiAgICAnUG9seWdvblBhdGNoJzogbWFrZVJlcGxhY2VyKEdNTDMucHJvdG90eXBlLnJlYWRQb2x5Z29uUGF0Y2gpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5TRUdNRU5UU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdMaW5lU3RyaW5nU2VnbWVudCc6IG1ha2VBcnJheUV4dGVuZGVyKFxuICAgICAgR01MMy5wcm90b3R5cGUucmVhZExpbmVTdHJpbmdTZWdtZW50XG4gICAgKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuTVVMVElQT0lOVF9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdwb2ludE1lbWJlcic6IG1ha2VBcnJheVB1c2hlcihHTUxCYXNlLnByb3RvdHlwZS5wb2ludE1lbWJlclBhcnNlciksXG4gICAgJ3BvaW50TWVtYmVycyc6IG1ha2VBcnJheVB1c2hlcihHTUxCYXNlLnByb3RvdHlwZS5wb2ludE1lbWJlclBhcnNlciksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLk1VTFRJTElORVNUUklOR19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdsaW5lU3RyaW5nTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKFxuICAgICAgR01MQmFzZS5wcm90b3R5cGUubGluZVN0cmluZ01lbWJlclBhcnNlclxuICAgICksXG4gICAgJ2xpbmVTdHJpbmdNZW1iZXJzJzogbWFrZUFycmF5UHVzaGVyKFxuICAgICAgR01MQmFzZS5wcm90b3R5cGUubGluZVN0cmluZ01lbWJlclBhcnNlclxuICAgICksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLk1VTFRJUE9MWUdPTl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdwb2x5Z29uTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnBvbHlnb25NZW1iZXJQYXJzZXIpLFxuICAgICdwb2x5Z29uTWVtYmVycyc6IG1ha2VBcnJheVB1c2hlcihHTUxCYXNlLnByb3RvdHlwZS5wb2x5Z29uTWVtYmVyUGFyc2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuUE9JTlRNRU1CRVJfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sLzMuMic6IHtcbiAgICAnUG9pbnQnOiBtYWtlQXJyYXlQdXNoZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZEZsYXRDb29yZGluYXRlc0Zyb21Ob2RlKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuTElORVNUUklOR01FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdMaW5lU3RyaW5nJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRMaW5lU3RyaW5nKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuUE9MWUdPTk1FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdQb2x5Z29uJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2x5Z29uKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUwzMi5wcm90b3R5cGUuUklOR19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdMaW5lYXJSaW5nJzogbWFrZVJlcGxhY2VyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRGbGF0TGluZWFyUmluZyksXG4gICAgJ1JpbmcnOiBtYWtlUmVwbGFjZXIoR01MMzIucHJvdG90eXBlLnJlYWRGbGF0Q3VydmVSaW5nKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5SSU5HX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdleHRlcmlvcic6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlUmluZyksXG4gICAgJ2ludGVyaW9yJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVSaW5nKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5FTlZFTE9QRV9TRVJJQUxJWkVSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sLzMuMic6IHtcbiAgICAnbG93ZXJDb3JuZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgICAndXBwZXJDb3JuZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbkdNTDMyLnByb3RvdHlwZS5TVVJGQUNFT1JQT0xZR09OTUVNQkVSX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdzdXJmYWNlTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICAgICdwb2x5Z29uTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb25NZW1iZXJcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLlBPSU5UTUVNQkVSX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdwb2ludE1lbWJlcic6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlUG9pbnRNZW1iZXIpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLkxJTkVTVFJJTkdPUkNVUlZFTUVNQkVSX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdsaW5lU3RyaW5nTWVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIoXG4gICAgICBHTUwzLnByb3RvdHlwZS53cml0ZUxpbmVTdHJpbmdPckN1cnZlTWVtYmVyXG4gICAgKSxcbiAgICAnY3VydmVNZW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcihcbiAgICAgIEdNTDMucHJvdG90eXBlLndyaXRlTGluZVN0cmluZ09yQ3VydmVNZW1iZXJcbiAgICApLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuR01MMzIucHJvdG90eXBlLkdFT01FVFJZX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvMy4yJzoge1xuICAgICdDdXJ2ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlQ3VydmVPckxpbmVTdHJpbmcpLFxuICAgICdNdWx0aUN1cnZlJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVNdWx0aUN1cnZlT3JMaW5lU3RyaW5nKSxcbiAgICAnUG9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzMi5wcm90b3R5cGUud3JpdGVQb2ludCksXG4gICAgJ011bHRpUG9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZU11bHRpUG9pbnQpLFxuICAgICdMaW5lU3RyaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIoR01MMy5wcm90b3R5cGUud3JpdGVDdXJ2ZU9yTGluZVN0cmluZyksXG4gICAgJ011bHRpTGluZVN0cmluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgR01MMy5wcm90b3R5cGUud3JpdGVNdWx0aUN1cnZlT3JMaW5lU3RyaW5nXG4gICAgKSxcbiAgICAnTGluZWFyUmluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlTGluZWFyUmluZyksXG4gICAgJ1BvbHlnb24nOiBtYWtlQ2hpbGRBcHBlbmRlcihHTUwzLnByb3RvdHlwZS53cml0ZVN1cmZhY2VPclBvbHlnb24pLFxuICAgICdNdWx0aVBvbHlnb24nOiBtYWtlQ2hpbGRBcHBlbmRlcihcbiAgICAgIEdNTDMucHJvdG90eXBlLndyaXRlTXVsdGlTdXJmYWNlT3JQb2x5Z29uXG4gICAgKSxcbiAgICAnU3VyZmFjZSc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlU3VyZmFjZU9yUG9seWdvbiksXG4gICAgJ011bHRpU3VyZmFjZSc6IG1ha2VDaGlsZEFwcGVuZGVyKFxuICAgICAgR01MMy5wcm90b3R5cGUud3JpdGVNdWx0aVN1cmZhY2VPclBvbHlnb25cbiAgICApLFxuICAgICdFbnZlbG9wZSc6IG1ha2VDaGlsZEFwcGVuZGVyKEdNTDMucHJvdG90eXBlLndyaXRlRW52ZWxvcGUpLFxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgR01MMzI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0dNTEJhc2VcbiAqL1xuLy8gRklYTUUgRW52ZWxvcGVzIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBnZW9tZXRyaWVzISByZWFkRW52ZWxvcGVfIGlzIHBhcnRcbi8vIG9mIEdFT01FVFJZX1BBUlNFUlNfIGFuZCBtZXRob2RzIHVzaW5nIEdFT01FVFJZX1BBUlNFUlNfIGRvIG5vdCBleHBlY3Rcbi8vIGVudmVsb3Blcy9leHRlbnRzLCBvbmx5IGdlb21ldHJpZXMhXG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5LmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTGluZWFyUmluZyBmcm9tICcuLi9nZW9tL0xpbmVhclJpbmcuanMnO1xuaW1wb3J0IE11bHRpTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL011bHRpTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlQb2ludCBmcm9tICcuLi9nZW9tL011bHRpUG9pbnQuanMnO1xuaW1wb3J0IE11bHRpUG9seWdvbiBmcm9tICcuLi9nZW9tL011bHRpUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IFhNTEZlYXR1cmUgZnJvbSAnLi9YTUxGZWF0dXJlLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge1xuICBnZXRBbGxUZXh0Q29udGVudCxcbiAgZ2V0QXR0cmlidXRlTlMsXG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZVJlcGxhY2VyLFxuICBwYXJzZU5vZGUsXG4gIHB1c2hQYXJzZUFuZFBvcCxcbn0gZnJvbSAnLi4veG1sLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtcbiAgdHJhbnNmb3JtRXh0ZW50V2l0aE9wdGlvbnMsXG4gIHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMsXG59IGZyb20gJy4vRmVhdHVyZS5qcyc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgR01MTlMgPSAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnO1xuXG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBpZiBhIHN0cmluZyBvbmx5IGNvbnRhaW5zIHdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlcnMuIEl0IHdpbGwgZS5nLiBtYXRjaCBgJydgLCBgJyAnYCwgYCdcXG4nYCBldGMuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBPTkxZX1dISVRFU1BBQ0VfUkUgPSAvXlxccyokLztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz58c3RyaW5nfSBbZmVhdHVyZU5TXSBGZWF0dXJlXG4gKiBuYW1lc3BhY2UuIElmIG5vdCBkZWZpbmVkIHdpbGwgYmUgZGVyaXZlZCBmcm9tIEdNTC4gSWYgbXVsdGlwbGVcbiAqIGZlYXR1cmUgdHlwZXMgaGF2ZSBiZWVuIGNvbmZpZ3VyZWQgd2hpY2ggY29tZSBmcm9tIGRpZmZlcmVudCBmZWF0dXJlXG4gKiBuYW1lc3BhY2VzLCB0aGlzIHdpbGwgYmUgYW4gb2JqZWN0IHdpdGggdGhlIGtleXMgYmVpbmcgdGhlIHByZWZpeGVzIHVzZWRcbiAqIGluIHRoZSBlbnRyaWVzIG9mIGZlYXR1cmVUeXBlIGFycmF5LiBUaGUgdmFsdWVzIG9mIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGVcbiAqIGZlYXR1cmUgbmFtZXNwYWNlcyB0aGVtc2VsdmVzLiBTbyBmb3IgaW5zdGFuY2UgdGhlcmUgbWlnaHQgYmUgYSBmZWF0dXJlVHlwZVxuICogaXRlbSBgdG9wcDpzdGF0ZXNgIGluIHRoZSBgZmVhdHVyZVR5cGVgIGFycmF5IGFuZCB0aGVuIHRoZXJlIHdpbGwgYmUgYSBrZXlcbiAqIGB0b3BwYCBpbiB0aGUgZmVhdHVyZU5TIG9iamVjdCB3aXRoIHZhbHVlIGBodHRwOi8vd3d3Lm9wZW5wbGFucy5vcmcvdG9wcGAuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz58c3RyaW5nfSBbZmVhdHVyZVR5cGVdIEZlYXR1cmUgdHlwZShzKSB0byBwYXJzZS5cbiAqIElmIG11bHRpcGxlIGZlYXR1cmUgdHlwZXMgbmVlZCB0byBiZSBjb25maWd1cmVkXG4gKiB3aGljaCBjb21lIGZyb20gZGlmZmVyZW50IGZlYXR1cmUgbmFtZXNwYWNlcywgYGZlYXR1cmVOU2Agd2lsbCBiZSBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGtleXMgYmVpbmcgdGhlIHByZWZpeGVzIHVzZWQgaW4gdGhlIGVudHJpZXMgb2YgZmVhdHVyZVR5cGUgYXJyYXkuXG4gKiBUaGUgdmFsdWVzIG9mIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGUgZmVhdHVyZSBuYW1lc3BhY2VzIHRoZW1zZWx2ZXMuXG4gKiBTbyBmb3IgaW5zdGFuY2UgdGhlcmUgbWlnaHQgYmUgYSBmZWF0dXJlVHlwZSBpdGVtIGB0b3BwOnN0YXRlc2AgYW5kIHRoZW5cbiAqIHRoZXJlIHdpbGwgYmUgYSBrZXkgbmFtZWQgYHRvcHBgIGluIHRoZSBmZWF0dXJlTlMgb2JqZWN0IHdpdGggdmFsdWVcbiAqIGBodHRwOi8vd3d3Lm9wZW5wbGFucy5vcmcvdG9wcGAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Nyc05hbWVdIHNyc05hbWUgdG8gdXNlIHdoZW4gd3JpdGluZyBnZW9tZXRyaWVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3VyZmFjZT1mYWxzZV0gV3JpdGUgZ21sOlN1cmZhY2UgaW5zdGVhZCBvZiBnbWw6UG9seWdvblxuICogZWxlbWVudHMuIFRoaXMgYWxzbyBhZmZlY3RzIHRoZSBlbGVtZW50cyBpbiBtdWx0aS1wYXJ0IGdlb21ldHJpZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjdXJ2ZT1mYWxzZV0gV3JpdGUgZ21sOkN1cnZlIGluc3RlYWQgb2YgZ21sOkxpbmVTdHJpbmdcbiAqIGVsZW1lbnRzLiBUaGlzIGFsc28gYWZmZWN0cyB0aGUgZWxlbWVudHMgaW4gbXVsdGktcGFydCBnZW9tZXRyaWVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlDdXJ2ZT10cnVlXSBXcml0ZSBnbWw6TXVsdGlDdXJ2ZSBpbnN0ZWFkIG9mIGdtbDpNdWx0aUxpbmVTdHJpbmcuXG4gKiBTaW5jZSB0aGUgbGF0dGVyIGlzIGRlcHJlY2F0ZWQgaW4gR01MIDMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aVN1cmZhY2U9dHJ1ZV0gV3JpdGUgZ21sOm11bHRpU3VyZmFjZSBpbnN0ZWFkIG9mXG4gKiBnbWw6TXVsdGlQb2x5Z29uLiBTaW5jZSB0aGUgbGF0dGVyIGlzIGRlcHJlY2F0ZWQgaW4gR01MIDMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NjaGVtYUxvY2F0aW9uXSBPcHRpb25hbCBzY2hlbWFMb2NhdGlvbiB0byB1c2Ugd2hlblxuICogd3JpdGluZyBvdXQgdGhlIEdNTCwgdGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaGFzWj1mYWxzZV0gSWYgY29vcmRpbmF0ZXMgaGF2ZSBhIFogdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBGZWF0dXJlIGJhc2UgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEdNTCBmb3JtYXQuXG4gKiBUaGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQsIGl0IGNvbnRhaW5zIG9ubHkgYmFzZSBjb250ZW50IHRoYXRcbiAqIGlzIHNoYXJlZCB3aXRoIHZlcnNpb25lZCBmb3JtYXQgY2xhc3NlcyBHTUwyIGFuZCBHTUwzLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBHTUxCYXNlIGV4dGVuZHMgWE1MRmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz58c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVUeXBlID0gb3B0aW9ucy5mZWF0dXJlVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZU5TID0gb3B0aW9ucy5mZWF0dXJlTlM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zcnNOYW1lID0gb3B0aW9ucy5zcnNOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zY2hlbWFMb2NhdGlvbiA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIE9iamVjdD4+fVxuICAgICAqL1xuICAgIHRoaXMuRkVBVFVSRV9DT0xMRUNUSU9OX1BBUlNFUlMgPSB7fTtcbiAgICB0aGlzLkZFQVRVUkVfQ09MTEVDVElPTl9QQVJTRVJTW3RoaXMubmFtZXNwYWNlXSA9IHtcbiAgICAgICdmZWF0dXJlTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKHRoaXMucmVhZEZlYXR1cmVzSW50ZXJuYWwpLFxuICAgICAgJ2ZlYXR1cmVNZW1iZXJzJzogbWFrZVJlcGxhY2VyKHRoaXMucmVhZEZlYXR1cmVzSW50ZXJuYWwpLFxuICAgIH07XG5cbiAgICB0aGlzLnN1cHBvcnRlZE1lZGlhVHlwZXMgPSBbJ2FwcGxpY2F0aW9uL2dtbCt4bWwnXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtBcnJheTxGZWF0dXJlPiB8IHVuZGVmaW5lZH0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNJbnRlcm5hbChub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IG5vZGUubG9jYWxOYW1lO1xuICAgIGxldCBmZWF0dXJlcyA9IG51bGw7XG4gICAgaWYgKGxvY2FsTmFtZSA9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICBmZWF0dXJlcyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgICAgW10sXG4gICAgICAgIHRoaXMuRkVBVFVSRV9DT0xMRUNUSU9OX1BBUlNFUlMsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBsb2NhbE5hbWUgPT0gJ2ZlYXR1cmVNZW1iZXJzJyB8fFxuICAgICAgbG9jYWxOYW1lID09ICdmZWF0dXJlTWVtYmVyJyB8fFxuICAgICAgbG9jYWxOYW1lID09ICdtZW1iZXInXG4gICAgKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbMF07XG4gICAgICBsZXQgZmVhdHVyZVR5cGUgPSBjb250ZXh0WydmZWF0dXJlVHlwZSddO1xuICAgICAgbGV0IGZlYXR1cmVOUyA9IGNvbnRleHRbJ2ZlYXR1cmVOUyddO1xuICAgICAgY29uc3QgcHJlZml4ID0gJ3AnO1xuICAgICAgY29uc3QgZGVmYXVsdFByZWZpeCA9ICdwMCc7XG4gICAgICBpZiAoIWZlYXR1cmVUeXBlICYmIG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgICAoZmVhdHVyZVR5cGUgPSBbXSksIChmZWF0dXJlTlMgPSB7fSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZnQgPSBjaGlsZC5ub2RlTmFtZS5zcGxpdCgnOicpLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlVHlwZS5pbmNsdWRlcyhmdCkpIHtcbiAgICAgICAgICAgICAgbGV0IGtleSA9ICcnO1xuICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICBjb25zdCB1cmkgPSBjaGlsZC5uYW1lc3BhY2VVUkk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIGluIGZlYXR1cmVOUykge1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTlNbY2FuZGlkYXRlXSA9PT0gdXJpKSB7XG4gICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArIGNvdW50O1xuICAgICAgICAgICAgICAgIGZlYXR1cmVOU1trZXldID0gdXJpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZlYXR1cmVUeXBlLnB1c2goa2V5ICsgJzonICsgZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxOYW1lICE9ICdmZWF0dXJlTWVtYmVyJykge1xuICAgICAgICAgIC8vIHJlY2hlY2sgZmVhdHVyZVR5cGUgZm9yIGVhY2ggZmVhdHVyZU1lbWJlclxuICAgICAgICAgIGNvbnRleHRbJ2ZlYXR1cmVUeXBlJ10gPSBmZWF0dXJlVHlwZTtcbiAgICAgICAgICBjb250ZXh0WydmZWF0dXJlTlMnXSA9IGZlYXR1cmVOUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmZWF0dXJlTlMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG5zID0gZmVhdHVyZU5TO1xuICAgICAgICBmZWF0dXJlTlMgPSB7fTtcbiAgICAgICAgZmVhdHVyZU5TW2RlZmF1bHRQcmVmaXhdID0gbnM7XG4gICAgICB9XG4gICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn0gKi9cbiAgICAgIGNvbnN0IHBhcnNlcnNOUyA9IHt9O1xuICAgICAgY29uc3QgZmVhdHVyZVR5cGVzID0gQXJyYXkuaXNBcnJheShmZWF0dXJlVHlwZSlcbiAgICAgICAgPyBmZWF0dXJlVHlwZVxuICAgICAgICA6IFtmZWF0dXJlVHlwZV07XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gZmVhdHVyZU5TKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj59ICovXG4gICAgICAgIGNvbnN0IHBhcnNlcnMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmVhdHVyZVR5cGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBmZWF0dXJlUHJlZml4ID0gZmVhdHVyZVR5cGVzW2ldLmluY2x1ZGVzKCc6JylcbiAgICAgICAgICAgID8gZmVhdHVyZVR5cGVzW2ldLnNwbGl0KCc6JylbMF1cbiAgICAgICAgICAgIDogZGVmYXVsdFByZWZpeDtcbiAgICAgICAgICBpZiAoZmVhdHVyZVByZWZpeCA9PT0gcCkge1xuICAgICAgICAgICAgcGFyc2Vyc1tmZWF0dXJlVHlwZXNbaV0uc3BsaXQoJzonKS5wb3AoKV0gPVxuICAgICAgICAgICAgICBsb2NhbE5hbWUgPT0gJ2ZlYXR1cmVNZW1iZXJzJ1xuICAgICAgICAgICAgICAgID8gbWFrZUFycmF5UHVzaGVyKHRoaXMucmVhZEZlYXR1cmVFbGVtZW50LCB0aGlzKVxuICAgICAgICAgICAgICAgIDogbWFrZVJlcGxhY2VyKHRoaXMucmVhZEZlYXR1cmVFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2Vyc05TW2ZlYXR1cmVOU1twXV0gPSBwYXJzZXJzO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2FsTmFtZSA9PSAnZmVhdHVyZU1lbWJlcicgfHwgbG9jYWxOYW1lID09ICdtZW1iZXInKSB7XG4gICAgICAgIGZlYXR1cmVzID0gcHVzaFBhcnNlQW5kUG9wKHVuZGVmaW5lZCwgcGFyc2Vyc05TLCBub2RlLCBvYmplY3RTdGFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZWF0dXJlcyA9IHB1c2hQYXJzZUFuZFBvcChbXSwgcGFyc2Vyc05TLCBub2RlLCBvYmplY3RTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmZWF0dXJlcyA9PT0gbnVsbCkge1xuICAgICAgZmVhdHVyZXMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gR2VvbWV0cnkuXG4gICAqL1xuICByZWFkR2VvbWV0cnlPckV4dGVudChub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrWzBdKTtcbiAgICBjb250ZXh0WydzcnNOYW1lJ10gPSBub2RlLmZpcnN0RWxlbWVudENoaWxkLmdldEF0dHJpYnV0ZSgnc3JzTmFtZScpO1xuICAgIGNvbnRleHRbJ3Nyc0RpbWVuc2lvbiddID1cbiAgICAgIG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdzcnNEaW1lbnNpb24nKTtcbiAgICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuR0VPTUVUUllfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBHZW9tZXRyeS5cbiAgICovXG4gIHJlYWRFeHRlbnRFbGVtZW50KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbMF0pO1xuICAgIGNvbnN0IGV4dGVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gKi8gKFxuICAgICAgdGhpcy5yZWFkR2VvbWV0cnlPckV4dGVudChub2RlLCBvYmplY3RTdGFjaylcbiAgICApO1xuICAgIHJldHVybiBleHRlbnQgPyB0cmFuc2Zvcm1FeHRlbnRXaXRoT3B0aW9ucyhleHRlbnQsIGNvbnRleHQpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5LlxuICAgKi9cbiAgcmVhZEdlb21ldHJ5RWxlbWVudChub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrWzBdKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICB0aGlzLnJlYWRHZW9tZXRyeU9yRXh0ZW50KG5vZGUsIG9iamVjdFN0YWNrKVxuICAgICk7XG4gICAgcmV0dXJuIGdlb21ldHJ5XG4gICAgICA/IHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoZ2VvbWV0cnksIGZhbHNlLCBjb250ZXh0KVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHBhcmFtIHtib29sZWFufSBhc0ZlYXR1cmUgd2hldGhlciByZXN1bHQgc2hvdWxkIGJlIHdyYXBwZWQgYXMgYSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlfE9iamVjdH0gRmVhdHVyZVxuICAgKi9cbiAgcmVhZEZlYXR1cmVFbGVtZW50SW50ZXJuYWwobm9kZSwgb2JqZWN0U3RhY2ssIGFzRmVhdHVyZSkge1xuICAgIGxldCBnZW9tZXRyeU5hbWU7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IG47IG4gPSBuLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgY29uc3QgbG9jYWxOYW1lID0gbi5sb2NhbE5hbWU7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgaXQgaXMgc2ltcGxlIGF0dHJpYnV0ZVxuICAgICAgaWYgKFxuICAgICAgICBuLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIChuLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgKG4uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMyB8fCBuLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0QWxsVGV4dENvbnRlbnQobiwgZmFsc2UpO1xuICAgICAgICBpZiAoT05MWV9XSElURVNQQUNFX1JFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhc0ZlYXR1cmUpIHtcbiAgICAgICAgICAvL2lmIGZlYXR1cmUsIHRyeSBpdCBhcyBhIGdlb21ldHJ5IG9yIGV4dGVudFxuICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgIGxvY2FsTmFtZSA9PT0gJ2JvdW5kZWRCeSdcbiAgICAgICAgICAgICAgPyB0aGlzLnJlYWRFeHRlbnRFbGVtZW50KG4sIG9iamVjdFN0YWNrKVxuICAgICAgICAgICAgICA6IHRoaXMucmVhZEdlb21ldHJ5RWxlbWVudChuLCBvYmplY3RTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIC8vaWYgbm90IGEgZ2VvbWV0cnkgb3Igbm90IGEgZmVhdHVyZSwgdHJlYXQgaXQgYXMgYSBjb21wbGV4IGF0dHJpYnV0ZVxuICAgICAgICAgIHZhbHVlID0gdGhpcy5yZWFkRmVhdHVyZUVsZW1lbnRJbnRlcm5hbChuLCBvYmplY3RTdGFjaywgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsTmFtZSAhPT0gJ2JvdW5kZWRCeScpIHtcbiAgICAgICAgICAvLyBib3VuZGVkQnkgaXMgYW4gZXh0ZW50IGFuZCBtdXN0IG5vdCBiZSBjb25zaWRlcmVkIGFzIGEgZ2VvbWV0cnlcbiAgICAgICAgICBnZW9tZXRyeU5hbWUgPSBsb2NhbE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbGVuID0gbi5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAwICYmICEodmFsdWUgaW5zdGFuY2VvZiBHZW9tZXRyeSkpIHtcbiAgICAgICAgdmFsdWUgPSB7X2NvbnRlbnRfOiB2YWx1ZX07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBhdHROYW1lID0gbi5hdHRyaWJ1dGVzW2ldLm5hbWU7XG4gICAgICAgICAgdmFsdWVbYXR0TmFtZV0gPSBuLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlc1tsb2NhbE5hbWVdKSB7XG4gICAgICAgIGlmICghKHZhbHVlc1tsb2NhbE5hbWVdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgdmFsdWVzW2xvY2FsTmFtZV0gPSBbdmFsdWVzW2xvY2FsTmFtZV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tsb2NhbE5hbWVdLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2xvY2FsTmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhc0ZlYXR1cmUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZSh2YWx1ZXMpO1xuICAgIGlmIChnZW9tZXRyeU5hbWUpIHtcbiAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnlOYW1lKGdlb21ldHJ5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZpZCA9XG4gICAgICBub2RlLmdldEF0dHJpYnV0ZSgnZmlkJykgfHwgZ2V0QXR0cmlidXRlTlMobm9kZSwgdGhpcy5uYW1lc3BhY2UsICdpZCcpO1xuICAgIGlmIChmaWQpIHtcbiAgICAgIGZlYXR1cmUuc2V0SWQoZmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7RmVhdHVyZX0gRmVhdHVyZS5cbiAgICovXG4gIHJlYWRGZWF0dXJlRWxlbWVudChub2RlLCBvYmplY3RTdGFjaykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlRWxlbWVudEludGVybmFsKG5vZGUsIG9iamVjdFN0YWNrLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtQb2ludHx1bmRlZmluZWR9IFBvaW50LlxuICAgKi9cbiAgcmVhZFBvaW50KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5yZWFkRmxhdENvb3JkaW5hdGVzRnJvbU5vZGUobm9kZSwgb2JqZWN0U3RhY2spO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoZmxhdENvb3JkaW5hdGVzLCAnWFlaJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge011bHRpUG9pbnR8dW5kZWZpbmVkfSBNdWx0aVBvaW50LlxuICAgKi9cbiAgcmVhZE11bHRpUG9pbnQobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fSAqL1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgW10sXG4gICAgICB0aGlzLk1VTFRJUE9JTlRfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChjb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd8dW5kZWZpbmVkfSBNdWx0aUxpbmVTdHJpbmcuXG4gICAqL1xuICByZWFkTXVsdGlMaW5lU3RyaW5nKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxMaW5lU3RyaW5nPn0gKi9cbiAgICBjb25zdCBsaW5lU3RyaW5ncyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgIFtdLFxuICAgICAgdGhpcy5NVUxUSUxJTkVTVFJJTkdfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChsaW5lU3RyaW5ncykge1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvbHlnb258dW5kZWZpbmVkfSBNdWx0aVBvbHlnb24uXG4gICAqL1xuICByZWFkTXVsdGlQb2x5Z29uKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxQb2x5Z29uPn0gKi9cbiAgICBjb25zdCBwb2x5Z29ucyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgIFtdLFxuICAgICAgdGhpcy5NVUxUSVBPTFlHT05fUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChwb2x5Z29ucykge1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKi9cbiAgcG9pbnRNZW1iZXJQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBwYXJzZU5vZGUodGhpcy5QT0lOVE1FTUJFUl9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjaywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICovXG4gIGxpbmVTdHJpbmdNZW1iZXJQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBwYXJzZU5vZGUodGhpcy5MSU5FU1RSSU5HTUVNQkVSX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKi9cbiAgcG9seWdvbk1lbWJlclBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICAgIHBhcnNlTm9kZSh0aGlzLlBPTFlHT05NRU1CRVJfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2ssIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge0xpbmVTdHJpbmd8dW5kZWZpbmVkfSBMaW5lU3RyaW5nLlxuICAgKi9cbiAgcmVhZExpbmVTdHJpbmcobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLnJlYWRGbGF0Q29vcmRpbmF0ZXNGcm9tTm9kZShub2RlLCBvYmplY3RTdGFjayk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgY29uc3QgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgJ1hZWicpO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IExpbmVhclJpbmcgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIHJlYWRGbGF0TGluZWFyUmluZyhub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IHJpbmcgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5HRU9NRVRSWV9GTEFUX0NPT1JESU5BVEVTX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBpZiAocmluZykge1xuICAgICAgcmV0dXJuIHJpbmc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7TGluZWFyUmluZ3x1bmRlZmluZWR9IExpbmVhclJpbmcuXG4gICAqL1xuICByZWFkTGluZWFyUmluZyhub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMucmVhZEZsYXRDb29yZGluYXRlc0Zyb21Ob2RlKG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICByZXR1cm4gbmV3IExpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCAnWFlaJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEByZXR1cm4ge1BvbHlnb258dW5kZWZpbmVkfSBQb2x5Z29uLlxuICAgKi9cbiAgcmVhZFBvbHlnb24obm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fSAqL1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgIFtudWxsXSxcbiAgICAgIHRoaXMuRkxBVF9MSU5FQVJfUklOR1NfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIGlmIChmbGF0TGluZWFyUmluZ3MgJiYgZmxhdExpbmVhclJpbmdzWzBdKSB7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBmbGF0TGluZWFyUmluZ3NbMF07XG4gICAgICBjb25zdCBlbmRzID0gW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICAgICAgbGV0IGksIGlpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBmbGF0TGluZWFyUmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBleHRlbmQoZmxhdENvb3JkaW5hdGVzLCBmbGF0TGluZWFyUmluZ3NbaV0pO1xuICAgICAgICBlbmRzLnB1c2goZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFlaJywgZW5kcyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIHJlYWRGbGF0Q29vcmRpbmF0ZXNGcm9tTm9kZShub2RlLCBvYmplY3RTdGFjaykge1xuICAgIHJldHVybiBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5HRU9NRVRSWV9GTEFUX0NPT1JESU5BVEVTX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICByZWFkR2VvbWV0cnlGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnJlYWRHZW9tZXRyeUVsZW1lbnQobm9kZSwgW1xuICAgICAgdGhpcy5nZXRSZWFkT3B0aW9ucyhub2RlLCBvcHRpb25zID8gb3B0aW9ucyA6IHt9KSxcbiAgICBdKTtcbiAgICByZXR1cm4gZ2VvbWV0cnkgPyBnZW9tZXRyeSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgZmVhdHVyZVR5cGU6IHRoaXMuZmVhdHVyZVR5cGUsXG4gICAgICBmZWF0dXJlTlM6IHRoaXMuZmVhdHVyZU5TLFxuICAgIH07XG4gICAgaWYgKGludGVybmFsT3B0aW9ucykge1xuICAgICAgT2JqZWN0LmFzc2lnbihpbnRlcm5hbE9wdGlvbnMsIHRoaXMuZ2V0UmVhZE9wdGlvbnMobm9kZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMucmVhZEZlYXR1cmVzSW50ZXJuYWwobm9kZSwgW2ludGVybmFsT3B0aW9uc10pO1xuICAgIHJldHVybiBmZWF0dXJlcyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkUHJvamVjdGlvbkZyb21Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0UHJvamVjdGlvbihcbiAgICAgIHRoaXMuc3JzTmFtZVxuICAgICAgICA/IHRoaXMuc3JzTmFtZVxuICAgICAgICA6IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdzcnNOYW1lJylcbiAgICApO1xuICB9XG59XG5cbkdNTEJhc2UucHJvdG90eXBlLm5hbWVzcGFjZSA9IEdNTE5TO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MQmFzZS5wcm90b3R5cGUuRkxBVF9MSU5FQVJfUklOR1NfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge30sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MQmFzZS5wcm90b3R5cGUuR0VPTUVUUllfRkxBVF9DT09SRElOQVRFU19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7fSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUxCYXNlLnByb3RvdHlwZS5HRU9NRVRSWV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7fSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUxCYXNlLnByb3RvdHlwZS5NVUxUSVBPSU5UX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAncG9pbnRNZW1iZXInOiBtYWtlQXJyYXlQdXNoZXIoR01MQmFzZS5wcm90b3R5cGUucG9pbnRNZW1iZXJQYXJzZXIpLFxuICAgICdwb2ludE1lbWJlcnMnOiBtYWtlQXJyYXlQdXNoZXIoR01MQmFzZS5wcm90b3R5cGUucG9pbnRNZW1iZXJQYXJzZXIpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTEJhc2UucHJvdG90eXBlLk1VTFRJTElORVNUUklOR19QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ2xpbmVTdHJpbmdNZW1iZXInOiBtYWtlQXJyYXlQdXNoZXIoXG4gICAgICBHTUxCYXNlLnByb3RvdHlwZS5saW5lU3RyaW5nTWVtYmVyUGFyc2VyXG4gICAgKSxcbiAgICAnbGluZVN0cmluZ01lbWJlcnMnOiBtYWtlQXJyYXlQdXNoZXIoXG4gICAgICBHTUxCYXNlLnByb3RvdHlwZS5saW5lU3RyaW5nTWVtYmVyUGFyc2VyXG4gICAgKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUxCYXNlLnByb3RvdHlwZS5NVUxUSVBPTFlHT05fUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdwb2x5Z29uTWVtYmVyJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnBvbHlnb25NZW1iZXJQYXJzZXIpLFxuICAgICdwb2x5Z29uTWVtYmVycyc6IG1ha2VBcnJheVB1c2hlcihHTUxCYXNlLnByb3RvdHlwZS5wb2x5Z29uTWVtYmVyUGFyc2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUxCYXNlLnByb3RvdHlwZS5QT0lOVE1FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ1BvaW50JzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRGbGF0Q29vcmRpbmF0ZXNGcm9tTm9kZSksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuR01MQmFzZS5wcm90b3R5cGUuTElORVNUUklOR01FTUJFUl9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwnOiB7XG4gICAgJ0xpbmVTdHJpbmcnOiBtYWtlQXJyYXlQdXNoZXIoR01MQmFzZS5wcm90b3R5cGUucmVhZExpbmVTdHJpbmcpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbkdNTEJhc2UucHJvdG90eXBlLlBPTFlHT05NRU1CRVJfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sJzoge1xuICAgICdQb2x5Z29uJzogbWFrZUFycmF5UHVzaGVyKEdNTEJhc2UucHJvdG90eXBlLnJlYWRQb2x5Z29uKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5HTUxCYXNlLnByb3RvdHlwZS5SSU5HX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAnTGluZWFyUmluZyc6IG1ha2VSZXBsYWNlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkRmxhdExpbmVhclJpbmcpLFxuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgR01MQmFzZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvR1BYXG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFhNTEZlYXR1cmUgZnJvbSAnLi9YTUxGZWF0dXJlLmpzJztcbmltcG9ydCB7XG4gIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gIFhNTF9TQ0hFTUFfSU5TVEFOQ0VfVVJJLFxuICBjcmVhdGVFbGVtZW50TlMsXG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZUFycmF5U2VyaWFsaXplcixcbiAgbWFrZUNoaWxkQXBwZW5kZXIsXG4gIG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcixcbiAgbWFrZVNlcXVlbmNlLFxuICBtYWtlU2ltcGxlTm9kZUZhY3RvcnksXG4gIG1ha2VTdHJ1Y3R1cmVOUyxcbiAgcGFyc2VOb2RlLFxuICBwdXNoUGFyc2VBbmRQb3AsXG4gIHB1c2hTZXJpYWxpemVBbmRQb3AsXG59IGZyb20gJy4uL3htbC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7XG4gIHJlYWREYXRlVGltZSxcbiAgcmVhZERlY2ltYWwsXG4gIHJlYWRQb3NpdGl2ZUludGVnZXIsXG4gIHJlYWRTdHJpbmcsXG4gIHdyaXRlRGF0ZVRpbWVUZXh0Tm9kZSxcbiAgd3JpdGVEZWNpbWFsVGV4dE5vZGUsXG4gIHdyaXRlTm9uTmVnYXRpdmVJbnRlZ2VyVGV4dE5vZGUsXG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUsXG59IGZyb20gJy4veHNkLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9uc30gZnJvbSAnLi9GZWF0dXJlLmpzJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudWxsfHN0cmluZz59XG4gKi9cbmNvbnN0IE5BTUVTUEFDRV9VUklTID0gW1xuICBudWxsLFxuICAnaHR0cDovL3d3dy50b3BvZ3JhZml4LmNvbS9HUFgvMS8wJyxcbiAgJ2h0dHA6Ly93d3cudG9wb2dyYWZpeC5jb20vR1BYLzEvMScsXG5dO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgU0NIRU1BX0xPQ0FUSU9OID1cbiAgJ2h0dHA6Ly93d3cudG9wb2dyYWZpeC5jb20vR1BYLzEvMSAnICtcbiAgJ2h0dHA6Ly93d3cudG9wb2dyYWZpeC5jb20vR1BYLzEvMS9ncHgueHNkJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbihOb2RlLCBBcnJheTwqPik6IChGZWF0dXJlfHVuZGVmaW5lZCk+fVxuICovXG5jb25zdCBGRUFUVVJFX1JFQURFUiA9IHtcbiAgJ3J0ZSc6IHJlYWRSdGUsXG4gICd0cmsnOiByZWFkVHJrLFxuICAnd3B0JzogcmVhZFdwdCxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBHUFhfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAncnRlJzogbWFrZUFycmF5UHVzaGVyKHJlYWRSdGUpLFxuICAndHJrJzogbWFrZUFycmF5UHVzaGVyKHJlYWRUcmspLFxuICAnd3B0JzogbWFrZUFycmF5UHVzaGVyKHJlYWRXcHQpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBMSU5LX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ3RleHQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZywgJ2xpbmtUZXh0JyksXG4gICd0eXBlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcsICdsaW5rVHlwZScpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgR1BYX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdydGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVJ0ZSksXG4gICd0cmsnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVRyayksXG4gICd3cHQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVdwdCksXG59KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEZlYXR1cmUsIE5vZGUpOnZvaWR9IFtyZWFkRXh0ZW5zaW9uc10gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIHRvIHByb2Nlc3MgYGV4dGVuc2lvbnNgIG5vZGVzLiBUbyBwcmV2ZW50IG1lbW9yeSBsZWFrcywgdGhpcyBjYWxsYmFjayBmdW5jdGlvbiBtdXN0XG4gKiBub3Qgc3RvcmUgYW55IHJlZmVyZW5jZXMgdG8gdGhlIG5vZGUuIE5vdGUgdGhhdCB0aGUgYGV4dGVuc2lvbnNgXG4gKiBub2RlIGlzIG5vdCBhbGxvd2VkIGluIEdQWCAxLjAuIE1vcmVvdmVyLCBvbmx5IGBleHRlbnNpb25zYFxuICogbm9kZXMgZnJvbSBgd3B0YCwgYHJ0ZWAgYW5kIGB0cmtgIGNhbiBiZSBwcm9jZXNzZWQsIGFzIHRob3NlIGFyZVxuICogZGlyZWN0bHkgbWFwcGVkIHRvIGEgZmVhdHVyZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExheW91dE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hhc1pdIEhhc1ouXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoYXNNXSBIYXNNLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRmVhdHVyZSBmb3JtYXQgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgZGF0YSBpbiB0aGUgR1BYIGZvcm1hdC5cbiAqXG4gKiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9mb3JtYXQvR1BYfkdQWCNyZWFkRmVhdHVyZX0gb25seSByZWFkcyB0aGUgZmlyc3RcbiAqIGZlYXR1cmUgb2YgdGhlIHNvdXJjZS5cbiAqXG4gKiBXaGVuIHJlYWRpbmcsIHJvdXRlcyAoYDxydGU+YCkgYXJlIGNvbnZlcnRlZCBpbnRvIExpbmVTdHJpbmcgZ2VvbWV0cmllcywgYW5kXG4gKiB0cmFja3MgKGA8dHJrPmApIGludG8gTXVsdGlMaW5lU3RyaW5nLiBBbnkgcHJvcGVydGllcyBvbiByb3V0ZSBhbmQgdHJhY2tcbiAqIHdheXBvaW50cyBhcmUgaWdub3JlZC5cbiAqXG4gKiBXaGVuIHdyaXRpbmcsIExpbmVTdHJpbmcgZ2VvbWV0cmllcyBhcmUgb3V0cHV0IGFzIHJvdXRlcyAoYDxydGU+YCksIGFuZFxuICogTXVsdGlMaW5lU3RyaW5nIGFzIHRyYWNrcyAoYDx0cms+YCkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBHUFggZXh0ZW5kcyBYTUxGZWF0dXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YVByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKCdFUFNHOjQzMjYnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihGZWF0dXJlLCBOb2RlKTogdm9pZHx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlYWRFeHRlbnNpb25zXyA9IG9wdGlvbnMucmVhZEV4dGVuc2lvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxGZWF0dXJlPn0gZmVhdHVyZXMgTGlzdCBvZiBmZWF0dXJlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVJlYWRFeHRlbnNpb25zXyhmZWF0dXJlcykge1xuICAgIGlmICghZmVhdHVyZXMpIHtcbiAgICAgIGZlYXR1cmVzID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgIGlmICh0aGlzLnJlYWRFeHRlbnNpb25zXykge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zTm9kZSA9IGZlYXR1cmUuZ2V0KCdleHRlbnNpb25zTm9kZV8nKSB8fCBudWxsO1xuICAgICAgICB0aGlzLnJlYWRFeHRlbnNpb25zXyhmZWF0dXJlLCBleHRlbnNpb25zTm9kZSk7XG4gICAgICB9XG4gICAgICBmZWF0dXJlLnNldCgnZXh0ZW5zaW9uc05vZGVfJywgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFOQU1FU1BBQ0VfVVJJUy5pbmNsdWRlcyhub2RlLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmZWF0dXJlUmVhZGVyID0gRkVBVFVSRV9SRUFERVJbbm9kZS5sb2NhbE5hbWVdO1xuICAgIGlmICghZmVhdHVyZVJlYWRlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlUmVhZGVyKG5vZGUsIFt0aGlzLmdldFJlYWRPcHRpb25zKG5vZGUsIG9wdGlvbnMpXSk7XG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVSZWFkRXh0ZW5zaW9uc18oW2ZlYXR1cmVdKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21Ob2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIU5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG5vZGUubmFtZXNwYWNlVVJJKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ2dweCcpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59ICovXG4gICAgICBjb25zdCBmZWF0dXJlcyA9IHB1c2hQYXJzZUFuZFBvcChbXSwgR1BYX1BBUlNFUlMsIG5vZGUsIFtcbiAgICAgICAgdGhpcy5nZXRSZWFkT3B0aW9ucyhub2RlLCBvcHRpb25zKSxcbiAgICAgIF0pO1xuICAgICAgaWYgKGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVhZEV4dGVuc2lvbnNfKGZlYXR1cmVzKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIHRoZSBHUFggZm9ybWF0IGFzIGFuIFhNTCBub2RlLlxuICAgKiBMaW5lU3RyaW5nIGdlb21ldHJpZXMgYXJlIG91dHB1dCBhcyByb3V0ZXMgKGA8cnRlPmApLCBhbmQgTXVsdGlMaW5lU3RyaW5nXG4gICAqIGFzIHRyYWNrcyAoYDx0cms+YCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RmVhdHVyZT59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlLlxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzTm9kZShmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAvL0ZJWE1FIFNlcmlhbGl6ZSBtZXRhZGF0YVxuICAgIGNvbnN0IGdweCA9IGNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy50b3BvZ3JhZml4LmNvbS9HUFgvMS8xJywgJ2dweCcpO1xuICAgIGNvbnN0IHhtbG5zVXJpID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJztcbiAgICBncHguc2V0QXR0cmlidXRlTlMoeG1sbnNVcmksICd4bWxuczp4c2knLCBYTUxfU0NIRU1BX0lOU1RBTkNFX1VSSSk7XG4gICAgZ3B4LnNldEF0dHJpYnV0ZU5TKFxuICAgICAgWE1MX1NDSEVNQV9JTlNUQU5DRV9VUkksXG4gICAgICAneHNpOnNjaGVtYUxvY2F0aW9uJyxcbiAgICAgIFNDSEVNQV9MT0NBVElPTlxuICAgICk7XG4gICAgZ3B4LnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTtcbiAgICBncHguc2V0QXR0cmlidXRlKCdjcmVhdG9yJywgJ09wZW5MYXllcnMnKTtcblxuICAgIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICAgICAgKHtub2RlOiBncHh9KSxcbiAgICAgIEdQWF9TRVJJQUxJWkVSUyxcbiAgICAgIEdQWF9OT0RFX0ZBQ1RPUlksXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIFtvcHRpb25zXVxuICAgICk7XG4gICAgcmV0dXJuIGdweDtcbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUlRFX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ25hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdjbXQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdkZXNjJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnc3JjJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnbGluayc6IHBhcnNlTGluayxcbiAgJ251bWJlcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgJ2V4dGVuc2lvbnMnOiBwYXJzZUV4dGVuc2lvbnMsXG4gICd0eXBlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAncnRlcHQnOiBwYXJzZVJ0ZVB0LFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBSVEVQVF9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdlbGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAndGltZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGF0ZVRpbWUpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBUUktfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnbmFtZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2NtdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2Rlc2MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdzcmMnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdsaW5rJzogcGFyc2VMaW5rLFxuICAnbnVtYmVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAndHlwZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2V4dGVuc2lvbnMnOiBwYXJzZUV4dGVuc2lvbnMsXG4gICd0cmtzZWcnOiBwYXJzZVRya1NlZyxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgVFJLU0VHX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ3Rya3B0JzogcGFyc2VUcmtQdCxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgVFJLUFRfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnZWxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ3RpbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERhdGVUaW1lKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgV1BUX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2VsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICd0aW1lJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREYXRlVGltZSksXG4gICdtYWd2YXInOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAnZ2VvaWRoZWlnaHQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAnbmFtZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2NtdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2Rlc2MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdzcmMnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdsaW5rJzogcGFyc2VMaW5rLFxuICAnc3ltJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAndHlwZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ2ZpeCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ3NhdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgJ2hkb3AnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAndmRvcCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdwZG9wJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ2FnZW9mZGdwc2RhdGEnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAnZGdwc2lkJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAnZXh0ZW5zaW9ucyc6IHBhcnNlRXh0ZW5zaW9ucyxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbmNvbnN0IExJTktfU0VRVUVOQ0UgPSBbJ3RleHQnLCAndHlwZSddO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IExJTktfU0VSSUFMSVpFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ3RleHQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3R5cGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PHN0cmluZz4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBSVEVfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ25hbWUnLFxuICAnY210JyxcbiAgJ2Rlc2MnLFxuICAnc3JjJyxcbiAgJ2xpbmsnLFxuICAnbnVtYmVyJyxcbiAgJ3R5cGUnLFxuICAncnRlcHQnLFxuXSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUlRFX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICduYW1lJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICdjbXQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ2Rlc2MnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3NyYyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAnbGluayc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTGluayksXG4gICdudW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZU5vbk5lZ2F0aXZlSW50ZWdlclRleHROb2RlKSxcbiAgJ3R5cGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3J0ZXB0JzogbWFrZUFycmF5U2VyaWFsaXplcihtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVdwdFR5cGUpKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PHN0cmluZz4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBSVEVQVF9UWVBFX1NFUVVFTkNFID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCBbJ2VsZScsICd0aW1lJ10pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PHN0cmluZz4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBUUktfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ25hbWUnLFxuICAnY210JyxcbiAgJ2Rlc2MnLFxuICAnc3JjJyxcbiAgJ2xpbmsnLFxuICAnbnVtYmVyJyxcbiAgJ3R5cGUnLFxuICAndHJrc2VnJyxcbl0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFRSS19TRVJJQUxJWkVSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnbmFtZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAnY210JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICdkZXNjJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICdzcmMnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ2xpbmsnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUxpbmspLFxuICAnbnVtYmVyJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVOb25OZWdhdGl2ZUludGVnZXJUZXh0Tm9kZSksXG4gICd0eXBlJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICd0cmtzZWcnOiBtYWtlQXJyYXlTZXJpYWxpemVyKG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlVHJrU2VnKSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtmdW5jdGlvbigqLCBBcnJheTwqPiwgc3RyaW5nPSk6IChOb2RlfHVuZGVmaW5lZCl9XG4gKi9cbmNvbnN0IFRSS1NFR19OT0RFX0ZBQ1RPUlkgPSBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoJ3Rya3B0Jyk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgVFJLU0VHX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICd0cmtwdCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlV3B0VHlwZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxzdHJpbmc+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgV1BUX1RZUEVfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ2VsZScsXG4gICd0aW1lJyxcbiAgJ21hZ3ZhcicsXG4gICdnZW9pZGhlaWdodCcsXG4gICduYW1lJyxcbiAgJ2NtdCcsXG4gICdkZXNjJyxcbiAgJ3NyYycsXG4gICdsaW5rJyxcbiAgJ3N5bScsXG4gICd0eXBlJyxcbiAgJ2ZpeCcsXG4gICdzYXQnLFxuICAnaGRvcCcsXG4gICd2ZG9wJyxcbiAgJ3Bkb3AnLFxuICAnYWdlb2ZkZ3BzZGF0YScsXG4gICdkZ3BzaWQnLFxuXSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgV1BUX1RZUEVfU0VSSUFMSVpFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2VsZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGVjaW1hbFRleHROb2RlKSxcbiAgJ3RpbWUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURhdGVUaW1lVGV4dE5vZGUpLFxuICAnbWFndmFyJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAnZ2VvaWRoZWlnaHQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURlY2ltYWxUZXh0Tm9kZSksXG4gICduYW1lJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICdjbXQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ2Rlc2MnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3NyYyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAnbGluayc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTGluayksXG4gICdzeW0nOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3R5cGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ2ZpeCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAnc2F0JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVOb25OZWdhdGl2ZUludGVnZXJUZXh0Tm9kZSksXG4gICdoZG9wJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAndmRvcCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGVjaW1hbFRleHROb2RlKSxcbiAgJ3Bkb3AnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURlY2ltYWxUZXh0Tm9kZSksXG4gICdhZ2VvZmRncHNkYXRhJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAnZGdwc2lkJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVOb25OZWdhdGl2ZUludGVnZXJUZXh0Tm9kZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBHRU9NRVRSWV9UWVBFX1RPX05PREVOQU1FID0ge1xuICAnUG9pbnQnOiAnd3B0JyxcbiAgJ0xpbmVTdHJpbmcnOiAncnRlJyxcbiAgJ011bHRpTGluZVN0cmluZyc6ICd0cmsnLFxufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlTmFtZV0gTm9kZSBuYW1lLlxuICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IE5vZGUuXG4gKi9cbmZ1bmN0aW9uIEdQWF9OT0RFX0ZBQ1RPUlkodmFsdWUsIG9iamVjdFN0YWNrLCBub2RlTmFtZSkge1xuICBjb25zdCBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7RmVhdHVyZX0gKi8gKHZhbHVlKS5nZXRHZW9tZXRyeSgpO1xuICBpZiAoZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IEdFT01FVFJZX1RZUEVfVE9fTk9ERU5BTUVbZ2VvbWV0cnkuZ2V0VHlwZSgpXTtcbiAgICBpZiAobm9kZU5hbWUpIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnROUyhwYXJlbnROb2RlLm5hbWVzcGFjZVVSSSwgbm9kZU5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0xheW91dE9wdGlvbnN9IGxheW91dE9wdGlvbnMgTGF5b3V0IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gdmFsdWVzIFZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZENvb3JkaW5hdGUoZmxhdENvb3JkaW5hdGVzLCBsYXlvdXRPcHRpb25zLCBub2RlLCB2YWx1ZXMpIHtcbiAgZmxhdENvb3JkaW5hdGVzLnB1c2goXG4gICAgcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnbG9uJykpLFxuICAgIHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2xhdCcpKVxuICApO1xuICBpZiAoJ2VsZScgaW4gdmFsdWVzKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzLnB1c2goLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZXNbJ2VsZSddKSk7XG4gICAgZGVsZXRlIHZhbHVlc1snZWxlJ107XG4gICAgbGF5b3V0T3B0aW9ucy5oYXNaID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaCgwKTtcbiAgfVxuICBpZiAoJ3RpbWUnIGluIHZhbHVlcykge1xuICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWVzWyd0aW1lJ10pKTtcbiAgICBkZWxldGUgdmFsdWVzWyd0aW1lJ107XG4gICAgbGF5b3V0T3B0aW9ucy5oYXNNID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gZmxhdENvb3JkaW5hdGVzO1xufVxuXG4vKipcbiAqIENob29zZSBHZW9tZXRyeUxheW91dCBiYXNlZCBvbiBmbGFncyBpbiBsYXlvdXRPcHRpb25zIGFuZCBhZGp1c3QgZmxhdENvb3JkaW5hdGVzXG4gKiBhbmQgZW5kcyBhcnJheXMgYnkgc2hyaW5raW5nIHRoZW0gYWNjb3JkaW5nbHkgKHJlbW92aW5nIHVudXNlZCB6ZXJvIGVudHJpZXMpLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0T3B0aW9uc30gbGF5b3V0T3B0aW9ucyBMYXlvdXQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbmRzXSBFbmRzLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gTGF5b3V0LlxuICovXG5mdW5jdGlvbiBhcHBseUxheW91dE9wdGlvbnMobGF5b3V0T3B0aW9ucywgZmxhdENvb3JkaW5hdGVzLCBlbmRzKSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gKi9cbiAgbGV0IGxheW91dCA9ICdYWSc7XG4gIGxldCBzdHJpZGUgPSAyO1xuICBpZiAobGF5b3V0T3B0aW9ucy5oYXNaICYmIGxheW91dE9wdGlvbnMuaGFzTSkge1xuICAgIGxheW91dCA9ICdYWVpNJztcbiAgICBzdHJpZGUgPSA0O1xuICB9IGVsc2UgaWYgKGxheW91dE9wdGlvbnMuaGFzWikge1xuICAgIGxheW91dCA9ICdYWVonO1xuICAgIHN0cmlkZSA9IDM7XG4gIH0gZWxzZSBpZiAobGF5b3V0T3B0aW9ucy5oYXNNKSB7XG4gICAgbGF5b3V0ID0gJ1hZTSc7XG4gICAgc3RyaWRlID0gMztcbiAgfVxuICBpZiAoc3RyaWRlICE9PSA0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIDQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbaSAqIHN0cmlkZV0gPSBmbGF0Q29vcmRpbmF0ZXNbaSAqIDRdO1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKiBzdHJpZGUgKyAxXSA9IGZsYXRDb29yZGluYXRlc1tpICogNCArIDFdO1xuICAgICAgaWYgKGxheW91dE9wdGlvbnMuaGFzWikge1xuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbaSAqIHN0cmlkZSArIDJdID0gZmxhdENvb3JkaW5hdGVzW2kgKiA0ICsgMl07XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0T3B0aW9ucy5oYXNNKSB7XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tpICogc3RyaWRlICsgMl0gPSBmbGF0Q29vcmRpbmF0ZXNbaSAqIDQgKyAzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IChmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC8gNCkgKiBzdHJpZGU7XG4gICAgaWYgKGVuZHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBlbmRzW2ldID0gKGVuZHNbaV0gLyA0KSAqIHN0cmlkZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gcGFyc2VMaW5rKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHZhbHVlcyA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBjb25zdCBocmVmID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgaWYgKGhyZWYgIT09IG51bGwpIHtcbiAgICB2YWx1ZXNbJ2xpbmsnXSA9IGhyZWY7XG4gIH1cbiAgcGFyc2VOb2RlKExJTktfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBwYXJzZUV4dGVuc2lvbnMobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgdmFsdWVzID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIHZhbHVlc1snZXh0ZW5zaW9uc05vZGVfJ10gPSBub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBwYXJzZVJ0ZVB0KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHZhbHVlcyA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgUlRFUFRfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xuICBpZiAodmFsdWVzKSB7XG4gICAgY29uc3QgcnRlVmFsdWVzID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoXG4gICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoXG4gICAgICBydGVWYWx1ZXNbJ2ZsYXRDb29yZGluYXRlcyddXG4gICAgKTtcbiAgICBjb25zdCBsYXlvdXRPcHRpb25zID0gLyoqIEB0eXBlIHtMYXlvdXRPcHRpb25zfSAqLyAoXG4gICAgICBydGVWYWx1ZXNbJ2xheW91dE9wdGlvbnMnXVxuICAgICk7XG4gICAgYXBwZW5kQ29vcmRpbmF0ZShmbGF0Q29vcmRpbmF0ZXMsIGxheW91dE9wdGlvbnMsIG5vZGUsIHZhbHVlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gcGFyc2VUcmtQdChub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCB2YWx1ZXMgPSBwdXNoUGFyc2VBbmRQb3Aoe30sIFRSS1BUX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgaWYgKHZhbHVlcykge1xuICAgIGNvbnN0IHRya1ZhbHVlcyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKFxuICAgICAgb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICApO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKFxuICAgICAgdHJrVmFsdWVzWydmbGF0Q29vcmRpbmF0ZXMnXVxuICAgICk7XG4gICAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IC8qKiBAdHlwZSB7TGF5b3V0T3B0aW9uc30gKi8gKFxuICAgICAgdHJrVmFsdWVzWydsYXlvdXRPcHRpb25zJ11cbiAgICApO1xuICAgIGFwcGVuZENvb3JkaW5hdGUoZmxhdENvb3JkaW5hdGVzLCBsYXlvdXRPcHRpb25zLCBub2RlLCB2YWx1ZXMpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJrU2VnKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHZhbHVlcyA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBwYXJzZU5vZGUoVFJLU0VHX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID1cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgKHZhbHVlc1snZmxhdENvb3JkaW5hdGVzJ10pO1xuICBjb25zdCBlbmRzID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAodmFsdWVzWydlbmRzJ10pO1xuICBlbmRzLnB1c2goZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtGZWF0dXJlfHVuZGVmaW5lZH0gVHJhY2suXG4gKi9cbmZ1bmN0aW9uIHJlYWRSdGUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3Qgb3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSAqLyAoXG4gICAgb2JqZWN0U3RhY2tbMF1cbiAgKTtcbiAgY29uc3QgdmFsdWVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIHtcbiAgICAgICdmbGF0Q29vcmRpbmF0ZXMnOiBbXSxcbiAgICAgICdsYXlvdXRPcHRpb25zJzoge30sXG4gICAgfSxcbiAgICBSVEVfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGlmICghdmFsdWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICAodmFsdWVzWydmbGF0Q29vcmRpbmF0ZXMnXSk7XG4gIGRlbGV0ZSB2YWx1ZXNbJ2ZsYXRDb29yZGluYXRlcyddO1xuICBjb25zdCBsYXlvdXRPcHRpb25zID0gLyoqIEB0eXBlIHtMYXlvdXRPcHRpb25zfSAqLyAodmFsdWVzWydsYXlvdXRPcHRpb25zJ10pO1xuICBkZWxldGUgdmFsdWVzWydsYXlvdXRPcHRpb25zJ107XG4gIGNvbnN0IGxheW91dCA9IGFwcGx5TGF5b3V0T3B0aW9ucyhsYXlvdXRPcHRpb25zLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICBjb25zdCBnZW9tZXRyeSA9IG5ldyBMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgbGF5b3V0KTtcbiAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgZmFsc2UsIG9wdGlvbnMpO1xuICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoZ2VvbWV0cnkpO1xuICBmZWF0dXJlLnNldFByb3BlcnRpZXModmFsdWVzLCB0cnVlKTtcbiAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtGZWF0dXJlfHVuZGVmaW5lZH0gVHJhY2suXG4gKi9cbmZ1bmN0aW9uIHJlYWRUcmsobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3Qgb3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSAqLyAoXG4gICAgb2JqZWN0U3RhY2tbMF1cbiAgKTtcbiAgY29uc3QgdmFsdWVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIHtcbiAgICAgICdmbGF0Q29vcmRpbmF0ZXMnOiBbXSxcbiAgICAgICdlbmRzJzogW10sXG4gICAgICAnbGF5b3V0T3B0aW9ucyc6IHt9LFxuICAgIH0sXG4gICAgVFJLX1BBUlNFUlMsXG4gICAgbm9kZSxcbiAgICBvYmplY3RTdGFja1xuICApO1xuICBpZiAoIXZhbHVlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID1cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgKHZhbHVlc1snZmxhdENvb3JkaW5hdGVzJ10pO1xuICBkZWxldGUgdmFsdWVzWydmbGF0Q29vcmRpbmF0ZXMnXTtcbiAgY29uc3QgZW5kcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKHZhbHVlc1snZW5kcyddKTtcbiAgZGVsZXRlIHZhbHVlc1snZW5kcyddO1xuICBjb25zdCBsYXlvdXRPcHRpb25zID0gLyoqIEB0eXBlIHtMYXlvdXRPcHRpb25zfSAqLyAodmFsdWVzWydsYXlvdXRPcHRpb25zJ10pO1xuICBkZWxldGUgdmFsdWVzWydsYXlvdXRPcHRpb25zJ107XG4gIGNvbnN0IGxheW91dCA9IGFwcGx5TGF5b3V0T3B0aW9ucyhsYXlvdXRPcHRpb25zLCBmbGF0Q29vcmRpbmF0ZXMsIGVuZHMpO1xuICBjb25zdCBnZW9tZXRyeSA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpO1xuICB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCBmYWxzZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZShnZW9tZXRyeSk7XG4gIGZlYXR1cmUuc2V0UHJvcGVydGllcyh2YWx1ZXMsIHRydWUpO1xuICByZXR1cm4gZmVhdHVyZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge0ZlYXR1cmV8dW5kZWZpbmVkfSBXYXlwb2ludC5cbiAqL1xuZnVuY3Rpb24gcmVhZFdwdChub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9ICovIChcbiAgICBvYmplY3RTdGFja1swXVxuICApO1xuICBjb25zdCB2YWx1ZXMgPSBwdXNoUGFyc2VBbmRQb3Aoe30sIFdQVF9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmICghdmFsdWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBsYXlvdXRPcHRpb25zID0gLyoqIEB0eXBlIHtMYXlvdXRPcHRpb25zfSAqLyAoe30pO1xuICBjb25zdCBjb29yZGluYXRlcyA9IGFwcGVuZENvb3JkaW5hdGUoW10sIGxheW91dE9wdGlvbnMsIG5vZGUsIHZhbHVlcyk7XG4gIGNvbnN0IGxheW91dCA9IGFwcGx5TGF5b3V0T3B0aW9ucyhsYXlvdXRPcHRpb25zLCBjb29yZGluYXRlcyk7XG4gIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFBvaW50KGNvb3JkaW5hdGVzLCBsYXlvdXQpO1xuICB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCBmYWxzZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZShnZW9tZXRyeSk7XG4gIGZlYXR1cmUuc2V0UHJvcGVydGllcyh2YWx1ZXMsIHRydWUpO1xuICByZXR1cm4gZmVhdHVyZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSBmb3IgdGhlIGxpbmsncyBgaHJlZmAgYXR0cmlidXRlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVMaW5rKG5vZGUsIHZhbHVlLCBvYmplY3RTdGFjaykge1xuICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gY29udGV4dFsncHJvcGVydGllcyddO1xuICBjb25zdCBsaW5rID0gW3Byb3BlcnRpZXNbJ2xpbmtUZXh0J10sIHByb3BlcnRpZXNbJ2xpbmtUeXBlJ11dO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovICh7bm9kZTogbm9kZX0pLFxuICAgIExJTktfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICBsaW5rLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIExJTktfU0VRVUVOQ0VcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlV3B0VHlwZShub2RlLCBjb29yZGluYXRlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBjb250ZXh0Lm5vZGU7XG4gIGNvbnN0IG5hbWVzcGFjZVVSSSA9IHBhcmVudE5vZGUubmFtZXNwYWNlVVJJO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gY29udGV4dFsncHJvcGVydGllcyddO1xuICAvL0ZJWE1FIFByb2plY3Rpb24gaGFuZGxpbmdcbiAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnbGF0JywgU3RyaW5nKGNvb3JkaW5hdGVbMV0pKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnbG9uJywgU3RyaW5nKGNvb3JkaW5hdGVbMF0pKTtcbiAgY29uc3QgZ2VvbWV0cnlMYXlvdXQgPSBjb250ZXh0WydnZW9tZXRyeUxheW91dCddO1xuICBzd2l0Y2ggKGdlb21ldHJ5TGF5b3V0KSB7XG4gICAgY2FzZSAnWFlaTSc6XG4gICAgICBpZiAoY29vcmRpbmF0ZVszXSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzWyd0aW1lJ10gPSBjb29yZGluYXRlWzNdO1xuICAgICAgfVxuICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgJ1hZWic6XG4gICAgICBpZiAoY29vcmRpbmF0ZVsyXSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzWydlbGUnXSA9IGNvb3JkaW5hdGVbMl07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdYWU0nOlxuICAgICAgaWYgKGNvb3JkaW5hdGVbMl0gIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllc1sndGltZSddID0gY29vcmRpbmF0ZVsyXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgLy8gcGFzc1xuICB9XG4gIGNvbnN0IG9yZGVyZWRLZXlzID1cbiAgICBub2RlLm5vZGVOYW1lID09ICdydGVwdCdcbiAgICAgID8gUlRFUFRfVFlQRV9TRVFVRU5DRVtuYW1lc3BhY2VVUkldXG4gICAgICA6IFdQVF9UWVBFX1NFUVVFTkNFW25hbWVzcGFjZVVSSV07XG4gIGNvbnN0IHZhbHVlcyA9IG1ha2VTZXF1ZW5jZShwcm9wZXJ0aWVzLCBvcmRlcmVkS2V5cyk7XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICAoe25vZGU6IG5vZGUsICdwcm9wZXJ0aWVzJzogcHJvcGVydGllc30pLFxuICAgIFdQVF9UWVBFX1NFUklBTElaRVJTLFxuICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgdmFsdWVzLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIG9yZGVyZWRLZXlzXG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVSdGUobm9kZSwgZmVhdHVyZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3Qgb3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gKi8gKFxuICAgIG9iamVjdFN0YWNrWzBdXG4gICk7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcbiAgY29uc3QgY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgY29udGV4dFsncHJvcGVydGllcyddID0gcHJvcGVydGllcztcbiAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgY29uc3QgbGluZVN0cmluZyA9IC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi8gKFxuICAgICAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgdHJ1ZSwgb3B0aW9ucylcbiAgICApO1xuICAgIGNvbnRleHRbJ2dlb21ldHJ5TGF5b3V0J10gPSBsaW5lU3RyaW5nLmdldExheW91dCgpO1xuICAgIHByb3BlcnRpZXNbJ3J0ZXB0J10gPSBsaW5lU3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gIGNvbnN0IG9yZGVyZWRLZXlzID0gUlRFX1NFUVVFTkNFW3BhcmVudE5vZGUubmFtZXNwYWNlVVJJXTtcbiAgY29uc3QgdmFsdWVzID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIG9yZGVyZWRLZXlzKTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIFJURV9TRVJJQUxJWkVSUyxcbiAgICBPQkpFQ1RfUFJPUEVSVFlfTk9ERV9GQUNUT1JZLFxuICAgIHZhbHVlcyxcbiAgICBvYmplY3RTdGFjayxcbiAgICBvcmRlcmVkS2V5c1xuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVHJrKG5vZGUsIGZlYXR1cmUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9ICovIChcbiAgICBvYmplY3RTdGFja1swXVxuICApO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovXG4gIGNvbnN0IGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIGNvbnRleHRbJ3Byb3BlcnRpZXMnXSA9IHByb3BlcnRpZXM7XG4gIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgY29uc3QgbXVsdGlMaW5lU3RyaW5nID0gLyoqIEB0eXBlIHtNdWx0aUxpbmVTdHJpbmd9ICovIChcbiAgICAgIHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoZ2VvbWV0cnksIHRydWUsIG9wdGlvbnMpXG4gICAgKTtcbiAgICBwcm9wZXJ0aWVzWyd0cmtzZWcnXSA9IG11bHRpTGluZVN0cmluZy5nZXRMaW5lU3RyaW5ncygpO1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICBjb25zdCBvcmRlcmVkS2V5cyA9IFRSS19TRVFVRU5DRVtwYXJlbnROb2RlLm5hbWVzcGFjZVVSSV07XG4gIGNvbnN0IHZhbHVlcyA9IG1ha2VTZXF1ZW5jZShwcm9wZXJ0aWVzLCBvcmRlcmVkS2V5cyk7XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgY29udGV4dCxcbiAgICBUUktfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZVN0cmluZyBMaW5lU3RyaW5nLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZVRya1NlZyhub2RlLCBsaW5lU3RyaW5nLCBvYmplY3RTdGFjaykge1xuICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICBjb25zdCBjb250ZXh0ID0ge25vZGU6IG5vZGV9O1xuICBjb250ZXh0WydnZW9tZXRyeUxheW91dCddID0gbGluZVN0cmluZy5nZXRMYXlvdXQoKTtcbiAgY29udGV4dFsncHJvcGVydGllcyddID0ge307XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgY29udGV4dCxcbiAgICBUUktTRUdfU0VSSUFMSVpFUlMsXG4gICAgVFJLU0VHX05PREVfRkFDVE9SWSxcbiAgICBsaW5lU3RyaW5nLmdldENvb3JkaW5hdGVzKCksXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZVdwdChub2RlLCBmZWF0dXJlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSAqLyAoXG4gICAgb2JqZWN0U3RhY2tbMF1cbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBjb250ZXh0Wydwcm9wZXJ0aWVzJ10gPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcbiAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT0gJ1BvaW50Jykge1xuICAgIGNvbnN0IHBvaW50ID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKFxuICAgICAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgdHJ1ZSwgb3B0aW9ucylcbiAgICApO1xuICAgIGNvbnRleHRbJ2dlb21ldHJ5TGF5b3V0J10gPSBwb2ludC5nZXRMYXlvdXQoKTtcbiAgICB3cml0ZVdwdFR5cGUobm9kZSwgcG9pbnQuZ2V0Q29vcmRpbmF0ZXMoKSwgb2JqZWN0U3RhY2spO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdQWDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvSUdDXG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBUZXh0RmVhdHVyZSBmcm9tICcuL1RleHRGZWF0dXJlLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYmFyb21ldHJpYycgfCAnZ3BzJyB8ICdub25lJ30gSUdDWlxuICogSUdDIGFsdGl0dWRlL3ouIE9uZSBvZiAnYmFyb21ldHJpYycsICdncHMnLCAnbm9uZScuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IEJfUkVDT1JEX1JFID1cbiAgL15CKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezV9KShbTlNdKShcXGR7M30pKFxcZHs1fSkoW0VXXSkoW0FWXSkoXFxkezV9KShcXGR7NX0pLztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IEhfUkVDT1JEX1JFID0gL15ILihbQS1aXXszfSkuKj86KC4qKS87XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBIRkRURV9SRUNPUkRfUkUgPSAvXkhGRFRFKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pLztcblxuLyoqXG4gKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGluZyB0aGUgbmV3bGluZSBjaGFyYWN0ZXJzIGBcXHJcXG5gLCBgXFxyYCBhbmQgYFxcbmAuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBORVdMSU5FX1JFID0gL1xcclxcbnxcXHJ8XFxuLztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0lHQ1p9IFthbHRpdHVkZU1vZGU9J25vbmUnXSBBbHRpdHVkZSBtb2RlLiBQb3NzaWJsZVxuICogdmFsdWVzIGFyZSBgJ2Jhcm9tZXRyaWMnYCwgYCdncHMnYCwgYW5kIGAnbm9uZSdgLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRmVhdHVyZSBmb3JtYXQgZm9yIGAqLmlnY2AgZmxpZ2h0IHJlY29yZGluZyBmaWxlcy5cbiAqXG4gKiBBcyBJR0Mgc291cmNlcyBjb250YWluIGEgc2luZ2xlIGZlYXR1cmUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2Zvcm1hdC9JR0N+SUdDI3JlYWRGZWF0dXJlc30gd2lsbCByZXR1cm4gdGhlIGZlYXR1cmUgaW4gYW5cbiAqIGFycmF5XG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBJR0MgZXh0ZW5kcyBUZXh0RmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbignRVBTRzo0MzI2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJR0NafVxuICAgICAqL1xuICAgIHRoaXMuYWx0aXR1ZGVNb2RlXyA9IG9wdGlvbnMuYWx0aXR1ZGVNb2RlID8gb3B0aW9ucy5hbHRpdHVkZU1vZGUgOiAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWx0aXR1ZGVNb2RlID0gdGhpcy5hbHRpdHVkZU1vZGVfO1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChORVdMSU5FX1JFKTtcbiAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGxldCB5ZWFyID0gMjAwMDtcbiAgICBsZXQgbW9udGggPSAwO1xuICAgIGxldCBkYXkgPSAxO1xuICAgIGxldCBsYXN0RGF0ZVRpbWUgPSAtMTtcbiAgICBsZXQgaSwgaWk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBsZXQgbTtcbiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PSAnQicpIHtcbiAgICAgICAgbSA9IEJfUkVDT1JEX1JFLmV4ZWMobGluZSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgY29uc3QgaG91ciA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICAgICAgICBjb25zdCBtaW51dGUgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgICAgICAgIGxldCB5ID0gcGFyc2VJbnQobVs0XSwgMTApICsgcGFyc2VJbnQobVs1XSwgMTApIC8gNjAwMDA7XG4gICAgICAgICAgaWYgKG1bNl0gPT0gJ1MnKSB7XG4gICAgICAgICAgICB5ID0gLXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB4ID0gcGFyc2VJbnQobVs3XSwgMTApICsgcGFyc2VJbnQobVs4XSwgMTApIC8gNjAwMDA7XG4gICAgICAgICAgaWYgKG1bOV0gPT0gJ1cnKSB7XG4gICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKHgsIHkpO1xuICAgICAgICAgIGlmIChhbHRpdHVkZU1vZGUgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBsZXQgejtcbiAgICAgICAgICAgIGlmIChhbHRpdHVkZU1vZGUgPT0gJ2dwcycpIHtcbiAgICAgICAgICAgICAgeiA9IHBhcnNlSW50KG1bMTFdLCAxMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsdGl0dWRlTW9kZSA9PSAnYmFyb21ldHJpYycpIHtcbiAgICAgICAgICAgICAgeiA9IHBhcnNlSW50KG1bMTJdLCAxMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB6ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKHopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZGF0ZVRpbWUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCk7XG4gICAgICAgICAgLy8gRGV0ZWN0IFVUQyBtaWRuaWdodCB3cmFwIGFyb3VuZC5cbiAgICAgICAgICBpZiAoZGF0ZVRpbWUgPCBsYXN0RGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIGRhdGVUaW1lID0gRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSArIDEsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goZGF0ZVRpbWUgLyAxMDAwKTtcbiAgICAgICAgICBsYXN0RGF0ZVRpbWUgPSBkYXRlVGltZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaW5lLmNoYXJBdCgwKSA9PSAnSCcpIHtcbiAgICAgICAgbSA9IEhGRFRFX1JFQ09SRF9SRS5leGVjKGxpbmUpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGRheSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICAgICAgICBtb250aCA9IHBhcnNlSW50KG1bMl0sIDEwKSAtIDE7XG4gICAgICAgICAgeWVhciA9IDIwMDAgKyBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9IEhfUkVDT1JEX1JFLmV4ZWMobGluZSk7XG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbbVsxXV0gPSBtWzJdLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXQgPSBhbHRpdHVkZU1vZGUgPT0gJ25vbmUnID8gJ1hZTScgOiAnWFlaTSc7XG4gICAgY29uc3QgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgbGF5b3V0KTtcbiAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoXG4gICAgICB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGxpbmVTdHJpbmcsIGZhbHNlLCBvcHRpb25zKVxuICAgICk7XG4gICAgZmVhdHVyZS5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRydWUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge0FycmF5PEZlYXR1cmU+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21UZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5yZWFkRmVhdHVyZUZyb21UZXh0KHRleHQsIG9wdGlvbnMpO1xuICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gW2ZlYXR1cmVdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUdDO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9LTUxcbiAqL1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnLi4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgRmlsbCBmcm9tICcuLi9zdHlsZS9GaWxsLmpzJztcbmltcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi4vc3R5bGUvSWNvbi5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aVBvaW50IGZyb20gJy4uL2dlb20vTXVsdGlQb2ludC5qcyc7XG5pbXBvcnQgTXVsdGlQb2x5Z29uIGZyb20gJy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9nZW9tL1BvaW50LmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4uL3N0eWxlL1N0cm9rZS5qcyc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi4vc3R5bGUvVGV4dC5qcyc7XG5pbXBvcnQgWE1MRmVhdHVyZSBmcm9tICcuL1hNTEZlYXR1cmUuanMnO1xuaW1wb3J0IHtcbiAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgWE1MX1NDSEVNQV9JTlNUQU5DRV9VUkksXG4gIGNyZWF0ZUVsZW1lbnROUyxcbiAgZ2V0QWxsVGV4dENvbnRlbnQsXG4gIGlzRG9jdW1lbnQsXG4gIG1ha2VBcnJheUV4dGVuZGVyLFxuICBtYWtlQXJyYXlQdXNoZXIsXG4gIG1ha2VDaGlsZEFwcGVuZGVyLFxuICBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIsXG4gIG1ha2VSZXBsYWNlcixcbiAgbWFrZVNlcXVlbmNlLFxuICBtYWtlU2ltcGxlTm9kZUZhY3RvcnksXG4gIG1ha2VTdHJ1Y3R1cmVOUyxcbiAgcGFyc2UsXG4gIHBhcnNlTm9kZSxcbiAgcHVzaFBhcnNlQW5kUG9wLFxuICBwdXNoU2VyaWFsaXplQW5kUG9wLFxufSBmcm9tICcuLi94bWwuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge1xuICByZWFkQm9vbGVhbixcbiAgcmVhZERlY2ltYWwsXG4gIHJlYWRTdHJpbmcsXG4gIHdyaXRlQm9vbGVhblRleHROb2RlLFxuICB3cml0ZUNEQVRBU2VjdGlvbixcbiAgd3JpdGVEZWNpbWFsVGV4dE5vZGUsXG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUsXG59IGZyb20gJy4veHNkLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9uc30gZnJvbSAnLi9GZWF0dXJlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWZWMyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL0ljb24uanNcIikuSWNvbkFuY2hvclVuaXRzfSB4dW5pdHMgVW5pdHMgb2YgeC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN9IHl1bml0cyBVbml0cyBvZiBZLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9JY29uLmpzXCIpLkljb25PcmlnaW59IFtvcmlnaW5dIE9yaWdpbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEd4VHJhY2tPYmplY3RcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB3aGVucyBXaGVucy5cbiAqL1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbmNvbnN0IEdYX05BTUVTUEFDRV9VUklTID0gWydodHRwOi8vd3d3Lmdvb2dsZS5jb20va21sL2V4dC8yLjInXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudWxsfHN0cmluZz59XG4gKi9cbmNvbnN0IE5BTUVTUEFDRV9VUklTID0gW1xuICBudWxsLFxuICAnaHR0cDovL2VhcnRoLmdvb2dsZS5jb20va21sLzIuMCcsXG4gICdodHRwOi8vZWFydGguZ29vZ2xlLmNvbS9rbWwvMi4xJyxcbiAgJ2h0dHA6Ly9lYXJ0aC5nb29nbGUuY29tL2ttbC8yLjInLFxuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9rbWwvMi4yJyxcbl07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBTQ0hFTUFfTE9DQVRJT04gPVxuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9rbWwvMi4yICcgK1xuICAnaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20va21sL3NjaGVtYS9rbWwyMmd4LnhzZCc7XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3N0eWxlL0ljb24uanNcIikuSWNvbkFuY2hvclVuaXRzPn1cbiAqL1xuY29uc3QgSUNPTl9BTkNIT1JfVU5JVFNfTUFQID0ge1xuICAnZnJhY3Rpb24nOiAnZnJhY3Rpb24nLFxuICAncGl4ZWxzJzogJ3BpeGVscycsXG4gICdpbnNldFBpeGVscyc6ICdwaXhlbHMnLFxufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFBMQUNFTUFSS19QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdFeHRlbmRlZERhdGEnOiBleHRlbmRlZERhdGFQYXJzZXIsXG4gICAgJ1JlZ2lvbic6IHJlZ2lvblBhcnNlcixcbiAgICAnTXVsdGlHZW9tZXRyeSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkTXVsdGlHZW9tZXRyeSwgJ2dlb21ldHJ5JyksXG4gICAgJ0xpbmVTdHJpbmcnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZExpbmVTdHJpbmcsICdnZW9tZXRyeScpLFxuICAgICdMaW5lYXJSaW5nJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRMaW5lYXJSaW5nLCAnZ2VvbWV0cnknKSxcbiAgICAnUG9pbnQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvaW50LCAnZ2VvbWV0cnknKSxcbiAgICAnUG9seWdvbic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9seWdvbiwgJ2dlb21ldHJ5JyksXG4gICAgJ1N0eWxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHlsZSksXG4gICAgJ1N0eWxlTWFwJzogcGxhY2VtYXJrU3R5bGVNYXBQYXJzZXIsXG4gICAgJ2FkZHJlc3MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICAgJ2Rlc2NyaXB0aW9uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAgICduYW1lJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAgICdvcGVuJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRCb29sZWFuKSxcbiAgICAncGhvbmVOdW1iZXInOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICAgJ3N0eWxlVXJsJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHlsZVVSTCksXG4gICAgJ3Zpc2liaWxpdHknOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEJvb2xlYW4pLFxuICB9LFxuICBtYWtlU3RydWN0dXJlTlMoR1hfTkFNRVNQQUNFX1VSSVMsIHtcbiAgICAnTXVsdGlUcmFjayc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkR3hNdWx0aVRyYWNrLCAnZ2VvbWV0cnknKSxcbiAgICAnVHJhY2snOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEd4VHJhY2ssICdnZW9tZXRyeScpLFxuICB9KVxuKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IE5FVFdPUktfTElOS19QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdFeHRlbmRlZERhdGEnOiBleHRlbmRlZERhdGFQYXJzZXIsXG4gICdSZWdpb24nOiByZWdpb25QYXJzZXIsXG4gICdMaW5rJzogbGlua1BhcnNlcixcbiAgJ2FkZHJlc3MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdkZXNjcmlwdGlvbic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ25hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdvcGVuJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRCb29sZWFuKSxcbiAgJ3Bob25lTnVtYmVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAndmlzaWJpbGl0eSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQm9vbGVhbiksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IExJTktfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnaHJlZic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkVVJJKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgQ0FNRVJBX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgQWx0aXR1ZGU6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gIExvbmdpdHVkZTogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgTGF0aXR1ZGU6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gIFRpbHQ6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gIEFsdGl0dWRlTW9kZTogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICBIZWFkaW5nOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICBSb2xsOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBSRUdJT05fUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTGF0TG9uQWx0Qm94JzogbGF0TG9uQWx0Qm94UGFyc2VyLFxuICAnTG9kJzogbG9kUGFyc2VyLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8c3RyaW5nPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEtNTF9TRVFVRU5DRSA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywgWydEb2N1bWVudCcsICdQbGFjZW1hcmsnXSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgS01MX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdEb2N1bWVudCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRG9jdW1lbnQpLFxuICAnUGxhY2VtYXJrJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVQbGFjZW1hcmspLFxufSk7XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfVxuICovXG5sZXQgREVGQVVMVF9DT0xPUjtcblxuLyoqXG4gKiBAdHlwZSB7RmlsbHxudWxsfVxuICovXG5sZXQgREVGQVVMVF9GSUxMX1NUWUxFID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgZmlsbCBzdHlsZSAob3IgbnVsbCBpZiBub3QgeWV0IHNldCkuXG4gKiBAcmV0dXJuIHtGaWxsfG51bGx9IFRoZSBkZWZhdWx0IGZpbGwgc3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RmlsbFN0eWxlKCkge1xuICByZXR1cm4gREVGQVVMVF9GSUxMX1NUWUxFO1xufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gKi9cbmxldCBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUjtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN9XG4gKi9cbmxldCBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUl9YX1VOSVRTO1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9JY29uLmpzXCIpLkljb25BbmNob3JVbml0c31cbiAqL1xubGV0IERFRkFVTFRfSU1BR0VfU1RZTEVfQU5DSE9SX1lfVU5JVFM7XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAqL1xubGV0IERFRkFVTFRfSU1BR0VfU1RZTEVfU0laRTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5sZXQgREVGQVVMVF9JTUFHRV9TVFlMRV9TUkM7XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAqL1xubGV0IERFRkFVTFRfSU1BR0VfU1RZTEUgPSBudWxsO1xuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBpbWFnZSBzdHlsZSAob3IgbnVsbCBpZiBub3QgeWV0IHNldCkuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9JbWFnZS5qc1wiKS5kZWZhdWx0fG51bGx9IFRoZSBkZWZhdWx0IGltYWdlIHN0eWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEltYWdlU3R5bGUoKSB7XG4gIHJldHVybiBERUZBVUxUX0lNQUdFX1NUWUxFO1xufVxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmxldCBERUZBVUxUX05PX0lNQUdFX1NUWUxFO1xuXG4vKipcbiAqIEB0eXBlIHtTdHJva2V8bnVsbH1cbiAqL1xubGV0IERFRkFVTFRfU1RST0tFX1NUWUxFID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgc3Ryb2tlIHN0eWxlIChvciBudWxsIGlmIG5vdCB5ZXQgc2V0KS5cbiAqIEByZXR1cm4ge1N0cm9rZXxudWxsfSBUaGUgZGVmYXVsdCBzdHJva2Ugc3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0U3Ryb2tlU3R5bGUoKSB7XG4gIHJldHVybiBERUZBVUxUX1NUUk9LRV9TVFlMRTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7U3Ryb2tlfVxuICovXG5sZXQgREVGQVVMVF9URVhUX1NUUk9LRV9TVFlMRTtcblxuLyoqXG4gKiBAdHlwZSB7VGV4dHxudWxsfVxuICovXG5sZXQgREVGQVVMVF9URVhUX1NUWUxFID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdGV4dCBzdHlsZSAob3IgbnVsbCBpZiBub3QgeWV0IHNldCkuXG4gKiBAcmV0dXJuIHtUZXh0fG51bGx9IFRoZSBkZWZhdWx0IHRleHQgc3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VGV4dFN0eWxlKCkge1xuICByZXR1cm4gREVGQVVMVF9URVhUX1NUWUxFO1xufVxuXG4vKipcbiAqIEB0eXBlIHtTdHlsZXxudWxsfVxuICovXG5sZXQgREVGQVVMVF9TVFlMRSA9IG51bGw7XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHN0eWxlIChvciBudWxsIGlmIG5vdCB5ZXQgc2V0KS5cbiAqIEByZXR1cm4ge1N0eWxlfG51bGx9IFRoZSBkZWZhdWx0IHN0eWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlKCkge1xuICByZXR1cm4gREVGQVVMVF9TVFlMRTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3R5bGU+fG51bGx9XG4gKi9cbmxldCBERUZBVUxUX1NUWUxFX0FSUkFZID0gbnVsbDtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgc3R5bGUgYXJyYXkgKG9yIG51bGwgaWYgbm90IHlldCBzZXQpLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fG51bGx9IFRoZSBkZWZhdWx0IHN0eWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlQXJyYXkoKSB7XG4gIHJldHVybiBERUZBVUxUX1NUWUxFX0FSUkFZO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2NhbGUgbmVlZGVkIHRvIG5vcm1hbGl6ZSBhbiBpY29uIGltYWdlIHRvIDMyIHBpeGVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIEltYWdlIHNpemUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNjYWxlLlxuICovXG5mdW5jdGlvbiBzY2FsZUZvclNpemUoc2l6ZSkge1xuICByZXR1cm4gMzIgLyBNYXRoLm1pbihzaXplWzBdLCBzaXplWzFdKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVEZWZhdWx0cygpIHtcbiAgREVGQVVMVF9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcblxuICBERUZBVUxUX0ZJTExfU1RZTEUgPSBuZXcgRmlsbCh7XG4gICAgY29sb3I6IERFRkFVTFRfQ09MT1IsXG4gIH0pO1xuXG4gIERFRkFVTFRfSU1BR0VfU1RZTEVfQU5DSE9SID0gWzIwLCAyXTtcblxuICBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUl9YX1VOSVRTID0gJ3BpeGVscyc7XG5cbiAgREVGQVVMVF9JTUFHRV9TVFlMRV9BTkNIT1JfWV9VTklUUyA9ICdwaXhlbHMnO1xuXG4gIERFRkFVTFRfSU1BR0VfU1RZTEVfU0laRSA9IFs2NCwgNjRdO1xuXG4gIERFRkFVTFRfSU1BR0VfU1RZTEVfU1JDID1cbiAgICAnaHR0cHM6Ly9tYXBzLmdvb2dsZS5jb20vbWFwZmlsZXMva21sL3B1c2hwaW4veWx3LXB1c2hwaW4ucG5nJztcblxuICBERUZBVUxUX0lNQUdFX1NUWUxFID0gbmV3IEljb24oe1xuICAgIGFuY2hvcjogREVGQVVMVF9JTUFHRV9TVFlMRV9BTkNIT1IsXG4gICAgYW5jaG9yT3JpZ2luOiAnYm90dG9tLWxlZnQnLFxuICAgIGFuY2hvclhVbml0czogREVGQVVMVF9JTUFHRV9TVFlMRV9BTkNIT1JfWF9VTklUUyxcbiAgICBhbmNob3JZVW5pdHM6IERFRkFVTFRfSU1BR0VfU1RZTEVfQU5DSE9SX1lfVU5JVFMsXG4gICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNjYWxlOiBzY2FsZUZvclNpemUoREVGQVVMVF9JTUFHRV9TVFlMRV9TSVpFKSxcbiAgICBzaXplOiBERUZBVUxUX0lNQUdFX1NUWUxFX1NJWkUsXG4gICAgc3JjOiBERUZBVUxUX0lNQUdFX1NUWUxFX1NSQyxcbiAgfSk7XG5cbiAgREVGQVVMVF9OT19JTUFHRV9TVFlMRSA9ICdOT19JTUFHRSc7XG5cbiAgREVGQVVMVF9TVFJPS0VfU1RZTEUgPSBuZXcgU3Ryb2tlKHtcbiAgICBjb2xvcjogREVGQVVMVF9DT0xPUixcbiAgICB3aWR0aDogMSxcbiAgfSk7XG5cbiAgREVGQVVMVF9URVhUX1NUUk9LRV9TVFlMRSA9IG5ldyBTdHJva2Uoe1xuICAgIGNvbG9yOiBbNTEsIDUxLCA1MSwgMV0sXG4gICAgd2lkdGg6IDIsXG4gIH0pO1xuXG4gIERFRkFVTFRfVEVYVF9TVFlMRSA9IG5ldyBUZXh0KHtcbiAgICBmb250OiAnYm9sZCAxNnB4IEhlbHZldGljYScsXG4gICAgZmlsbDogREVGQVVMVF9GSUxMX1NUWUxFLFxuICAgIHN0cm9rZTogREVGQVVMVF9URVhUX1NUUk9LRV9TVFlMRSxcbiAgICBzY2FsZTogMC44LFxuICB9KTtcblxuICBERUZBVUxUX1NUWUxFID0gbmV3IFN0eWxlKHtcbiAgICBmaWxsOiBERUZBVUxUX0ZJTExfU1RZTEUsXG4gICAgaW1hZ2U6IERFRkFVTFRfSU1BR0VfU1RZTEUsXG4gICAgdGV4dDogREVGQVVMVF9URVhUX1NUWUxFLFxuICAgIHN0cm9rZTogREVGQVVMVF9TVFJPS0VfU1RZTEUsXG4gICAgekluZGV4OiAwLFxuICB9KTtcblxuICBERUZBVUxUX1NUWUxFX0FSUkFZID0gW0RFRkFVTFRfU1RZTEVdO1xufVxuXG4vKipcbiAqIEB0eXBlIHtIVE1MVGV4dEFyZWFFbGVtZW50fVxuICovXG5sZXQgVEVYVEFSRUE7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdXJsIGB7c3RyaW5nfWAgYW5kIHJldHVybnMgYSB1cmwgYHtzdHJpbmd9YC5cbiAqIE1pZ2h0IGJlIHVzZWQgdG8gY2hhbmdlIGFuIGljb24gcGF0aCBvciB0byBzdWJzdGl0dXRlIGFcbiAqIGRhdGEgdXJsIG9idGFpbmVkIGZyb20gYSBLTVogYXJyYXkgYnVmZmVyLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihzdHJpbmcpOnN0cmluZ30gSWNvblVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSB1cmwgdW5jaGFuZ2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgSW5wdXQgdXJsLlxuICogQHJldHVybiB7c3RyaW5nfSBPdXRwdXQgdXJsLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0SWNvblVybEZ1bmN0aW9uKGhyZWYpIHtcbiAgcmV0dXJuIGhyZWY7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZXh0cmFjdFN0eWxlcz10cnVlXSBFeHRyYWN0IHN0eWxlcyBmcm9tIHRoZSBLTUwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93UG9pbnROYW1lcz10cnVlXSBTaG93IG5hbWVzIGFzIGxhYmVscyBmb3IgcGxhY2VtYXJrcyB3aGljaCBjb250YWluIHBvaW50cy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8U3R5bGU+fSBbZGVmYXVsdFN0eWxlXSBEZWZhdWx0IHN0eWxlLiBUaGVcbiAqIGRlZmF1bHQgZGVmYXVsdCBzdHlsZSBpcyB0aGUgc2FtZSBhcyBHb29nbGUgRWFydGguXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cml0ZVN0eWxlcz10cnVlXSBXcml0ZSBzdHlsZXMgaW50byBLTUwuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW49J2Fub255bW91cyddIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgYVxuICogYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBAcHJvcGVydHkge0ljb25VcmxGdW5jdGlvbn0gW2ljb25VcmxGdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCB0YWtlcyBhIHVybCBzdHJpbmcgYW5kIHJldHVybnMgYSB1cmwgc3RyaW5nLlxuICogTWlnaHQgYmUgdXNlZCB0byBjaGFuZ2UgYW4gaWNvbiBwYXRoIG9yIHRvIHN1YnN0aXR1dGUgYSBkYXRhIHVybCBvYnRhaW5lZCBmcm9tIGEgS01aIGFycmF5IGJ1ZmZlci5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEtNTCBmb3JtYXQuXG4gKlxuICoge0BsaW5rIG1vZHVsZTpvbC9mb3JtYXQvS01MfktNTCNyZWFkRmVhdHVyZX0gd2lsbCByZWFkIHRoZSBmaXJzdCBmZWF0dXJlIGZyb21cbiAqIGEgS01MIHNvdXJjZS5cbiAqXG4gKiBNdWx0aUdlb21ldHJpZXMgYXJlIGNvbnZlcnRlZCBpbnRvIEdlb21ldHJ5Q29sbGVjdGlvbnMgaWYgdGhleSBhcmUgYSBtaXggb2ZcbiAqIGdlb21ldHJ5IHR5cGVzLCBhbmQgaW50byBNdWx0aVBvaW50L011bHRpTGluZVN0cmluZy9NdWx0aVBvbHlnb24gaWYgdGhleSBhcmVcbiAqIGFsbCBvZiB0aGUgc2FtZSB0eXBlLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgS01MIGV4dGVuZHMgWE1MRmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGlmICghREVGQVVMVF9TVFlMRV9BUlJBWSkge1xuICAgICAgY3JlYXRlU3R5bGVEZWZhdWx0cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbignRVBTRzo0MzI2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0U3R5bGVfID0gb3B0aW9ucy5kZWZhdWx0U3R5bGVcbiAgICAgID8gb3B0aW9ucy5kZWZhdWx0U3R5bGVcbiAgICAgIDogREVGQVVMVF9TVFlMRV9BUlJBWTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0U3R5bGVzXyA9XG4gICAgICBvcHRpb25zLmV4dHJhY3RTdHlsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdFN0eWxlcyA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLndyaXRlU3R5bGVzXyA9XG4gICAgICBvcHRpb25zLndyaXRlU3R5bGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyaXRlU3R5bGVzIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAoQXJyYXk8U3R5bGU+fHN0cmluZyk+fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmVkU3R5bGVzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3dQb2ludE5hbWVzXyA9XG4gICAgICBvcHRpb25zLnNob3dQb2ludE5hbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNob3dQb2ludE5hbWVzIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsfHN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SWNvblVybEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuaWNvblVybEZ1bmN0aW9uXyA9IG9wdGlvbnMuaWNvblVybEZ1bmN0aW9uXG4gICAgICA/IG9wdGlvbnMuaWNvblVybEZ1bmN0aW9uXG4gICAgICA6IGRlZmF1bHRJY29uVXJsRnVuY3Rpb247XG5cbiAgICB0aGlzLnN1cHBvcnRlZE1lZGlhVHlwZXMgPSBbJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0FycmF5PEZlYXR1cmU+fHVuZGVmaW5lZH0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRG9jdW1lbnRPckZvbGRlcl8obm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgICAvLyBGSVhNRSB1c2Ugc2NvcGUgc29tZWhvd1xuICAgIGNvbnN0IHBhcnNlcnNOUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAgICAgJ0RvY3VtZW50JzogbWFrZUFycmF5RXh0ZW5kZXIodGhpcy5yZWFkRG9jdW1lbnRPckZvbGRlcl8sIHRoaXMpLFxuICAgICAgJ0ZvbGRlcic6IG1ha2VBcnJheUV4dGVuZGVyKHRoaXMucmVhZERvY3VtZW50T3JGb2xkZXJfLCB0aGlzKSxcbiAgICAgICdQbGFjZW1hcmsnOiBtYWtlQXJyYXlQdXNoZXIodGhpcy5yZWFkUGxhY2VtYXJrXywgdGhpcyksXG4gICAgICAnU3R5bGUnOiB0aGlzLnJlYWRTaGFyZWRTdHlsZV8uYmluZCh0aGlzKSxcbiAgICAgICdTdHlsZU1hcCc6IHRoaXMucmVhZFNoYXJlZFN0eWxlTWFwXy5iaW5kKHRoaXMpLFxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59ICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGZlYXR1cmVzID0gcHVzaFBhcnNlQW5kUG9wKFtdLCBwYXJzZXJzTlMsIG5vZGUsIG9iamVjdFN0YWNrLCB0aGlzKTtcbiAgICBpZiAoZmVhdHVyZXMpIHtcbiAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtGZWF0dXJlfHVuZGVmaW5lZH0gRmVhdHVyZS5cbiAgICovXG4gIHJlYWRQbGFjZW1hcmtfKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgeydnZW9tZXRyeSc6IG51bGx9LFxuICAgICAgUExBQ0VNQVJLX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgIGZlYXR1cmUuc2V0SWQoaWQpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9ICovIChcbiAgICAgIG9iamVjdFN0YWNrWzBdXG4gICAgKTtcblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0WydnZW9tZXRyeSddO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgZmFsc2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBmZWF0dXJlLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICBkZWxldGUgb2JqZWN0WydnZW9tZXRyeSddO1xuXG4gICAgaWYgKHRoaXMuZXh0cmFjdFN0eWxlc18pIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gb2JqZWN0WydTdHlsZSddO1xuICAgICAgY29uc3Qgc3R5bGVVcmwgPSBvYmplY3RbJ3N0eWxlVXJsJ107XG4gICAgICBjb25zdCBzdHlsZUZ1bmN0aW9uID0gY3JlYXRlRmVhdHVyZVN0eWxlRnVuY3Rpb24oXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBzdHlsZVVybCxcbiAgICAgICAgdGhpcy5kZWZhdWx0U3R5bGVfLFxuICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc18sXG4gICAgICAgIHRoaXMuc2hvd1BvaW50TmFtZXNfXG4gICAgICApO1xuICAgICAgZmVhdHVyZS5zZXRTdHlsZShzdHlsZUZ1bmN0aW9uKTtcbiAgICB9XG4gICAgZGVsZXRlIG9iamVjdFsnU3R5bGUnXTtcbiAgICAvLyB3ZSBkbyBub3QgcmVtb3ZlIHRoZSBzdHlsZVVybCBwcm9wZXJ0eSBmcm9tIHRoZSBvYmplY3QsIHNvIGl0XG4gICAgLy8gZ2V0cyBzdG9yZWQgb24gZmVhdHVyZSB3aGVuIHNldFByb3BlcnRpZXMgaXMgY2FsbGVkXG5cbiAgICBmZWF0dXJlLnNldFByb3BlcnRpZXMob2JqZWN0LCB0cnVlKTtcblxuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWFkU2hhcmVkU3R5bGVfKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgY29uc3QgaWQgPSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gcmVhZFN0eWxlLmNhbGwodGhpcywgbm9kZSwgb2JqZWN0U3RhY2spO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBzdHlsZVVyaTtcbiAgICAgICAgbGV0IGJhc2VVUkkgPSBub2RlLmJhc2VVUkk7XG4gICAgICAgIGlmICghYmFzZVVSSSB8fCBiYXNlVVJJID09ICdhYm91dDpibGFuaycpIHtcbiAgICAgICAgICBiYXNlVVJJID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VVUkkpIHtcbiAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCcjJyArIGlkLCBiYXNlVVJJKTtcbiAgICAgICAgICBzdHlsZVVyaSA9IHVybC5ocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlVXJpID0gJyMnICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNfW3N0eWxlVXJpXSA9IHN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVhZFNoYXJlZFN0eWxlTWFwXyhub2RlLCBvYmplY3RTdGFjaykge1xuICAgIGNvbnN0IGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlTWFwVmFsdWUgPSByZWFkU3R5bGVNYXBWYWx1ZS5jYWxsKHRoaXMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgICBpZiAoIXN0eWxlTWFwVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0eWxlVXJpO1xuICAgIGxldCBiYXNlVVJJID0gbm9kZS5iYXNlVVJJO1xuICAgIGlmICghYmFzZVVSSSB8fCBiYXNlVVJJID09ICdhYm91dDpibGFuaycpIHtcbiAgICAgIGJhc2VVUkkgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgaWYgKGJhc2VVUkkpIHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJyMnICsgaWQsIGJhc2VVUkkpO1xuICAgICAgc3R5bGVVcmkgPSB1cmwuaHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVVcmkgPSAnIycgKyBpZDtcbiAgICB9XG4gICAgdGhpcy5zaGFyZWRTdHlsZXNfW3N0eWxlVXJpXSA9IHN0eWxlTWFwVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFOQU1FU1BBQ0VfVVJJUy5pbmNsdWRlcyhub2RlLm5hbWVzcGFjZVVSSSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5yZWFkUGxhY2VtYXJrXyhub2RlLCBbXG4gICAgICB0aGlzLmdldFJlYWRPcHRpb25zKG5vZGUsIG9wdGlvbnMpLFxuICAgIF0pO1xuICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21Ob2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIU5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG5vZGUubmFtZXNwYWNlVVJJKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgZmVhdHVyZXM7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgaWYgKGxvY2FsTmFtZSA9PSAnRG9jdW1lbnQnIHx8IGxvY2FsTmFtZSA9PSAnRm9sZGVyJykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLnJlYWREb2N1bWVudE9yRm9sZGVyXyhub2RlLCBbXG4gICAgICAgIHRoaXMuZ2V0UmVhZE9wdGlvbnMobm9kZSwgb3B0aW9ucyksXG4gICAgICBdKTtcbiAgICAgIGlmIChmZWF0dXJlcykge1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChsb2NhbE5hbWUgPT0gJ1BsYWNlbWFyaycpIHtcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLnJlYWRQbGFjZW1hcmtfKG5vZGUsIFtcbiAgICAgICAgdGhpcy5nZXRSZWFkT3B0aW9ucyhub2RlLCBvcHRpb25zKSxcbiAgICAgIF0pO1xuICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFtmZWF0dXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGxvY2FsTmFtZSA9PSAna21sJykge1xuICAgICAgZmVhdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IG4gPSBub2RlLmZpcnN0RWxlbWVudENoaWxkOyBuOyBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3QgZnMgPSB0aGlzLnJlYWRGZWF0dXJlc0Zyb21Ob2RlKG4sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICBleHRlbmQoZmVhdHVyZXMsIGZzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmFtZSBvZiB0aGUgS01MLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBOYW1lLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkTmFtZShzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZE5hbWVGcm9tRG9jdW1lbnQoZG9jKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZE5hbWVGcm9tRG9jdW1lbnQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkTmFtZUZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHNvdXJjZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gTmFtZS5cbiAgICovXG4gIHJlYWROYW1lRnJvbURvY3VtZW50KGRvYykge1xuICAgIGZvciAobGV0IG4gPSAvKiogQHR5cGUge05vZGV9ICovIChkb2MuZmlyc3RDaGlsZCk7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5yZWFkTmFtZUZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG4pKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBOYW1lLlxuICAgKi9cbiAgcmVhZE5hbWVGcm9tTm9kZShub2RlKSB7XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IG47IG4gPSBuLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgaWYgKE5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG4ubmFtZXNwYWNlVVJJKSAmJiBuLmxvY2FsTmFtZSA9PSAnbmFtZScpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcobik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSBub2RlLmZpcnN0RWxlbWVudENoaWxkOyBuOyBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG4ubG9jYWxOYW1lO1xuICAgICAgaWYgKFxuICAgICAgICBOQU1FU1BBQ0VfVVJJUy5pbmNsdWRlcyhuLm5hbWVzcGFjZVVSSSkgJiZcbiAgICAgICAgKGxvY2FsTmFtZSA9PSAnRG9jdW1lbnQnIHx8XG4gICAgICAgICAgbG9jYWxOYW1lID09ICdGb2xkZXInIHx8XG4gICAgICAgICAgbG9jYWxOYW1lID09ICdQbGFjZW1hcmsnIHx8XG4gICAgICAgICAgbG9jYWxOYW1lID09ICdrbWwnKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnJlYWROYW1lRnJvbU5vZGUobik7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXR3b3JrIGxpbmtzIG9mIHRoZSBLTUwuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IE5ldHdvcmsgbGlua3MuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWROZXR3b3JrTGlua3Moc291cmNlKSB7XG4gICAgY29uc3QgbmV0d29ya0xpbmtzID0gW107XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgZXh0ZW5kKG5ldHdvcmtMaW5rcywgdGhpcy5yZWFkTmV0d29ya0xpbmtzRnJvbURvY3VtZW50KGRvYykpO1xuICAgIH0gZWxzZSBpZiAoaXNEb2N1bWVudChzb3VyY2UpKSB7XG4gICAgICBleHRlbmQoXG4gICAgICAgIG5ldHdvcmtMaW5rcyxcbiAgICAgICAgdGhpcy5yZWFkTmV0d29ya0xpbmtzRnJvbURvY3VtZW50KC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChzb3VyY2UpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKFxuICAgICAgICBuZXR3b3JrTGlua3MsXG4gICAgICAgIHRoaXMucmVhZE5ldHdvcmtMaW5rc0Zyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHNvdXJjZSkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV0d29ya0xpbmtzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gTmV0d29yayBsaW5rcy5cbiAgICovXG4gIHJlYWROZXR3b3JrTGlua3NGcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgY29uc3QgbmV0d29ya0xpbmtzID0gW107XG4gICAgZm9yIChsZXQgbiA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGRvYy5maXJzdENoaWxkKTsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChuLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICBuZXR3b3JrTGlua3MsXG4gICAgICAgICAgdGhpcy5yZWFkTmV0d29ya0xpbmtzRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobikpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXR3b3JrTGlua3M7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IE5ldHdvcmsgbGlua3MuXG4gICAqL1xuICByZWFkTmV0d29ya0xpbmtzRnJvbU5vZGUobm9kZSkge1xuICAgIGNvbnN0IG5ldHdvcmtMaW5rcyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSBub2RlLmZpcnN0RWxlbWVudENoaWxkOyBuOyBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgTkFNRVNQQUNFX1VSSVMuaW5jbHVkZXMobi5uYW1lc3BhY2VVUkkpICYmXG4gICAgICAgIG4ubG9jYWxOYW1lID09ICdOZXR3b3JrTGluaydcbiAgICAgICkge1xuICAgICAgICBjb25zdCBvYmogPSBwdXNoUGFyc2VBbmRQb3Aoe30sIE5FVFdPUktfTElOS19QQVJTRVJTLCBuLCBbXSk7XG4gICAgICAgIG5ldHdvcmtMaW5rcy5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IG4gPSBub2RlLmZpcnN0RWxlbWVudENoaWxkOyBuOyBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG4ubG9jYWxOYW1lO1xuICAgICAgaWYgKFxuICAgICAgICBOQU1FU1BBQ0VfVVJJUy5pbmNsdWRlcyhuLm5hbWVzcGFjZVVSSSkgJiZcbiAgICAgICAgKGxvY2FsTmFtZSA9PSAnRG9jdW1lbnQnIHx8IGxvY2FsTmFtZSA9PSAnRm9sZGVyJyB8fCBsb2NhbE5hbWUgPT0gJ2ttbCcpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKG5ldHdvcmtMaW5rcywgdGhpcy5yZWFkTmV0d29ya0xpbmtzRnJvbU5vZGUobikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV0d29ya0xpbmtzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHJlZ2lvbnMgb2YgdGhlIEtNTC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudHxFbGVtZW50fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gUmVnaW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZFJlZ2lvbihzb3VyY2UpIHtcbiAgICBjb25zdCByZWdpb25zID0gW107XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgZXh0ZW5kKHJlZ2lvbnMsIHRoaXMucmVhZFJlZ2lvbkZyb21Eb2N1bWVudChkb2MpKTtcbiAgICB9IGVsc2UgaWYgKGlzRG9jdW1lbnQoc291cmNlKSkge1xuICAgICAgZXh0ZW5kKFxuICAgICAgICByZWdpb25zLFxuICAgICAgICB0aGlzLnJlYWRSZWdpb25Gcm9tRG9jdW1lbnQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQocmVnaW9ucywgdGhpcy5yZWFkUmVnaW9uRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoc291cmNlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgRG9jdW1lbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IFJlZ2lvbi5cbiAgICovXG4gIHJlYWRSZWdpb25Gcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgY29uc3QgcmVnaW9ucyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAvKiogQHR5cGUge05vZGV9ICovIChkb2MuZmlyc3RDaGlsZCk7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBleHRlbmQocmVnaW9ucywgdGhpcy5yZWFkUmVnaW9uRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IFJlZ2lvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZFJlZ2lvbkZyb21Ob2RlKG5vZGUpIHtcbiAgICBjb25zdCByZWdpb25zID0gW107XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IG47IG4gPSBuLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgaWYgKE5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG4ubmFtZXNwYWNlVVJJKSAmJiBuLmxvY2FsTmFtZSA9PSAnUmVnaW9uJykge1xuICAgICAgICBjb25zdCBvYmogPSBwdXNoUGFyc2VBbmRQb3Aoe30sIFJFR0lPTl9QQVJTRVJTLCBuLCBbXSk7XG4gICAgICAgIHJlZ2lvbnMucHVzaChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBuID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgbjsgbiA9IG4ubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjb25zdCBsb2NhbE5hbWUgPSBuLmxvY2FsTmFtZTtcbiAgICAgIGlmIChcbiAgICAgICAgTkFNRVNQQUNFX1VSSVMuaW5jbHVkZXMobi5uYW1lc3BhY2VVUkkpICYmXG4gICAgICAgIChsb2NhbE5hbWUgPT0gJ0RvY3VtZW50JyB8fCBsb2NhbE5hbWUgPT0gJ0ZvbGRlcicgfHwgbG9jYWxOYW1lID09ICdrbWwnKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZWdpb25zLCB0aGlzLnJlYWRSZWdpb25Gcm9tTm9kZShuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWdpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEtNTENhbWVyYSBTcGVjaWZpZXMgdGhlIG9ic2VydmVyJ3Mgdmlld3BvaW50IGFuZCBhc3NvY2lhdGVkIHZpZXcgcGFyYW1ldGVycy5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtMYXRpdHVkZV0gTGF0aXR1ZGUgb2YgdGhlIGNhbWVyYS5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtMb25naXR1ZGVdIExvbmdpdHVkZSBvZiB0aGUgY2FtZXJhLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW0FsdGl0dWRlXSBBbHRpdHVkZSBvZiB0aGUgY2FtZXJhLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW0FsdGl0dWRlTW9kZV0gRmxvb3ItcmVsYXRlZCBhbHRpdHVkZSBtb2RlLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW0hlYWRpbmddIEhvcml6b250YWwgY2FtZXJhIHJvdGF0aW9uLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW1RpbHRdIExhdGVyYWwgY2FtZXJhIHJvdGF0aW9uLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW1JvbGxdIFZlcnRpY2FsIGNhbWVyYSByb3RhdGlvbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIGNhbWVyYXMgb2YgdGhlIEtNTC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudHxFbGVtZW50fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7QXJyYXk8S01MQ2FtZXJhPn0gQ2FtZXJhcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZENhbWVyYShzb3VyY2UpIHtcbiAgICBjb25zdCBjYW1lcmFzID0gW107XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgZXh0ZW5kKGNhbWVyYXMsIHRoaXMucmVhZENhbWVyYUZyb21Eb2N1bWVudChkb2MpKTtcbiAgICB9IGVsc2UgaWYgKGlzRG9jdW1lbnQoc291cmNlKSkge1xuICAgICAgZXh0ZW5kKFxuICAgICAgICBjYW1lcmFzLFxuICAgICAgICB0aGlzLnJlYWRDYW1lcmFGcm9tRG9jdW1lbnQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQoY2FtZXJhcywgdGhpcy5yZWFkQ2FtZXJhRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoc291cmNlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtZXJhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgRG9jdW1lbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PEtNTENhbWVyYT59IENhbWVyYXMuXG4gICAqL1xuICByZWFkQ2FtZXJhRnJvbURvY3VtZW50KGRvYykge1xuICAgIGNvbnN0IGNhbWVyYXMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9jLmZpcnN0Q2hpbGQpOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGV4dGVuZChjYW1lcmFzLCB0aGlzLnJlYWRDYW1lcmFGcm9tTm9kZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChuKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FtZXJhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHJldHVybiB7QXJyYXk8S01MQ2FtZXJhPn0gQ2FtZXJhcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZENhbWVyYUZyb21Ob2RlKG5vZGUpIHtcbiAgICBjb25zdCBjYW1lcmFzID0gW107XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IG47IG4gPSBuLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgaWYgKE5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG4ubmFtZXNwYWNlVVJJKSAmJiBuLmxvY2FsTmFtZSA9PT0gJ0NhbWVyYScpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBDQU1FUkFfUEFSU0VSUywgbiwgW10pO1xuICAgICAgICBjYW1lcmFzLnB1c2gob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbiA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IG47IG4gPSBuLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgY29uc3QgbG9jYWxOYW1lID0gbi5sb2NhbE5hbWU7XG4gICAgICBpZiAoXG4gICAgICAgIE5BTUVTUEFDRV9VUklTLmluY2x1ZGVzKG4ubmFtZXNwYWNlVVJJKSAmJlxuICAgICAgICAobG9jYWxOYW1lID09PSAnRG9jdW1lbnQnIHx8XG4gICAgICAgICAgbG9jYWxOYW1lID09PSAnRm9sZGVyJyB8fFxuICAgICAgICAgIGxvY2FsTmFtZSA9PT0gJ1BsYWNlbWFyaycgfHxcbiAgICAgICAgICBsb2NhbE5hbWUgPT09ICdrbWwnKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChjYW1lcmFzLCB0aGlzLnJlYWRDYW1lcmFGcm9tTm9kZShuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW1lcmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBhcnJheSBvZiBmZWF0dXJlcyBpbiB0aGUgS01MIGZvcm1hdCBhcyBhbiBYTUwgbm9kZS4gR2VvbWV0cnlDb2xsZWN0aW9ucyxcbiAgICogTXVsdGlQb2ludHMsIE11bHRpTGluZVN0cmluZ3MsIGFuZCBNdWx0aVBvbHlnb25zIGFyZSBvdXRwdXQgYXMgTXVsdGlHZW9tZXRyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEZlYXR1cmU+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7Tm9kZX0gTm9kZS5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlc05vZGUoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qga21sID0gY3JlYXRlRWxlbWVudE5TKE5BTUVTUEFDRV9VUklTWzRdLCAna21sJyk7XG4gICAgY29uc3QgeG1sbnNVcmkgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICAgIGttbC5zZXRBdHRyaWJ1dGVOUyh4bWxuc1VyaSwgJ3htbG5zOmd4JywgR1hfTkFNRVNQQUNFX1VSSVNbMF0pO1xuICAgIGttbC5zZXRBdHRyaWJ1dGVOUyh4bWxuc1VyaSwgJ3htbG5zOnhzaScsIFhNTF9TQ0hFTUFfSU5TVEFOQ0VfVVJJKTtcbiAgICBrbWwuc2V0QXR0cmlidXRlTlMoXG4gICAgICBYTUxfU0NIRU1BX0lOU1RBTkNFX1VSSSxcbiAgICAgICd4c2k6c2NoZW1hTG9jYXRpb24nLFxuICAgICAgU0NIRU1BX0xPQ0FUSU9OXG4gICAgKTtcblxuICAgIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7XG4gICAgICAgIG5vZGU6IGttbCxcbiAgICAgIH07XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgKEFycmF5PEZlYXR1cmU+fEZlYXR1cmV8dW5kZWZpbmVkKT59ICovXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICBwcm9wZXJ0aWVzWydEb2N1bWVudCddID0gZmVhdHVyZXM7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlcy5sZW5ndGggPT0gMSkge1xuICAgICAgcHJvcGVydGllc1snUGxhY2VtYXJrJ10gPSBmZWF0dXJlc1swXTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXJlZEtleXMgPSBLTUxfU0VRVUVOQ0Vba21sLm5hbWVzcGFjZVVSSV07XG4gICAgY29uc3QgdmFsdWVzID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIG9yZGVyZWRLZXlzKTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgY29udGV4dCxcbiAgICAgIEtNTF9TRVJJQUxJWkVSUyxcbiAgICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgICB2YWx1ZXMsXG4gICAgICBbb3B0aW9uc10sXG4gICAgICBvcmRlcmVkS2V5cyxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIHJldHVybiBrbWw7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlfHVuZGVmaW5lZH0gZm91bmRTdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUuXG4gKiBAcmV0dXJuIHtTdHlsZX0gc3R5bGUgU3R5bGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVTdHlsZUZ1bmN0aW9uKGZvdW5kU3R5bGUsIG5hbWUpIHtcbiAgY29uc3QgdGV4dE9mZnNldCA9IFswLCAwXTtcbiAgLyoqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovXG4gIGxldCB0ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICBjb25zdCBpbWFnZVN0eWxlID0gZm91bmRTdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGNvbnN0IGltYWdlU2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIGlmIChpbWFnZVNpemUgJiYgaW1hZ2VTaXplLmxlbmd0aCA9PSAyKSB7XG4gICAgICBjb25zdCBpbWFnZVNjYWxlID0gaW1hZ2VTdHlsZS5nZXRTY2FsZUFycmF5KCk7XG4gICAgICBjb25zdCBhbmNob3IgPSBpbWFnZVN0eWxlLmdldEFuY2hvcigpO1xuICAgICAgLy8gT2Zmc2V0IHRoZSBsYWJlbCB0byBiZSBjZW50ZXJlZCB0byB0aGUgcmlnaHQgb2YgdGhlIGljb24sXG4gICAgICAvLyBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICB0ZXh0T2Zmc2V0WzBdID0gaW1hZ2VTY2FsZVswXSAqIChpbWFnZVNpemVbMF0gLSBhbmNob3JbMF0pO1xuICAgICAgdGV4dE9mZnNldFsxXSA9IGltYWdlU2NhbGVbMV0gKiAoaW1hZ2VTaXplWzFdIC8gMiAtIGFuY2hvclsxXSk7XG4gICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgfVxuICB9XG4gIGxldCB0ZXh0U3R5bGUgPSBmb3VuZFN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIC8vIGNsb25lIHRoZSB0ZXh0IHN0eWxlLCBjdXN0b21pemluZyBpdCB3aXRoIG5hbWUsIGFsaWdubWVudHMgYW5kIG9mZnNldC5cbiAgICAvLyBOb3RlIHRoYXQga21sIGRvZXMgbm90IHN1cHBvcnQgbWFueSB0ZXh0IG9wdGlvbnMgdGhhdCBPcGVuTGF5ZXJzIGRvZXMgKHJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUpLlxuICAgIHRleHRTdHlsZSA9IHRleHRTdHlsZS5jbG9uZSgpO1xuICAgIHRleHRTdHlsZS5zZXRGb250KHRleHRTdHlsZS5nZXRGb250KCkgfHwgREVGQVVMVF9URVhUX1NUWUxFLmdldEZvbnQoKSk7XG4gICAgdGV4dFN0eWxlLnNldFNjYWxlKHRleHRTdHlsZS5nZXRTY2FsZSgpIHx8IERFRkFVTFRfVEVYVF9TVFlMRS5nZXRTY2FsZSgpKTtcbiAgICB0ZXh0U3R5bGUuc2V0RmlsbCh0ZXh0U3R5bGUuZ2V0RmlsbCgpIHx8IERFRkFVTFRfVEVYVF9TVFlMRS5nZXRGaWxsKCkpO1xuICAgIHRleHRTdHlsZS5zZXRTdHJva2UodGV4dFN0eWxlLmdldFN0cm9rZSgpIHx8IERFRkFVTFRfVEVYVF9TVFJPS0VfU1RZTEUpO1xuICB9IGVsc2Uge1xuICAgIHRleHRTdHlsZSA9IERFRkFVTFRfVEVYVF9TVFlMRS5jbG9uZSgpO1xuICB9XG4gIHRleHRTdHlsZS5zZXRUZXh0KG5hbWUpO1xuICB0ZXh0U3R5bGUuc2V0T2Zmc2V0WCh0ZXh0T2Zmc2V0WzBdKTtcbiAgdGV4dFN0eWxlLnNldE9mZnNldFkodGV4dE9mZnNldFsxXSk7XG4gIHRleHRTdHlsZS5zZXRUZXh0QWxpZ24odGV4dEFsaWduKTtcblxuICBjb25zdCBuYW1lU3R5bGUgPSBuZXcgU3R5bGUoe1xuICAgIGltYWdlOiBpbWFnZVN0eWxlLFxuICAgIHRleHQ6IHRleHRTdHlsZSxcbiAgfSk7XG4gIHJldHVybiBuYW1lU3R5bGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZT58dW5kZWZpbmVkfSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVVybCBTdHlsZSBVUkwuXG4gKiBAcGFyYW0ge0FycmF5PFN0eWxlPn0gZGVmYXVsdFN0eWxlIERlZmF1bHQgc3R5bGUuXG4gKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAoQXJyYXk8U3R5bGU+fHN0cmluZyk+fSBzaGFyZWRTdHlsZXMgU2hhcmVkIHN0eWxlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHNob3dQb2ludE5hbWVzIHRydWUgdG8gc2hvdyBuYW1lcyBmb3IgcG9pbnQgcGxhY2VtYXJrcy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IEZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZlYXR1cmVTdHlsZUZ1bmN0aW9uKFxuICBzdHlsZSxcbiAgc3R5bGVVcmwsXG4gIGRlZmF1bHRTdHlsZSxcbiAgc2hhcmVkU3R5bGVzLFxuICBzaG93UG9pbnROYW1lc1xuKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxTdHlsZT58U3R5bGV9IFN0eWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgICBsZXQgZHJhd05hbWUgPSBzaG93UG9pbnROYW1lcztcbiAgICAgIGxldCBuYW1lID0gJyc7XG4gICAgICBsZXQgbXVsdGlHZW9tZXRyeVBvaW50cyA9IFtdO1xuICAgICAgaWYgKGRyYXdOYW1lKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG11bHRpR2VvbWV0cnlQb2ludHMgPSBnZW9tZXRyeVxuICAgICAgICAgICAgICAuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKClcbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50JztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkcmF3TmFtZSA9IG11bHRpR2VvbWV0cnlQb2ludHMubGVuZ3RoID4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGRyYXdOYW1lID0gdHlwZSA9PT0gJ1BvaW50JyB8fCB0eXBlID09PSAnTXVsdGlQb2ludCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3TmFtZSkge1xuICAgICAgICBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChmZWF0dXJlLmdldCgnbmFtZScpKTtcbiAgICAgICAgZHJhd05hbWUgPSBkcmF3TmFtZSAmJiAhIW5hbWU7XG4gICAgICAgIC8vIGNvbnZlcnQgYW55IGh0bWwgY2hhcmFjdGVyIGNvZGVzXG4gICAgICAgIGlmIChkcmF3TmFtZSAmJiAvJlteJl0rOy8udGVzdChuYW1lKSkge1xuICAgICAgICAgIGlmICghVEVYVEFSRUEpIHtcbiAgICAgICAgICAgIFRFWFRBUkVBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVEVYVEFSRUEuaW5uZXJIVE1MID0gbmFtZTtcbiAgICAgICAgICBuYW1lID0gVEVYVEFSRUEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGZlYXR1cmVTdHlsZSA9IGRlZmF1bHRTdHlsZTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBmZWF0dXJlU3R5bGUgPSBzdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVVcmwpIHtcbiAgICAgICAgZmVhdHVyZVN0eWxlID0gZmluZFN0eWxlKHN0eWxlVXJsLCBkZWZhdWx0U3R5bGUsIHNoYXJlZFN0eWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAoZHJhd05hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZVN0eWxlID0gY3JlYXRlTmFtZVN0eWxlRnVuY3Rpb24oZmVhdHVyZVN0eWxlWzBdLCBuYW1lKTtcbiAgICAgICAgaWYgKG11bHRpR2VvbWV0cnlQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGluIG11bHRpZ2VvbWV0cmllcyByZXN0cmljdCB0aGUgbmFtZSBzdHlsZSB0byBwb2ludHMgYW5kIGNyZWF0ZSBhXG4gICAgICAgICAgLy8gc3R5bGUgd2l0aG91dCBpbWFnZSBvciB0ZXh0IGZvciBnZW9tZXRyaWVzIHJlcXVpcmluZyBmaWxsIG9yIHN0cm9rZVxuICAgICAgICAgIC8vIGluY2x1ZGluZyBhbnkgcG9seWdvbiBzcGVjaWZpYyBzdHlsZSBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICBuYW1lU3R5bGUuc2V0R2VvbWV0cnkobmV3IEdlb21ldHJ5Q29sbGVjdGlvbihtdWx0aUdlb21ldHJ5UG9pbnRzKSk7XG4gICAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gbmV3IFN0eWxlKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBmZWF0dXJlU3R5bGVbMF0uZ2V0R2VvbWV0cnkoKSxcbiAgICAgICAgICAgIGltYWdlOiBudWxsLFxuICAgICAgICAgICAgZmlsbDogZmVhdHVyZVN0eWxlWzBdLmdldEZpbGwoKSxcbiAgICAgICAgICAgIHN0cm9rZTogZmVhdHVyZVN0eWxlWzBdLmdldFN0cm9rZSgpLFxuICAgICAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gW25hbWVTdHlsZSwgYmFzZVN0eWxlXS5jb25jYXQoZmVhdHVyZVN0eWxlLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZVN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZlYXR1cmVTdHlsZTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZT58c3RyaW5nfHVuZGVmaW5lZH0gc3R5bGVWYWx1ZSBTdHlsZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXk8U3R5bGU+fSBkZWZhdWx0U3R5bGUgRGVmYXVsdCBzdHlsZS5cbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIChBcnJheTxTdHlsZT58c3RyaW5nKT59IHNoYXJlZFN0eWxlc1xuICogU2hhcmVkIHN0eWxlcy5cbiAqIEByZXR1cm4ge0FycmF5PFN0eWxlPn0gU3R5bGUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdHlsZShzdHlsZVZhbHVlLCBkZWZhdWx0U3R5bGUsIHNoYXJlZFN0eWxlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZVZhbHVlKSkge1xuICAgIHJldHVybiBzdHlsZVZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmluZFN0eWxlKHNoYXJlZFN0eWxlc1tzdHlsZVZhbHVlXSwgZGVmYXVsdFN0eWxlLCBzaGFyZWRTdHlsZXMpO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3R5bGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnx1bmRlZmluZWR9IENvbG9yLlxuICovXG5mdW5jdGlvbiByZWFkQ29sb3Iobm9kZSkge1xuICBjb25zdCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpO1xuICAvLyBUaGUgS01MIHNwZWNpZmljYXRpb24gc3RhdGVzIHRoYXQgY29sb3JzIHNob3VsZCBub3QgaW5jbHVkZSBhIGxlYWRpbmcgYCNgXG4gIC8vIGJ1dCB3ZSB0b2xlcmF0ZSB0aGVtLlxuICBjb25zdCBtID0gL15cXHMqIz9cXHMqKFswLTlBLUZhLWZdezh9KVxccyokLy5leGVjKHMpO1xuICBpZiAobSkge1xuICAgIGNvbnN0IGhleENvbG9yID0gbVsxXTtcbiAgICByZXR1cm4gW1xuICAgICAgcGFyc2VJbnQoaGV4Q29sb3Iuc3Vic3RyKDYsIDIpLCAxNiksXG4gICAgICBwYXJzZUludChoZXhDb2xvci5zdWJzdHIoNCwgMiksIDE2KSxcbiAgICAgIHBhcnNlSW50KGhleENvbG9yLnN1YnN0cigyLCAyKSwgMTYpLFxuICAgICAgcGFyc2VJbnQoaGV4Q29sb3Iuc3Vic3RyKDAsIDIpLCAxNikgLyAyNTUsXG4gICAgXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEZsYXQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkRmxhdENvb3JkaW5hdGVzKG5vZGUpIHtcbiAgbGV0IHMgPSBnZXRBbGxUZXh0Q29udGVudChub2RlLCBmYWxzZSk7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAvLyBUaGUgS01MIHNwZWNpZmljYXRpb24gc3RhdGVzIHRoYXQgY29vcmRpbmF0ZSB0dXBsZXMgc2hvdWxkIG5vdCBpbmNsdWRlXG4gIC8vIHNwYWNlcywgYnV0IHdlIHRvbGVyYXRlIHRoZW0uXG4gIHMgPSBzLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCcpO1xuICBjb25zdCByZSA9XG4gICAgL15cXHMqKFsrXFwtXT9cXGQqXFwuP1xcZCsoPzplWytcXC1dP1xcZCspPyksKFsrXFwtXT9cXGQqXFwuP1xcZCsoPzplWytcXC1dP1xcZCspPykoPzpcXHMrfCx8JCkoPzooWytcXC1dP1xcZCpcXC4/XFxkKyg/OmVbK1xcLV0/XFxkKyk/KSg/Olxccyt8JCkpP1xccyovaTtcbiAgbGV0IG07XG4gIHdoaWxlICgobSA9IHJlLmV4ZWMocykpKSB7XG4gICAgY29uc3QgeCA9IHBhcnNlRmxvYXQobVsxXSk7XG4gICAgY29uc3QgeSA9IHBhcnNlRmxvYXQobVsyXSk7XG4gICAgY29uc3QgeiA9IG1bM10gPyBwYXJzZUZsb2F0KG1bM10pIDogMDtcbiAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaCh4LCB5LCB6KTtcbiAgICBzID0gcy5zdWJzdHIobVswXS5sZW5ndGgpO1xuICB9XG4gIGlmIChzICE9PSAnJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZsYXRDb29yZGluYXRlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVVJJLlxuICovXG5mdW5jdGlvbiByZWFkVVJJKG5vZGUpIHtcbiAgY29uc3QgcyA9IGdldEFsbFRleHRDb250ZW50KG5vZGUsIGZhbHNlKS50cmltKCk7XG4gIGxldCBiYXNlVVJJID0gbm9kZS5iYXNlVVJJO1xuICBpZiAoIWJhc2VVUkkgfHwgYmFzZVVSSSA9PSAnYWJvdXQ6YmxhbmsnKSB7XG4gICAgYmFzZVVSSSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIGlmIChiYXNlVVJJKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzLCBiYXNlVVJJKTtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFVSSS5cbiAqL1xuZnVuY3Rpb24gcmVhZFN0eWxlVVJMKG5vZGUpIHtcbiAgLy8gS01MIGZpbGVzIGluIHRoZSB3aWxkIG9jY2FzaW9uYWxseSBmb3JnZXQgdGhlIGxlYWRpbmdcbiAgLy8gYCNgIG9uIHN0eWxlVXJsc2RlZmluZWQgaW4gdGhlIHNhbWUgZG9jdW1lbnQuXG4gIGNvbnN0IHMgPSBnZXRBbGxUZXh0Q29udGVudChub2RlLCBmYWxzZSlcbiAgICAudHJpbSgpXG4gICAgLnJlcGxhY2UoL14oPyEuKiMpLywgJyMnKTtcbiAgbGV0IGJhc2VVUkkgPSBub2RlLmJhc2VVUkk7XG4gIGlmICghYmFzZVVSSSB8fCBiYXNlVVJJID09ICdhYm91dDpibGFuaycpIHtcbiAgICBiYXNlVVJJID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbiAgaWYgKGJhc2VVUkkpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHMsIGJhc2VVUkkpO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEByZXR1cm4ge1ZlYzJ9IFZlYzIuXG4gKi9cbmZ1bmN0aW9uIHJlYWRWZWMyKG5vZGUpIHtcbiAgY29uc3QgeHVuaXRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3h1bml0cycpO1xuICBjb25zdCB5dW5pdHMgPSBub2RlLmdldEF0dHJpYnV0ZSgneXVuaXRzJyk7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9zdHlsZS9JY29uLmpzJykuSWNvbk9yaWdpbn0gKi9cbiAgbGV0IG9yaWdpbjtcbiAgaWYgKHh1bml0cyAhPT0gJ2luc2V0UGl4ZWxzJykge1xuICAgIGlmICh5dW5pdHMgIT09ICdpbnNldFBpeGVscycpIHtcbiAgICAgIG9yaWdpbiA9ICdib3R0b20tbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yaWdpbiA9ICd0b3AtbGVmdCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh5dW5pdHMgIT09ICdpbnNldFBpeGVscycpIHtcbiAgICAgIG9yaWdpbiA9ICdib3R0b20tcmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW4gPSAndG9wLXJpZ2h0JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4JykpLFxuICAgIHh1bml0czogSUNPTl9BTkNIT1JfVU5JVFNfTUFQW3h1bml0c10sXG4gICAgeTogcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneScpKSxcbiAgICB5dW5pdHM6IElDT05fQU5DSE9SX1VOSVRTX01BUFt5dW5pdHNdLFxuICAgIG9yaWdpbjogb3JpZ2luLFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gU2NhbGUuXG4gKi9cbmZ1bmN0aW9uIHJlYWRTY2FsZShub2RlKSB7XG4gIHJldHVybiByZWFkRGVjaW1hbChub2RlKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFNUWUxFX01BUF9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdQYWlyJzogcGFpckRhdGFQYXJzZXIsXG59KTtcblxuLyoqXG4gKiBAdGhpcyB7S01MfVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtBcnJheTxTdHlsZT58c3RyaW5nfHVuZGVmaW5lZH0gU3R5bGVNYXAuXG4gKi9cbmZ1bmN0aW9uIHJlYWRTdHlsZU1hcFZhbHVlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3AodW5kZWZpbmVkLCBTVFlMRV9NQVBfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2ssIHRoaXMpO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgSUNPTl9TVFlMRV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdJY29uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRJY29uKSxcbiAgJ2NvbG9yJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb2xvciksXG4gICdoZWFkaW5nJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ2hvdFNwb3QnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFZlYzIpLFxuICAnc2NhbGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFNjYWxlKSxcbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtLTUx9XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gaWNvblN0eWxlUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIC8vIEZJWE1FIHJlZnJlc2hNb2RlXG4gIC8vIEZJWE1FIHJlZnJlc2hJbnRlcnZhbFxuICAvLyBGSVhNRSB2aWV3UmVmcmVzaFRpbWVcbiAgLy8gRklYTUUgdmlld0JvdW5kU2NhbGVcbiAgLy8gRklYTUUgdmlld0Zvcm1hdFxuICAvLyBGSVhNRSBodHRwUXVlcnlcbiAgY29uc3Qgb2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBJQ09OX1NUWUxFX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3R5bGVPYmplY3QgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKFxuICAgIG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdXG4gICk7XG4gIGNvbnN0IEljb25PYmplY3QgPSAnSWNvbicgaW4gb2JqZWN0ID8gb2JqZWN0WydJY29uJ10gOiB7fTtcbiAgY29uc3QgZHJhd0ljb24gPSAhKCdJY29uJyBpbiBvYmplY3QpIHx8IE9iamVjdC5rZXlzKEljb25PYmplY3QpLmxlbmd0aCA+IDA7XG4gIGxldCBzcmM7XG4gIGNvbnN0IGhyZWYgPSAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovIChJY29uT2JqZWN0WydocmVmJ10pO1xuICBpZiAoaHJlZikge1xuICAgIHNyYyA9IGhyZWY7XG4gIH0gZWxzZSBpZiAoZHJhd0ljb24pIHtcbiAgICBzcmMgPSBERUZBVUxUX0lNQUdFX1NUWUxFX1NSQztcbiAgfVxuICBsZXQgYW5jaG9yLCBhbmNob3JYVW5pdHMsIGFuY2hvcllVbml0cztcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL3N0eWxlL0ljb24uanMnKS5JY29uT3JpZ2lufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGFuY2hvck9yaWdpbiA9ICdib3R0b20tbGVmdCc7XG4gIGNvbnN0IGhvdFNwb3QgPSAvKiogQHR5cGUge1ZlYzJ8dW5kZWZpbmVkfSAqLyAob2JqZWN0Wydob3RTcG90J10pO1xuICBpZiAoaG90U3BvdCkge1xuICAgIGFuY2hvciA9IFtob3RTcG90LngsIGhvdFNwb3QueV07XG4gICAgYW5jaG9yWFVuaXRzID0gaG90U3BvdC54dW5pdHM7XG4gICAgYW5jaG9yWVVuaXRzID0gaG90U3BvdC55dW5pdHM7XG4gICAgYW5jaG9yT3JpZ2luID0gaG90U3BvdC5vcmlnaW47XG4gIH0gZWxzZSBpZiAoL15odHRwcz86XFwvXFwvbWFwc1xcLig/Omdvb2dsZXxnc3RhdGljKVxcLmNvbVxcLy8udGVzdChzcmMpKSB7XG4gICAgLy8gR29vZ2xlIGhvdHNwb3RzIGZyb20gaHR0cHM6Ly9rbWw0ZWFydGguYXBwc3BvdC5jb20vaWNvbnMuaHRtbCNub3Rlc1xuICAgIGlmIChzcmMuaW5jbHVkZXMoJ3B1c2hwaW4nKSkge1xuICAgICAgYW5jaG9yID0gREVGQVVMVF9JTUFHRV9TVFlMRV9BTkNIT1I7XG4gICAgICBhbmNob3JYVW5pdHMgPSBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUl9YX1VOSVRTO1xuICAgICAgYW5jaG9yWVVuaXRzID0gREVGQVVMVF9JTUFHRV9TVFlMRV9BTkNIT1JfWV9VTklUUztcbiAgICB9IGVsc2UgaWYgKHNyYy5pbmNsdWRlcygnYXJyb3ctcmV2ZXJzZScpKSB7XG4gICAgICBhbmNob3IgPSBbNTQsIDQyXTtcbiAgICAgIGFuY2hvclhVbml0cyA9IERFRkFVTFRfSU1BR0VfU1RZTEVfQU5DSE9SX1hfVU5JVFM7XG4gICAgICBhbmNob3JZVW5pdHMgPSBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUl9ZX1VOSVRTO1xuICAgIH0gZWxzZSBpZiAoc3JjLmluY2x1ZGVzKCdwYWRkbGUnKSkge1xuICAgICAgYW5jaG9yID0gWzMyLCAxXTtcbiAgICAgIGFuY2hvclhVbml0cyA9IERFRkFVTFRfSU1BR0VfU1RZTEVfQU5DSE9SX1hfVU5JVFM7XG4gICAgICBhbmNob3JZVW5pdHMgPSBERUZBVUxUX0lNQUdFX1NUWUxFX0FOQ0hPUl9ZX1VOSVRTO1xuICAgIH1cbiAgfVxuXG4gIGxldCBvZmZzZXQ7XG4gIGNvbnN0IHggPSAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovIChJY29uT2JqZWN0Wyd4J10pO1xuICBjb25zdCB5ID0gLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqLyAoSWNvbk9iamVjdFsneSddKTtcbiAgaWYgKHggIT09IHVuZGVmaW5lZCAmJiB5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSBbeCwgeV07XG4gIH1cblxuICBsZXQgc2l6ZTtcbiAgY29uc3QgdyA9IC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKEljb25PYmplY3RbJ3cnXSk7XG4gIGNvbnN0IGggPSAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovIChJY29uT2JqZWN0WydoJ10pO1xuICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgIHNpemUgPSBbdywgaF07XG4gIH1cblxuICBsZXQgcm90YXRpb247XG4gIGNvbnN0IGhlYWRpbmcgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKG9iamVjdFsnaGVhZGluZyddKTtcbiAgaWYgKGhlYWRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIHJvdGF0aW9uID0gdG9SYWRpYW5zKGhlYWRpbmcpO1xuICB9XG5cbiAgY29uc3Qgc2NhbGUgPSAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovIChvYmplY3RbJ3NjYWxlJ10pO1xuXG4gIGNvbnN0IGNvbG9yID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gKi8gKG9iamVjdFsnY29sb3InXSk7XG5cbiAgaWYgKGRyYXdJY29uKSB7XG4gICAgaWYgKHNyYyA9PSBERUZBVUxUX0lNQUdFX1NUWUxFX1NSQykge1xuICAgICAgc2l6ZSA9IERFRkFVTFRfSU1BR0VfU1RZTEVfU0laRTtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZVN0eWxlID0gbmV3IEljb24oe1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBhbmNob3JPcmlnaW46IGFuY2hvck9yaWdpbixcbiAgICAgIGFuY2hvclhVbml0czogYW5jaG9yWFVuaXRzLFxuICAgICAgYW5jaG9yWVVuaXRzOiBhbmNob3JZVW5pdHMsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIG9mZnNldE9yaWdpbjogJ2JvdHRvbS1sZWZ0JyxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBzcmM6IHRoaXMuaWNvblVybEZ1bmN0aW9uXyhzcmMpLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaW1hZ2VTY2FsZSA9IGltYWdlU3R5bGUuZ2V0U2NhbGVBcnJheSgpWzBdO1xuICAgIGNvbnN0IGltYWdlU2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIGlmIChpbWFnZVNpemUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGltYWdlU3RhdGUgPSBpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKTtcbiAgICAgIGlmIChpbWFnZVN0YXRlID09PSBJbWFnZVN0YXRlLklETEUgfHwgaW1hZ2VTdGF0ZSA9PT0gSW1hZ2VTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IGltYWdlU3RhdGUgPSBpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICBpbWFnZVN0YXRlID09PSBJbWFnZVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgaW1hZ2VTdGF0ZSA9PT0gSW1hZ2VTdGF0ZS5MT0FESU5HXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVNpemUgPSBpbWFnZVN0eWxlLmdldFNpemUoKTtcbiAgICAgICAgICAgIGlmIChpbWFnZVNpemUgJiYgaW1hZ2VTaXplLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlID0gc2NhbGVGb3JTaXplKGltYWdlU2l6ZSk7XG4gICAgICAgICAgICAgIGltYWdlU3R5bGUuc2V0U2NhbGUoaW1hZ2VTY2FsZSAqIHJlc2l6ZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlU3R5bGUudW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpbWFnZVN0eWxlLmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGltYWdlU3RhdGUgPT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgICAgIGltYWdlU3R5bGUubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbWFnZVNpemUubGVuZ3RoID09IDIpIHtcbiAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlID0gc2NhbGVGb3JTaXplKGltYWdlU2l6ZSk7XG4gICAgICBpbWFnZVN0eWxlLnNldFNjYWxlKGltYWdlU2NhbGUgKiByZXNpemVTY2FsZSk7XG4gICAgfVxuICAgIHN0eWxlT2JqZWN0WydpbWFnZVN0eWxlJ10gPSBpbWFnZVN0eWxlO1xuICB9IGVsc2Uge1xuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHdlIGV4cGxpY2l0bHkgd2FudCB0byBkcmF3IG5vIGljb24uXG4gICAgc3R5bGVPYmplY3RbJ2ltYWdlU3R5bGUnXSA9IERFRkFVTFRfTk9fSU1BR0VfU1RZTEU7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IExBQkVMX1NUWUxFX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2NvbG9yJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb2xvciksXG4gICdzY2FsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU2NhbGUpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIGxhYmVsU3R5bGVQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgLy8gRklYTUUgY29sb3JNb2RlXG4gIGNvbnN0IG9iamVjdCA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgTEFCRUxfU1RZTEVfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdHlsZU9iamVjdCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBjb25zdCB0ZXh0U3R5bGUgPSBuZXcgVGV4dCh7XG4gICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgY29sb3I6XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9ICovXG4gICAgICAgICgnY29sb3InIGluIG9iamVjdCA/IG9iamVjdFsnY29sb3InXSA6IERFRkFVTFRfQ09MT1IpLFxuICAgIH0pLFxuICAgIHNjYWxlOiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovIChvYmplY3RbJ3NjYWxlJ10pLFxuICB9KTtcbiAgc3R5bGVPYmplY3RbJ3RleHRTdHlsZSddID0gdGV4dFN0eWxlO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgTElORV9TVFlMRV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdjb2xvcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQ29sb3IpLFxuICAnd2lkdGgnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIGxpbmVTdHlsZVBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICAvLyBGSVhNRSBjb2xvck1vZGVcbiAgLy8gRklYTUUgZ3g6b3V0ZXJDb2xvclxuICAvLyBGSVhNRSBneDpvdXRlcldpZHRoXG4gIC8vIEZJWE1FIGd4OnBoeXNpY2FsV2lkdGhcbiAgLy8gRklYTUUgZ3g6bGFiZWxWaXNpYmlsaXR5XG4gIGNvbnN0IG9iamVjdCA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgTElORV9TVFlMRV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gbmV3IFN0cm9rZSh7XG4gICAgY29sb3I6XG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSAqL1xuICAgICAgKCdjb2xvcicgaW4gb2JqZWN0ID8gb2JqZWN0Wydjb2xvciddIDogREVGQVVMVF9DT0xPUiksXG4gICAgd2lkdGg6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoJ3dpZHRoJyBpbiBvYmplY3QgPyBvYmplY3RbJ3dpZHRoJ10gOiAxKSxcbiAgfSk7XG4gIHN0eWxlT2JqZWN0WydzdHJva2VTdHlsZSddID0gc3Ryb2tlU3R5bGU7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBQT0xZX1NUWUxFX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2NvbG9yJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb2xvciksXG4gICdmaWxsJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRCb29sZWFuKSxcbiAgJ291dGxpbmUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEJvb2xlYW4pLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHBvbHlTdHlsZVBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICAvLyBGSVhNRSBjb2xvck1vZGVcbiAgY29uc3Qgb2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBQT0xZX1NUWUxFX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgY29uc3QgZmlsbFN0eWxlID0gbmV3IEZpbGwoe1xuICAgIGNvbG9yOlxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gKi9cbiAgICAgICgnY29sb3InIGluIG9iamVjdCA/IG9iamVjdFsnY29sb3InXSA6IERFRkFVTFRfQ09MT1IpLFxuICB9KTtcbiAgc3R5bGVPYmplY3RbJ2ZpbGxTdHlsZSddID0gZmlsbFN0eWxlO1xuICBjb25zdCBmaWxsID0gLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi8gKG9iamVjdFsnZmlsbCddKTtcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlT2JqZWN0WydmaWxsJ10gPSBmaWxsO1xuICB9XG4gIGNvbnN0IG91dGxpbmUgPSAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqLyAob2JqZWN0WydvdXRsaW5lJ10pO1xuICBpZiAob3V0bGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVPYmplY3RbJ291dGxpbmUnXSA9IG91dGxpbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEZMQVRfTElORUFSX1JJTkdfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnY29vcmRpbmF0ZXMnOiBtYWtlUmVwbGFjZXIocmVhZEZsYXRDb29yZGluYXRlcyksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IExpbmVhclJpbmcgZmxhdCBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gcmVhZEZsYXRMaW5lYXJSaW5nKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3AobnVsbCwgRkxBVF9MSU5FQVJfUklOR19QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIGd4Q29vcmRQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgZ3hUcmFja09iamVjdCA9XG4gICAgLyoqIEB0eXBlIHtHeFRyYWNrT2JqZWN0fSAqL1xuICAgIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gZ3hUcmFja09iamVjdC5jb29yZGluYXRlcztcbiAgY29uc3QgcyA9IGdldEFsbFRleHRDb250ZW50KG5vZGUsIGZhbHNlKTtcbiAgY29uc3QgcmUgPVxuICAgIC9eXFxzKihbK1xcLV0/XFxkKyg/OlxcLlxcZCopPyg/OmVbK1xcLV0/XFxkKik/KVxccysoWytcXC1dP1xcZCsoPzpcXC5cXGQqKT8oPzplWytcXC1dP1xcZCopPylcXHMrKFsrXFwtXT9cXGQrKD86XFwuXFxkKik/KD86ZVsrXFwtXT9cXGQqKT8pXFxzKiQvaTtcbiAgY29uc3QgbSA9IHJlLmV4ZWMocyk7XG4gIGlmIChtKSB7XG4gICAgY29uc3QgeCA9IHBhcnNlRmxvYXQobVsxXSk7XG4gICAgY29uc3QgeSA9IHBhcnNlRmxvYXQobVsyXSk7XG4gICAgY29uc3QgeiA9IHBhcnNlRmxvYXQobVszXSk7XG4gICAgY29vcmRpbmF0ZXMucHVzaChbeCwgeSwgel0pO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkaW5hdGVzLnB1c2goW10pO1xuICB9XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBHWF9NVUxUSVRSQUNLX0dFT01FVFJZX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoR1hfTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ1RyYWNrJzogbWFrZUFycmF5UHVzaGVyKHJlYWRHeFRyYWNrKSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfHVuZGVmaW5lZH0gTXVsdGlMaW5lU3RyaW5nLlxuICovXG5mdW5jdGlvbiByZWFkR3hNdWx0aVRyYWNrKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGxpbmVTdHJpbmdzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIFtdLFxuICAgIEdYX01VTFRJVFJBQ0tfR0VPTUVUUllfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGlmICghbGluZVN0cmluZ3MpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEdYX1RSQUNLX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoXG4gIE5BTUVTUEFDRV9VUklTLFxuICB7XG4gICAgJ3doZW4nOiB3aGVuUGFyc2VyLFxuICB9LFxuICBtYWtlU3RydWN0dXJlTlMoR1hfTkFNRVNQQUNFX1VSSVMsIHtcbiAgICAnY29vcmQnOiBneENvb3JkUGFyc2VyLFxuICB9KVxuKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge0xpbmVTdHJpbmd8dW5kZWZpbmVkfSBMaW5lU3RyaW5nLlxuICovXG5mdW5jdGlvbiByZWFkR3hUcmFjayhub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBneFRyYWNrT2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIC8qKiBAdHlwZSB7R3hUcmFja09iamVjdH0gKi8gKHtcbiAgICAgIGNvb3JkaW5hdGVzOiBbXSxcbiAgICAgIHdoZW5zOiBbXSxcbiAgICB9KSxcbiAgICBHWF9UUkFDS19QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbiAgaWYgKCFneFRyYWNrT2JqZWN0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgY29uc3QgY29vcmRpbmF0ZXMgPSBneFRyYWNrT2JqZWN0LmNvb3JkaW5hdGVzO1xuICBjb25zdCB3aGVucyA9IGd4VHJhY2tPYmplY3Qud2hlbnM7XG4gIGZvciAoXG4gICAgbGV0IGkgPSAwLCBpaSA9IE1hdGgubWluKGNvb3JkaW5hdGVzLmxlbmd0aCwgd2hlbnMubGVuZ3RoKTtcbiAgICBpIDwgaWk7XG4gICAgKytpXG4gICkge1xuICAgIGlmIChjb29yZGluYXRlc1tpXS5sZW5ndGggPT0gMykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goXG4gICAgICAgIGNvb3JkaW5hdGVzW2ldWzBdLFxuICAgICAgICBjb29yZGluYXRlc1tpXVsxXSxcbiAgICAgICAgY29vcmRpbmF0ZXNbaV1bMl0sXG4gICAgICAgIHdoZW5zW2ldXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCAnWFlaTScpO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgSUNPTl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdocmVmJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRVUkkpLFxuICB9LFxuICBtYWtlU3RydWN0dXJlTlMoR1hfTkFNRVNQQUNFX1VSSVMsIHtcbiAgICAneCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICAgJ3knOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAgICd3JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgICAnaCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gIH0pXG4pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fSBJY29uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEljb24obm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgaWNvbk9iamVjdCA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgSUNPTl9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmIChpY29uT2JqZWN0KSB7XG4gICAgcmV0dXJuIGljb25PYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBHRU9NRVRSWV9GTEFUX0NPT1JESU5BVEVTX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2Nvb3JkaW5hdGVzJzogbWFrZVJlcGxhY2VyKHJlYWRGbGF0Q29vcmRpbmF0ZXMpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiByZWFkRmxhdENvb3JkaW5hdGVzRnJvbU5vZGUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcChcbiAgICBudWxsLFxuICAgIEdFT01FVFJZX0ZMQVRfQ09PUkRJTkFURVNfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBFWFRSVURFX0FORF9BTFRJVFVERV9NT0RFX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ2V4dHJ1ZGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEJvb2xlYW4pLFxuICAndGVzc2VsbGF0ZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQm9vbGVhbiksXG4gICdhbHRpdHVkZU1vZGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge0xpbmVTdHJpbmd8dW5kZWZpbmVkfSBMaW5lU3RyaW5nLlxuICovXG5mdW5jdGlvbiByZWFkTGluZVN0cmluZyhub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIHt9LFxuICAgIEVYVFJVREVfQU5EX0FMVElUVURFX01PREVfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHJlYWRGbGF0Q29vcmRpbmF0ZXNGcm9tTm9kZShub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCAnWFlaJyk7XG4gICAgbGluZVN0cmluZy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRydWUpO1xuICAgIHJldHVybiBsaW5lU3RyaW5nO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtQb2x5Z29ufHVuZGVmaW5lZH0gUG9seWdvbi5cbiAqL1xuZnVuY3Rpb24gcmVhZExpbmVhclJpbmcobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICB7fSxcbiAgICBFWFRSVURFX0FORF9BTFRJVFVERV9NT0RFX1BBUlNFUlMsXG4gICAgbm9kZSxcbiAgICBvYmplY3RTdGFja1xuICApO1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSByZWFkRmxhdENvb3JkaW5hdGVzRnJvbU5vZGUobm9kZSwgb2JqZWN0U3RhY2spO1xuICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZWicsIFtcbiAgICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgXSk7XG4gICAgcG9seWdvbi5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRydWUpO1xuICAgIHJldHVybiBwb2x5Z29uO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBNVUxUSV9HRU9NRVRSWV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdMaW5lU3RyaW5nJzogbWFrZUFycmF5UHVzaGVyKHJlYWRMaW5lU3RyaW5nKSxcbiAgJ0xpbmVhclJpbmcnOiBtYWtlQXJyYXlQdXNoZXIocmVhZExpbmVhclJpbmcpLFxuICAnTXVsdGlHZW9tZXRyeSc6IG1ha2VBcnJheVB1c2hlcihyZWFkTXVsdGlHZW9tZXRyeSksXG4gICdQb2ludCc6IG1ha2VBcnJheVB1c2hlcihyZWFkUG9pbnQpLFxuICAnUG9seWdvbic6IG1ha2VBcnJheVB1c2hlcihyZWFkUG9seWdvbiksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRNdWx0aUdlb21ldHJ5KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGdlb21ldHJpZXMgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgW10sXG4gICAgTVVMVElfR0VPTUVUUllfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGlmICghZ2VvbWV0cmllcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChnZW9tZXRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMpO1xuICB9XG4gIGxldCBtdWx0aUdlb21ldHJ5O1xuICBsZXQgaG9tb2dlbmVvdXMgPSB0cnVlO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cmllc1swXS5nZXRUeXBlKCk7XG4gIGxldCBnZW9tZXRyeTtcbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgIT0gdHlwZSkge1xuICAgICAgaG9tb2dlbmVvdXMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaG9tb2dlbmVvdXMpIHtcbiAgICBsZXQgbGF5b3V0O1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKHR5cGUgPT0gJ1BvaW50Jykge1xuICAgICAgY29uc3QgcG9pbnQgPSBnZW9tZXRyaWVzWzBdO1xuICAgICAgbGF5b3V0ID0gcG9pbnQuZ2V0TGF5b3V0KCk7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBwb2ludC5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgIH1cbiAgICAgIG11bHRpR2VvbWV0cnkgPSBuZXcgTXVsdGlQb2ludChmbGF0Q29vcmRpbmF0ZXMsIGxheW91dCk7XG4gICAgICBzZXRDb21tb25HZW9tZXRyeVByb3BlcnRpZXMobXVsdGlHZW9tZXRyeSwgZ2VvbWV0cmllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdMaW5lU3RyaW5nJykge1xuICAgICAgbXVsdGlHZW9tZXRyeSA9IG5ldyBNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cmllcyk7XG4gICAgICBzZXRDb21tb25HZW9tZXRyeVByb3BlcnRpZXMobXVsdGlHZW9tZXRyeSwgZ2VvbWV0cmllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgbXVsdGlHZW9tZXRyeSA9IG5ldyBNdWx0aVBvbHlnb24oZ2VvbWV0cmllcyk7XG4gICAgICBzZXRDb21tb25HZW9tZXRyeVByb3BlcnRpZXMobXVsdGlHZW9tZXRyeSwgZ2VvbWV0cmllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICBtdWx0aUdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAzNyk7IC8vIFVua25vd24gZ2VvbWV0cnkgdHlwZSBmb3VuZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtdWx0aUdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChtdWx0aUdlb21ldHJ5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge1BvaW50fHVuZGVmaW5lZH0gUG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRQb2ludChub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIHt9LFxuICAgIEVYVFJVREVfQU5EX0FMVElUVURFX01PREVfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHJlYWRGbGF0Q29vcmRpbmF0ZXNGcm9tTm9kZShub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChmbGF0Q29vcmRpbmF0ZXMsICdYWVonKTtcbiAgICBwb2ludC5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRydWUpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgRkxBVF9MSU5FQVJfUklOR1NfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnaW5uZXJCb3VuZGFyeUlzJzogaW5uZXJCb3VuZGFyeUlzUGFyc2VyLFxuICAnb3V0ZXJCb3VuZGFyeUlzJzogb3V0ZXJCb3VuZGFyeUlzUGFyc2VyLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtQb2x5Z29ufHVuZGVmaW5lZH0gUG9seWdvbi5cbiAqL1xuZnVuY3Rpb24gcmVhZFBvbHlnb24obm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsKj59ICovICh7fSksXG4gICAgRVhUUlVERV9BTkRfQUxUSVRVREVfTU9ERV9QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbiAgY29uc3QgZmxhdExpbmVhclJpbmdzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIFtudWxsXSxcbiAgICBGTEFUX0xJTkVBUl9SSU5HU19QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbiAgaWYgKGZsYXRMaW5lYXJSaW5ncyAmJiBmbGF0TGluZWFyUmluZ3NbMF0pIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBmbGF0TGluZWFyUmluZ3NbMF07XG4gICAgY29uc3QgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgICBmb3IgKGxldCBpID0gMSwgaWkgPSBmbGF0TGluZWFyUmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgZmxhdExpbmVhclJpbmdzW2ldKTtcbiAgICAgIGVuZHMucHVzaChmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZWicsIGVuZHMpO1xuICAgIHBvbHlnb24uc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgU1RZTEVfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnSWNvblN0eWxlJzogaWNvblN0eWxlUGFyc2VyLFxuICAnTGFiZWxTdHlsZSc6IGxhYmVsU3R5bGVQYXJzZXIsXG4gICdMaW5lU3R5bGUnOiBsaW5lU3R5bGVQYXJzZXIsXG4gICdQb2x5U3R5bGUnOiBwb2x5U3R5bGVQYXJzZXIsXG59KTtcblxuLyoqXG4gKiBAdGhpcyB7S01MfVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtBcnJheTxTdHlsZT59IFN0eWxlLlxuICovXG5mdW5jdGlvbiByZWFkU3R5bGUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAge30sXG4gICAgU1RZTEVfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIHRoaXNcbiAgKTtcbiAgaWYgKCFzdHlsZU9iamVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBmaWxsU3R5bGUgPVxuICAgIC8qKiBAdHlwZSB7RmlsbH0gKi9cbiAgICAoXG4gICAgICAnZmlsbFN0eWxlJyBpbiBzdHlsZU9iamVjdCA/IHN0eWxlT2JqZWN0WydmaWxsU3R5bGUnXSA6IERFRkFVTFRfRklMTF9TVFlMRVxuICAgICk7XG4gIGNvbnN0IGZpbGwgPSAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqLyAoc3R5bGVPYmplY3RbJ2ZpbGwnXSk7XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQgJiYgIWZpbGwpIHtcbiAgICBmaWxsU3R5bGUgPSBudWxsO1xuICB9XG4gIGxldCBpbWFnZVN0eWxlO1xuICBpZiAoJ2ltYWdlU3R5bGUnIGluIHN0eWxlT2JqZWN0KSB7XG4gICAgaWYgKHN0eWxlT2JqZWN0WydpbWFnZVN0eWxlJ10gIT0gREVGQVVMVF9OT19JTUFHRV9TVFlMRSkge1xuICAgICAgaW1hZ2VTdHlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBzdHlsZU9iamVjdFsnaW1hZ2VTdHlsZSddXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbWFnZVN0eWxlID0gREVGQVVMVF9JTUFHRV9TVFlMRTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPVxuICAgIC8qKiBAdHlwZSB7VGV4dH0gKi9cbiAgICAoXG4gICAgICAndGV4dFN0eWxlJyBpbiBzdHlsZU9iamVjdCA/IHN0eWxlT2JqZWN0Wyd0ZXh0U3R5bGUnXSA6IERFRkFVTFRfVEVYVF9TVFlMRVxuICAgICk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID1cbiAgICAvKiogQHR5cGUge1N0cm9rZX0gKi9cbiAgICAoXG4gICAgICAnc3Ryb2tlU3R5bGUnIGluIHN0eWxlT2JqZWN0XG4gICAgICAgID8gc3R5bGVPYmplY3RbJ3N0cm9rZVN0eWxlJ11cbiAgICAgICAgOiBERUZBVUxUX1NUUk9LRV9TVFlMRVxuICAgICk7XG4gIGNvbnN0IG91dGxpbmUgPSAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqLyAoc3R5bGVPYmplY3RbJ291dGxpbmUnXSk7XG4gIGlmIChvdXRsaW5lICE9PSB1bmRlZmluZWQgJiYgIW91dGxpbmUpIHtcbiAgICAvLyBpZiB0aGUgcG9seXN0eWxlIHNwZWNpZmllcyBubyBvdXRsaW5lIHR3byBzdHlsZXMgYXJlIG5lZWRlZCxcbiAgICAvLyBvbmUgZm9yIG5vbi1wb2x5Z29uIGdlb21ldHJpZXMgd2hlcmUgbGluZXN0cmluZ3MgcmVxdWlyZSBhIHN0cm9rZVxuICAgIC8vIGFuZCBvbmUgZm9yIHBvbHlnb25zIHdoZXJlIHRoZXJlIHNob3VsZCBiZSBubyBzdHJva2VcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFN0eWxlKHtcbiAgICAgICAgZ2VvbWV0cnk6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPVxuICAgICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oXG4gICAgICAgICAgICAgIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlICE9PSAnUG9seWdvbicgJiYgdHlwZSAhPT0gJ011bHRpUG9seWdvbic7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlICE9PSAnUG9seWdvbicgJiYgdHlwZSAhPT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IGZpbGxTdHlsZSxcbiAgICAgICAgaW1hZ2U6IGltYWdlU3R5bGUsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlU3R5bGUsXG4gICAgICAgIHRleHQ6IHRleHRTdHlsZSxcbiAgICAgICAgekluZGV4OiB1bmRlZmluZWQsIC8vIEZJWE1FXG4gICAgICB9KSxcbiAgICAgIG5ldyBTdHlsZSh7XG4gICAgICAgIGdlb21ldHJ5OiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uID1cbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvblwiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgLmdldEdlb21ldHJpZXNBcnJheVJlY3Vyc2l2ZSgpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiBmaWxsU3R5bGUsXG4gICAgICAgIHN0cm9rZTogbnVsbCxcbiAgICAgICAgekluZGV4OiB1bmRlZmluZWQsIC8vIEZJWE1FXG4gICAgICB9KSxcbiAgICBdO1xuICB9XG4gIHJldHVybiBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGZpbGw6IGZpbGxTdHlsZSxcbiAgICAgIGltYWdlOiBpbWFnZVN0eWxlLFxuICAgICAgc3Ryb2tlOiBzdHJva2VTdHlsZSxcbiAgICAgIHRleHQ6IHRleHRTdHlsZSxcbiAgICAgIHpJbmRleDogdW5kZWZpbmVkLCAvLyBGSVhNRVxuICAgIH0pLFxuICBdO1xufVxuXG4vKipcbiAqIFJlYWRzIGFuIGFycmF5IG9mIGdlb21ldHJpZXMgYW5kIGNyZWF0ZXMgYXJyYXlzIGZvciBjb21tb24gZ2VvbWV0cnlcbiAqIHByb3BlcnRpZXMuIFRoZW4gc2V0cyB0aGVtIHRvIHRoZSBtdWx0aSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TXVsdGlQb2ludHxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29ufSBtdWx0aUdlb21ldHJ5IEEgbXVsdGktZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdD59IGdlb21ldHJpZXMgTGlzdCBvZiBnZW9tZXRyaWVzLlxuICovXG5mdW5jdGlvbiBzZXRDb21tb25HZW9tZXRyeVByb3BlcnRpZXMobXVsdGlHZW9tZXRyeSwgZ2VvbWV0cmllcykge1xuICBjb25zdCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICBjb25zdCBleHRydWRlcyA9IG5ldyBBcnJheShnZW9tZXRyaWVzLmxlbmd0aCk7XG4gIGNvbnN0IHRlc3NlbGxhdGVzID0gbmV3IEFycmF5KGdlb21ldHJpZXMubGVuZ3RoKTtcbiAgY29uc3QgYWx0aXR1ZGVNb2RlcyA9IG5ldyBBcnJheShnZW9tZXRyaWVzLmxlbmd0aCk7XG4gIGxldCBoYXNFeHRydWRlLCBoYXNUZXNzZWxsYXRlLCBoYXNBbHRpdHVkZU1vZGU7XG4gIGhhc0V4dHJ1ZGUgPSBmYWxzZTtcbiAgaGFzVGVzc2VsbGF0ZSA9IGZhbHNlO1xuICBoYXNBbHRpdHVkZU1vZGUgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgIGV4dHJ1ZGVzW2ldID0gZ2VvbWV0cnkuZ2V0KCdleHRydWRlJyk7XG4gICAgdGVzc2VsbGF0ZXNbaV0gPSBnZW9tZXRyeS5nZXQoJ3Rlc3NlbGxhdGUnKTtcbiAgICBhbHRpdHVkZU1vZGVzW2ldID0gZ2VvbWV0cnkuZ2V0KCdhbHRpdHVkZU1vZGUnKTtcbiAgICBoYXNFeHRydWRlID0gaGFzRXh0cnVkZSB8fCBleHRydWRlc1tpXSAhPT0gdW5kZWZpbmVkO1xuICAgIGhhc1Rlc3NlbGxhdGUgPSBoYXNUZXNzZWxsYXRlIHx8IHRlc3NlbGxhdGVzW2ldICE9PSB1bmRlZmluZWQ7XG4gICAgaGFzQWx0aXR1ZGVNb2RlID0gaGFzQWx0aXR1ZGVNb2RlIHx8IGFsdGl0dWRlTW9kZXNbaV07XG4gIH1cbiAgaWYgKGhhc0V4dHJ1ZGUpIHtcbiAgICBtdWx0aUdlb21ldHJ5LnNldCgnZXh0cnVkZScsIGV4dHJ1ZGVzKTtcbiAgfVxuICBpZiAoaGFzVGVzc2VsbGF0ZSkge1xuICAgIG11bHRpR2VvbWV0cnkuc2V0KCd0ZXNzZWxsYXRlJywgdGVzc2VsbGF0ZXMpO1xuICB9XG4gIGlmIChoYXNBbHRpdHVkZU1vZGUpIHtcbiAgICBtdWx0aUdlb21ldHJ5LnNldCgnYWx0aXR1ZGVNb2RlJywgYWx0aXR1ZGVNb2Rlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IERBVEFfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnZGlzcGxheU5hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICd2YWx1ZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBkYXRhUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICBwYXJzZU5vZGUoREFUQV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGNvbnN0IGZlYXR1cmVPYmplY3QgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKFxuICAgIG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdXG4gICk7XG4gIGlmIChuYW1lICYmIGZlYXR1cmVPYmplY3QuZGlzcGxheU5hbWUpIHtcbiAgICBmZWF0dXJlT2JqZWN0W25hbWVdID0ge1xuICAgICAgdmFsdWU6IGZlYXR1cmVPYmplY3QudmFsdWUsXG4gICAgICBkaXNwbGF5TmFtZTogZmVhdHVyZU9iamVjdC5kaXNwbGF5TmFtZSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlT2JqZWN0LnZhbHVlO1xuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICBmZWF0dXJlT2JqZWN0W25hbWVdID0gZmVhdHVyZU9iamVjdC52YWx1ZTtcbiAgfSBlbHNlIGlmIChmZWF0dXJlT2JqZWN0LmRpc3BsYXlOYW1lICE9PSBudWxsKSB7XG4gICAgZmVhdHVyZU9iamVjdFtmZWF0dXJlT2JqZWN0LmRpc3BsYXlOYW1lXSA9IGZlYXR1cmVPYmplY3QudmFsdWU7XG4gIH1cbiAgZGVsZXRlIGZlYXR1cmVPYmplY3RbJ3ZhbHVlJ107XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBFWFRFTkRFRF9EQVRBX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0RhdGEnOiBkYXRhUGFyc2VyLFxuICAnU2NoZW1hRGF0YSc6IHNjaGVtYURhdGFQYXJzZXIsXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kZWREYXRhUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHBhcnNlTm9kZShFWFRFTkRFRF9EQVRBX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gcmVnaW9uUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHBhcnNlTm9kZShSRUdJT05fUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUEFJUl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdTdHlsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3R5bGUpLFxuICAna2V5JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnc3R5bGVVcmwnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0eWxlVVJMKSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBwYWlyRGF0YVBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYWlyT2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBQQUlSX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrLCB0aGlzKTtcbiAgaWYgKCFwYWlyT2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi8gKHBhaXJPYmplY3RbJ2tleSddKTtcbiAgaWYgKGtleSAmJiBrZXkgPT0gJ25vcm1hbCcpIHtcbiAgICBjb25zdCBzdHlsZVVybCA9IC8qKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH0gKi8gKHBhaXJPYmplY3RbJ3N0eWxlVXJsJ10pO1xuICAgIGlmIChzdHlsZVVybCkge1xuICAgICAgb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0gPSBzdHlsZVVybDtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAocGFpck9iamVjdFsnU3R5bGUnXSk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSA9IHN0eWxlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtLTUx9XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gcGxhY2VtYXJrU3R5bGVNYXBQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3Qgc3R5bGVNYXBWYWx1ZSA9IHJlYWRTdHlsZU1hcFZhbHVlLmNhbGwodGhpcywgbm9kZSwgb2JqZWN0U3RhY2spO1xuICBpZiAoIXN0eWxlTWFwVmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGxhY2VtYXJrT2JqZWN0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlTWFwVmFsdWUpKSB7XG4gICAgcGxhY2VtYXJrT2JqZWN0WydTdHlsZSddID0gc3R5bGVNYXBWYWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3R5bGVNYXBWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwbGFjZW1hcmtPYmplY3RbJ3N0eWxlVXJsJ10gPSBzdHlsZU1hcFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgMzgpOyAvLyBgc3R5bGVNYXBWYWx1ZWAgaGFzIGFuIHVua25vd24gdHlwZVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTQ0hFTUFfREFUQV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdTaW1wbGVEYXRhJzogc2ltcGxlRGF0YVBhcnNlcixcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBzY2hlbWFEYXRhUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHBhcnNlTm9kZShTQ0hFTUFfREFUQV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZURhdGFQYXJzZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgbmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlYWRTdHJpbmcobm9kZSk7XG4gICAgY29uc3QgZmVhdHVyZU9iamVjdCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAoXG4gICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICk7XG4gICAgZmVhdHVyZU9iamVjdFtuYW1lXSA9IGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IExBVF9MT05fQUxUX0JPWF9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdhbHRpdHVkZU1vZGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdtaW5BbHRpdHVkZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdtYXhBbHRpdHVkZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdub3J0aCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdzb3V0aCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdlYXN0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ3dlc3QnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIGxhdExvbkFsdEJveFBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBvYmplY3QgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAge30sXG4gICAgTEFUX0xPTl9BTFRfQk9YX1BBUlNFUlMsXG4gICAgbm9kZSxcbiAgICBvYmplY3RTdGFja1xuICApO1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWdpb25PYmplY3QgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKFxuICAgIG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdXG4gICk7XG4gIGNvbnN0IGV4dGVudCA9IFtcbiAgICBwYXJzZUZsb2F0KG9iamVjdFsnd2VzdCddKSxcbiAgICBwYXJzZUZsb2F0KG9iamVjdFsnc291dGgnXSksXG4gICAgcGFyc2VGbG9hdChvYmplY3RbJ2Vhc3QnXSksXG4gICAgcGFyc2VGbG9hdChvYmplY3RbJ25vcnRoJ10pLFxuICBdO1xuICByZWdpb25PYmplY3RbJ2V4dGVudCddID0gZXh0ZW50O1xuICByZWdpb25PYmplY3RbJ2FsdGl0dWRlTW9kZSddID0gb2JqZWN0WydhbHRpdHVkZU1vZGUnXTtcbiAgcmVnaW9uT2JqZWN0WydtaW5BbHRpdHVkZSddID0gcGFyc2VGbG9hdChvYmplY3RbJ21pbkFsdGl0dWRlJ10pO1xuICByZWdpb25PYmplY3RbJ21heEFsdGl0dWRlJ10gPSBwYXJzZUZsb2F0KG9iamVjdFsnbWF4QWx0aXR1ZGUnXSk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBMT0RfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnbWluTG9kUGl4ZWxzJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ21heExvZFBpeGVscyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdtaW5GYWRlRXh0ZW50JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ21heEZhZGVFeHRlbnQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIGxvZFBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBvYmplY3QgPSBwdXNoUGFyc2VBbmRQb3Aoe30sIExPRF9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxvZE9iamVjdCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBsb2RPYmplY3RbJ21pbkxvZFBpeGVscyddID0gcGFyc2VGbG9hdChvYmplY3RbJ21pbkxvZFBpeGVscyddKTtcbiAgbG9kT2JqZWN0WydtYXhMb2RQaXhlbHMnXSA9IHBhcnNlRmxvYXQob2JqZWN0WydtYXhMb2RQaXhlbHMnXSk7XG4gIGxvZE9iamVjdFsnbWluRmFkZUV4dGVudCddID0gcGFyc2VGbG9hdChvYmplY3RbJ21pbkZhZGVFeHRlbnQnXSk7XG4gIGxvZE9iamVjdFsnbWF4RmFkZUV4dGVudCddID0gcGFyc2VGbG9hdChvYmplY3RbJ21heEZhZGVFeHRlbnQnXSk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBJTk5FUl9CT1VOREFSWV9JU19QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gIC8vIEtNTCBzcGVjIG9ubHkgYWxsb3dzIG9uZSBMaW5lYXJSaW5nICBwZXIgaW5uZXJCb3VuZGFyeUlzLCBidXQgR29vZ2xlIEVhcnRoXG4gIC8vIGFsbG93cyBtdWx0aXBsZSwgc28gd2UgcGFyc2UgbXVsdGlwbGUgaGVyZSB0b28uXG4gICdMaW5lYXJSaW5nJzogbWFrZUFycmF5UHVzaGVyKHJlYWRGbGF0TGluZWFyUmluZyksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gaW5uZXJCb3VuZGFyeUlzUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGlubmVyQm91bmRhcnlGbGF0TGluZWFyUmluZ3MgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gKi8gKFtdKSxcbiAgICBJTk5FUl9CT1VOREFSWV9JU19QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbiAgaWYgKGlubmVyQm91bmRhcnlGbGF0TGluZWFyUmluZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9XG4gICAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fSAqL1xuICAgICAgKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICBmbGF0TGluZWFyUmluZ3MucHVzaCguLi5pbm5lckJvdW5kYXJ5RmxhdExpbmVhclJpbmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgT1VURVJfQk9VTkRBUllfSVNfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTGluZWFyUmluZyc6IG1ha2VSZXBsYWNlcihyZWFkRmxhdExpbmVhclJpbmcpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIG91dGVyQm91bmRhcnlJc1BhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSAqL1xuICBjb25zdCBmbGF0TGluZWFyUmluZyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICB1bmRlZmluZWQsXG4gICAgT1VURVJfQk9VTkRBUllfSVNfUEFSU0VSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGlmIChmbGF0TGluZWFyUmluZykge1xuICAgIGNvbnN0IGZsYXRMaW5lYXJSaW5ncyA9XG4gICAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fSAqL1xuICAgICAgKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICBmbGF0TGluZWFyUmluZ3NbMF0gPSBmbGF0TGluZWFyUmluZztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiBsaW5rUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHBhcnNlTm9kZShMSU5LX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd2hlblBhcnNlcihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBneFRyYWNrT2JqZWN0ID1cbiAgICAvKiogQHR5cGUge0d4VHJhY2tPYmplY3R9ICovXG4gICAgKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgY29uc3Qgd2hlbnMgPSBneFRyYWNrT2JqZWN0LndoZW5zO1xuICBjb25zdCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpO1xuICBjb25zdCB3aGVuID0gRGF0ZS5wYXJzZShzKTtcbiAgd2hlbnMucHVzaChpc05hTih3aGVuKSA/IDAgOiB3aGVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBjb2xvciB0by5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqL1xuZnVuY3Rpb24gd3JpdGVDb2xvclRleHROb2RlKG5vZGUsIGNvbG9yKSB7XG4gIGNvbnN0IHJnYmEgPSBhc0FycmF5KGNvbG9yKTtcbiAgY29uc3Qgb3BhY2l0eSA9IHJnYmEubGVuZ3RoID09IDQgPyByZ2JhWzNdIDogMTtcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gKi9cbiAgY29uc3QgYWJnciA9IFtvcGFjaXR5ICogMjU1LCByZ2JhWzJdLCByZ2JhWzFdLCByZ2JhWzBdXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBjb25zdCBoZXggPSBNYXRoLmZsb29yKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoYWJncltpXSkpLnRvU3RyaW5nKDE2KTtcbiAgICBhYmdyW2ldID0gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICB9XG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUobm9kZSwgYWJnci5qb2luKCcnKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYXBwZW5kIGEgVGV4dE5vZGUgd2l0aCB0aGUgY29vcmRpbmF0ZXMgdG8uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUNvb3JkaW5hdGVzVGV4dE5vZGUobm9kZSwgY29vcmRpbmF0ZXMsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcblxuICBjb25zdCBsYXlvdXQgPSBjb250ZXh0WydsYXlvdXQnXTtcbiAgY29uc3Qgc3RyaWRlID0gY29udGV4dFsnc3RyaWRlJ107XG5cbiAgbGV0IGRpbWVuc2lvbjtcbiAgaWYgKGxheW91dCA9PSAnWFknIHx8IGxheW91dCA9PSAnWFlNJykge1xuICAgIGRpbWVuc2lvbiA9IDI7XG4gIH0gZWxzZSBpZiAobGF5b3V0ID09ICdYWVonIHx8IGxheW91dCA9PSAnWFlaTScpIHtcbiAgICBkaW1lbnNpb24gPSAzO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgMzQpOyAvLyBJbnZhbGlkIGdlb21ldHJ5IGxheW91dFxuICB9XG5cbiAgY29uc3QgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGxldCB0ZXh0ID0gJyc7XG4gIGlmIChpaSA+IDApIHtcbiAgICB0ZXh0ICs9IGNvb3JkaW5hdGVzWzBdO1xuICAgIGZvciAobGV0IGQgPSAxOyBkIDwgZGltZW5zaW9uOyArK2QpIHtcbiAgICAgIHRleHQgKz0gJywnICsgY29vcmRpbmF0ZXNbZF07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHRleHQgKz0gJyAnICsgY29vcmRpbmF0ZXNbaV07XG4gICAgICBmb3IgKGxldCBkID0gMTsgZCA8IGRpbWVuc2lvbjsgKytkKSB7XG4gICAgICAgIHRleHQgKz0gJywnICsgY29vcmRpbmF0ZXNbaSArIGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3cml0ZVN0cmluZ1RleHROb2RlKG5vZGUsIHRleHQpO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEVYVEVOREVEREFUQV9OT0RFX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdEYXRhJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEYXRhTm9kZSksXG4gICd2YWx1ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGF0YU5vZGVWYWx1ZSksXG4gICdkaXNwbGF5TmFtZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGF0YU5vZGVOYW1lKSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHt7bmFtZTogKiwgdmFsdWU6ICp9fSBwYWlyIE5hbWUgdmFsdWUgcGFpci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVEYXRhTm9kZShub2RlLCBwYWlyLCBvYmplY3RTdGFjaykge1xuICBub2RlLnNldEF0dHJpYnV0ZSgnbmFtZScsIHBhaXIubmFtZSk7XG4gIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmRpc3BsYXlOYW1lKSB7XG4gICAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBFWFRFTkRFRERBVEFfTk9ERV9TRVJJQUxJWkVSUyxcbiAgICAgICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICAgICAgW3ZhbHVlLmRpc3BsYXlOYW1lXSxcbiAgICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICAgIFsnZGlzcGxheU5hbWUnXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUudmFsdWUpIHtcbiAgICAgIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIEVYVEVOREVEREFUQV9OT0RFX1NFUklBTElaRVJTLFxuICAgICAgICBPQkpFQ1RfUFJPUEVSVFlfTk9ERV9GQUNUT1JZLFxuICAgICAgICBbdmFsdWUudmFsdWVdLFxuICAgICAgICBvYmplY3RTdGFjayxcbiAgICAgICAgWyd2YWx1ZSddXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgY29udGV4dCxcbiAgICAgIEVYVEVOREVEREFUQV9OT0RFX1NFUklBTElaRVJTLFxuICAgICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICAgIFt2YWx1ZV0sXG4gICAgICBvYmplY3RTdGFjayxcbiAgICAgIFsndmFsdWUnXVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBuYW1lIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRGlzcGxheU5hbWUuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRGF0YU5vZGVOYW1lKG5vZGUsIG5hbWUpIHtcbiAgd3JpdGVDREFUQVNlY3Rpb24obm9kZSwgbmFtZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYXBwZW5kIGEgQ0RBVEEgU2VjdGlvbiB3aXRoIHRoZSB2YWx1ZSB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVEYXRhTm9kZVZhbHVlKG5vZGUsIHZhbHVlKSB7XG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUobm9kZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IERPQ1VNRU5UX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdQbGFjZW1hcmsnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVBsYWNlbWFyayksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVOYW1lXSBOb2RlIG5hbWUuXG4gKiBAcmV0dXJuIHtOb2RlfHVuZGVmaW5lZH0gTm9kZS5cbiAqL1xuY29uc3QgRE9DVU1FTlRfTk9ERV9GQUNUT1JZID0gZnVuY3Rpb24gKHZhbHVlLCBvYmplY3RTdGFjaywgbm9kZU5hbWUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50TlMocGFyZW50Tm9kZS5uYW1lc3BhY2VVUkksICdQbGFjZW1hcmsnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PEZlYXR1cmU+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEB0aGlzIHtLTUx9XG4gKi9cbmZ1bmN0aW9uIHdyaXRlRG9jdW1lbnQobm9kZSwgZmVhdHVyZXMsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgY29udGV4dCxcbiAgICBET0NVTUVOVF9TRVJJQUxJWkVSUyxcbiAgICBET0NVTUVOVF9OT0RFX0ZBQ1RPUlksXG4gICAgZmVhdHVyZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgdW5kZWZpbmVkLFxuICAgIHRoaXNcbiAgKTtcbn1cblxuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGNyZWF0aW5nIERhdGEgbm9kZXMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtmdW5jdGlvbigqLCBBcnJheTwqPik6IChOb2RlfHVuZGVmaW5lZCl9XG4gKi9cbmNvbnN0IERBVEFfTk9ERV9GQUNUT1JZID0gbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdEYXRhJyk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge3tuYW1lczogQXJyYXk8c3RyaW5nPiwgdmFsdWVzOiAoQXJyYXk8Kj4pfX0gbmFtZXNBbmRWYWx1ZXMgTmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVFeHRlbmRlZERhdGEobm9kZSwgbmFtZXNBbmRWYWx1ZXMsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIGNvbnN0IG5hbWVzID0gbmFtZXNBbmRWYWx1ZXMubmFtZXM7XG4gIGNvbnN0IHZhbHVlcyA9IG5hbWVzQW5kVmFsdWVzLnZhbHVlcztcbiAgY29uc3QgbGVuZ3RoID0gbmFtZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgY29udGV4dCxcbiAgICAgIEVYVEVOREVEREFUQV9OT0RFX1NFUklBTElaRVJTLFxuICAgICAgREFUQV9OT0RFX0ZBQ1RPUlksXG4gICAgICBbe25hbWU6IG5hbWVzW2ldLCB2YWx1ZTogdmFsdWVzW2ldfV0sXG4gICAgICBvYmplY3RTdGFja1xuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxzdHJpbmc+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgSUNPTl9TRVFVRU5DRSA9IG1ha2VTdHJ1Y3R1cmVOUyhcbiAgTkFNRVNQQUNFX1VSSVMsXG4gIFsnaHJlZiddLFxuICBtYWtlU3RydWN0dXJlTlMoR1hfTkFNRVNQQUNFX1VSSVMsIFsneCcsICd5JywgJ3cnLCAnaCddKVxuKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBJQ09OX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdocmVmJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gIH0sXG4gIG1ha2VTdHJ1Y3R1cmVOUyhHWF9OQU1FU1BBQ0VfVVJJUywge1xuICAgICd4JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAgICd5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAgICd3JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICAgICdoJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEZWNpbWFsVGV4dE5vZGUpLFxuICB9KVxuKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVOYW1lXSBOb2RlIG5hbWUuXG4gKiBAcmV0dXJuIHtOb2RlfHVuZGVmaW5lZH0gTm9kZS5cbiAqL1xuY29uc3QgR1hfTk9ERV9GQUNUT1JZID0gZnVuY3Rpb24gKHZhbHVlLCBvYmplY3RTdGFjaywgbm9kZU5hbWUpIHtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnROUyhHWF9OQU1FU1BBQ0VfVVJJU1swXSwgJ2d4OicgKyBub2RlTmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtPYmplY3R9IGljb24gSWNvbiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlSWNvbihub2RlLCBpY29uLCBvYmplY3RTdGFjaykge1xuICBjb25zdCAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqLyBjb250ZXh0ID0ge25vZGU6IG5vZGV9O1xuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgbGV0IG9yZGVyZWRLZXlzID0gSUNPTl9TRVFVRU5DRVtwYXJlbnROb2RlLm5hbWVzcGFjZVVSSV07XG4gIGxldCB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UoaWNvbiwgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgSUNPTl9TRVJJQUxJWkVSUyxcbiAgICBPQkpFQ1RfUFJPUEVSVFlfTk9ERV9GQUNUT1JZLFxuICAgIHZhbHVlcyxcbiAgICBvYmplY3RTdGFjayxcbiAgICBvcmRlcmVkS2V5c1xuICApO1xuICBvcmRlcmVkS2V5cyA9IElDT05fU0VRVUVOQ0VbR1hfTkFNRVNQQUNFX1VSSVNbMF1dO1xuICB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UoaWNvbiwgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgSUNPTl9TRVJJQUxJWkVSUyxcbiAgICBHWF9OT0RFX0ZBQ1RPUlksXG4gICAgdmFsdWVzLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIG9yZGVyZWRLZXlzXG4gICk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8c3RyaW5nPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IElDT05fU1RZTEVfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ3NjYWxlJyxcbiAgJ2hlYWRpbmcnLFxuICAnSWNvbicsXG4gICdjb2xvcicsXG4gICdob3RTcG90Jyxcbl0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IElDT05fU1RZTEVfU0VSSUFMSVpFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0ljb24nOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUljb24pLFxuICAnY29sb3InOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUNvbG9yVGV4dE5vZGUpLFxuICAnaGVhZGluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGVjaW1hbFRleHROb2RlKSxcbiAgJ2hvdFNwb3QnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVZlYzIpLFxuICAnc2NhbGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVNjYWxlVGV4dE5vZGUpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL0ljb24uanNcIikuZGVmYXVsdH0gc3R5bGUgSWNvbiBzdHlsZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVJY29uU3R5bGUobm9kZSwgc3R5bGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIGNvbnN0IC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn0gKi8gcHJvcGVydGllcyA9IHt9O1xuICBjb25zdCBzcmMgPSBzdHlsZS5nZXRTcmMoKTtcbiAgY29uc3Qgc2l6ZSA9IHN0eWxlLmdldFNpemUoKTtcbiAgY29uc3QgaWNvbkltYWdlU2l6ZSA9IHN0eWxlLmdldEltYWdlU2l6ZSgpO1xuICBjb25zdCBpY29uUHJvcGVydGllcyA9IHtcbiAgICAnaHJlZic6IHNyYyxcbiAgfTtcblxuICBpZiAoc2l6ZSkge1xuICAgIGljb25Qcm9wZXJ0aWVzWyd3J10gPSBzaXplWzBdO1xuICAgIGljb25Qcm9wZXJ0aWVzWydoJ10gPSBzaXplWzFdO1xuICAgIGNvbnN0IGFuY2hvciA9IHN0eWxlLmdldEFuY2hvcigpOyAvLyB0b3AtbGVmdFxuICAgIGNvbnN0IG9yaWdpbiA9IHN0eWxlLmdldE9yaWdpbigpOyAvLyB0b3AtbGVmdFxuXG4gICAgaWYgKG9yaWdpbiAmJiBpY29uSW1hZ2VTaXplICYmIG9yaWdpblswXSAhPT0gMCAmJiBvcmlnaW5bMV0gIT09IHNpemVbMV0pIHtcbiAgICAgIGljb25Qcm9wZXJ0aWVzWyd4J10gPSBvcmlnaW5bMF07XG4gICAgICBpY29uUHJvcGVydGllc1sneSddID0gaWNvbkltYWdlU2l6ZVsxXSAtIChvcmlnaW5bMV0gKyBzaXplWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yICYmIChhbmNob3JbMF0gIT09IHNpemVbMF0gLyAyIHx8IGFuY2hvclsxXSAhPT0gc2l6ZVsxXSAvIDIpKSB7XG4gICAgICBjb25zdCAvKiogQHR5cGUge1ZlYzJ9ICovIGhvdFNwb3QgPSB7XG4gICAgICAgICAgeDogYW5jaG9yWzBdLFxuICAgICAgICAgIHh1bml0czogJ3BpeGVscycsXG4gICAgICAgICAgeTogc2l6ZVsxXSAtIGFuY2hvclsxXSxcbiAgICAgICAgICB5dW5pdHM6ICdwaXhlbHMnLFxuICAgICAgICB9O1xuICAgICAgcHJvcGVydGllc1snaG90U3BvdCddID0gaG90U3BvdDtcbiAgICB9XG4gIH1cblxuICBwcm9wZXJ0aWVzWydJY29uJ10gPSBpY29uUHJvcGVydGllcztcblxuICBsZXQgc2NhbGUgPSBzdHlsZS5nZXRTY2FsZUFycmF5KClbMF07XG4gIGxldCBpbWFnZVNpemUgPSBzaXplO1xuICBpZiAoaW1hZ2VTaXplID09PSBudWxsKSB7XG4gICAgaW1hZ2VTaXplID0gREVGQVVMVF9JTUFHRV9TVFlMRV9TSVpFO1xuICB9XG4gIGlmIChpbWFnZVNpemUubGVuZ3RoID09IDIpIHtcbiAgICBjb25zdCByZXNpemVTY2FsZSA9IHNjYWxlRm9yU2l6ZShpbWFnZVNpemUpO1xuICAgIHNjYWxlID0gc2NhbGUgLyByZXNpemVTY2FsZTtcbiAgfVxuICBpZiAoc2NhbGUgIT09IDEpIHtcbiAgICBwcm9wZXJ0aWVzWydzY2FsZSddID0gc2NhbGU7XG4gIH1cblxuICBjb25zdCByb3RhdGlvbiA9IHN0eWxlLmdldFJvdGF0aW9uKCk7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIHByb3BlcnRpZXNbJ2hlYWRpbmcnXSA9IHJvdGF0aW9uOyAvLyAwLTM2MFxuICB9XG5cbiAgY29uc3QgY29sb3IgPSBzdHlsZS5nZXRDb2xvcigpO1xuICBpZiAoY29sb3IpIHtcbiAgICBwcm9wZXJ0aWVzWydjb2xvciddID0gY29sb3I7XG4gIH1cblxuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBJQ09OX1NUWUxFX1NFUVVFTkNFW3BhcmVudE5vZGUubmFtZXNwYWNlVVJJXTtcbiAgY29uc3QgdmFsdWVzID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIG9yZGVyZWRLZXlzKTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIElDT05fU1RZTEVfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxzdHJpbmc+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgTEFCRUxfU1RZTEVfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ2NvbG9yJyxcbiAgJ3NjYWxlJyxcbl0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5TZXJpYWxpemVyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IExBQkVMX1NUWUxFX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdjb2xvcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQ29sb3JUZXh0Tm9kZSksXG4gICdzY2FsZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU2NhbGVUZXh0Tm9kZSksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7VGV4dH0gc3R5bGUgc3R5bGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTGFiZWxTdHlsZShub2RlLCBzdHlsZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICBjb25zdCBmaWxsID0gc3R5bGUuZ2V0RmlsbCgpO1xuICBpZiAoZmlsbCkge1xuICAgIHByb3BlcnRpZXNbJ2NvbG9yJ10gPSBmaWxsLmdldENvbG9yKCk7XG4gIH1cbiAgY29uc3Qgc2NhbGUgPSBzdHlsZS5nZXRTY2FsZSgpO1xuICBpZiAoc2NhbGUgJiYgc2NhbGUgIT09IDEpIHtcbiAgICBwcm9wZXJ0aWVzWydzY2FsZSddID0gc2NhbGU7XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gIGNvbnN0IG9yZGVyZWRLZXlzID0gTEFCRUxfU1RZTEVfU0VRVUVOQ0VbcGFyZW50Tm9kZS5uYW1lc3BhY2VVUkldO1xuICBjb25zdCB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UocHJvcGVydGllcywgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgTEFCRUxfU1RZTEVfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxzdHJpbmc+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgTElORV9TVFlMRV9TRVFVRU5DRSA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywgWydjb2xvcicsICd3aWR0aCddKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBMSU5FX1NUWUxFX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdjb2xvcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQ29sb3JUZXh0Tm9kZSksXG4gICd3aWR0aCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRGVjaW1hbFRleHROb2RlKSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtTdHJva2V9IHN0eWxlIHN0eWxlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUxpbmVTdHlsZShub2RlLCBzdHlsZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAnY29sb3InOiBzdHlsZS5nZXRDb2xvcigpLFxuICAgICd3aWR0aCc6IE51bWJlcihzdHlsZS5nZXRXaWR0aCgpKSB8fCAxLFxuICB9O1xuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBMSU5FX1NUWUxFX1NFUVVFTkNFW3BhcmVudE5vZGUubmFtZXNwYWNlVVJJXTtcbiAgY29uc3QgdmFsdWVzID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIG9yZGVyZWRLZXlzKTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIExJTkVfU1RZTEVfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBHRU9NRVRSWV9UWVBFX1RPX05PREVOQU1FID0ge1xuICAnUG9pbnQnOiAnUG9pbnQnLFxuICAnTGluZVN0cmluZyc6ICdMaW5lU3RyaW5nJyxcbiAgJ0xpbmVhclJpbmcnOiAnTGluZWFyUmluZycsXG4gICdQb2x5Z29uJzogJ1BvbHlnb24nLFxuICAnTXVsdGlQb2ludCc6ICdNdWx0aUdlb21ldHJ5JyxcbiAgJ011bHRpTGluZVN0cmluZyc6ICdNdWx0aUdlb21ldHJ5JyxcbiAgJ011bHRpUG9seWdvbic6ICdNdWx0aUdlb21ldHJ5JyxcbiAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6ICdNdWx0aUdlb21ldHJ5Jyxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlTmFtZV0gTm9kZSBuYW1lLlxuICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IE5vZGUuXG4gKi9cbmNvbnN0IEdFT01FVFJZX05PREVfRkFDVE9SWSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2JqZWN0U3RhY2ssIG5vZGVOYW1lKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXS5ub2RlO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50TlMoXG4gICAgICBwYXJlbnROb2RlLm5hbWVzcGFjZVVSSSxcbiAgICAgIEdFT01FVFJZX1RZUEVfVE9fTk9ERU5BTUVbXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAodmFsdWUpLmdldFR5cGUoKVxuICAgICAgXVxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBmYWN0b3J5IGZvciBjcmVhdGluZyBQb2ludCBub2Rlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge2Z1bmN0aW9uKCosIEFycmF5PCo+LCBzdHJpbmc9KTogKE5vZGV8dW5kZWZpbmVkKX1cbiAqL1xuY29uc3QgUE9JTlRfTk9ERV9GQUNUT1JZID0gbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdQb2ludCcpO1xuXG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgTGluZVN0cmluZyBub2Rlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge2Z1bmN0aW9uKCosIEFycmF5PCo+LCBzdHJpbmc9KTogKE5vZGV8dW5kZWZpbmVkKX1cbiAqL1xuY29uc3QgTElORV9TVFJJTkdfTk9ERV9GQUNUT1JZID0gbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdMaW5lU3RyaW5nJyk7XG5cbi8qKlxuICogQSBmYWN0b3J5IGZvciBjcmVhdGluZyBMaW5lYXJSaW5nIG5vZGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfVxuICovXG5jb25zdCBMSU5FQVJfUklOR19OT0RFX0ZBQ1RPUlkgPSBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoJ0xpbmVhclJpbmcnKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFBvbHlnb24gbm9kZXMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtmdW5jdGlvbigqLCBBcnJheTwqPiwgc3RyaW5nPSk6IChOb2RlfHVuZGVmaW5lZCl9XG4gKi9cbmNvbnN0IFBPTFlHT05fTk9ERV9GQUNUT1JZID0gbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdQb2x5Z29uJyk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgTVVMVElfR0VPTUVUUllfU0VSSUFMSVpFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0xpbmVTdHJpbmcnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVByaW1pdGl2ZUdlb21ldHJ5KSxcbiAgJ1BvaW50JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVQcmltaXRpdmVHZW9tZXRyeSksXG4gICdQb2x5Z29uJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVQb2x5Z29uKSxcbiAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTXVsdGlHZW9tZXRyeSksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVNdWx0aUdlb21ldHJ5KG5vZGUsIGdlb21ldHJ5LCBvYmplY3RTdGFjaykge1xuICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICBjb25zdCBjb250ZXh0ID0ge25vZGU6IG5vZGV9O1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdD59ICovXG4gIGxldCBnZW9tZXRyaWVzID0gW107XG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfSAqL1xuICBsZXQgZmFjdG9yeTtcbiAgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgLyoqIEB0eXBlIHtHZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSlcbiAgICAgIC5nZXRHZW9tZXRyaWVzQXJyYXlSZWN1cnNpdmUoKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICAgIGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgICBnZW9tZXRyaWVzID0gZ2VvbWV0cmllcy5jb25jYXQoXG4gICAgICAgICAgICAvKiogQHR5cGUge011bHRpUG9pbnR9ICovIChnZW9tZXRyeSkuZ2V0UG9pbnRzKClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgZ2VvbWV0cmllcyA9IGdlb21ldHJpZXMuY29uY2F0KFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtNdWx0aUxpbmVTdHJpbmd9ICovIChnZW9tZXRyeSkuZ2V0TGluZVN0cmluZ3MoKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICBnZW9tZXRyaWVzID0gZ2VvbWV0cmllcy5jb25jYXQoXG4gICAgICAgICAgICAvKiogQHR5cGUge011bHRpUG9seWdvbn0gKi8gKGdlb21ldHJ5KS5nZXRQb2x5Z29ucygpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlID09PSAnUG9pbnQnIHx8XG4gICAgICAgICAgdHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZSA9PT0gJ1BvbHlnb24nXG4gICAgICAgICkge1xuICAgICAgICAgIGdlb21ldHJpZXMucHVzaChnZW9tZXRyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCAzOSk7IC8vIFVua25vd24gZ2VvbWV0cnkgdHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBmYWN0b3J5ID0gR0VPTUVUUllfTk9ERV9GQUNUT1JZO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge011bHRpUG9pbnR9ICovIChnZW9tZXRyeSkuZ2V0UG9pbnRzKCk7XG4gICAgZmFjdG9yeSA9IFBPSU5UX05PREVfRkFDVE9SWTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge011bHRpTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KS5nZXRMaW5lU3RyaW5ncygpO1xuICAgIGZhY3RvcnkgPSBMSU5FX1NUUklOR19OT0RFX0ZBQ1RPUlk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHtNdWx0aVBvbHlnb259ICovIChnZW9tZXRyeSkuZ2V0UG9seWdvbnMoKTtcbiAgICBmYWN0b3J5ID0gUE9MWUdPTl9OT0RFX0ZBQ1RPUlk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAzOSk7IC8vIFVua25vd24gZ2VvbWV0cnkgdHlwZVxuICB9XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgY29udGV4dCxcbiAgICBNVUxUSV9HRU9NRVRSWV9TRVJJQUxJWkVSUyxcbiAgICBmYWN0b3J5LFxuICAgIGdlb21ldHJpZXMsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBCT1VOREFSWV9JU19TRVJJQUxJWkVSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTGluZWFyUmluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlUHJpbWl0aXZlR2VvbWV0cnkpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZWFyUmluZy5qc1wiKS5kZWZhdWx0fSBsaW5lYXJSaW5nIExpbmVhciByaW5nLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUJvdW5kYXJ5SXMobm9kZSwgbGluZWFyUmluZywgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIEJPVU5EQVJZX0lTX1NFUklBTElaRVJTLFxuICAgIExJTkVBUl9SSU5HX05PREVfRkFDVE9SWSxcbiAgICBbbGluZWFyUmluZ10sXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBQTEFDRU1BUktfU0VSSUFMSVpFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0V4dGVuZGVkRGF0YSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlRXh0ZW5kZWREYXRhKSxcbiAgJ011bHRpR2VvbWV0cnknOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZU11bHRpR2VvbWV0cnkpLFxuICAnTGluZVN0cmluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlUHJpbWl0aXZlR2VvbWV0cnkpLFxuICAnTGluZWFyUmluZyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlUHJpbWl0aXZlR2VvbWV0cnkpLFxuICAnUG9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVByaW1pdGl2ZUdlb21ldHJ5KSxcbiAgJ1BvbHlnb24nOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVBvbHlnb24pLFxuICAnU3R5bGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0eWxlKSxcbiAgJ2FkZHJlc3MnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ2Rlc2NyaXB0aW9uJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICduYW1lJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICdvcGVuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVCb29sZWFuVGV4dE5vZGUpLFxuICAncGhvbmVOdW1iZXInOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVN0cmluZ1RleHROb2RlKSxcbiAgJ3N0eWxlVXJsJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gICd2aXNpYmlsaXR5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVCb29sZWFuVGV4dE5vZGUpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8c3RyaW5nPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFBMQUNFTUFSS19TRVFVRU5DRSA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywgW1xuICAnbmFtZScsXG4gICdvcGVuJyxcbiAgJ3Zpc2liaWxpdHknLFxuICAnYWRkcmVzcycsXG4gICdwaG9uZU51bWJlcicsXG4gICdkZXNjcmlwdGlvbicsXG4gICdzdHlsZVVybCcsXG4gICdTdHlsZScsXG5dKTtcblxuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGNyZWF0aW5nIEV4dGVuZGVkRGF0YSBub2Rlcy5cbiAqIEBjb25zdFxuICogQHR5cGUge2Z1bmN0aW9uKCosIEFycmF5PCo+KTogKE5vZGV8dW5kZWZpbmVkKX1cbiAqL1xuY29uc3QgRVhURU5ERUREQVRBX05PREVfRkFDVE9SWSA9IG1ha2VTaW1wbGVOb2RlRmFjdG9yeSgnRXh0ZW5kZWREYXRhJyk7XG5cbi8qKlxuICogRklYTUUgY3VycmVudGx5IHdlIGRvIHNlcmlhbGl6ZSBhcmJpdHJhcnkvY3VzdG9tIGZlYXR1cmUgcHJvcGVydGllc1xuICogKEV4dGVuZGVkRGF0YSkuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHRoaXMge0tNTH1cbiAqL1xuZnVuY3Rpb24gd3JpdGVQbGFjZW1hcmsobm9kZSwgZmVhdHVyZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcblxuICAvLyBzZXQgaWRcbiAgaWYgKGZlYXR1cmUuZ2V0SWQoKSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZmVhdHVyZS5nZXRJZCgpKSk7XG4gIH1cblxuICAvLyBzZXJpYWxpemUgcHJvcGVydGllcyAocHJvcGVydGllcyB1bmtub3duIHRvIEtNTCBhcmUgbm90IHNlcmlhbGl6ZWQpXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcblxuICAvLyBkb24ndCBleHBvcnQgdGhlc2UgdG8gRXh0ZW5kZWREYXRhXG4gIGNvbnN0IGZpbHRlciA9IHtcbiAgICAnYWRkcmVzcyc6IDEsXG4gICAgJ2Rlc2NyaXB0aW9uJzogMSxcbiAgICAnbmFtZSc6IDEsXG4gICAgJ29wZW4nOiAxLFxuICAgICdwaG9uZU51bWJlcic6IDEsXG4gICAgJ3N0eWxlVXJsJzogMSxcbiAgICAndmlzaWJpbGl0eSc6IDEsXG4gIH07XG4gIGZpbHRlcltmZWF0dXJlLmdldEdlb21ldHJ5TmFtZSgpXSA9IDE7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzIHx8IHt9KVxuICAgIC5zb3J0KClcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gIWZpbHRlclt2XTtcbiAgICB9KTtcblxuICBjb25zdCBzdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCk7XG4gIGlmIChzdHlsZUZ1bmN0aW9uKSB7XG4gICAgLy8gRklYTUUgdGhlIHN0eWxlcyByZXR1cm5lZCBieSB0aGUgc3R5bGUgZnVuY3Rpb24gYXJlIHN1cHBvc2VkIHRvIGJlXG4gICAgLy8gcmVzb2x1dGlvbi1pbmRlcGVuZGVudCBoZXJlXG4gICAgY29uc3Qgc3R5bGVzID0gc3R5bGVGdW5jdGlvbihmZWF0dXJlLCAwKTtcbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBjb25zdCBzdHlsZUFycmF5ID0gQXJyYXkuaXNBcnJheShzdHlsZXMpID8gc3R5bGVzIDogW3N0eWxlc107XG4gICAgICBsZXQgcG9pbnRTdHlsZXMgPSBzdHlsZUFycmF5O1xuICAgICAgaWYgKGZlYXR1cmUuZ2V0R2VvbWV0cnkoKSkge1xuICAgICAgICBwb2ludFN0eWxlcyA9IHN0eWxlQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gc3R5bGUuZ2V0R2VvbWV0cnlGdW5jdGlvbigpKGZlYXR1cmUpO1xuICAgICAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtHZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSlcbiAgICAgICAgICAgICAgICAuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50JztcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1BvaW50JyB8fCB0eXBlID09PSAnTXVsdGlQb2ludCc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKCdQb2ludCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud3JpdGVTdHlsZXNfKSB7XG4gICAgICAgIGxldCBsaW5lU3R5bGVzID0gc3R5bGVBcnJheTtcbiAgICAgICAgbGV0IHBvbHlTdHlsZXMgPSBzdHlsZUFycmF5O1xuICAgICAgICBpZiAoZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSB7XG4gICAgICAgICAgbGluZVN0eWxlcyA9IHN0eWxlQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7R2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICAgICAgICAgICAuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKClcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ011bHRpTGluZVN0cmluZyc7XG4gICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb2x5U3R5bGVzID0gc3R5bGVBcnJheS5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHN0eWxlLmdldEdlb21ldHJ5RnVuY3Rpb24oKShmZWF0dXJlKTtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtHZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSlcbiAgICAgICAgICAgICAgICAgIC5nZXRHZW9tZXRyaWVzQXJyYXlSZWN1cnNpdmUoKVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByb3BlcnRpZXNbJ1N0eWxlJ10gPSB7XG4gICAgICAgICAgcG9pbnRTdHlsZXM6IHBvaW50U3R5bGVzLFxuICAgICAgICAgIGxpbmVTdHlsZXM6IGxpbmVTdHlsZXMsXG4gICAgICAgICAgcG9seVN0eWxlczogcG9seVN0eWxlcyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChwb2ludFN0eWxlcy5sZW5ndGggJiYgcHJvcGVydGllc1snbmFtZSddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGV4dFN0eWxlID0gcG9pbnRTdHlsZXNbMF0uZ2V0VGV4dCgpO1xuICAgICAgICBpZiAodGV4dFN0eWxlKSB7XG4gICAgICAgICAgcHJvcGVydGllc1snbmFtZSddID0gdGV4dFN0eWxlLmdldFRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBQTEFDRU1BUktfU0VRVUVOQ0VbcGFyZW50Tm9kZS5uYW1lc3BhY2VVUkldO1xuICBjb25zdCB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UocHJvcGVydGllcywgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgUExBQ0VNQVJLX1NFUklBTElaRVJTLFxuICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgdmFsdWVzLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIG9yZGVyZWRLZXlzXG4gICk7XG5cbiAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIGtleXMpO1xuICAgIGNvbnN0IG5hbWVzQW5kVmFsdWVzID0ge25hbWVzOiBrZXlzLCB2YWx1ZXM6IHNlcXVlbmNlfTtcbiAgICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgICAgY29udGV4dCxcbiAgICAgIFBMQUNFTUFSS19TRVJJQUxJWkVSUyxcbiAgICAgIEVYVEVOREVEREFUQV9OT0RFX0ZBQ1RPUlksXG4gICAgICBbbmFtZXNBbmRWYWx1ZXNdLFxuICAgICAgb2JqZWN0U3RhY2tcbiAgICApO1xuICB9XG5cbiAgLy8gc2VyaWFsaXplIGdlb21ldHJ5XG4gIGNvbnN0IG9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9ICovIChcbiAgICBvYmplY3RTdGFja1swXVxuICApO1xuICBsZXQgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gIGlmIChnZW9tZXRyeSkge1xuICAgIGdlb21ldHJ5ID0gdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIFBMQUNFTUFSS19TRVJJQUxJWkVSUyxcbiAgICBHRU9NRVRSWV9OT0RFX0ZBQ1RPUlksXG4gICAgW2dlb21ldHJ5XSxcbiAgICBvYmplY3RTdGFja1xuICApO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PHN0cmluZz4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBQUklNSVRJVkVfR0VPTUVUUllfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ2V4dHJ1ZGUnLFxuICAndGVzc2VsbGF0ZScsXG4gICdhbHRpdHVkZU1vZGUnLFxuICAnY29vcmRpbmF0ZXMnLFxuXSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUFJJTUlUSVZFX0dFT01FVFJZX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdleHRydWRlJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVCb29sZWFuVGV4dE5vZGUpLFxuICAndGVzc2VsbGF0ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQm9vbGVhblRleHROb2RlKSxcbiAgJ2FsdGl0dWRlTW9kZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICAnY29vcmRpbmF0ZXMnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUNvb3JkaW5hdGVzVGV4dE5vZGUpLFxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUHJpbWl0aXZlR2VvbWV0cnkobm9kZSwgZ2VvbWV0cnksIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICBjb25zdCAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqLyBjb250ZXh0ID0ge25vZGU6IG5vZGV9O1xuICBjb250ZXh0WydsYXlvdXQnXSA9IGdlb21ldHJ5LmdldExheW91dCgpO1xuICBjb250ZXh0WydzdHJpZGUnXSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuXG4gIC8vIHNlcmlhbGl6ZSBwcm9wZXJ0aWVzIChwcm9wZXJ0aWVzIHVua25vd24gdG8gS01MIGFyZSBub3Qgc2VyaWFsaXplZClcbiAgY29uc3QgcHJvcGVydGllcyA9IGdlb21ldHJ5LmdldFByb3BlcnRpZXMoKTtcbiAgcHJvcGVydGllcy5jb29yZGluYXRlcyA9IGZsYXRDb29yZGluYXRlcztcblxuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBQUklNSVRJVkVfR0VPTUVUUllfU0VRVUVOQ0VbcGFyZW50Tm9kZS5uYW1lc3BhY2VVUkldO1xuICBjb25zdCB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UocHJvcGVydGllcywgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgUFJJTUlUSVZFX0dFT01FVFJZX1NFUklBTElaRVJTLFxuICAgIE9CSkVDVF9QUk9QRVJUWV9OT0RFX0ZBQ1RPUlksXG4gICAgdmFsdWVzLFxuICAgIG9iamVjdFN0YWNrLFxuICAgIG9yZGVyZWRLZXlzXG4gICk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8c3RyaW5nPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFBPTFlfU1RZTEVfU0VRVUVOQ0UgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIFtcbiAgJ2NvbG9yJyxcbiAgJ2ZpbGwnLFxuICAnb3V0bGluZScsXG5dKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBQT0xZR09OX1NFUklBTElaRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdvdXRlckJvdW5kYXJ5SXMnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUJvdW5kYXJ5SXMpLFxuICAnaW5uZXJCb3VuZGFyeUlzJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVCb3VuZGFyeUlzKSxcbn0pO1xuXG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgaW5uZXJCb3VuZGFyeUlzIG5vZGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfVxuICovXG5jb25zdCBJTk5FUl9CT1VOREFSWV9OT0RFX0ZBQ1RPUlkgPSBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoJ2lubmVyQm91bmRhcnlJcycpO1xuXG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgb3V0ZXJCb3VuZGFyeUlzIG5vZGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfVxuICovXG5jb25zdCBPVVRFUl9CT1VOREFSWV9OT0RFX0ZBQ1RPUlkgPSBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoJ291dGVyQm91bmRhcnlJcycpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24uXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUG9seWdvbihub2RlLCBwb2x5Z29uLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBsaW5lYXJSaW5ncyA9IHBvbHlnb24uZ2V0TGluZWFyUmluZ3MoKTtcbiAgY29uc3Qgb3V0ZXJSaW5nID0gbGluZWFyUmluZ3Muc2hpZnQoKTtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgLy8gaW5uZXIgcmluZ3NcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIFBPTFlHT05fU0VSSUFMSVpFUlMsXG4gICAgSU5ORVJfQk9VTkRBUllfTk9ERV9GQUNUT1JZLFxuICAgIGxpbmVhclJpbmdzLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIC8vIG91dGVyIHJpbmdcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIFBPTFlHT05fU0VSSUFMSVpFUlMsXG4gICAgT1VURVJfQk9VTkRBUllfTk9ERV9GQUNUT1JZLFxuICAgIFtvdXRlclJpbmddLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUE9MWV9TVFlMRV9TRVJJQUxJWkVSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnY29sb3InOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUNvbG9yVGV4dE5vZGUpLFxuICAnZmlsbCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQm9vbGVhblRleHROb2RlKSxcbiAgJ291dGxpbmUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUJvb2xlYW5UZXh0Tm9kZSksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7U3R5bGV9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZVBvbHlTdHlsZShub2RlLCBzdHlsZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi8gY29udGV4dCA9IHtub2RlOiBub2RlfTtcbiAgY29uc3QgZmlsbCA9IHN0eWxlLmdldEZpbGwoKTtcbiAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgJ2NvbG9yJzogZmlsbCA/IGZpbGwuZ2V0Q29sb3IoKSA6IHVuZGVmaW5lZCxcbiAgICAnZmlsbCc6IGZpbGwgPyB1bmRlZmluZWQgOiBmYWxzZSxcbiAgICAnb3V0bGluZSc6IHN0cm9rZSA/IHVuZGVmaW5lZCA6IGZhbHNlLFxuICB9O1xuICBjb25zdCBwYXJlbnROb2RlID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgY29uc3Qgb3JkZXJlZEtleXMgPSBQT0xZX1NUWUxFX1NFUVVFTkNFW3BhcmVudE5vZGUubmFtZXNwYWNlVVJJXTtcbiAgY29uc3QgdmFsdWVzID0gbWFrZVNlcXVlbmNlKHByb3BlcnRpZXMsIG9yZGVyZWRLZXlzKTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBjb250ZXh0LFxuICAgIFBPTFlfU1RZTEVfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBzY2FsZSB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gc2NhbGUgU2NhbGUuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU2NhbGVUZXh0Tm9kZShub2RlLCBzY2FsZSkge1xuICAvLyB0aGUgTWF0aCBpcyB0byByZW1vdmUgYW55IGV4Y2VzcyBkZWNpbWFscyBjcmVhdGVkIGJ5IGZsb2F0IGFyaXRobWV0aWNcbiAgd3JpdGVEZWNpbWFsVGV4dE5vZGUobm9kZSwgTWF0aC5yb3VuZChzY2FsZSAqIDFlNikgLyAxZTYpO1xufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PHN0cmluZz4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTVFlMRV9TRVFVRU5DRSA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywgW1xuICAnSWNvblN0eWxlJyxcbiAgJ0xhYmVsU3R5bGUnLFxuICAnTGluZVN0eWxlJyxcbiAgJ1BvbHlTdHlsZScsXG5dKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTVFlMRV9TRVJJQUxJWkVSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnSWNvblN0eWxlJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVJY29uU3R5bGUpLFxuICAnTGFiZWxTdHlsZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTGFiZWxTdHlsZSksXG4gICdMaW5lU3R5bGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUxpbmVTdHlsZSksXG4gICdQb2x5U3R5bGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVBvbHlTdHlsZSksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgQXJyYXk8U3R5bGU+Pn0gc3R5bGVzIFN0eWxlcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVTdHlsZShub2RlLCBzdHlsZXMsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIGNvbnRleHQgPSB7bm9kZTogbm9kZX07XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgaWYgKHN0eWxlcy5wb2ludFN0eWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZXMucG9pbnRTdHlsZXNbMF0uZ2V0VGV4dCgpO1xuICAgIGlmICh0ZXh0U3R5bGUpIHtcbiAgICAgIHByb3BlcnRpZXNbJ0xhYmVsU3R5bGUnXSA9IHRleHRTdHlsZTtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VTdHlsZSA9IHN0eWxlcy5wb2ludFN0eWxlc1swXS5nZXRJbWFnZSgpO1xuICAgIGlmIChcbiAgICAgIGltYWdlU3R5bGUgJiZcbiAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoaW1hZ2VTdHlsZSkuZ2V0U3JjKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgcHJvcGVydGllc1snSWNvblN0eWxlJ10gPSBpbWFnZVN0eWxlO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVzLmxpbmVTdHlsZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHlsZXMubGluZVN0eWxlc1swXS5nZXRTdHJva2UoKTtcbiAgICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICAgIHByb3BlcnRpZXNbJ0xpbmVTdHlsZSddID0gc3Ryb2tlU3R5bGU7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZXMucG9seVN0eWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlcy5wb2x5U3R5bGVzWzBdLmdldFN0cm9rZSgpO1xuICAgIGlmIChzdHJva2VTdHlsZSAmJiAhcHJvcGVydGllc1snTGluZVN0eWxlJ10pIHtcbiAgICAgIHByb3BlcnRpZXNbJ0xpbmVTdHlsZSddID0gc3Ryb2tlU3R5bGU7XG4gICAgfVxuICAgIHByb3BlcnRpZXNbJ1BvbHlTdHlsZSddID0gc3R5bGVzLnBvbHlTdHlsZXNbMF07XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gIGNvbnN0IG9yZGVyZWRLZXlzID0gU1RZTEVfU0VRVUVOQ0VbcGFyZW50Tm9kZS5uYW1lc3BhY2VVUkldO1xuICBjb25zdCB2YWx1ZXMgPSBtYWtlU2VxdWVuY2UocHJvcGVydGllcywgb3JkZXJlZEtleXMpO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGNvbnRleHQsXG4gICAgU1RZTEVfU0VSSUFMSVpFUlMsXG4gICAgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSxcbiAgICB2YWx1ZXMsXG4gICAgb2JqZWN0U3RhY2ssXG4gICAgb3JkZXJlZEtleXNcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBWZWMyIHRvLlxuICogQHBhcmFtIHtWZWMyfSB2ZWMyIFZlYzIuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVmVjMihub2RlLCB2ZWMyKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKCd4JywgU3RyaW5nKHZlYzIueCkpO1xuICBub2RlLnNldEF0dHJpYnV0ZSgneScsIFN0cmluZyh2ZWMyLnkpKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3h1bml0cycsIHZlYzIueHVuaXRzKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3l1bml0cycsIHZlYzIueXVuaXRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgS01MO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9PV1NcbiAqL1xuaW1wb3J0IFhNTCBmcm9tICcuL1hNTC5qcyc7XG5pbXBvcnQge1xuICBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIsXG4gIG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcixcbiAgbWFrZVN0cnVjdHVyZU5TLFxuICBwdXNoUGFyc2VBbmRQb3AsXG59IGZyb20gJy4uL3htbC5qcyc7XG5pbXBvcnQge3JlYWRIcmVmfSBmcm9tICcuL3hsaW5rLmpzJztcbmltcG9ydCB7cmVhZFN0cmluZ30gZnJvbSAnLi94c2QuanMnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bGx8c3RyaW5nPn1cbiAqL1xuY29uc3QgTkFNRVNQQUNFX1VSSVMgPSBbbnVsbCwgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb3dzLzEuMSddO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnU2VydmljZUlkZW50aWZpY2F0aW9uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTZXJ2aWNlSWRlbnRpZmljYXRpb24pLFxuICAnU2VydmljZVByb3ZpZGVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTZXJ2aWNlUHJvdmlkZXIpLFxuICAnT3BlcmF0aW9uc01ldGFkYXRhJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRPcGVyYXRpb25zTWV0YWRhdGEpLFxufSk7XG5cbmNsYXNzIE9XUyBleHRlbmRzIFhNTCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0XG4gICAqL1xuICByZWFkRnJvbU5vZGUobm9kZSkge1xuICAgIGNvbnN0IG93c09iamVjdCA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgUEFSU0VSUywgbm9kZSwgW10pO1xuICAgIHJldHVybiBvd3NPYmplY3QgPyBvd3NPYmplY3QgOiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBBRERSRVNTX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0RlbGl2ZXJ5UG9pbnQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdDaXR5JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQWRtaW5pc3RyYXRpdmVBcmVhJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnUG9zdGFsQ29kZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ0NvdW50cnknOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdFbGVjdHJvbmljTWFpbEFkZHJlc3MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEFMTE9XRURfVkFMVUVTX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ1ZhbHVlJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRWYWx1ZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IENPTlNUUkFJTlRfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnQWxsb3dlZFZhbHVlcyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQWxsb3dlZFZhbHVlcyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IENPTlRBQ1RfSU5GT19QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdQaG9uZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUGhvbmUpLFxuICAnQWRkcmVzcyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQWRkcmVzcyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IERDUF9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdIVFRQJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRIdHRwKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgSFRUUF9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdHZXQnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZEdldCksXG4gICdQb3N0JzogdW5kZWZpbmVkLCAvLyBUT0RPXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IE9QRVJBVElPTl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdEQ1AnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERjcCksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IE9QRVJBVElPTlNfTUVUQURBVEFfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnT3BlcmF0aW9uJzogcmVhZE9wZXJhdGlvbixcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUEhPTkVfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnVm9pY2UnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdGYWNzaW1pbGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFJFUVVFU1RfTUVUSE9EX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0NvbnN0cmFpbnQnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZENvbnN0cmFpbnQpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTRVJWSUNFX0NPTlRBQ1RfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnSW5kaXZpZHVhbE5hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdQb3NpdGlvbk5hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdDb250YWN0SW5mbyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQ29udGFjdEluZm8pLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTRVJWSUNFX0lERU5USUZJQ0FUSU9OX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0Fic3RyYWN0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQWNjZXNzQ29uc3RyYWludHMnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdGZWVzJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnVGl0bGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdTZXJ2aWNlVHlwZVZlcnNpb24nOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdTZXJ2aWNlVHlwZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgU0VSVklDRV9QUk9WSURFUl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdQcm92aWRlck5hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdQcm92aWRlclNpdGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEhyZWYpLFxuICAnU2VydmljZUNvbnRhY3QnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFNlcnZpY2VDb250YWN0KSxcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIHJlYWRBZGRyZXNzKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIEFERFJFU1NfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gcmVhZEFsbG93ZWRWYWx1ZXMobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgQUxMT1dFRF9WQUxVRVNfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRDb25zdHJhaW50KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3AoeyduYW1lJzogbmFtZX0sIENPTlNUUkFJTlRfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIGNvbnRhY3QgaW5mby5cbiAqL1xuZnVuY3Rpb24gcmVhZENvbnRhY3RJbmZvKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIENPTlRBQ1RfSU5GT19QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBUaGUgRENQLlxuICovXG5mdW5jdGlvbiByZWFkRGNwKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIERDUF9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBUaGUgR0VUIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEdldChub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBocmVmID0gcmVhZEhyZWYobm9kZSk7XG4gIGlmICghaHJlZikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcChcbiAgICB7J2hyZWYnOiBocmVmfSxcbiAgICBSRVFVRVNUX01FVEhPRF9QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRoZSBIVFRQIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEh0dHAobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgSFRUUF9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBUaGUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiByZWFkT3BlcmF0aW9uKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IG5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICBjb25zdCB2YWx1ZSA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgT1BFUkFUSU9OX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgb2JqZWN0ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIG9wZXJhdGlvbnMgbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIHJlYWRPcGVyYXRpb25zTWV0YWRhdGEobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgT1BFUkFUSU9OU19NRVRBREFUQV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBUaGUgcGhvbmUuXG4gKi9cbmZ1bmN0aW9uIHJlYWRQaG9uZShub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBQSE9ORV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBUaGUgc2VydmljZSBpZGVudGlmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVhZFNlcnZpY2VJZGVudGlmaWNhdGlvbihub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBTRVJWSUNFX0lERU5USUZJQ0FUSU9OX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRoZSBzZXJ2aWNlIGNvbnRhY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRTZXJ2aWNlQ29udGFjdChub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBTRVJWSUNFX0NPTlRBQ1RfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGhlIHNlcnZpY2UgcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHJlYWRTZXJ2aWNlUHJvdmlkZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgU0VSVklDRV9QUk9WSURFUl9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJlYWRWYWx1ZShub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcmVhZFN0cmluZyhub2RlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgT1dTO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9Qb2x5bGluZVxuICovXG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgVGV4dEZlYXR1cmUgZnJvbSAnLi9UZXh0RmVhdHVyZS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2ZsaXBYWX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ZsaXAuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2dldFN0cmlkZUZvckxheW91dH0gZnJvbSAnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZmFjdG9yPTFlNV0gVGhlIGZhY3RvciBieSB3aGljaCB0aGUgY29vcmRpbmF0ZXMgdmFsdWVzIHdpbGwgYmUgc2NhbGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbZ2VvbWV0cnlMYXlvdXQ9J1hZJ10gTGF5b3V0IG9mIHRoZVxuICogZmVhdHVyZSBnZW9tZXRyaWVzIGNyZWF0ZWQgYnkgdGhlIGZvcm1hdCByZWFkZXIuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGZWF0dXJlIGZvcm1hdCBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBkYXRhIGluIHRoZSBFbmNvZGVkXG4gKiBQb2x5bGluZSBBbGdvcml0aG0gRm9ybWF0LlxuICpcbiAqIFdoZW4gcmVhZGluZyBmZWF0dXJlcywgdGhlIGNvb3JkaW5hdGVzIGFyZSBhc3N1bWVkIHRvIGJlIGluIHR3byBkaW1lbnNpb25zXG4gKiBhbmQgaW4gW2xhdGl0dWRlLCBsb25naXR1ZGVdIG9yZGVyLlxuICpcbiAqIEFzIFBvbHlsaW5lIHNvdXJjZXMgY29udGFpbiBhIHNpbmdsZSBmZWF0dXJlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9mb3JtYXQvUG9seWxpbmV+UG9seWxpbmUjcmVhZEZlYXR1cmVzfSB3aWxsIHJldHVybiB0aGVcbiAqIGZlYXR1cmUgaW4gYW4gYXJyYXkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQb2x5bGluZSBleHRlbmRzIFRleHRGZWF0dXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbignRVBTRzo0MzI2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mYWN0b3JfID0gb3B0aW9ucy5mYWN0b3IgPyBvcHRpb25zLmZhY3RvciA6IDFlNTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUxheW91dF8gPSBvcHRpb25zLmdlb21ldHJ5TGF5b3V0XG4gICAgICA/IG9wdGlvbnMuZ2VvbWV0cnlMYXlvdXRcbiAgICAgIDogJ1hZJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqL1xuICByZWFkRmVhdHVyZUZyb21UZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucmVhZEdlb21ldHJ5RnJvbVRleHQodGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlKGdlb21ldHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxGZWF0dXJlPn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRoaXMucmVhZEZlYXR1cmVGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gW2ZlYXR1cmVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICByZWFkR2VvbWV0cnlGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RyaWRlID0gZ2V0U3RyaWRlRm9yTGF5b3V0KHRoaXMuZ2VvbWV0cnlMYXlvdXRfKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBkZWNvZGVEZWx0YXModGV4dCwgc3RyaWRlLCB0aGlzLmZhY3Rvcl8pO1xuICAgIGZsaXBYWShmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgc3RyaWRlXG4gICAgKTtcbiAgICBjb25zdCBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHRoaXMuZ2VvbWV0cnlMYXlvdXRfKTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKFxuICAgICAgbGluZVN0cmluZyxcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PExpbmVTdHJpbmc+fSBmZWF0dXJlIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGV4dC5cbiAgICovXG4gIHdyaXRlRmVhdHVyZVRleHQoZmVhdHVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGVHZW9tZXRyeVRleHQoZ2VvbWV0cnksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3NlcnQoZmFsc2UsIDQwKTsgLy8gRXhwZWN0ZWQgYGZlYXR1cmVgIHRvIGhhdmUgYSBnZW9tZXRyeVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxMaW5lU3RyaW5nPj59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGV4dC5cbiAgICovXG4gIHdyaXRlRmVhdHVyZXNUZXh0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVGZWF0dXJlVGV4dChmZWF0dXJlc1swXSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtMaW5lU3RyaW5nfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQuXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5VGV4dChnZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIGdlb21ldHJ5ID1cbiAgICAgIC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi9cbiAgICAgIChcbiAgICAgICAgdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgdHJ1ZSwgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucykpXG4gICAgICApO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGZsaXBYWShmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICByZXR1cm4gZW5jb2RlRGVsdGFzKGZsYXRDb29yZGluYXRlcywgc3RyaWRlLCB0aGlzLmZhY3Rvcl8pO1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIGEgbGlzdCBvZiBuLWRpbWVuc2lvbmFsIHBvaW50cyBhbmQgcmV0dXJuIGFuIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQXR0ZW50aW9uOiBUaGlzIGZ1bmN0aW9uIHdpbGwgbW9kaWZ5IHRoZSBwYXNzZWQgYXJyYXkhXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBudW1iZXJzIEEgbGlzdCBvZiBuLWRpbWVuc2lvbmFsIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgVGhlIG51bWJlciBvZiBkaW1lbnNpb24gb2YgdGhlIHBvaW50cyBpbiB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmFjdG9yXSBUaGUgZmFjdG9yIGJ5IHdoaWNoIHRoZSBudW1iZXJzIHdpbGwgYmVcbiAqICAgICBtdWx0aXBsaWVkLiBUaGUgcmVtYWluaW5nIGRlY2ltYWwgcGxhY2VzIHdpbGwgZ2V0IHJvdW5kZWQgYXdheS5cbiAqICAgICBEZWZhdWx0IGlzIGAxZTVgLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEZWx0YXMobnVtYmVycywgc3RyaWRlLCBmYWN0b3IpIHtcbiAgZmFjdG9yID0gZmFjdG9yID8gZmFjdG9yIDogMWU1O1xuICBsZXQgZDtcblxuICBjb25zdCBsYXN0TnVtYmVycyA9IG5ldyBBcnJheShzdHJpZGUpO1xuICBmb3IgKGQgPSAwOyBkIDwgc3RyaWRlOyArK2QpIHtcbiAgICBsYXN0TnVtYmVyc1tkXSA9IDA7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBudW1iZXJzLmxlbmd0aDsgaSA8IGlpOyApIHtcbiAgICBmb3IgKGQgPSAwOyBkIDwgc3RyaWRlOyArK2QsICsraSkge1xuICAgICAgY29uc3QgbnVtID0gbnVtYmVyc1tpXTtcbiAgICAgIGNvbnN0IGRlbHRhID0gbnVtIC0gbGFzdE51bWJlcnNbZF07XG4gICAgICBsYXN0TnVtYmVyc1tkXSA9IG51bTtcblxuICAgICAgbnVtYmVyc1tpXSA9IGRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbmNvZGVGbG9hdHMobnVtYmVycywgZmFjdG9yKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBsaXN0IG9mIG4tZGltZW5zaW9uYWwgcG9pbnRzIGZyb20gYW4gZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZCBBbiBlbmNvZGVkIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgVGhlIG51bWJlciBvZiBkaW1lbnNpb24gb2YgdGhlIHBvaW50cyBpbiB0aGVcbiAqICAgICBlbmNvZGVkIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmFjdG9yXSBUaGUgZmFjdG9yIGJ5IHdoaWNoIHRoZSByZXN1bHRpbmcgbnVtYmVycyB3aWxsXG4gKiAgICAgYmUgZGl2aWRlZC4gRGVmYXVsdCBpcyBgMWU1YC5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEEgbGlzdCBvZiBuLWRpbWVuc2lvbmFsIHBvaW50cy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZURlbHRhcyhlbmNvZGVkLCBzdHJpZGUsIGZhY3Rvcikge1xuICBmYWN0b3IgPSBmYWN0b3IgPyBmYWN0b3IgOiAxZTU7XG4gIGxldCBkO1xuXG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgbGFzdE51bWJlcnMgPSBuZXcgQXJyYXkoc3RyaWRlKTtcbiAgZm9yIChkID0gMDsgZCA8IHN0cmlkZTsgKytkKSB7XG4gICAgbGFzdE51bWJlcnNbZF0gPSAwO1xuICB9XG5cbiAgY29uc3QgbnVtYmVycyA9IGRlY29kZUZsb2F0cyhlbmNvZGVkLCBmYWN0b3IpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IG51bWJlcnMubGVuZ3RoOyBpIDwgaWk7ICkge1xuICAgIGZvciAoZCA9IDA7IGQgPCBzdHJpZGU7ICsrZCwgKytpKSB7XG4gICAgICBsYXN0TnVtYmVyc1tkXSArPSBudW1iZXJzW2ldO1xuXG4gICAgICBudW1iZXJzW2ldID0gbGFzdE51bWJlcnNbZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bWJlcnM7XG59XG5cbi8qKlxuICogRW5jb2RlIGEgbGlzdCBvZiBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFuZCByZXR1cm4gYW4gZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBBdHRlbnRpb246IFRoaXMgZnVuY3Rpb24gd2lsbCBtb2RpZnkgdGhlIHBhc3NlZCBhcnJheSFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG51bWJlcnMgQSBsaXN0IG9mIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZhY3Rvcl0gVGhlIGZhY3RvciBieSB3aGljaCB0aGUgbnVtYmVycyB3aWxsIGJlXG4gKiAgICAgbXVsdGlwbGllZC4gVGhlIHJlbWFpbmluZyBkZWNpbWFsIHBsYWNlcyB3aWxsIGdldCByb3VuZGVkIGF3YXkuXG4gKiAgICAgRGVmYXVsdCBpcyBgMWU1YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRmxvYXRzKG51bWJlcnMsIGZhY3Rvcikge1xuICBmYWN0b3IgPSBmYWN0b3IgPyBmYWN0b3IgOiAxZTU7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IG51bWJlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIG51bWJlcnNbaV0gPSBNYXRoLnJvdW5kKG51bWJlcnNbaV0gKiBmYWN0b3IpO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kZVNpZ25lZEludGVnZXJzKG51bWJlcnMpO1xufVxuXG4vKipcbiAqIERlY29kZSBhIGxpc3Qgb2YgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBmcm9tIGFuIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWQgQW4gZW5jb2RlZCBzdHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZhY3Rvcl0gVGhlIGZhY3RvciBieSB3aGljaCB0aGUgcmVzdWx0IHdpbGwgYmUgZGl2aWRlZC5cbiAqICAgICBEZWZhdWx0IGlzIGAxZTVgLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQSBsaXN0IG9mIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbG9hdHMoZW5jb2RlZCwgZmFjdG9yKSB7XG4gIGZhY3RvciA9IGZhY3RvciA/IGZhY3RvciA6IDFlNTtcbiAgY29uc3QgbnVtYmVycyA9IGRlY29kZVNpZ25lZEludGVnZXJzKGVuY29kZWQpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBudW1iZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBudW1iZXJzW2ldIC89IGZhY3RvcjtcbiAgfVxuICByZXR1cm4gbnVtYmVycztcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBsaXN0IG9mIHNpZ25lZCBpbnRlZ2VycyBhbmQgcmV0dXJuIGFuIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQXR0ZW50aW9uOiBUaGlzIGZ1bmN0aW9uIHdpbGwgbW9kaWZ5IHRoZSBwYXNzZWQgYXJyYXkhXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBudW1iZXJzIEEgbGlzdCBvZiBzaWduZWQgaW50ZWdlcnMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVNpZ25lZEludGVnZXJzKG51bWJlcnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gbnVtYmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgbnVtID0gbnVtYmVyc1tpXTtcbiAgICBudW1iZXJzW2ldID0gbnVtIDwgMCA/IH4obnVtIDw8IDEpIDogbnVtIDw8IDE7XG4gIH1cbiAgcmV0dXJuIGVuY29kZVVuc2lnbmVkSW50ZWdlcnMobnVtYmVycyk7XG59XG5cbi8qKlxuICogRGVjb2RlIGEgbGlzdCBvZiBzaWduZWQgaW50ZWdlcnMgZnJvbSBhbiBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkIEFuIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQSBsaXN0IG9mIHNpZ25lZCBpbnRlZ2Vycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVNpZ25lZEludGVnZXJzKGVuY29kZWQpIHtcbiAgY29uc3QgbnVtYmVycyA9IGRlY29kZVVuc2lnbmVkSW50ZWdlcnMoZW5jb2RlZCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IG51bWJlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IG51bSA9IG51bWJlcnNbaV07XG4gICAgbnVtYmVyc1tpXSA9IG51bSAmIDEgPyB+KG51bSA+PiAxKSA6IG51bSA+PiAxO1xuICB9XG4gIHJldHVybiBudW1iZXJzO1xufVxuXG4vKipcbiAqIEVuY29kZSBhIGxpc3Qgb2YgdW5zaWduZWQgaW50ZWdlcnMgYW5kIHJldHVybiBhbiBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbnVtYmVycyBBIGxpc3Qgb2YgdW5zaWduZWQgaW50ZWdlcnMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVuc2lnbmVkSW50ZWdlcnMobnVtYmVycykge1xuICBsZXQgZW5jb2RlZCA9ICcnO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBudW1iZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBlbmNvZGVkICs9IGVuY29kZVVuc2lnbmVkSW50ZWdlcihudW1iZXJzW2ldKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBsaXN0IG9mIHVuc2lnbmVkIGludGVnZXJzIGZyb20gYW4gZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZCBBbiBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEEgbGlzdCBvZiB1bnNpZ25lZCBpbnRlZ2Vycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVuc2lnbmVkSW50ZWdlcnMoZW5jb2RlZCkge1xuICBjb25zdCBudW1iZXJzID0gW107XG4gIGxldCBjdXJyZW50ID0gMDtcbiAgbGV0IHNoaWZ0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5jb2RlZC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgYiA9IGVuY29kZWQuY2hhckNvZGVBdChpKSAtIDYzO1xuICAgIGN1cnJlbnQgfD0gKGIgJiAweDFmKSA8PCBzaGlmdDtcbiAgICBpZiAoYiA8IDB4MjApIHtcbiAgICAgIG51bWJlcnMucHVzaChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgc2hpZnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGlmdCArPSA1O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVycztcbn1cblxuLyoqXG4gKiBFbmNvZGUgb25lIHNpbmdsZSB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm4gYW4gZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFVuc2lnbmVkIGludGVnZXIgdGhhdCBzaG91bGQgYmUgZW5jb2RlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVW5zaWduZWRJbnRlZ2VyKG51bSkge1xuICBsZXQgdmFsdWUsXG4gICAgZW5jb2RlZCA9ICcnO1xuICB3aGlsZSAobnVtID49IDB4MjApIHtcbiAgICB2YWx1ZSA9ICgweDIwIHwgKG51bSAmIDB4MWYpKSArIDYzO1xuICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgbnVtID4+PSA1O1xuICB9XG4gIHZhbHVlID0gbnVtICsgNjM7XG4gIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb2x5bGluZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvVGV4dEZlYXR1cmVcbiAqL1xuaW1wb3J0IEZlYXR1cmVGb3JtYXQgZnJvbSAnLi4vZm9ybWF0L0ZlYXR1cmUuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgdGV4dCBmZWF0dXJlIGZvcm1hdHMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRleHRGZWF0dXJlIGV4dGVuZHMgRmVhdHVyZUZvcm1hdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlR5cGV9IEZvcm1hdC5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0ZXh0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBmZWF0dXJlIGZyb20gdGhlIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRGZWF0dXJlKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlRnJvbVRleHQoXG4gICAgICBnZXRUZXh0KHNvdXJjZSksXG4gICAgICB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZS5cbiAgICovXG4gIHJlYWRGZWF0dXJlRnJvbVRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIGZlYXR1cmVzIGZyb20gdGhlIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlc0Zyb21UZXh0KFxuICAgICAgZ2V0VGV4dChzb3VyY2UpLFxuICAgICAgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21UZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBnZW9tZXRyeSBmcm9tIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEdlb21ldHJ5KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRHZW9tZXRyeUZyb21UZXh0KFxuICAgICAgZ2V0VGV4dChzb3VyY2UpLFxuICAgICAgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKi9cbiAgcmVhZEdlb21ldHJ5RnJvbVRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHByb2plY3Rpb24gZnJvbSB0aGUgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBQcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkUHJvamVjdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkUHJvamVjdGlvbkZyb21UZXh0KGdldFRleHQoc291cmNlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkUHJvamVjdGlvbkZyb21UZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhUHJvamVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBmZWF0dXJlIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlKGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZUZlYXR1cmVUZXh0KGZlYXR1cmUsIHRoaXMuYWRhcHRPcHRpb25zKG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUZXh0LlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlVGV4dChmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIGZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzKGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVGZWF0dXJlc1RleHQoZmVhdHVyZXMsIHRoaXMuYWRhcHRPcHRpb25zKG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQuXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzVGV4dChmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2luZ2xlIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gR2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZUdlb21ldHJ5VGV4dChnZW9tZXRyeSwgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUZXh0LlxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeVRleHQoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0LlxuICovXG5mdW5jdGlvbiBnZXRUZXh0KHNvdXJjZSkge1xuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dEZlYXR1cmU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L1RvcG9KU09OXG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IEpTT05GZWF0dXJlIGZyb20gJy4vSlNPTkZlYXR1cmUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi4vZ2VvbS9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBNdWx0aVBvbHlnb24gZnJvbSAnLi4vZ2VvbS9NdWx0aVBvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJ0b3BvanNvbi1zcGVjaWZpY2F0aW9uXCIpLlRvcG9sb2d5fSBUb3BvSlNPTlRvcG9sb2d5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwidG9wb2pzb24tc3BlY2lmaWNhdGlvblwiKS5HZW9tZXRyeUNvbGxlY3Rpb259IFRvcG9KU09OR2VvbWV0cnlDb2xsZWN0aW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwidG9wb2pzb24tc3BlY2lmaWNhdGlvblwiKS5HZW9tZXRyeU9iamVjdH0gVG9wb0pTT05HZW9tZXRyeVxuICogQHR5cGVkZWYge2ltcG9ydChcInRvcG9qc29uLXNwZWNpZmljYXRpb25cIikuUG9pbnR9IFRvcG9KU09OUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJ0b3BvanNvbi1zcGVjaWZpY2F0aW9uXCIpLk11bHRpUG9pbnR9IFRvcG9KU09OTXVsdGlQb2ludFxuICogQHR5cGVkZWYge2ltcG9ydChcInRvcG9qc29uLXNwZWNpZmljYXRpb25cIikuTGluZVN0cmluZ30gVG9wb0pTT05MaW5lU3RyaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwidG9wb2pzb24tc3BlY2lmaWNhdGlvblwiKS5NdWx0aUxpbmVTdHJpbmd9IFRvcG9KU09OTXVsdGlMaW5lU3RyaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwidG9wb2pzb24tc3BlY2lmaWNhdGlvblwiKS5Qb2x5Z29ufSBUb3BvSlNPTlBvbHlnb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJ0b3BvanNvbi1zcGVjaWZpY2F0aW9uXCIpLk11bHRpUG9seWdvbn0gVG9wb0pTT05NdWx0aVBvbHlnb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW2RhdGFQcm9qZWN0aW9uPSdFUFNHOjQzMjYnXSBEZWZhdWx0IGRhdGEgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGF5ZXJOYW1lXSBTZXQgdGhlIG5hbWUgb2YgdGhlIFRvcG9KU09OIHRvcG9sb2d5XG4gKiBgb2JqZWN0c2AncyBjaGlsZHJlbiBhcyBmZWF0dXJlIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLiBUaGlzIG1lYW5zXG4gKiB0aGF0IHdoZW4gc2V0IHRvIGAnbGF5ZXInYCwgYSB0b3BvbG9neSBsaWtlXG4gKiBgYGBcbiAqIHtcbiAqICAgXCJ0eXBlXCI6IFwiVG9wb2xvZ3lcIixcbiAqICAgXCJvYmplY3RzXCI6IHtcbiAqICAgICBcImV4YW1wbGVcIjoge1xuICogICAgICAgXCJ0eXBlXCI6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gKiAgICAgICBcImdlb21ldHJpZXNcIjogW11cbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogd2lsbCByZXN1bHQgaW4gZmVhdHVyZXMgdGhhdCBoYXZlIGEgcHJvcGVydHkgYCdsYXllcidgIHNldCB0byBgJ2V4YW1wbGUnYC5cbiAqIFdoZW4gbm90IHNldCwgbm8gcHJvcGVydHkgd2lsbCBiZSBhZGRlZCB0byBmZWF0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW2xheWVyc10gTmFtZXMgb2YgdGhlIFRvcG9KU09OIHRvcG9sb2d5J3NcbiAqIGBvYmplY3RzYCdzIGNoaWxkcmVuIHRvIHJlYWQgZmVhdHVyZXMgZnJvbS4gIElmIG5vdCBwcm92aWRlZCwgZmVhdHVyZXMgd2lsbFxuICogYmUgcmVhZCBmcm9tIGFsbCBjaGlsZHJlbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGRhdGEgaW4gdGhlIFRvcG9KU09OIGZvcm1hdC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRvcG9KU09OIGV4dGVuZHMgSlNPTkZlYXR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJOYW1lXyA9IG9wdGlvbnMubGF5ZXJOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5sYXllcnNfID0gb3B0aW9ucy5sYXllcnMgPyBvcHRpb25zLmxheWVycyA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5kYXRhUHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24oXG4gICAgICBvcHRpb25zLmRhdGFQcm9qZWN0aW9uID8gb3B0aW9ucy5kYXRhUHJvamVjdGlvbiA6ICdFUFNHOjQzMjYnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7QXJyYXk8RmVhdHVyZT59IEZlYXR1cmVzLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVzRnJvbU9iamVjdChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICBpZiAob2JqZWN0LnR5cGUgPT0gJ1RvcG9sb2d5Jykge1xuICAgICAgY29uc3QgdG9wb0pTT05Ub3BvbG9neSA9IC8qKiBAdHlwZSB7VG9wb0pTT05Ub3BvbG9neX0gKi8gKG9iamVjdCk7XG4gICAgICBsZXQgdHJhbnNmb3JtLFxuICAgICAgICBzY2FsZSA9IG51bGwsXG4gICAgICAgIHRyYW5zbGF0ZSA9IG51bGw7XG4gICAgICBpZiAodG9wb0pTT05Ub3BvbG9neVsndHJhbnNmb3JtJ10pIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdG9wb0pTT05Ub3BvbG9neVsndHJhbnNmb3JtJ107XG4gICAgICAgIHNjYWxlID0gdHJhbnNmb3JtWydzY2FsZSddO1xuICAgICAgICB0cmFuc2xhdGUgPSB0cmFuc2Zvcm1bJ3RyYW5zbGF0ZSddO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJjcyA9IHRvcG9KU09OVG9wb2xvZ3lbJ2FyY3MnXTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtQXJjcyhhcmNzLCBzY2FsZSwgdHJhbnNsYXRlKTtcbiAgICAgIH1cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59ICovXG4gICAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgICAgY29uc3QgdG9wb0pTT05GZWF0dXJlcyA9IHRvcG9KU09OVG9wb2xvZ3lbJ29iamVjdHMnXTtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5sYXllck5hbWVfO1xuICAgICAgbGV0IGZlYXR1cmU7XG4gICAgICBmb3IgKGNvbnN0IG9iamVjdE5hbWUgaW4gdG9wb0pTT05GZWF0dXJlcykge1xuICAgICAgICBpZiAodGhpcy5sYXllcnNfICYmICF0aGlzLmxheWVyc18uaW5jbHVkZXMob2JqZWN0TmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wb0pTT05GZWF0dXJlc1tvYmplY3ROYW1lXS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge1RvcG9KU09OR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoXG4gICAgICAgICAgICB0b3BvSlNPTkZlYXR1cmVzW29iamVjdE5hbWVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmZWF0dXJlcy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICByZWFkRmVhdHVyZXNGcm9tR2VvbWV0cnlDb2xsZWN0aW9uKFxuICAgICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAgICBhcmNzLFxuICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgb2JqZWN0TmFtZSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7VG9wb0pTT05HZW9tZXRyeX0gKi8gKFxuICAgICAgICAgICAgdG9wb0pTT05GZWF0dXJlc1tvYmplY3ROYW1lXVxuICAgICAgICAgICk7XG4gICAgICAgICAgZmVhdHVyZXMucHVzaChcbiAgICAgICAgICAgIHJlYWRGZWF0dXJlRnJvbUdlb21ldHJ5KFxuICAgICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAgICBhcmNzLFxuICAgICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgb2JqZWN0TmFtZSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgcmVhZFByb2plY3Rpb25Gcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFQcm9qZWN0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oVG9wb0pTT05HZW9tZXRyeSwgQXJyYXksIC4uLkFycmF5PSk6IGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdD59XG4gKi9cbmNvbnN0IEdFT01FVFJZX1JFQURFUlMgPSB7XG4gICdQb2ludCc6IHJlYWRQb2ludEdlb21ldHJ5LFxuICAnTGluZVN0cmluZyc6IHJlYWRMaW5lU3RyaW5nR2VvbWV0cnksXG4gICdQb2x5Z29uJzogcmVhZFBvbHlnb25HZW9tZXRyeSxcbiAgJ011bHRpUG9pbnQnOiByZWFkTXVsdGlQb2ludEdlb21ldHJ5LFxuICAnTXVsdGlMaW5lU3RyaW5nJzogcmVhZE11bHRpTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnTXVsdGlQb2x5Z29uJzogcmVhZE11bHRpUG9seWdvbkdlb21ldHJ5LFxufTtcblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhcmNzIGludG8gYSBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbmRpY2VzIEluZGljZXMgb2YgYXJjcyB0byBjb25jYXRlbmF0ZS4gIE5lZ2F0aXZlXG4gKiAgICAgdmFsdWVzIGluZGljYXRlIGFyY3MgbmVlZCB0byBiZSByZXZlcnNlZC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGFyY3MgQXJyYXkgb2YgYXJjcyAoYWxyZWFkeVxuICogICAgIHRyYW5zZm9ybWVkKS5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzIGFycmF5LlxuICovXG5mdW5jdGlvbiBjb25jYXRlbmF0ZUFyY3MoaW5kaWNlcywgYXJjcykge1xuICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovXG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gIGxldCBpbmRleDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaW5kZXggPSBpbmRpY2VzW2ldO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgLy8gc3BsaWNpbmcgdG9nZXRoZXIgYXJjcywgZGlzY2FyZCBsYXN0IHBvaW50XG4gICAgICBjb29yZGluYXRlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIGZvcndhcmQgYXJjXG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2luZGV4XTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGFyYy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzLnB1c2goYXJjW2pdLnNsaWNlKDApKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV2ZXJzZSBhcmNcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbfmluZGV4XTtcbiAgICAgIGZvciAobGV0IGogPSBhcmMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChhcmNbal0uc2xpY2UoMCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcG9pbnQgZnJvbSBhIFRvcG9KU09OIGdlb21ldHJ5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1RvcG9KU09OUG9pbnR9IG9iamVjdCBUb3BvSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNjYWxlIFNjYWxlIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdHJhbnNsYXRlIFRyYW5zbGF0aW9uIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEByZXR1cm4ge1BvaW50fSBHZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gcmVhZFBvaW50R2VvbWV0cnkob2JqZWN0LCBzY2FsZSwgdHJhbnNsYXRlKSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gb2JqZWN0Wydjb29yZGluYXRlcyddO1xuICBpZiAoc2NhbGUgJiYgdHJhbnNsYXRlKSB7XG4gICAgdHJhbnNmb3JtVmVydGV4KGNvb3JkaW5hdGVzLCBzY2FsZSwgdHJhbnNsYXRlKTtcbiAgfVxuICByZXR1cm4gbmV3IFBvaW50KGNvb3JkaW5hdGVzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBtdWx0aS1wb2ludCBmcm9tIGEgVG9wb0pTT04gZ2VvbWV0cnkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VG9wb0pTT05NdWx0aVBvaW50fSBvYmplY3QgVG9wb0pTT04gb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzY2FsZSBTY2FsZSBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRyYW5zbGF0ZSBUcmFuc2xhdGlvbiBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtNdWx0aVBvaW50fSBHZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gcmVhZE11bHRpUG9pbnRHZW9tZXRyeShvYmplY3QsIHNjYWxlLCB0cmFuc2xhdGUpIHtcbiAgY29uc3QgY29vcmRpbmF0ZXMgPSBvYmplY3RbJ2Nvb3JkaW5hdGVzJ107XG4gIGlmIChzY2FsZSAmJiB0cmFuc2xhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0cmFuc2Zvcm1WZXJ0ZXgoY29vcmRpbmF0ZXNbaV0sIHNjYWxlLCB0cmFuc2xhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IE11bHRpUG9pbnQoY29vcmRpbmF0ZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxpbmVzdHJpbmcgZnJvbSBhIFRvcG9KU09OIGdlb21ldHJ5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1RvcG9KU09OTGluZVN0cmluZ30gb2JqZWN0IFRvcG9KU09OIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGFyY3MgQXJyYXkgb2YgYXJjcy5cbiAqIEByZXR1cm4ge0xpbmVTdHJpbmd9IEdlb21ldHJ5LlxuICovXG5mdW5jdGlvbiByZWFkTGluZVN0cmluZ0dlb21ldHJ5KG9iamVjdCwgYXJjcykge1xuICBjb25zdCBjb29yZGluYXRlcyA9IGNvbmNhdGVuYXRlQXJjcyhvYmplY3RbJ2FyY3MnXSwgYXJjcyk7XG4gIHJldHVybiBuZXcgTGluZVN0cmluZyhjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbXVsdGktbGluZXN0cmluZyBmcm9tIGEgVG9wb0pTT04gZ2VvbWV0cnkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VG9wb0pTT05NdWx0aUxpbmVTdHJpbmd9IG9iamVjdCBUb3BvSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBhcmNzIEFycmF5IG9mIGFyY3MuXG4gKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IEdlb21ldHJ5LlxuICovXG5mdW5jdGlvbiByZWFkTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkob2JqZWN0LCBhcmNzKSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IG9iamVjdFsnYXJjcyddLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb29yZGluYXRlc1tpXSA9IGNvbmNhdGVuYXRlQXJjcyhvYmplY3RbJ2FyY3MnXVtpXSwgYXJjcyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhIFRvcG9KU09OIGdlb21ldHJ5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1RvcG9KU09OUG9seWdvbn0gb2JqZWN0IFRvcG9KU09OIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGFyY3MgQXJyYXkgb2YgYXJjcy5cbiAqIEByZXR1cm4ge1BvbHlnb259IEdlb21ldHJ5LlxuICovXG5mdW5jdGlvbiByZWFkUG9seWdvbkdlb21ldHJ5KG9iamVjdCwgYXJjcykge1xuICBjb25zdCBjb29yZGluYXRlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBvYmplY3RbJ2FyY3MnXS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29vcmRpbmF0ZXNbaV0gPSBjb25jYXRlbmF0ZUFyY3Mob2JqZWN0WydhcmNzJ11baV0sIGFyY3MpO1xuICB9XG4gIHJldHVybiBuZXcgUG9seWdvbihjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbXVsdGktcG9seWdvbiBmcm9tIGEgVG9wb0pTT04gZ2VvbWV0cnkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VG9wb0pTT05NdWx0aVBvbHlnb259IG9iamVjdCBUb3BvSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBhcmNzIEFycmF5IG9mIGFyY3MuXG4gKiBAcmV0dXJuIHtNdWx0aVBvbHlnb259IEdlb21ldHJ5LlxuICovXG5mdW5jdGlvbiByZWFkTXVsdGlQb2x5Z29uR2VvbWV0cnkob2JqZWN0LCBhcmNzKSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IG9iamVjdFsnYXJjcyddLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAvLyBmb3IgZWFjaCBwb2x5Z29uXG4gICAgY29uc3QgcG9seUFycmF5ID0gb2JqZWN0WydhcmNzJ11baV07XG4gICAgY29uc3QgcmluZ0Nvb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHBvbHlBcnJheS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAvLyBmb3IgZWFjaCByaW5nXG4gICAgICByaW5nQ29vcmRzW2pdID0gY29uY2F0ZW5hdGVBcmNzKHBvbHlBcnJheVtqXSwgYXJjcyk7XG4gICAgfVxuICAgIGNvb3JkaW5hdGVzW2ldID0gcmluZ0Nvb3JkcztcbiAgfVxuICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGZlYXR1cmVzIGZyb20gYSBUb3BvSlNPTiBHZW9tZXRyeUNvbGxlY3Rpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VG9wb0pTT05HZW9tZXRyeUNvbGxlY3Rpb259IGNvbGxlY3Rpb24gVG9wb0pTT04gR2VvbWV0cnlcbiAqICAgICBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBhcmNzIEFycmF5IG9mIGFyY3MuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNjYWxlIFNjYWxlIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdHJhbnNsYXRlIFRyYW5zbGF0aW9uIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0IHRoZSBgR2VvbWV0cnlDb2xsZWN0aW9uYCdzIHBhcmVudFxuICogICAgIG9iamVjdCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGBUb3BvbG9neWAncyBjaGlsZCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5PEZlYXR1cmU+fSBBcnJheSBvZiBmZWF0dXJlcy5cbiAqL1xuZnVuY3Rpb24gcmVhZEZlYXR1cmVzRnJvbUdlb21ldHJ5Q29sbGVjdGlvbihcbiAgY29sbGVjdGlvbixcbiAgYXJjcyxcbiAgc2NhbGUsXG4gIHRyYW5zbGF0ZSxcbiAgcHJvcGVydHksXG4gIG5hbWUsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBnZW9tZXRyaWVzID0gY29sbGVjdGlvblsnZ2VvbWV0cmllcyddO1xuICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBmZWF0dXJlc1tpXSA9IHJlYWRGZWF0dXJlRnJvbUdlb21ldHJ5KFxuICAgICAgZ2VvbWV0cmllc1tpXSxcbiAgICAgIGFyY3MsXG4gICAgICBzY2FsZSxcbiAgICAgIHRyYW5zbGF0ZSxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiBmZWF0dXJlcztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmZWF0dXJlIGZyb20gYSBUb3BvSlNPTiBnZW9tZXRyeSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtUb3BvSlNPTkdlb21ldHJ5fSBvYmplY3QgVG9wb0pTT04gZ2VvbWV0cnkgb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gYXJjcyBBcnJheSBvZiBhcmNzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzY2FsZSBTY2FsZSBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRyYW5zbGF0ZSBUcmFuc2xhdGlvbiBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCB0aGUgYEdlb21ldHJ5Q29sbGVjdGlvbmAncyBwYXJlbnRcbiAqICAgICBvYmplY3QgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBgVG9wb2xvZ3lgJ3MgY2hpbGQgb2JqZWN0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtGZWF0dXJlfSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZWFkRmVhdHVyZUZyb21HZW9tZXRyeShcbiAgb2JqZWN0LFxuICBhcmNzLFxuICBzY2FsZSxcbiAgdHJhbnNsYXRlLFxuICBwcm9wZXJ0eSxcbiAgbmFtZSxcbiAgb3B0aW9uc1xuKSB7XG4gIGxldCBnZW9tZXRyeSA9IG51bGw7XG4gIGNvbnN0IHR5cGUgPSBvYmplY3QudHlwZTtcbiAgaWYgKHR5cGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeVJlYWRlciA9IEdFT01FVFJZX1JFQURFUlNbdHlwZV07XG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgfHwgdHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5UmVhZGVyKG9iamVjdCwgc2NhbGUsIHRyYW5zbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlSZWFkZXIob2JqZWN0LCBhcmNzKTtcbiAgICB9XG4gICAgZ2VvbWV0cnkgPSB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCBmYWxzZSwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKHtnZW9tZXRyeTogZ2VvbWV0cnl9KTtcbiAgaWYgKG9iamVjdC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmVhdHVyZS5zZXRJZChvYmplY3QuaWQpO1xuICB9XG4gIGxldCBwcm9wZXJ0aWVzID0gb2JqZWN0LnByb3BlcnRpZXM7XG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgIH1cbiAgICBwcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IG5hbWU7XG4gIH1cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBmZWF0dXJlLnNldFByb3BlcnRpZXMocHJvcGVydGllcywgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGZlYXR1cmU7XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5lYXIgdHJhbnNmb3JtIHRvIGFycmF5IG9mIGFyY3MuICBUaGUgcHJvdmlkZWQgYXJyYXkgb2YgYXJjcyBpc1xuICogbW9kaWZpZWQgaW4gcGxhY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gYXJjcyBBcnJheSBvZiBhcmNzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzY2FsZSBTY2FsZSBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHRyYW5zbGF0ZSBUcmFuc2xhdGlvbiBmb3IgZWFjaCBkaW1lbnNpb24uXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUFyY3MoYXJjcywgc2NhbGUsIHRyYW5zbGF0ZSkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcmNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB0cmFuc2Zvcm1BcmMoYXJjc1tpXSwgc2NhbGUsIHRyYW5zbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBhIGxpbmVhciB0cmFuc2Zvcm0gdG8gYW4gYXJjLiAgVGhlIHByb3ZpZGVkIGFyYyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGFyYyBBcmMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNjYWxlIFNjYWxlIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdHJhbnNsYXRlIFRyYW5zbGF0aW9uIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQXJjKGFyYywgc2NhbGUsIHRyYW5zbGF0ZSkge1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJjLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSBhcmNbaV07XG4gICAgeCArPSB2ZXJ0ZXhbMF07XG4gICAgeSArPSB2ZXJ0ZXhbMV07XG4gICAgdmVydGV4WzBdID0geDtcbiAgICB2ZXJ0ZXhbMV0gPSB5O1xuICAgIHRyYW5zZm9ybVZlcnRleCh2ZXJ0ZXgsIHNjYWxlLCB0cmFuc2xhdGUpO1xuICB9XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5lYXIgdHJhbnNmb3JtIHRvIGEgdmVydGV4LiAgVGhlIHByb3ZpZGVkIHZlcnRleCBpcyBtb2RpZmllZCBpblxuICogcGxhY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHZlcnRleCBWZXJ0ZXguXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNjYWxlIFNjYWxlIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdHJhbnNsYXRlIFRyYW5zbGF0aW9uIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVmVydGV4KHZlcnRleCwgc2NhbGUsIHRyYW5zbGF0ZSkge1xuICB2ZXJ0ZXhbMF0gPSB2ZXJ0ZXhbMF0gKiBzY2FsZVswXSArIHRyYW5zbGF0ZVswXTtcbiAgdmVydGV4WzFdID0gdmVydGV4WzFdICogc2NhbGVbMV0gKyB0cmFuc2xhdGVbMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvcG9KU09OO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9XRlNcbiAqL1xuaW1wb3J0IEdNTDIgZnJvbSAnLi9HTUwyLmpzJztcbmltcG9ydCBHTUwzIGZyb20gJy4vR01MMy5qcyc7XG5pbXBvcnQgR01MMzIgZnJvbSAnLi9HTUwzMi5qcyc7XG5pbXBvcnQgR01MQmFzZSwge0dNTE5TfSBmcm9tICcuL0dNTEJhc2UuanMnO1xuaW1wb3J0IFhNTEZlYXR1cmUgZnJvbSAnLi9YTUxGZWF0dXJlLmpzJztcbmltcG9ydCB7XG4gIFhNTF9TQ0hFTUFfSU5TVEFOQ0VfVVJJLFxuICBjcmVhdGVFbGVtZW50TlMsXG4gIGlzRG9jdW1lbnQsXG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZUNoaWxkQXBwZW5kZXIsXG4gIG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcixcbiAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5LFxuICBwYXJzZSxcbiAgcGFyc2VOb2RlLFxuICBwdXNoUGFyc2VBbmRQb3AsXG4gIHB1c2hTZXJpYWxpemVBbmRQb3AsXG59IGZyb20gJy4uL3htbC5qcyc7XG5pbXBvcnQge2FuZCBhcyBhbmRGaWx0ZXJGbiwgYmJveCBhcyBiYm94RmlsdGVyRm59IGZyb20gJy4vZmlsdGVyLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtcbiAgcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyxcbiAgcmVhZFBvc2l0aXZlSW50ZWdlcixcbiAgd3JpdGVTdHJpbmdUZXh0Tm9kZSxcbn0gZnJvbSAnLi94c2QuanMnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuY29uc3QgRkVBVFVSRV9DT0xMRUNUSU9OX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbCc6IHtcbiAgICAnYm91bmRlZEJ5JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKFxuICAgICAgR01MQmFzZS5wcm90b3R5cGUucmVhZEV4dGVudEVsZW1lbnQsXG4gICAgICAnYm91bmRzJ1xuICAgICksXG4gIH0sXG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcy8yLjAnOiB7XG4gICAgJ21lbWJlcic6IG1ha2VBcnJheVB1c2hlcihHTUxCYXNlLnByb3RvdHlwZS5yZWFkRmVhdHVyZXNJbnRlcm5hbCksXG4gIH0sXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuY29uc3QgVFJBTlNBQ1RJT05fU1VNTUFSWV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnMnOiB7XG4gICAgJ3RvdGFsSW5zZXJ0ZWQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gICAgJ3RvdGFsVXBkYXRlZCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgICAndG90YWxEZWxldGVkJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICB9LFxuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnMvMi4wJzoge1xuICAgICd0b3RhbEluc2VydGVkJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAgICd0b3RhbFVwZGF0ZWQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gICAgJ3RvdGFsRGVsZXRlZCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG5jb25zdCBUUkFOU0FDVElPTl9SRVNQT05TRV9QQVJTRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnMnOiB7XG4gICAgJ1RyYW5zYWN0aW9uU3VtbWFyeSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihcbiAgICAgIHJlYWRUcmFuc2FjdGlvblN1bW1hcnksXG4gICAgICAndHJhbnNhY3Rpb25TdW1tYXJ5J1xuICAgICksXG4gICAgJ0luc2VydFJlc3VsdHMnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEluc2VydFJlc3VsdHMsICdpbnNlcnRJZHMnKSxcbiAgfSxcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzLzIuMCc6IHtcbiAgICAnVHJhbnNhY3Rpb25TdW1tYXJ5JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKFxuICAgICAgcmVhZFRyYW5zYWN0aW9uU3VtbWFyeSxcbiAgICAgICd0cmFuc2FjdGlvblN1bW1hcnknXG4gICAgKSxcbiAgICAnSW5zZXJ0UmVzdWx0cyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkSW5zZXJ0UmVzdWx0cywgJ2luc2VydElkcycpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuY29uc3QgUVVFUllfU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyc6IHtcbiAgICAnUHJvcGVydHlOYW1lJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTdHJpbmdUZXh0Tm9kZSksXG4gIH0sXG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcy8yLjAnOiB7XG4gICAgJ1Byb3BlcnR5TmFtZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3RyaW5nVGV4dE5vZGUpLFxuICB9LFxufTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlNlcmlhbGl6ZXI+Pn1cbiAqL1xuY29uc3QgVFJBTlNBQ1RJT05fU0VSSUFMSVpFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyc6IHtcbiAgICAnSW5zZXJ0JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVGZWF0dXJlKSxcbiAgICAnVXBkYXRlJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVVcGRhdGUpLFxuICAgICdEZWxldGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURlbGV0ZSksXG4gICAgJ1Byb3BlcnR5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVQcm9wZXJ0eSksXG4gICAgJ05hdGl2ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTmF0aXZlKSxcbiAgfSxcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzLzIuMCc6IHtcbiAgICAnSW5zZXJ0JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVGZWF0dXJlKSxcbiAgICAnVXBkYXRlJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVVcGRhdGUpLFxuICAgICdEZWxldGUnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURlbGV0ZSksXG4gICAgJ1Byb3BlcnR5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVQcm9wZXJ0eSksXG4gICAgJ05hdGl2ZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTmF0aXZlKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fHN0cmluZ30gW2ZlYXR1cmVOU10gVGhlIG5hbWVzcGFjZSBVUkkgdXNlZCBmb3IgZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz58c3RyaW5nfSBbZmVhdHVyZVR5cGVdIFRoZSBmZWF0dXJlIHR5cGUgdG8gcGFyc2UuIE9ubHkgdXNlZCBmb3IgcmVhZCBvcGVyYXRpb25zLlxuICogQHByb3BlcnR5IHtHTUxCYXNlfSBbZ21sRm9ybWF0XSBUaGUgR01MIGZvcm1hdCB0byB1c2UgdG8gcGFyc2UgdGhlIHJlc3BvbnNlLlxuICogRGVmYXVsdCBpcyBgb2wvZm9ybWF0L0dNTDJgIGZvciBXRlMgMS4wLjAsIGBvbC9mb3JtYXQvR01MM2AgZm9yIFdGUyAxLjEuMCBhbmQgYG9sL2Zvcm1hdC9HTUwzMmAgZm9yIFdGUyAyLjAuMC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2NoZW1hTG9jYXRpb25dIE9wdGlvbmFsIHNjaGVtYUxvY2F0aW9uIHRvIHVzZSBmb3Igc2VyaWFsaXphdGlvbiwgdGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2ZXJzaW9uPScxLjEuMCddIFdGUyB2ZXJzaW9uIHRvIHVzZS4gQ2FuIGJlIGVpdGhlciBgMS4wLjBgLCBgMS4xLjBgIG9yIGAyLjAuMGAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXcml0ZUdldEZlYXR1cmVPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmVhdHVyZU5TIFRoZSBuYW1lc3BhY2UgVVJJIHVzZWQgZm9yIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZlYXR1cmVQcmVmaXggVGhlIHByZWZpeCBmb3IgdGhlIGZlYXR1cmUgbmFtZXNwYWNlLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmd8RmVhdHVyZVR5cGU+fSBmZWF0dXJlVHlwZXMgVGhlIGZlYXR1cmUgdHlwZSBuYW1lcyBvciBGZWF0dXJlVHlwZSBvYmplY3RzIHRvXG4gKiBkZWZpbmUgYSB1bmlxdWUgYmJveCBmaWx0ZXIgcGVyIGZlYXR1cmUgdHlwZSBuYW1lIChpbiB0aGlzIGNhc2UsIG9wdGlvbnMgYGJib3hgIGFuZCBgZ2VvbWV0cnlOYW1lYCBhcmVcbiAqIGlnbm9yZWQuKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmUgc2V0IG9uXG4gKiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2hhbmRsZV0gSGFuZGxlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvdXRwdXRGb3JtYXRdIE91dHB1dCBmb3JtYXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heEZlYXR1cmVzXSBNYXhpbXVtIG51bWJlciBvZiBmZWF0dXJlcyB0byBmZXRjaC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2VvbWV0cnlOYW1lXSBHZW9tZXRyeSBuYW1lIHRvIHVzZSBpbiBhIEJCT1ggZmlsdGVyLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbcHJvcGVydHlOYW1lc10gT3B0aW9uYWwgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byBzZXJpYWxpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3ZpZXdQYXJhbXNdIHZpZXdQYXJhbXMgR2VvU2VydmVyIHZlbmRvciBwYXJhbWV0ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIHVzZSBmb3IgV0ZTIHBhZ2luZy4gVGhpcyBpcyBhXG4gKiBXRlMgMi4wIGZlYXR1cmUgYmFja3BvcnRlZCB0byBXRlMgMS4xLjAgYnkgc29tZSBXZWIgRmVhdHVyZSBTZXJ2aWNlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY291bnRdIE51bWJlciBvZiBmZWF0dXJlcyB0byByZXRyaWV2ZSB3aGVuIHBhZ2luZy4gVGhpcyBpcyBhXG4gKiBXRlMgMi4wIGZlYXR1cmUgYmFja3BvcnRlZCB0byBXRlMgMS4xLjAgYnkgc29tZSBXZWIgRmVhdHVyZSBTZXJ2aWNlcy4gUGxlYXNlIG5vdGUgdGhhdCBzb21lXG4gKiBXZWIgRmVhdHVyZSBTZXJ2aWNlcyBoYXZlIHJlcHVycG9zZWQgYG1heGZlYXR1cmVzYCBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbYmJveF0gRXh0ZW50IHRvIHVzZSBmb3IgdGhlIEJCT1ggZmlsdGVyLiBUaGUgYGdlb21ldHJ5TmFtZWBcbiAqIG9wdGlvbiBtdXN0IGJlIHNldC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9maWx0ZXIvRmlsdGVyLmpzXCIpLmRlZmF1bHR9IFtmaWx0ZXJdIEZpbHRlciBjb25kaXRpb24uIFNlZVxuICoge0BsaW5rIG1vZHVsZTpvbC9mb3JtYXQvZmlsdGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVzdWx0VHlwZV0gSW5kaWNhdGVzIHdoYXQgcmVzcG9uc2Ugc2hvdWxkIGJlIHJldHVybmVkLFxuICogZS5nLiBgaGl0c2Agb25seSBpbmNsdWRlcyB0aGUgYG51bWJlck9mRmVhdHVyZXNgIGF0dHJpYnV0ZSBpbiB0aGUgcmVzcG9uc2UgYW5kIG5vIGZlYXR1cmVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmVhdHVyZVR5cGVcbiAqIEBwcm9wZXJ0eSB7IXN0cmluZ30gbmFtZSBUaGUgZmVhdHVyZSB0eXBlIG5hbWUuXG4gKiBAcHJvcGVydHkgeyFpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBiYm94IEV4dGVudCB0byB1c2UgZm9yIHRoZSBCQk9YIGZpbHRlci5cbiAqIEBwcm9wZXJ0eSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlIGluIHRoZSBCQk9YIGZpbHRlci5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdyaXRlVHJhbnNhY3Rpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmVhdHVyZU5TIFRoZSBuYW1lc3BhY2UgVVJJIHVzZWQgZm9yIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZlYXR1cmVQcmVmaXggVGhlIHByZWZpeCBmb3IgdGhlIGZlYXR1cmUgbmFtZXNwYWNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZlYXR1cmVUeXBlIFRoZSBmZWF0dXJlIHR5cGUgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmUgc2V0IG9uXG4gKiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2hhbmRsZV0gSGFuZGxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaGFzWl0gTXVzdCBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgZm9yXG4gKiBhIDNEIGxheWVyLiBUaGlzIHdpbGwgYWxsb3cgdGhlIFogY29vcmRpbmF0ZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PE9iamVjdD59IG5hdGl2ZUVsZW1lbnRzIE5hdGl2ZSBlbGVtZW50cy4gQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vR01MQmFzZS5qc1wiKS5PcHRpb25zfSBbZ21sT3B0aW9uc10gR01MIG9wdGlvbnMgZm9yIHRoZSBXRlMgdHJhbnNhY3Rpb24gd3JpdGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2ZXJzaW9uPScxLjEuMCddIFdGUyB2ZXJzaW9uIHRvIHVzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLiBDYW4gYmUgZWl0aGVyIGAxLjAuMGAsIGAxLjEuMGAgb3IgYDIuMC4wYC5cbiAqL1xuXG4vKipcbiAqIE51bWJlciBvZiBmZWF0dXJlczsgYm91bmRzL2V4dGVudC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZlYXR1cmVDb2xsZWN0aW9uTWV0YWRhdGFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1iZXJPZkZlYXR1cmVzIE51bWJlck9mRmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGJvdW5kcyBCb3VuZHMuXG4gKi9cblxuLyoqXG4gKiBUb3RhbCBkZWxldGVkOyB0b3RhbCBpbnNlcnRlZDsgdG90YWwgdXBkYXRlZDsgYXJyYXkgb2YgaW5zZXJ0IGlkcy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbERlbGV0ZWQgVG90YWxEZWxldGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvdGFsSW5zZXJ0ZWQgVG90YWxJbnNlcnRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbFVwZGF0ZWQgVG90YWxVcGRhdGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBpbnNlcnRJZHMgSW5zZXJ0SWRzLlxuICovXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgRkVBVFVSRV9QUkVGSVggPSAnZmVhdHVyZSc7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgWE1MTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBPR0NOUyA9IHtcbiAgJzIuMC4wJzogJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djLzEuMScsXG4gICcxLjEuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nYycsXG4gICcxLjAuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nYycsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBXRlNOUyA9IHtcbiAgJzIuMC4wJzogJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzLzIuMCcsXG4gICcxLjEuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcycsXG4gICcxLjAuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcycsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBGRVNOUyA9IHtcbiAgJzIuMC4wJzogJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZmVzLzIuMCcsXG4gICcxLjEuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2ZlcycsXG4gICcxLjAuMCc6ICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2ZlcycsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5jb25zdCBTQ0hFTUFfTE9DQVRJT05TID0ge1xuICAnMi4wLjAnOlxuICAgICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcy8yLjAgaHR0cDovL3NjaGVtYXMub3Blbmdpcy5uZXQvd2ZzLzIuMC93ZnMueHNkJyxcbiAgJzEuMS4wJzpcbiAgICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnMgaHR0cDovL3NjaGVtYXMub3Blbmdpcy5uZXQvd2ZzLzEuMS4wL3dmcy54c2QnLFxuICAnMS4wLjAnOlxuICAgICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyBodHRwOi8vc2NoZW1hcy5vcGVuZ2lzLm5ldC93ZnMvMS4wLjAvd2ZzLnhzZCcsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5jb25zdCBHTUxfRk9STUFUUyA9IHtcbiAgJzIuMC4wJzogR01MMzIsXG4gICcxLjEuMCc6IEdNTDMsXG4gICcxLjAuMCc6IEdNTDIsXG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgREVGQVVMVF9WRVJTSU9OID0gJzEuMS4wJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGZWF0dXJlIGZvcm1hdCBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBkYXRhIGluIHRoZSBXRlMgZm9ybWF0LlxuICogQnkgZGVmYXVsdCwgc3VwcG9ydHMgV0ZTIHZlcnNpb24gMS4xLjAuIFlvdSBjYW4gcGFzcyBhIEdNTCBmb3JtYXRcbiAqIGFzIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdC5cbiAqIEFsc28gc2VlIHtAbGluayBtb2R1bGU6b2wvZm9ybWF0L0dNTEJhc2V+R01MQmFzZX0gd2hpY2ggaXMgdXNlZCBieSB0aGlzIGZvcm1hdC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFdGUyBleHRlbmRzIFhNTEZlYXR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbl8gPSBvcHRpb25zLnZlcnNpb24gPyBvcHRpb25zLnZlcnNpb24gOiBERUZBVUxUX1ZFUlNJT047XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fHN0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlVHlwZV8gPSBvcHRpb25zLmZlYXR1cmVUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZU5TXyA9IG9wdGlvbnMuZmVhdHVyZU5TO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7R01MQmFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmdtbEZvcm1hdF8gPSBvcHRpb25zLmdtbEZvcm1hdFxuICAgICAgPyBvcHRpb25zLmdtbEZvcm1hdFxuICAgICAgOiBuZXcgR01MX0ZPUk1BVFNbdGhpcy52ZXJzaW9uX10oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNjaGVtYUxvY2F0aW9uXyA9IG9wdGlvbnMuc2NoZW1hTG9jYXRpb25cbiAgICAgID8gb3B0aW9ucy5zY2hlbWFMb2NhdGlvblxuICAgICAgOiBTQ0hFTUFfTE9DQVRJT05TW3RoaXMudmVyc2lvbl9dO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz58c3RyaW5nfHVuZGVmaW5lZH0gZmVhdHVyZVR5cGVcbiAgICovXG4gIGdldEZlYXR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVUeXBlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz58c3RyaW5nfHVuZGVmaW5lZH0gZmVhdHVyZVR5cGUgRmVhdHVyZSB0eXBlKHMpIHRvIHBhcnNlLlxuICAgKi9cbiAgc2V0RmVhdHVyZVR5cGUoZmVhdHVyZVR5cGUpIHtcbiAgICB0aGlzLmZlYXR1cmVUeXBlXyA9IGZlYXR1cmVUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbm9kZSxcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dCwge1xuICAgICAgJ2ZlYXR1cmVUeXBlJzogdGhpcy5mZWF0dXJlVHlwZV8sXG4gICAgICAnZmVhdHVyZU5TJzogdGhpcy5mZWF0dXJlTlNfLFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCB0aGlzLmdldFJlYWRPcHRpb25zKG5vZGUsIG9wdGlvbnMgPyBvcHRpb25zIDoge30pKTtcbiAgICBjb25zdCBvYmplY3RTdGFjayA9IFtjb250ZXh0XTtcbiAgICBsZXQgZmVhdHVyZXNOUztcbiAgICBpZiAodGhpcy52ZXJzaW9uXyA9PT0gJzIuMC4wJykge1xuICAgICAgZmVhdHVyZXNOUyA9IEZFQVRVUkVfQ09MTEVDVElPTl9QQVJTRVJTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlc05TID0gdGhpcy5nbWxGb3JtYXRfLkZFQVRVUkVfQ09MTEVDVElPTl9QQVJTRVJTO1xuICAgIH1cbiAgICBsZXQgZmVhdHVyZXMgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBbXSxcbiAgICAgIGZlYXR1cmVzTlMsXG4gICAgICBub2RlLFxuICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICB0aGlzLmdtbEZvcm1hdF9cbiAgICApO1xuICAgIGlmICghZmVhdHVyZXMpIHtcbiAgICAgIGZlYXR1cmVzID0gW107XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRyYW5zYWN0aW9uIHJlc3BvbnNlIG9mIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvblJlc3BvbnNlfHVuZGVmaW5lZH0gVHJhbnNhY3Rpb24gcmVzcG9uc2UuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRUcmFuc2FjdGlvblJlc3BvbnNlKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVHJhbnNhY3Rpb25SZXNwb25zZUZyb21Eb2N1bWVudChkb2MpO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVHJhbnNhY3Rpb25SZXNwb25zZUZyb21Eb2N1bWVudChcbiAgICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlYWRUcmFuc2FjdGlvblJlc3BvbnNlRnJvbU5vZGUoXG4gICAgICAvKiogQHR5cGUge0VsZW1lbnR9ICovIChzb3VyY2UpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGZlYXR1cmUgY29sbGVjdGlvbiBtZXRhZGF0YSBvZiB0aGUgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb25NZXRhZGF0YXx1bmRlZmluZWR9XG4gICAqICAgICBGZWF0dXJlQ29sbGVjdGlvbiBtZXRhZGF0YS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmVDb2xsZWN0aW9uTWV0YWRhdGEoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZG9jID0gcGFyc2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlQ29sbGVjdGlvbk1ldGFkYXRhRnJvbURvY3VtZW50KGRvYyk7XG4gICAgfVxuICAgIGlmIChpc0RvY3VtZW50KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlQ29sbGVjdGlvbk1ldGFkYXRhRnJvbURvY3VtZW50KFxuICAgICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAoc291cmNlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZEZlYXR1cmVDb2xsZWN0aW9uTWV0YWRhdGFGcm9tTm9kZShcbiAgICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHNvdXJjZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb25NZXRhZGF0YXx1bmRlZmluZWR9XG4gICAqICAgICBGZWF0dXJlQ29sbGVjdGlvbiBtZXRhZGF0YS5cbiAgICovXG4gIHJlYWRGZWF0dXJlQ29sbGVjdGlvbk1ldGFkYXRhRnJvbURvY3VtZW50KGRvYykge1xuICAgIGZvciAobGV0IG4gPSAvKiogQHR5cGUge05vZGV9ICovIChkb2MuZmlyc3RDaGlsZCk7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmVhdHVyZUNvbGxlY3Rpb25NZXRhZGF0YUZyb21Ob2RlKFxuICAgICAgICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG4pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uTWV0YWRhdGF8dW5kZWZpbmVkfVxuICAgKiAgICAgRmVhdHVyZUNvbGxlY3Rpb24gbWV0YWRhdGEuXG4gICAqL1xuICByZWFkRmVhdHVyZUNvbGxlY3Rpb25NZXRhZGF0YUZyb21Ob2RlKG5vZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlYWROb25OZWdhdGl2ZUludGVnZXJTdHJpbmcoXG4gICAgICBub2RlLmdldEF0dHJpYnV0ZSgnbnVtYmVyT2ZGZWF0dXJlcycpXG4gICAgKTtcbiAgICByZXN1bHRbJ251bWJlck9mRmVhdHVyZXMnXSA9IHZhbHVlO1xuICAgIHJldHVybiBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICAvKiogQHR5cGUge0ZlYXR1cmVDb2xsZWN0aW9uTWV0YWRhdGF9ICovIChyZXN1bHQpLFxuICAgICAgRkVBVFVSRV9DT0xMRUNUSU9OX1BBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgW10sXG4gICAgICB0aGlzLmdtbEZvcm1hdF9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7VHJhbnNhY3Rpb25SZXNwb25zZXx1bmRlZmluZWR9IFRyYW5zYWN0aW9uIHJlc3BvbnNlLlxuICAgKi9cbiAgcmVhZFRyYW5zYWN0aW9uUmVzcG9uc2VGcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgZm9yIChsZXQgbiA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGRvYy5maXJzdENoaWxkKTsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChuLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUcmFuc2FjdGlvblJlc3BvbnNlRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvblJlc3BvbnNlfHVuZGVmaW5lZH0gVHJhbnNhY3Rpb24gcmVzcG9uc2UuXG4gICAqL1xuICByZWFkVHJhbnNhY3Rpb25SZXNwb25zZUZyb21Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgLyoqIEB0eXBlIHtUcmFuc2FjdGlvblJlc3BvbnNlfSAqLyAoe30pLFxuICAgICAgVFJBTlNBQ1RJT05fUkVTUE9OU0VfUEFSU0VSUyxcbiAgICAgIG5vZGUsXG4gICAgICBbXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGZvcm1hdCBhcyBXRlMgYEdldEZlYXR1cmVgIGFuZCByZXR1cm4gdGhlIE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7V3JpdGVHZXRGZWF0dXJlT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBSZXN1bHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlR2V0RmVhdHVyZShvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVsZW1lbnROUyhXRlNOU1t0aGlzLnZlcnNpb25fXSwgJ0dldEZlYXR1cmUnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnc2VydmljZScsICdXRlMnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsIHRoaXMudmVyc2lvbl8pO1xuICAgIGlmIChvcHRpb25zLmhhbmRsZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2hhbmRsZScsIG9wdGlvbnMuaGFuZGxlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0cHV0Rm9ybWF0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnb3V0cHV0Rm9ybWF0Jywgb3B0aW9ucy5vdXRwdXRGb3JtYXQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYXhGZWF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnbWF4RmVhdHVyZXMnLCBTdHJpbmcob3B0aW9ucy5tYXhGZWF0dXJlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXN1bHRUeXBlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgncmVzdWx0VHlwZScsIG9wdGlvbnMucmVzdWx0VHlwZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YXJ0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0SW5kZXgnLCBTdHJpbmcob3B0aW9ucy5zdGFydEluZGV4KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjb3VudCcsIFN0cmluZyhvcHRpb25zLmNvdW50KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZpZXdQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZpZXdQYXJhbXMnLCBvcHRpb25zLnZpZXdQYXJhbXMpO1xuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgWE1MX1NDSEVNQV9JTlNUQU5DRV9VUkksXG4gICAgICAneHNpOnNjaGVtYUxvY2F0aW9uJyxcbiAgICAgIHRoaXMuc2NoZW1hTG9jYXRpb25fXG4gICAgKTtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBub2RlLFxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCB7XG4gICAgICAndmVyc2lvbic6IHRoaXMudmVyc2lvbl8sXG4gICAgICAnc3JzTmFtZSc6IG9wdGlvbnMuc3JzTmFtZSxcbiAgICAgICdmZWF0dXJlTlMnOiBvcHRpb25zLmZlYXR1cmVOUyA/IG9wdGlvbnMuZmVhdHVyZU5TIDogdGhpcy5mZWF0dXJlTlNfLFxuICAgICAgJ2ZlYXR1cmVQcmVmaXgnOiBvcHRpb25zLmZlYXR1cmVQcmVmaXgsXG4gICAgICAncHJvcGVydHlOYW1lcyc6IG9wdGlvbnMucHJvcGVydHlOYW1lcyA/IG9wdGlvbnMucHJvcGVydHlOYW1lcyA6IFtdLFxuICAgIH0pO1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KG9wdGlvbnMuZmVhdHVyZVR5cGVzKSwgMTEpOyAvLyBgb3B0aW9ucy5mZWF0dXJlVHlwZXNgIG11c3QgYmUgYW4gQXJyYXlcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmVhdHVyZVR5cGVzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgICAgICBhc3NlcnQob3B0aW9ucy5nZW9tZXRyeU5hbWUsIDEyKTsgLy8gYG9wdGlvbnMuZ2VvbWV0cnlOYW1lYCBtdXN0IGFsc28gYmUgcHJvdmlkZWQgd2hlbiBgb3B0aW9ucy5iYm94YCBpcyBzZXRcbiAgICAgICAgZmlsdGVyID0gdGhpcy5jb21iaW5lQmJveEFuZEZpbHRlcihcbiAgICAgICAgICBvcHRpb25zLmdlb21ldHJ5TmFtZSxcbiAgICAgICAgICBvcHRpb25zLmJib3gsXG4gICAgICAgICAgb3B0aW9ucy5zcnNOYW1lLFxuICAgICAgICAgIGZpbHRlclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgICdnZW9tZXRyeU5hbWUnOiBvcHRpb25zLmdlb21ldHJ5TmFtZSxcbiAgICAgICAgJ2ZpbHRlcic6IGZpbHRlcixcbiAgICAgIH0pO1xuICAgICAgd3JpdGVHZXRGZWF0dXJlKFxuICAgICAgICBub2RlLFxuICAgICAgICAvKiogQHR5cGUgeyFBcnJheTxzdHJpbmc+fSAqLyAob3B0aW9ucy5mZWF0dXJlVHlwZXMpLFxuICAgICAgICBbY29udGV4dF1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdyaXRlIG9uZSBxdWVyeSBub2RlIHBlciBlbGVtZW50IGluIGZlYXR1cmVzVHlwZS5cbiAgICAgIG9wdGlvbnMuZmVhdHVyZVR5cGVzLmZvckVhY2goKC8qKiBAdHlwZSB7RmVhdHVyZVR5cGV9ICovIGZlYXR1cmVUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlRmlsdGVyID0gdGhpcy5jb21iaW5lQmJveEFuZEZpbHRlcihcbiAgICAgICAgICBmZWF0dXJlVHlwZS5nZW9tZXRyeU5hbWUsXG4gICAgICAgICAgZmVhdHVyZVR5cGUuYmJveCxcbiAgICAgICAgICBvcHRpb25zLnNyc05hbWUsXG4gICAgICAgICAgb3B0aW9ucy5maWx0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgICAgJ2dlb21ldHJ5TmFtZSc6IGZlYXR1cmVUeXBlLmdlb21ldHJ5TmFtZSxcbiAgICAgICAgICAnZmlsdGVyJzogY29tcGxldGVGaWx0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB3cml0ZUdldEZlYXR1cmUobm9kZSwgW2ZlYXR1cmVUeXBlLm5hbWVdLCBbY29udGV4dF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJib3ggZmlsdGVyIGFuZCBjb21iaW5lIGl0IHdpdGggYW5vdGhlciBvcHRpb25hbCBmaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvRmlsdGVyLmpzXCIpLmRlZmF1bHR9IFtmaWx0ZXJdIEZpbHRlciBjb25kaXRpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZmlsdGVyL0ZpbHRlci5qc1wiKS5kZWZhdWx0fSBUaGUgZmlsdGVyLlxuICAgKi9cbiAgY29tYmluZUJib3hBbmRGaWx0ZXIoZ2VvbWV0cnlOYW1lLCBleHRlbnQsIHNyc05hbWUsIGZpbHRlcikge1xuICAgIGNvbnN0IGJib3hGaWx0ZXIgPSBiYm94RmlsdGVyRm4oZ2VvbWV0cnlOYW1lLCBleHRlbnQsIHNyc05hbWUpO1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIC8vIGlmIGJib3ggYW5kIGZpbHRlciBhcmUgYm90aCBzZXQsIGNvbWJpbmUgdGhlIHR3byBpbnRvIGEgc2luZ2xlIGZpbHRlclxuICAgICAgcmV0dXJuIGFuZEZpbHRlckZuKGZpbHRlciwgYmJveEZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiBiYm94RmlsdGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBmb3JtYXQgYXMgV0ZTIGBUcmFuc2FjdGlvbmAgYW5kIHJldHVybiB0aGUgTm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBpbnNlcnRzIFRoZSBmZWF0dXJlcyB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gdXBkYXRlcyBUaGUgZmVhdHVyZXMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGRlbGV0ZXMgVGhlIGZlYXR1cmVzIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIHtXcml0ZVRyYW5zYWN0aW9uT3B0aW9uc30gb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBSZXN1bHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlVHJhbnNhY3Rpb24oaW5zZXJ0cywgdXBkYXRlcywgZGVsZXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG9iamVjdFN0YWNrID0gW107XG4gICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/IG9wdGlvbnMudmVyc2lvbiA6IHRoaXMudmVyc2lvbl87XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVsZW1lbnROUyhXRlNOU1t2ZXJzaW9uXSwgJ1RyYW5zYWN0aW9uJyk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnc2VydmljZScsICdXRlMnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsIHZlcnNpb24pO1xuICAgIGxldCBiYXNlT2JqO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGJhc2VPYmogPSBvcHRpb25zLmdtbE9wdGlvbnMgPyBvcHRpb25zLmdtbE9wdGlvbnMgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLmhhbmRsZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaGFuZGxlJywgb3B0aW9ucy5oYW5kbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgWE1MX1NDSEVNQV9JTlNUQU5DRV9VUkksXG4gICAgICAneHNpOnNjaGVtYUxvY2F0aW9uJyxcbiAgICAgIFNDSEVNQV9MT0NBVElPTlNbdmVyc2lvbl1cbiAgICApO1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZVRyYW5zYWN0aW9uUmVxdWVzdChub2RlLCBiYXNlT2JqLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICBpZiAoaW5zZXJ0cykge1xuICAgICAgc2VyaWFsaXplVHJhbnNhY3Rpb25SZXF1ZXN0KCdJbnNlcnQnLCBpbnNlcnRzLCBvYmplY3RTdGFjaywgcmVxdWVzdCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICBzZXJpYWxpemVUcmFuc2FjdGlvblJlcXVlc3QoJ1VwZGF0ZScsIHVwZGF0ZXMsIG9iamVjdFN0YWNrLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZXMpIHtcbiAgICAgIHNlcmlhbGl6ZVRyYW5zYWN0aW9uUmVxdWVzdCgnRGVsZXRlJywgZGVsZXRlcywgb2JqZWN0U3RhY2ssIHJlcXVlc3QpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVFbGVtZW50cykge1xuICAgICAgc2VyaWFsaXplVHJhbnNhY3Rpb25SZXF1ZXN0KFxuICAgICAgICAnTmF0aXZlJyxcbiAgICAgICAgb3B0aW9ucy5uYXRpdmVFbGVtZW50cyxcbiAgICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICAgIHJlcXVlc3RcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkUHJvamVjdGlvbkZyb21Eb2N1bWVudChkb2MpIHtcbiAgICBmb3IgKGxldCBuID0gZG9jLmZpcnN0Q2hpbGQ7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkUHJvamVjdGlvbkZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgcmVhZFByb2plY3Rpb25Gcm9tTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQgJiYgbm9kZS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgbm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICBmb3IgKGxldCBuID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgbjsgbiA9IG4ubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKG4uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgbi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RhY2sgPSBbe31dO1xuICAgICAgICAgIHRoaXMuZ21sRm9ybWF0Xy5yZWFkR2VvbWV0cnlFbGVtZW50KG4sIG9iamVjdFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZ2V0UHJvamVjdGlvbihvYmplY3RTdGFjay5wb3AoKS5zcnNOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0geyp9IGJhc2VPYmogQmFzZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiBWZXJzaW9uLlxuICogQHBhcmFtIHtXcml0ZVRyYW5zYWN0aW9uT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXF1ZXN0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25SZXF1ZXN0KG5vZGUsIGJhc2VPYmosIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgZmVhdHVyZVByZWZpeCA9IG9wdGlvbnMuZmVhdHVyZVByZWZpeFxuICAgID8gb3B0aW9ucy5mZWF0dXJlUHJlZml4XG4gICAgOiBGRUFUVVJFX1BSRUZJWDtcbiAgbGV0IGdtbFZlcnNpb247XG4gIGlmICh2ZXJzaW9uID09PSAnMS4wLjAnKSB7XG4gICAgZ21sVmVyc2lvbiA9IDI7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gJzEuMS4wJykge1xuICAgIGdtbFZlcnNpb24gPSAzO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09ICcyLjAuMCcpIHtcbiAgICBnbWxWZXJzaW9uID0gMy4yO1xuICB9XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24oXG4gICAge25vZGV9LFxuICAgIHtcbiAgICAgIHZlcnNpb24sXG4gICAgICAnZmVhdHVyZU5TJzogb3B0aW9ucy5mZWF0dXJlTlMsXG4gICAgICAnZmVhdHVyZVR5cGUnOiBvcHRpb25zLmZlYXR1cmVUeXBlLFxuICAgICAgJ2ZlYXR1cmVQcmVmaXgnOiBmZWF0dXJlUHJlZml4LFxuICAgICAgJ2dtbFZlcnNpb24nOiBnbWxWZXJzaW9uLFxuICAgICAgJ2hhc1onOiBvcHRpb25zLmhhc1osXG4gICAgICAnc3JzTmFtZSc6IG9wdGlvbnMuc3JzTmFtZSxcbiAgICB9LFxuICAgIGJhc2VPYmpcbiAgKTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBSZXF1ZXN0IHR5cGUuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHBhcmFtIHtFbGVtZW50fSByZXF1ZXN0IFRyYW5zYWN0aW9uIFJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uUmVxdWVzdCh0eXBlLCBmZWF0dXJlcywgb2JqZWN0U3RhY2ssIHJlcXVlc3QpIHtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICByZXF1ZXN0LFxuICAgIFRSQU5TQUNUSU9OX1NFUklBTElaRVJTLFxuICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeSh0eXBlKSxcbiAgICBmZWF0dXJlcyxcbiAgICBvYmplY3RTdGFja1xuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVHJhbnNhY3Rpb24gU3VtbWFyeS5cbiAqL1xuZnVuY3Rpb24gcmVhZFRyYW5zYWN0aW9uU3VtbWFyeShub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBUUkFOU0FDVElPTl9TVU1NQVJZX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbmNvbnN0IE9HQ19GSURfUEFSU0VSUyA9IHtcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb2djJzoge1xuICAgICdGZWF0dXJlSWQnOiBtYWtlQXJyYXlQdXNoZXIoZnVuY3Rpb24gKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoJ2ZpZCcpO1xuICAgIH0pLFxuICB9LFxuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2MvMS4xJzoge1xuICAgICdGZWF0dXJlSWQnOiBtYWtlQXJyYXlQdXNoZXIoZnVuY3Rpb24gKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoJ2ZpZCcpO1xuICAgIH0pLFxuICB9LFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqL1xuZnVuY3Rpb24gZmlkUGFyc2VyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHBhcnNlTm9kZShPR0NfRklEX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbmNvbnN0IElOU0VSVF9SRVNVTFRTX1BBUlNFUlMgPSB7XG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcyc6IHtcbiAgICAnRmVhdHVyZSc6IGZpZFBhcnNlcixcbiAgfSxcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzLzIuMCc6IHtcbiAgICAnRmVhdHVyZSc6IGZpZFBhcnNlcixcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fHVuZGVmaW5lZH0gSW5zZXJ0IHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIHJlYWRJbnNlcnRSZXN1bHRzKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3AoW10sIElOU0VSVF9SRVNVTFRTX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUZlYXR1cmUobm9kZSwgZmVhdHVyZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBjb25zdCBmZWF0dXJlVHlwZSA9IGNvbnRleHRbJ2ZlYXR1cmVUeXBlJ107XG4gIGNvbnN0IGZlYXR1cmVOUyA9IGNvbnRleHRbJ2ZlYXR1cmVOUyddO1xuICBjb25zdCBnbWxWZXJzaW9uID0gY29udGV4dFsnZ21sVmVyc2lvbiddO1xuICBjb25zdCBjaGlsZCA9IGNyZWF0ZUVsZW1lbnROUyhmZWF0dXJlTlMsIGZlYXR1cmVUeXBlKTtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIGlmIChnbWxWZXJzaW9uID09PSAyKSB7XG4gICAgR01MMi5wcm90b3R5cGUud3JpdGVGZWF0dXJlRWxlbWVudChjaGlsZCwgZmVhdHVyZSwgb2JqZWN0U3RhY2spO1xuICB9IGVsc2UgaWYgKGdtbFZlcnNpb24gPT09IDMpIHtcbiAgICBHTUwzLnByb3RvdHlwZS53cml0ZUZlYXR1cmVFbGVtZW50KGNoaWxkLCBmZWF0dXJlLCBvYmplY3RTdGFjayk7XG4gIH0gZWxzZSB7XG4gICAgR01MMzIucHJvdG90eXBlLndyaXRlRmVhdHVyZUVsZW1lbnQoY2hpbGQsIGZlYXR1cmUsIG9iamVjdFN0YWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmaWQgRmVhdHVyZSBpZGVudGlmaWVyLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVPZ2NGaWRGaWx0ZXIobm9kZSwgZmlkLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBjb250ZXh0ID0gb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gIGNvbnN0IHZlcnNpb24gPSBjb250ZXh0Wyd2ZXJzaW9uJ107XG4gIGNvbnN0IG5zID0gT0dDTlNbdmVyc2lvbl07XG4gIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUVsZW1lbnROUyhucywgJ0ZpbHRlcicpO1xuICBjb25zdCBjaGlsZCA9IGNyZWF0ZUVsZW1lbnROUyhucywgJ0ZlYXR1cmVJZCcpO1xuICBmaWx0ZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2ZpZCcsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZmlkKSk7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZlYXR1cmVQcmVmaXggVGhlIHByZWZpeCBvZiB0aGUgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlVHlwZSBUaGUgdHlwZSBvZiB0aGUgZmVhdHVyZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSB0eXBlTmFtZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWUoZmVhdHVyZVByZWZpeCwgZmVhdHVyZVR5cGUpIHtcbiAgZmVhdHVyZVByZWZpeCA9IGZlYXR1cmVQcmVmaXggPyBmZWF0dXJlUHJlZml4IDogRkVBVFVSRV9QUkVGSVg7XG4gIGNvbnN0IHByZWZpeCA9IGZlYXR1cmVQcmVmaXggKyAnOic7XG4gIC8vIFRoZSBmZWF0dXJlVHlwZSBhbHJlYWR5IGNvbnRhaW5zIHRoZSBwcmVmaXguXG4gIGlmIChmZWF0dXJlVHlwZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4gZmVhdHVyZVR5cGU7XG4gIH1cbiAgcmV0dXJuIHByZWZpeCArIGZlYXR1cmVUeXBlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRGVsZXRlKG5vZGUsIGZlYXR1cmUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXTtcbiAgYXNzZXJ0KGZlYXR1cmUuZ2V0SWQoKSAhPT0gdW5kZWZpbmVkLCAyNik7IC8vIEZlYXR1cmVzIG11c3QgaGF2ZSBhbiBpZCBzZXRcbiAgY29uc3QgZmVhdHVyZVR5cGUgPSBjb250ZXh0WydmZWF0dXJlVHlwZSddO1xuICBjb25zdCBmZWF0dXJlUHJlZml4ID0gY29udGV4dFsnZmVhdHVyZVByZWZpeCddO1xuICBjb25zdCBmZWF0dXJlTlMgPSBjb250ZXh0WydmZWF0dXJlTlMnXTtcbiAgY29uc3QgdHlwZU5hbWUgPSBnZXRUeXBlTmFtZShmZWF0dXJlUHJlZml4LCBmZWF0dXJlVHlwZSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKCd0eXBlTmFtZScsIHR5cGVOYW1lKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhYTUxOUywgJ3htbG5zOicgKyBmZWF0dXJlUHJlZml4LCBmZWF0dXJlTlMpO1xuICBjb25zdCBmaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdyaXRlT2djRmlkRmlsdGVyKG5vZGUsIGZpZCwgb2JqZWN0U3RhY2spO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVVcGRhdGUobm9kZSwgZmVhdHVyZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBhc3NlcnQoZmVhdHVyZS5nZXRJZCgpICE9PSB1bmRlZmluZWQsIDI3KTsgLy8gRmVhdHVyZXMgbXVzdCBoYXZlIGFuIGlkIHNldFxuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuICBjb25zdCBmZWF0dXJlVHlwZSA9IGNvbnRleHRbJ2ZlYXR1cmVUeXBlJ107XG4gIGNvbnN0IGZlYXR1cmVQcmVmaXggPSBjb250ZXh0WydmZWF0dXJlUHJlZml4J107XG4gIGNvbnN0IGZlYXR1cmVOUyA9IGNvbnRleHRbJ2ZlYXR1cmVOUyddO1xuICBjb25zdCB0eXBlTmFtZSA9IGdldFR5cGVOYW1lKGZlYXR1cmVQcmVmaXgsIGZlYXR1cmVUeXBlKTtcbiAgY29uc3QgZ2VvbWV0cnlOYW1lID0gZmVhdHVyZS5nZXRHZW9tZXRyeU5hbWUoKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGVOYW1lJywgdHlwZU5hbWUpO1xuICBub2RlLnNldEF0dHJpYnV0ZU5TKFhNTE5TLCAneG1sbnM6JyArIGZlYXR1cmVQcmVmaXgsIGZlYXR1cmVOUyk7XG4gIGNvbnN0IGZpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qga2V5cyA9IGZlYXR1cmUuZ2V0S2V5cygpO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBmZWF0dXJlLmdldChrZXlzW2ldKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovICh2YWx1ZSkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBuYW1lID0gZ2VvbWV0cnlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovICh7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgICdnbWxWZXJzaW9uJzogY29udGV4dFsnZ21sVmVyc2lvbiddLFxuICAgICAgICBub2RlLFxuICAgICAgICAnaGFzWic6IGNvbnRleHRbJ2hhc1onXSxcbiAgICAgICAgJ3Nyc05hbWUnOiBjb250ZXh0WydzcnNOYW1lJ10sXG4gICAgICB9KSxcbiAgICAgIFRSQU5TQUNUSU9OX1NFUklBTElaRVJTLFxuICAgICAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdQcm9wZXJ0eScpLFxuICAgICAgdmFsdWVzLFxuICAgICAgb2JqZWN0U3RhY2tcbiAgICApO1xuICAgIHdyaXRlT2djRmlkRmlsdGVyKG5vZGUsIGZpZCwgb2JqZWN0U3RhY2spO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFpciBQcm9wZXJ0eSBuYW1lIGFuZCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUHJvcGVydHkobm9kZSwgcGFpciwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuICBjb25zdCBucyA9IFdGU05TW3ZlcnNpb25dO1xuICBjb25zdCBuYW1lID0gY3JlYXRlRWxlbWVudE5TKG5zLCAnTmFtZScpO1xuICBjb25zdCBnbWxWZXJzaW9uID0gY29udGV4dFsnZ21sVmVyc2lvbiddO1xuICBub2RlLmFwcGVuZENoaWxkKG5hbWUpO1xuICB3cml0ZVN0cmluZ1RleHROb2RlKG5hbWUsIHBhaXIubmFtZSk7XG4gIGlmIChwYWlyLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFpci52YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHZhbHVlID0gY3JlYXRlRWxlbWVudE5TKG5zLCAnVmFsdWUnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICBpZiAoXG4gICAgICBwYWlyLnZhbHVlICYmXG4gICAgICB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKHBhaXIudmFsdWUpLmdldFNpbXBsaWZpZWRHZW9tZXRyeSkgPT09XG4gICAgICAgICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGlmIChnbWxWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIEdNTDIucHJvdG90eXBlLndyaXRlR2VvbWV0cnlFbGVtZW50KHZhbHVlLCBwYWlyLnZhbHVlLCBvYmplY3RTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKGdtbFZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgR01MMy5wcm90b3R5cGUud3JpdGVHZW9tZXRyeUVsZW1lbnQodmFsdWUsIHBhaXIudmFsdWUsIG9iamVjdFN0YWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEdNTDMyLnByb3RvdHlwZS53cml0ZUdlb21ldHJ5RWxlbWVudCh2YWx1ZSwgcGFpci52YWx1ZSwgb2JqZWN0U3RhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZVN0cmluZ1RleHROb2RlKHZhbHVlLCBwYWlyLnZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7e3ZlbmRvcklkOiBzdHJpbmcsIHNhZmVUb0lnbm9yZTogYm9vbGVhbiwgdmFsdWU6IHN0cmluZ319IG5hdGl2ZUVsZW1lbnQgVGhlIG5hdGl2ZSBlbGVtZW50LlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVOYXRpdmUobm9kZSwgbmF0aXZlRWxlbWVudCwgb2JqZWN0U3RhY2spIHtcbiAgaWYgKG5hdGl2ZUVsZW1lbnQudmVuZG9ySWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmVuZG9ySWQnLCBuYXRpdmVFbGVtZW50LnZlbmRvcklkKTtcbiAgfVxuICBpZiAobmF0aXZlRWxlbWVudC5zYWZlVG9JZ25vcmUgIT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzYWZlVG9JZ25vcmUnLCBTdHJpbmcobmF0aXZlRWxlbWVudC5zYWZlVG9JZ25vcmUpKTtcbiAgfVxuICBpZiAobmF0aXZlRWxlbWVudC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd3JpdGVTdHJpbmdUZXh0Tm9kZShub2RlLCBuYXRpdmVFbGVtZW50LnZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuU2VyaWFsaXplcj4+fVxuICovXG5jb25zdCBHRVRGRUFUVVJFX1NFUklBTElaRVJTID0ge1xuICAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93ZnMnOiB7XG4gICAgJ1F1ZXJ5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVRdWVyeSksXG4gIH0sXG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmcy8yLjAnOiB7XG4gICAgJ1F1ZXJ5JzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVRdWVyeSksXG4gIH0sXG4gICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L29nYyc6IHtcbiAgICAnRHVyaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEdXJpbmdGaWx0ZXIpLFxuICAgICdBbmQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUxvZ2ljYWxGaWx0ZXIpLFxuICAgICdPcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTG9naWNhbEZpbHRlciksXG4gICAgJ05vdCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTm90RmlsdGVyKSxcbiAgICAnQkJPWCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQmJveEZpbHRlciksXG4gICAgJ0NvbnRhaW5zJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTcGF0aWFsRmlsdGVyKSxcbiAgICAnSW50ZXJzZWN0cyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3BhdGlhbEZpbHRlciksXG4gICAgJ1dpdGhpbic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3BhdGlhbEZpbHRlciksXG4gICAgJ0RXaXRoaW4nOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURXaXRoaW5GaWx0ZXIpLFxuICAgICdQcm9wZXJ0eUlzRXF1YWxUbyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQ29tcGFyaXNvbkZpbHRlciksXG4gICAgJ1Byb3BlcnR5SXNOb3RFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0xlc3NUaGFuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0xlc3NUaGFuT3JFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0dyZWF0ZXJUaGFuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0dyZWF0ZXJUaGFuT3JFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc051bGwnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUlzTnVsbEZpbHRlciksXG4gICAgJ1Byb3BlcnR5SXNCZXR3ZWVuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVJc0JldHdlZW5GaWx0ZXIpLFxuICAgICdQcm9wZXJ0eUlzTGlrZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlSXNMaWtlRmlsdGVyKSxcbiAgfSxcbiAgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZmVzLzIuMCc6IHtcbiAgICAnRHVyaW5nJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVEdXJpbmdGaWx0ZXIpLFxuICAgICdBbmQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUxvZ2ljYWxGaWx0ZXIpLFxuICAgICdPcic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTG9naWNhbEZpbHRlciksXG4gICAgJ05vdCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlTm90RmlsdGVyKSxcbiAgICAnQkJPWCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQmJveEZpbHRlciksXG4gICAgJ0NvbnRhaW5zJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTcGF0aWFsRmlsdGVyKSxcbiAgICAnRGlzam9pbnQnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZVNwYXRpYWxGaWx0ZXIpLFxuICAgICdJbnRlcnNlY3RzJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVTcGF0aWFsRmlsdGVyKSxcbiAgICAnUmVzb3VyY2VJZCc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlUmVzb3VyY2VJZEZpbHRlciksXG4gICAgJ1dpdGhpbic6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlU3BhdGlhbEZpbHRlciksXG4gICAgJ0RXaXRoaW4nOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZURXaXRoaW5GaWx0ZXIpLFxuICAgICdQcm9wZXJ0eUlzRXF1YWxUbyc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlQ29tcGFyaXNvbkZpbHRlciksXG4gICAgJ1Byb3BlcnR5SXNOb3RFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0xlc3NUaGFuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0xlc3NUaGFuT3JFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0dyZWF0ZXJUaGFuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc0dyZWF0ZXJUaGFuT3JFcXVhbFRvJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVDb21wYXJpc29uRmlsdGVyKSxcbiAgICAnUHJvcGVydHlJc051bGwnOiBtYWtlQ2hpbGRBcHBlbmRlcih3cml0ZUlzTnVsbEZpbHRlciksXG4gICAgJ1Byb3BlcnR5SXNCZXR3ZWVuJzogbWFrZUNoaWxkQXBwZW5kZXIod3JpdGVJc0JldHdlZW5GaWx0ZXIpLFxuICAgICdQcm9wZXJ0eUlzTGlrZSc6IG1ha2VDaGlsZEFwcGVuZGVyKHdyaXRlSXNMaWtlRmlsdGVyKSxcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVR5cGUgRmVhdHVyZSB0eXBlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVRdWVyeShub2RlLCBmZWF0dXJlVHlwZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuICBjb25zdCBmZWF0dXJlUHJlZml4ID0gY29udGV4dFsnZmVhdHVyZVByZWZpeCddO1xuICBjb25zdCBmZWF0dXJlTlMgPSBjb250ZXh0WydmZWF0dXJlTlMnXTtcbiAgY29uc3QgcHJvcGVydHlOYW1lcyA9IGNvbnRleHRbJ3Byb3BlcnR5TmFtZXMnXTtcbiAgY29uc3Qgc3JzTmFtZSA9IGNvbnRleHRbJ3Nyc05hbWUnXTtcbiAgbGV0IHR5cGVOYW1lO1xuICAvLyBJZiBmZWF0dXJlIHByZWZpeCBpcyBub3QgZGVmaW5lZCwgd2UgbXVzdCBub3QgdXNlIHRoZSBkZWZhdWx0IHByZWZpeC5cbiAgaWYgKGZlYXR1cmVQcmVmaXgpIHtcbiAgICB0eXBlTmFtZSA9IGdldFR5cGVOYW1lKGZlYXR1cmVQcmVmaXgsIGZlYXR1cmVUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlTmFtZSA9IGZlYXR1cmVUeXBlO1xuICB9XG4gIGxldCB0eXBlTmFtZUF0dHI7XG4gIGlmICh2ZXJzaW9uID09PSAnMi4wLjAnKSB7XG4gICAgdHlwZU5hbWVBdHRyID0gJ3R5cGVOYW1lcyc7XG4gIH0gZWxzZSB7XG4gICAgdHlwZU5hbWVBdHRyID0gJ3R5cGVOYW1lJztcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZSh0eXBlTmFtZUF0dHIsIHR5cGVOYW1lKTtcbiAgaWYgKHNyc05hbWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnc3JzTmFtZScsIHNyc05hbWUpO1xuICB9XG4gIGlmIChmZWF0dXJlTlMpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKFhNTE5TLCAneG1sbnM6JyArIGZlYXR1cmVQcmVmaXgsIGZlYXR1cmVOUyk7XG4gIH1cbiAgY29uc3QgaXRlbSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovIChcbiAgICBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KVxuICApO1xuICBpdGVtLm5vZGUgPSBub2RlO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGl0ZW0sXG4gICAgUVVFUllfU0VSSUFMSVpFUlMsXG4gICAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdQcm9wZXJ0eU5hbWUnKSxcbiAgICBwcm9wZXJ0eU5hbWVzLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGNvbnN0IGZpbHRlciA9IGNvbnRleHRbJ2ZpbHRlciddO1xuICBpZiAoZmlsdGVyKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGVFbGVtZW50TlMoZ2V0RmlsdGVyTlModmVyc2lvbiksICdGaWx0ZXInKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB3cml0ZUZpbHRlckNvbmRpdGlvbihjaGlsZCwgZmlsdGVyLCBvYmplY3RTdGFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvRmlsdGVyLmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUZpbHRlckNvbmRpdGlvbihub2RlLCBmaWx0ZXIsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGNvbnRleHQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi94bWwuanNcIikuTm9kZVN0YWNrSXRlbX0gKi9cbiAgY29uc3QgaXRlbSA9IHtub2RlfTtcbiAgT2JqZWN0LmFzc2lnbihpdGVtLCB7Y29udGV4dH0pO1xuICBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICAgIGl0ZW0sXG4gICAgR0VURkVBVFVSRV9TRVJJQUxJWkVSUyxcbiAgICBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoZmlsdGVyLmdldFRhZ05hbWUoKSksXG4gICAgW2ZpbHRlcl0sXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvQmJveC5qc1wiKS5kZWZhdWx0fSBmaWx0ZXIgRmlsdGVyLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVCYm94RmlsdGVyKG5vZGUsIGZpbHRlciwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBwYXJlbnRbJ2NvbnRleHQnXTtcbiAgY29uc3QgdmVyc2lvbiA9IGNvbnRleHRbJ3ZlcnNpb24nXTtcbiAgcGFyZW50WydzcnNOYW1lJ10gPSBmaWx0ZXIuc3JzTmFtZTtcbiAgY29uc3QgZm9ybWF0ID0gR01MX0ZPUk1BVFNbdmVyc2lvbl07XG5cbiAgd3JpdGVQcm9wZXJ0eU5hbWUodmVyc2lvbiwgbm9kZSwgZmlsdGVyLmdlb21ldHJ5TmFtZSk7XG4gIGZvcm1hdC5wcm90b3R5cGUud3JpdGVHZW9tZXRyeUVsZW1lbnQobm9kZSwgZmlsdGVyLmV4dGVudCwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2ZpbHRlci9SZXNvdXJjZUlkLmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZVJlc291cmNlSWRGaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjaykge1xuICBub2RlLnNldEF0dHJpYnV0ZSgncmlkJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovIChmaWx0ZXIucmlkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZmlsdGVyL1NwYXRpYWwuanNcIikuZGVmYXVsdH0gZmlsdGVyIEZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3BhdGlhbEZpbHRlcihub2RlLCBmaWx0ZXIsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjb250ZXh0ID0gcGFyZW50Wydjb250ZXh0J107XG4gIGNvbnN0IHZlcnNpb24gPSBjb250ZXh0Wyd2ZXJzaW9uJ107XG4gIHBhcmVudFsnc3JzTmFtZSddID0gZmlsdGVyLnNyc05hbWU7XG4gIGNvbnN0IGZvcm1hdCA9IEdNTF9GT1JNQVRTW3ZlcnNpb25dO1xuXG4gIHdyaXRlUHJvcGVydHlOYW1lKHZlcnNpb24sIG5vZGUsIGZpbHRlci5nZW9tZXRyeU5hbWUpO1xuICBmb3JtYXQucHJvdG90eXBlLndyaXRlR2VvbWV0cnlFbGVtZW50KG5vZGUsIGZpbHRlci5nZW9tZXRyeSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2ZpbHRlci9EV2l0aGluLmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZURXaXRoaW5GaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY29udGV4dCA9IHBhcmVudFsnY29udGV4dCddO1xuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuICB3cml0ZVNwYXRpYWxGaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjayk7XG4gIGNvbnN0IGRpc3RhbmNlID0gY3JlYXRlRWxlbWVudE5TKGdldEZpbHRlck5TKHZlcnNpb24pLCAnRGlzdGFuY2UnKTtcbiAgd3JpdGVTdHJpbmdUZXh0Tm9kZShkaXN0YW5jZSwgZmlsdGVyLmRpc3RhbmNlLnRvU3RyaW5nKCkpO1xuICBpZiAodmVyc2lvbiA9PT0gJzIuMC4wJykge1xuICAgIGRpc3RhbmNlLnNldEF0dHJpYnV0ZSgndW9tJywgZmlsdGVyLnVuaXQpO1xuICB9IGVsc2Uge1xuICAgIGRpc3RhbmNlLnNldEF0dHJpYnV0ZSgndW5pdHMnLCBmaWx0ZXIudW5pdCk7XG4gIH1cbiAgbm9kZS5hcHBlbmRDaGlsZChkaXN0YW5jZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZmlsdGVyL0R1cmluZy5qc1wiKS5kZWZhdWx0fSBmaWx0ZXIgRmlsdGVyLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVEdXJpbmdGaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY29udGV4dCA9IHBhcmVudFsnY29udGV4dCddO1xuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuXG4gIHdyaXRlRXhwcmVzc2lvbihGRVNOU1t2ZXJzaW9uXSwgJ1ZhbHVlUmVmZXJlbmNlJywgbm9kZSwgZmlsdGVyLnByb3BlcnR5TmFtZSk7XG4gIGNvbnN0IHRpbWVQZXJpb2QgPSBjcmVhdGVFbGVtZW50TlMoR01MTlMsICdUaW1lUGVyaW9kJyk7XG5cbiAgbm9kZS5hcHBlbmRDaGlsZCh0aW1lUGVyaW9kKTtcblxuICBjb25zdCBiZWdpbiA9IGNyZWF0ZUVsZW1lbnROUyhHTUxOUywgJ2JlZ2luJyk7XG4gIHRpbWVQZXJpb2QuYXBwZW5kQ2hpbGQoYmVnaW4pO1xuICB3cml0ZVRpbWVJbnN0YW50KGJlZ2luLCBmaWx0ZXIuYmVnaW4pO1xuXG4gIGNvbnN0IGVuZCA9IGNyZWF0ZUVsZW1lbnROUyhHTUxOUywgJ2VuZCcpO1xuICB0aW1lUGVyaW9kLmFwcGVuZENoaWxkKGVuZCk7XG4gIHdyaXRlVGltZUluc3RhbnQoZW5kLCBmaWx0ZXIuZW5kKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvTG9naWNhbE5hcnkuanNcIikuZGVmYXVsdH0gZmlsdGVyIEZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTG9naWNhbEZpbHRlcihub2RlLCBmaWx0ZXIsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjb250ZXh0ID0gcGFyZW50Wydjb250ZXh0J107XG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4veG1sLmpzXCIpLk5vZGVTdGFja0l0ZW19ICovXG4gIGNvbnN0IGl0ZW0gPSB7bm9kZX07XG4gIE9iamVjdC5hc3NpZ24oaXRlbSwge2NvbnRleHR9KTtcbiAgY29uc3QgY29uZGl0aW9ucyA9IGZpbHRlci5jb25kaXRpb25zO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb25kaXRpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBjb25kaXRpb24gPSBjb25kaXRpb25zW2ldO1xuICAgIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgICBpdGVtLFxuICAgICAgR0VURkVBVFVSRV9TRVJJQUxJWkVSUyxcbiAgICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeShjb25kaXRpb24uZ2V0VGFnTmFtZSgpKSxcbiAgICAgIFtjb25kaXRpb25dLFxuICAgICAgb2JqZWN0U3RhY2tcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZmlsdGVyL05vdC5qc1wiKS5kZWZhdWx0fSBmaWx0ZXIgRmlsdGVyLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqL1xuZnVuY3Rpb24gd3JpdGVOb3RGaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY29udGV4dCA9IHBhcmVudFsnY29udGV4dCddO1xuICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqL1xuICBjb25zdCBpdGVtID0ge25vZGV9O1xuICBPYmplY3QuYXNzaWduKGl0ZW0sIHtjb250ZXh0fSk7XG4gIGNvbnN0IGNvbmRpdGlvbiA9IGZpbHRlci5jb25kaXRpb247XG4gIHB1c2hTZXJpYWxpemVBbmRQb3AoXG4gICAgaXRlbSxcbiAgICBHRVRGRUFUVVJFX1NFUklBTElaRVJTLFxuICAgIG1ha2VTaW1wbGVOb2RlRmFjdG9yeShjb25kaXRpb24uZ2V0VGFnTmFtZSgpKSxcbiAgICBbY29uZGl0aW9uXSxcbiAgICBvYmplY3RTdGFja1xuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2ZpbHRlci9Db21wYXJpc29uQmluYXJ5LmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUNvbXBhcmlzb25GaWx0ZXIobm9kZSwgZmlsdGVyLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgY29udGV4dCA9IHBhcmVudFsnY29udGV4dCddO1xuICBjb25zdCB2ZXJzaW9uID0gY29udGV4dFsndmVyc2lvbiddO1xuICBpZiAoZmlsdGVyLm1hdGNoQ2FzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ21hdGNoQ2FzZScsIGZpbHRlci5tYXRjaENhc2UudG9TdHJpbmcoKSk7XG4gIH1cbiAgd3JpdGVQcm9wZXJ0eU5hbWUodmVyc2lvbiwgbm9kZSwgZmlsdGVyLnByb3BlcnR5TmFtZSk7XG4gIHdyaXRlTGl0ZXJhbCh2ZXJzaW9uLCBub2RlLCAnJyArIGZpbHRlci5leHByZXNzaW9uKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvSXNOdWxsLmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUlzTnVsbEZpbHRlcihub2RlLCBmaWx0ZXIsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAob2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjb250ZXh0ID0gcGFyZW50Wydjb250ZXh0J107XG4gIGNvbnN0IHZlcnNpb24gPSBjb250ZXh0Wyd2ZXJzaW9uJ107XG4gIHdyaXRlUHJvcGVydHlOYW1lKHZlcnNpb24sIG5vZGUsIGZpbHRlci5wcm9wZXJ0eU5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2ZpbHRlci9Jc0JldHdlZW4uanNcIikuZGVmYXVsdH0gZmlsdGVyIEZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlSXNCZXR3ZWVuRmlsdGVyKG5vZGUsIGZpbHRlciwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBwYXJlbnRbJ2NvbnRleHQnXTtcbiAgY29uc3QgdmVyc2lvbiA9IGNvbnRleHRbJ3ZlcnNpb24nXTtcbiAgY29uc3QgbnMgPSBnZXRGaWx0ZXJOUyh2ZXJzaW9uKTtcblxuICB3cml0ZVByb3BlcnR5TmFtZSh2ZXJzaW9uLCBub2RlLCBmaWx0ZXIucHJvcGVydHlOYW1lKTtcblxuICBjb25zdCBsb3dlckJvdW5kYXJ5ID0gY3JlYXRlRWxlbWVudE5TKG5zLCAnTG93ZXJCb3VuZGFyeScpO1xuICBub2RlLmFwcGVuZENoaWxkKGxvd2VyQm91bmRhcnkpO1xuICB3cml0ZUxpdGVyYWwodmVyc2lvbiwgbG93ZXJCb3VuZGFyeSwgJycgKyBmaWx0ZXIubG93ZXJCb3VuZGFyeSk7XG5cbiAgY29uc3QgdXBwZXJCb3VuZGFyeSA9IGNyZWF0ZUVsZW1lbnROUyhucywgJ1VwcGVyQm91bmRhcnknKTtcbiAgbm9kZS5hcHBlbmRDaGlsZCh1cHBlckJvdW5kYXJ5KTtcbiAgd3JpdGVMaXRlcmFsKHZlcnNpb24sIHVwcGVyQm91bmRhcnksICcnICsgZmlsdGVyLnVwcGVyQm91bmRhcnkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2ZpbHRlci9Jc0xpa2UuanNcIikuZGVmYXVsdH0gZmlsdGVyIEZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE5vZGUgc3RhY2suXG4gKi9cbmZ1bmN0aW9uIHdyaXRlSXNMaWtlRmlsdGVyKG5vZGUsIGZpbHRlciwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBwYXJlbnRbJ2NvbnRleHQnXTtcbiAgY29uc3QgdmVyc2lvbiA9IGNvbnRleHRbJ3ZlcnNpb24nXTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3dpbGRDYXJkJywgZmlsdGVyLndpbGRDYXJkKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NpbmdsZUNoYXInLCBmaWx0ZXIuc2luZ2xlQ2hhcik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKCdlc2NhcGVDaGFyJywgZmlsdGVyLmVzY2FwZUNoYXIpO1xuICBpZiAoZmlsdGVyLm1hdGNoQ2FzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ21hdGNoQ2FzZScsIGZpbHRlci5tYXRjaENhc2UudG9TdHJpbmcoKSk7XG4gIH1cbiAgd3JpdGVQcm9wZXJ0eU5hbWUodmVyc2lvbiwgbm9kZSwgZmlsdGVyLnByb3BlcnR5TmFtZSk7XG4gIHdyaXRlTGl0ZXJhbCh2ZXJzaW9uLCBub2RlLCAnJyArIGZpbHRlci5wYXR0ZXJuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbnMgTmFtZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGFnIG5hbWUuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVFeHByZXNzaW9uKG5zLCB0YWdOYW1lLCBub2RlLCB2YWx1ZSkge1xuICBjb25zdCBwcm9wZXJ0eSA9IGNyZWF0ZUVsZW1lbnROUyhucywgdGFnTmFtZSk7XG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUocHJvcGVydHksIHZhbHVlKTtcbiAgbm9kZS5hcHBlbmRDaGlsZChwcm9wZXJ0eSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbi5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFByb3BlcnR5TmFtZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVMaXRlcmFsKHZlcnNpb24sIG5vZGUsIHZhbHVlKSB7XG4gIHdyaXRlRXhwcmVzc2lvbihnZXRGaWx0ZXJOUyh2ZXJzaW9uKSwgJ0xpdGVyYWwnLCBub2RlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbi5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFByb3BlcnR5TmFtZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVQcm9wZXJ0eU5hbWUodmVyc2lvbiwgbm9kZSwgdmFsdWUpIHtcbiAgaWYgKHZlcnNpb24gPT09ICcyLjAuMCcpIHtcbiAgICB3cml0ZUV4cHJlc3Npb24oRkVTTlNbdmVyc2lvbl0sICdWYWx1ZVJlZmVyZW5jZScsIG5vZGUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUV4cHJlc3Npb24oT0dDTlNbdmVyc2lvbl0sICdQcm9wZXJ0eU5hbWUnLCBub2RlLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lIFByb3BlcnR5TmFtZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVUaW1lSW5zdGFudChub2RlLCB0aW1lKSB7XG4gIGNvbnN0IHRpbWVJbnN0YW50ID0gY3JlYXRlRWxlbWVudE5TKEdNTE5TLCAnVGltZUluc3RhbnQnKTtcbiAgbm9kZS5hcHBlbmRDaGlsZCh0aW1lSW5zdGFudCk7XG5cbiAgY29uc3QgdGltZVBvc2l0aW9uID0gY3JlYXRlRWxlbWVudE5TKEdNTE5TLCAndGltZVBvc2l0aW9uJyk7XG4gIHRpbWVJbnN0YW50LmFwcGVuZENoaWxkKHRpbWVQb3NpdGlvbik7XG4gIHdyaXRlU3RyaW5nVGV4dE5vZGUodGltZVBvc2l0aW9uLCB0aW1lKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgZmlsdGVyIGFzIFdGUyBgRmlsdGVyYCBhbmQgcmV0dXJuIHRoZSBOb2RlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9maWx0ZXIvRmlsdGVyLmpzXCIpLmRlZmF1bHR9IGZpbHRlciBGaWx0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiBXRlMgdmVyc2lvbi4gSWYgbm90IHByb3ZpZGVkIGRlZmF1bHRzIHRvICcxLjEuMCdcbiAqIEByZXR1cm4ge05vZGV9IFJlc3VsdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlRmlsdGVyKGZpbHRlciwgdmVyc2lvbikge1xuICB2ZXJzaW9uID0gdmVyc2lvbiB8fCAnMS4xLjAnO1xuICBjb25zdCBjaGlsZCA9IGNyZWF0ZUVsZW1lbnROUyhnZXRGaWx0ZXJOUyh2ZXJzaW9uKSwgJ0ZpbHRlcicpO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5vZGU6IGNoaWxkLFxuICB9O1xuICBPYmplY3QuYXNzaWduKGNvbnRleHQsIHtcbiAgICAndmVyc2lvbic6IHZlcnNpb24sXG4gICAgJ2ZpbHRlcic6IGZpbHRlcixcbiAgfSk7XG4gIHdyaXRlRmlsdGVyQ29uZGl0aW9uKGNoaWxkLCBmaWx0ZXIsIFtjb250ZXh0XSk7XG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZmVhdHVyZVR5cGVzIEZlYXR1cmUgdHlwZXMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBOb2RlIHN0YWNrLlxuICovXG5mdW5jdGlvbiB3cml0ZUdldEZlYXR1cmUobm9kZSwgZmVhdHVyZVR5cGVzLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL3htbC5qc1wiKS5Ob2RlU3RhY2tJdGVtfSAqLyAoXG4gICAgT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dClcbiAgKTtcbiAgaXRlbS5ub2RlID0gbm9kZTtcbiAgcHVzaFNlcmlhbGl6ZUFuZFBvcChcbiAgICBpdGVtLFxuICAgIEdFVEZFQVRVUkVfU0VSSUFMSVpFUlMsXG4gICAgbWFrZVNpbXBsZU5vZGVGYWN0b3J5KCdRdWVyeScpLFxuICAgIGZlYXR1cmVUeXBlcyxcbiAgICBvYmplY3RTdGFja1xuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJOUyh2ZXJzaW9uKSB7XG4gIGxldCBucztcbiAgaWYgKHZlcnNpb24gPT09ICcyLjAuMCcpIHtcbiAgICBucyA9IEZFU05TW3ZlcnNpb25dO1xuICB9IGVsc2Uge1xuICAgIG5zID0gT0dDTlNbdmVyc2lvbl07XG4gIH1cbiAgcmV0dXJuIG5zO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXRlM7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L1dLQlxuICovXG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBGZWF0dXJlRm9ybWF0LCB7dHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9uc30gZnJvbSAnLi9GZWF0dXJlLmpzJztcbmltcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi4vZ2VvbS9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBNdWx0aVBvbHlnb24gZnJvbSAnLi4vZ2VvbS9NdWx0aVBvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5cbi8vIFdLQiBzcGVjOiBodHRwczovL3d3dy5vZ2Mub3JnL3N0YW5kYXJkcy9zZmFcbi8vIEVXS0Igc3BlYzogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3Bvc3RnaXMvcG9zdGdpcy8yLjEuMC9kb2MvWk1TZ2VvbXMudHh0XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBXS0JHZW9tZXRyeVR5cGUgPSB7XG4gIFBPSU5UOiAxLFxuICBMSU5FX1NUUklORzogMixcbiAgUE9MWUdPTjogMyxcbiAgTVVMVElfUE9JTlQ6IDQsXG4gIE1VTFRJX0xJTkVfU1RSSU5HOiA1LFxuICBNVUxUSV9QT0xZR09OOiA2LFxuICBHRU9NRVRSWV9DT0xMRUNUSU9OOiA3LFxuXG4gIC8qXG4gIENJUkNVTEFSX1NUUklORzogOCxcbiAgQ09NUE9VTkRfQ1VSVkU6IDksXG4gIENVUlZFX1BPTFlHT046IDEwLFxuXG4gIE1VTFRJX0NVUlZFOiAxMSxcbiAgTVVMVElfU1VSRkFDRTogMTIsXG4gIENVUlZFOiAxMyxcbiAgU1VSRkFDRTogMTQsXG4gICovXG5cbiAgUE9MWUhFRFJBTF9TVVJGQUNFOiAxNSxcbiAgVElOOiAxNixcbiAgVFJJQU5HTEU6IDE3LFxufTtcblxuY2xhc3MgV2tiUmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IHZpZXcgc291cmNlIHRvIHJlYWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLnZpZXdfID0gdmlldztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvc18gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxpemVkXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTGl0dGxlRW5kaWFuXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhc1pfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGFzTV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3JpZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxheW91dF8gPSAnWFknO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVaW50OCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3Xy5nZXRVaW50OCh0aGlzLnBvc18rKyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNMaXR0bGVFbmRpYW5dIFdoZXRoZXIgcmVhZCB2YWx1ZSBhcyBsaXR0bGUgZW5kaWFuXG4gICAqIEByZXR1cm4ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVaW50MzIoaXNMaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy52aWV3Xy5nZXRVaW50MzIoXG4gICAgICAodGhpcy5wb3NfICs9IDQpIC0gNCxcbiAgICAgIGlzTGl0dGxlRW5kaWFuICE9PSB1bmRlZmluZWQgPyBpc0xpdHRsZUVuZGlhbiA6IHRoaXMuaXNMaXR0bGVFbmRpYW5fXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xpdHRsZUVuZGlhbl0gV2hldGhlciByZWFkIHZhbHVlIGFzIGxpdHRsZSBlbmRpYW5cbiAgICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZERvdWJsZShpc0xpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLnZpZXdfLmdldEZsb2F0NjQoXG4gICAgICAodGhpcy5wb3NfICs9IDgpIC0gOCxcbiAgICAgIGlzTGl0dGxlRW5kaWFuICE9PSB1bmRlZmluZWQgPyBpc0xpdHRsZUVuZGlhbiA6IHRoaXMuaXNMaXR0bGVFbmRpYW5fXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlfSBjb29yZHMgZm9yIFBvaW50XG4gICAqL1xuICByZWFkUG9pbnQoKSB7XG4gICAgLyoqIEB0eXBlIGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGUgKi9cbiAgICBjb25zdCBjb29yZHMgPSBbXTtcblxuICAgIGNvb3Jkcy5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICBjb29yZHMucHVzaCh0aGlzLnJlYWREb3VibGUoKSk7XG4gICAgaWYgKHRoaXMuaGFzWl8pIHtcbiAgICAgIGNvb3Jkcy5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzTV8pIHtcbiAgICAgIGNvb3Jkcy5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+fSBjb29yZHMgZm9yIExpbmVTdHJpbmcgLyBMaW5lYXJSaW5nXG4gICAqL1xuICByZWFkTGluZVN0cmluZygpIHtcbiAgICBjb25zdCBudW1Qb2ludHMgPSB0aGlzLnJlYWRVaW50MzIoKTtcblxuICAgIC8qKiBAdHlwZSBBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPiAqL1xuICAgIGNvbnN0IGNvb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgIGNvb3Jkcy5wdXNoKHRoaXMucmVhZFBvaW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZHM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBjb29yZHMgZm9yIFBvbHlnb24gbGlrZVxuICAgKi9cbiAgcmVhZFBvbHlnb24oKSB7XG4gICAgY29uc3QgbnVtUmluZ3MgPSB0aGlzLnJlYWRVaW50MzIoKTtcblxuICAgIC8qKiBAdHlwZSBBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj4gKi9cbiAgICBjb25zdCByaW5ncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUmluZ3M7IGkrKykge1xuICAgICAgcmluZ3MucHVzaCh0aGlzLnJlYWRMaW5lU3RyaW5nKCkpOyAvLyBhcyBhIExpbmVhclJpbmdcbiAgICB9XG5cbiAgICByZXR1cm4gcmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtleHBlY3RlZFR5cGVJZF0gRXhwZWN0ZWQgV0tCIFR5cGUgSURcbiAgICogQHJldHVybiB7bnVtYmVyfSBXS0IgVHlwZSBJRFxuICAgKi9cbiAgcmVhZFdrYkhlYWRlcihleHBlY3RlZFR5cGVJZCkge1xuICAgIGNvbnN0IGJ5dGVPcmRlciA9IHRoaXMucmVhZFVpbnQ4KCk7XG4gICAgY29uc3QgaXNMaXR0bGVFbmRpYW4gPSBieXRlT3JkZXIgPiAwO1xuXG4gICAgY29uc3Qgd2tiVHlwZSA9IHRoaXMucmVhZFVpbnQzMihpc0xpdHRsZUVuZGlhbik7XG4gICAgY29uc3Qgd2tiVHlwZVRob3VzYW5kdGggPSBNYXRoLmZsb29yKCh3a2JUeXBlICYgMHgwZmZmZmZmZikgLyAxMDAwKTtcbiAgICBjb25zdCBoYXNaID1cbiAgICAgIEJvb2xlYW4od2tiVHlwZSAmIDB4ODAwMDAwMDApIHx8XG4gICAgICB3a2JUeXBlVGhvdXNhbmR0aCA9PT0gMSB8fFxuICAgICAgd2tiVHlwZVRob3VzYW5kdGggPT09IDM7XG4gICAgY29uc3QgaGFzTSA9XG4gICAgICBCb29sZWFuKHdrYlR5cGUgJiAweDQwMDAwMDAwKSB8fFxuICAgICAgd2tiVHlwZVRob3VzYW5kdGggPT09IDIgfHxcbiAgICAgIHdrYlR5cGVUaG91c2FuZHRoID09PSAzO1xuICAgIGNvbnN0IGhhc1NSSUQgPSBCb29sZWFuKHdrYlR5cGUgJiAweDIwMDAwMDAwKTtcbiAgICBjb25zdCB0eXBlSWQgPSAod2tiVHlwZSAmIDB4MGZmZmZmZmYpICUgMTAwMDsgLy8gQXNzdW1lIDEwMDAgaXMgYW4gdXBwZXIgbGltaXQgZm9yIHR5cGUgSURcbiAgICBjb25zdCBsYXlvdXQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9ICovIChcbiAgICAgIFsnWFknLCBoYXNaID8gJ1onIDogJycsIGhhc00gPyAnTScgOiAnJ10uam9pbignJylcbiAgICApO1xuXG4gICAgY29uc3Qgc3JpZCA9IGhhc1NSSUQgPyB0aGlzLnJlYWRVaW50MzIoaXNMaXR0bGVFbmRpYW4pIDogbnVsbDtcblxuICAgIGlmIChleHBlY3RlZFR5cGVJZCAhPT0gdW5kZWZpbmVkICYmIGV4cGVjdGVkVHlwZUlkICE9PSB0eXBlSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBXS0IgZ2VvbWV0cnkgdHlwZSAnICsgdHlwZUlkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbml0aWFsaXplZF8pIHtcbiAgICAgIC8vIHNhbml0eSBjaGVja3NcbiAgICAgIGlmICh0aGlzLmlzTGl0dGxlRW5kaWFuXyAhPT0gaXNMaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgZW5kaWFuJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXlvdXRfICE9PSBsYXlvdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgZ2VvbWV0cnkgbGF5b3V0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3JpZCAmJiB0aGlzLnNyaWRfICE9PSBzcmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IGNvb3JkaW5hdGUgc3lzdGVtIChTUklEKScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzTGl0dGxlRW5kaWFuXyA9IGlzTGl0dGxlRW5kaWFuO1xuICAgICAgdGhpcy5oYXNaXyA9IGhhc1o7XG4gICAgICB0aGlzLmhhc01fID0gaGFzTTtcbiAgICAgIHRoaXMubGF5b3V0XyA9IGxheW91dDtcbiAgICAgIHRoaXMuc3JpZF8gPSBzcmlkO1xuICAgICAgdGhpcy5pbml0aWFsaXplZF8gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlSWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGVJZCBXS0IgVHlwZSBJRFxuICAgKiBAcmV0dXJuIHthbnl9IHZhbHVlcyByZWFkXG4gICAqL1xuICByZWFkV2tiUGF5bG9hZCh0eXBlSWQpIHtcbiAgICBzd2l0Y2ggKHR5cGVJZCkge1xuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRQb2ludCgpO1xuXG4gICAgICBjYXNlIFdLQkdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZExpbmVTdHJpbmcoKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlRSSUFOR0xFOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkUG9seWdvbigpO1xuXG4gICAgICBjYXNlIFdLQkdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE11bHRpUG9pbnQoKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRNdWx0aUxpbmVTdHJpbmcoKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlBPTFlIRURSQUxfU1VSRkFDRTpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlRJTjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE11bHRpUG9seWdvbigpO1xuXG4gICAgICBjYXNlIFdLQkdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkR2VvbWV0cnlDb2xsZWN0aW9uKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgV0tCIGdlb21ldHJ5IHR5cGUgJyArIHR5cGVJZCArICcgaXMgZm91bmQnXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZFR5cGVJZCBFeHBlY3RlZCBXS0IgVHlwZSBJRFxuICAgKiBAcmV0dXJuIHthbnl9IHZhbHVlcyByZWFkXG4gICAqL1xuICByZWFkV2tiQmxvY2soZXhwZWN0ZWRUeXBlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkV2tiUGF5bG9hZCh0aGlzLnJlYWRXa2JIZWFkZXIoZXhwZWN0ZWRUeXBlSWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWFkZXIgcmVhZGVyIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtleHBlY3RlZFR5cGVJZF0gRXhwZWN0ZWQgV0tCIFR5cGUgSURcbiAgICogQHJldHVybiB7YW55fSB2YWx1ZXMgcmVhZFxuICAgKi9cbiAgcmVhZFdrYkNvbGxlY3Rpb24ocmVhZGVyLCBleHBlY3RlZFR5cGVJZCkge1xuICAgIGNvbnN0IG51bSA9IHRoaXMucmVhZFVpbnQzMigpO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWFkZXIuY2FsbCh0aGlzLCBleHBlY3RlZFR5cGVJZCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGl0ZW1zLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT59IGNvb3JkcyBmb3IgTXVsdGlQb2ludFxuICAgKi9cbiAgcmVhZE11bHRpUG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZFdrYkNvbGxlY3Rpb24odGhpcy5yZWFkV2tiQmxvY2ssIFdLQkdlb21ldHJ5VHlwZS5QT0lOVCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBjb29yZHMgZm9yIE11bHRpTGluZVN0cmluZyBsaWtlXG4gICAqL1xuICByZWFkTXVsdGlMaW5lU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRXa2JDb2xsZWN0aW9uKFxuICAgICAgdGhpcy5yZWFkV2tiQmxvY2ssXG4gICAgICBXS0JHZW9tZXRyeVR5cGUuTElORV9TVFJJTkdcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+Pj59IGNvb3JkcyBmb3IgTXVsdGlQb2x5Z29uIGxpa2VcbiAgICovXG4gIHJlYWRNdWx0aVBvbHlnb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZFdrYkNvbGxlY3Rpb24odGhpcy5yZWFkV2tiQmxvY2ssIFdLQkdlb21ldHJ5VHlwZS5QT0xZR09OKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoJy4uL2dlb20vR2VvbWV0cnkuanMnKS5kZWZhdWx0Pn0gYXJyYXkgb2YgZ2VvbWV0cmllc1xuICAgKi9cbiAgcmVhZEdlb21ldHJ5Q29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkV2tiQ29sbGVjdGlvbih0aGlzLnJlYWRHZW9tZXRyeSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9nZW9tL0dlb21ldHJ5LmpzJykuZGVmYXVsdH0gZ2VvbWV0cnlcbiAgICovXG4gIHJlYWRHZW9tZXRyeSgpIHtcbiAgICBjb25zdCB0eXBlSWQgPSB0aGlzLnJlYWRXa2JIZWFkZXIoKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRXa2JQYXlsb2FkKHR5cGVJZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGVJZCkge1xuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlfSAqLyAocmVzdWx0KSxcbiAgICAgICAgICB0aGlzLmxheW91dF9cbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgIHJldHVybiBuZXcgTGluZVN0cmluZyhcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+fSAqLyAocmVzdWx0KSxcbiAgICAgICAgICB0aGlzLmxheW91dF9cbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlRSSUFOR0xFOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24oXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj59ICovIChcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICksXG4gICAgICAgICAgdGhpcy5sYXlvdXRfXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgICAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPn0gKi8gKHJlc3VsdCksXG4gICAgICAgICAgdGhpcy5sYXlvdXRfXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+Pn0gKi8gKFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgKSxcbiAgICAgICAgICB0aGlzLmxheW91dF9cbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBXS0JHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlBPTFlIRURSQUxfU1VSRkFDRTpcbiAgICAgIGNhc2UgV0tCR2VvbWV0cnlUeXBlLlRJTjpcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24oXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj4+fSAqLyAoXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMubGF5b3V0X1xuICAgICAgICApO1xuXG4gICAgICBjYXNlIFdLQkdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOlxuICAgICAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi4vZ2VvbS9HZW9tZXRyeS5qcycpLmRlZmF1bHQ+fSAqLyAocmVzdWx0KVxuICAgICAgICApO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfG51bGx9IFNSSUQgaW4gdGhlIEVXS0IuIGBudWxsYCBpZiBub3QgZGVmaW5lZC5cbiAgICovXG4gIGdldFNyaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JpZF87XG4gIH1cbn1cblxuY2xhc3MgV2tiV3JpdGVyIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGF5b3V0XSBnZW9tZXRyeUxheW91dFxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaXR0bGVFbmRpYW49dHJ1ZV0gbGl0dGxlRW5kaWFuXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2V3a2I9dHJ1ZV0gV2hldGhlciB3cml0ZXMgaW4gRVdLQiBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFtub2RhdGFdIE5vRGF0YSB2YWx1ZSBmb3IgZWFjaCBheGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMubGF5b3V0XyA9IG9wdHMubGF5b3V0O1xuICAgIHRoaXMuaXNMaXR0bGVFbmRpYW5fID0gb3B0cy5saXR0bGVFbmRpYW4gIT09IGZhbHNlO1xuXG4gICAgdGhpcy5pc0VXS0JfID0gb3B0cy5ld2tiICE9PSBmYWxzZTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59ICovXG4gICAgdGhpcy53cml0ZVF1ZXVlXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gWCBOb0RhdGEgdmFsdWUgZm9yIFhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gWSBOb0RhdGEgdmFsdWUgZm9yIFlcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gWiBOb0RhdGEgdmFsdWUgZm9yIFpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTSBOb0RhdGEgdmFsdWUgZm9yIE1cbiAgICAgKi9cbiAgICB0aGlzLm5vZGF0YV8gPSBPYmplY3QuYXNzaWduKHtYOiAwLCBZOiAwLCBaOiAwLCBNOiAwfSwgb3B0cy5ub2RhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgKi9cbiAgd3JpdGVVaW50OCh2YWx1ZSkge1xuICAgIHRoaXMud3JpdGVRdWV1ZV8ucHVzaChbMSwgdmFsdWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICovXG4gIHdyaXRlVWludDMyKHZhbHVlKSB7XG4gICAgdGhpcy53cml0ZVF1ZXVlXy5wdXNoKFs0LCB2YWx1ZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgKi9cbiAgd3JpdGVEb3VibGUodmFsdWUpIHtcbiAgICB0aGlzLndyaXRlUXVldWVfLnB1c2goWzgsIHZhbHVlXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlfSBjb29yZHMgY29vcmRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IGxheW91dFxuICAgKi9cbiAgd3JpdGVQb2ludChjb29yZHMsIGxheW91dCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFggTm9EYXRhIHZhbHVlIGZvciBYXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFkgTm9EYXRhIHZhbHVlIGZvciBZXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtaXSBOb0RhdGEgdmFsdWUgZm9yIFpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW01dIE5vRGF0YSB2YWx1ZSBmb3IgTVxuICAgICAqL1xuICAgIGNvbnN0IGNvb3Jkc09iaiA9IE9iamVjdC5hc3NpZ24uYXBwbHkoXG4gICAgICBudWxsLFxuICAgICAgbGF5b3V0LnNwbGl0KCcnKS5tYXAoKGF4aXMsIGlkeCkgPT4gKHtbYXhpc106IGNvb3Jkc1tpZHhdfSkpXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmxheW91dF8pIHtcbiAgICAgIHRoaXMud3JpdGVEb3VibGUoXG4gICAgICAgIGF4aXMgaW4gY29vcmRzT2JqID8gY29vcmRzT2JqW2F4aXNdIDogdGhpcy5ub2RhdGFfW2F4aXNdXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+fSBjb29yZHMgY29vcmRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IGxheW91dFxuICAgKi9cbiAgd3JpdGVMaW5lU3RyaW5nKGNvb3JkcywgbGF5b3V0KSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihjb29yZHMubGVuZ3RoKTsgLy8gbnVtUG9pbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVQb2ludChjb29yZHNbaV0sIGxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSByaW5ncyByaW5nc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGxheW91dCBsYXlvdXRcbiAgICovXG4gIHdyaXRlUG9seWdvbihyaW5ncywgbGF5b3V0KSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihyaW5ncy5sZW5ndGgpOyAvLyBudW1SaW5nc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVMaW5lU3RyaW5nKHJpbmdzW2ldLCBsYXlvdXQpOyAvLyBhcyBhIExpbmVhclJpbmdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdrYlR5cGUgV0tCIFR5cGUgSURcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzcmlkXSBTUklEXG4gICAqL1xuICB3cml0ZVdrYkhlYWRlcih3a2JUeXBlLCBzcmlkKSB7XG4gICAgd2tiVHlwZSAlPSAxMDAwOyAvLyBBc3N1bWUgMTAwMCBpcyBhbiB1cHBlciBsaW1pdCBmb3IgdHlwZSBJRFxuICAgIGlmICh0aGlzLmxheW91dF8uaW5jbHVkZXMoJ1onKSkge1xuICAgICAgd2tiVHlwZSArPSB0aGlzLmlzRVdLQl8gPyAweDgwMDAwMDAwIDogMTAwMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5b3V0Xy5pbmNsdWRlcygnTScpKSB7XG4gICAgICB3a2JUeXBlICs9IHRoaXMuaXNFV0tCXyA/IDB4NDAwMDAwMDAgOiAyMDAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VXS0JfICYmIE51bWJlci5pc0ludGVnZXIoc3JpZCkpIHtcbiAgICAgIHdrYlR5cGUgfD0gMHgyMDAwMDAwMDtcbiAgICB9XG5cbiAgICB0aGlzLndyaXRlVWludDgodGhpcy5pc0xpdHRsZUVuZGlhbl8gPyAxIDogMCk7XG4gICAgdGhpcy53cml0ZVVpbnQzMih3a2JUeXBlKTtcbiAgICBpZiAodGhpcy5pc0VXS0JfICYmIE51bWJlci5pc0ludGVnZXIoc3JpZCkpIHtcbiAgICAgIHRoaXMud3JpdGVVaW50MzIoc3JpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT59IGNvb3JkcyBjb29yZHNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBsYXlvdXQgbGF5b3V0XG4gICAqL1xuICB3cml0ZU11bHRpUG9pbnQoY29vcmRzLCBsYXlvdXQpIHtcbiAgICB0aGlzLndyaXRlVWludDMyKGNvb3Jkcy5sZW5ndGgpOyAvLyBudW1JdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlV2tiSGVhZGVyKDEpO1xuICAgICAgdGhpcy53cml0ZVBvaW50KGNvb3Jkc1tpXSwgbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj59IGNvb3JkcyBjb29yZHNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBsYXlvdXQgbGF5b3V0XG4gICAqL1xuICB3cml0ZU11bHRpTGluZVN0cmluZyhjb29yZHMsIGxheW91dCkge1xuICAgIHRoaXMud3JpdGVVaW50MzIoY29vcmRzLmxlbmd0aCk7IC8vIG51bUl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVXa2JIZWFkZXIoMik7XG4gICAgICB0aGlzLndyaXRlTGluZVN0cmluZyhjb29yZHNbaV0sIGxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+Pn0gY29vcmRzIGNvb3Jkc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGxheW91dCBsYXlvdXRcbiAgICovXG4gIHdyaXRlTXVsdGlQb2x5Z29uKGNvb3JkcywgbGF5b3V0KSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihjb29yZHMubGVuZ3RoKTsgLy8gbnVtSXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVdrYkhlYWRlcigzKTtcbiAgICAgIHRoaXMud3JpdGVQb2x5Z29uKGNvb3Jkc1tpXSwgbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2dlb20vR2VvbWV0cnkuanMnKS5kZWZhdWx0Pn0gZ2VvbWV0cmllcyBnZW9tZXRyaWVzXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihnZW9tZXRyaWVzLmxlbmd0aCk7IC8vIG51bUl0ZW1zXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVHZW9tZXRyeShnZW9tZXRyaWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb20gZ2VvbWV0cnlcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBsYXlvdXRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbWluaW11bSBsYXlvdXQgbWFkZSBieSBjb21tb24gYXhlc1xuICAgKi9cbiAgZmluZE1pbmltdW1MYXlvdXQoZ2VvbSwgbGF5b3V0ID0gJ1hZWk0nKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBhIEFcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGIgQlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IG1pbmltdW0gbGF5b3V0IG1hZGUgYnkgY29tbW9uIGF4ZXNcbiAgICAgKi9cbiAgICBjb25zdCBHZW9tZXRyeUxheW91dF9taW4gPSAoYSwgYikgPT4ge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhID09PSAnWFlaTScpIHtcbiAgICAgICAgLy8gYW55dGhpbmcgYGJgIGlzIG1pbmltdW1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBpZiAoYiA9PT0gJ1hZWk0nKSB7XG4gICAgICAgIC8vIGFueXRoaW5nIGBhYCBpcyBtaW5pbXVtXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2UsIGluY29tcGF0aWJsZVxuICAgICAgcmV0dXJuICdYWSc7XG4gICAgfTtcblxuICAgIGlmIChnZW9tIGluc3RhbmNlb2YgU2ltcGxlR2VvbWV0cnkpIHtcbiAgICAgIHJldHVybiBHZW9tZXRyeUxheW91dF9taW4oZ2VvbS5nZXRMYXlvdXQoKSwgbGF5b3V0KTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgY29uc3QgZ2VvbXMgPSBnZW9tLmdldEdlb21ldHJpZXNBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tcy5sZW5ndGggJiYgbGF5b3V0ICE9PSAnWFknOyBpKyspIHtcbiAgICAgICAgbGF5b3V0ID0gdGhpcy5maW5kTWluaW11bUxheW91dChnZW9tc1tpXSwgbGF5b3V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tIGdlb21ldHJ5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3JpZF0gU1JJRFxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeShnZW9tLCBzcmlkKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIFdLQkdlb21ldHJ5VHlwZT59XG4gICAgICovXG4gICAgY29uc3Qgd2tibHV0ID0ge1xuICAgICAgUG9pbnQ6IFdLQkdlb21ldHJ5VHlwZS5QT0lOVCxcbiAgICAgIExpbmVTdHJpbmc6IFdLQkdlb21ldHJ5VHlwZS5MSU5FX1NUUklORyxcbiAgICAgIFBvbHlnb246IFdLQkdlb21ldHJ5VHlwZS5QT0xZR09OLFxuICAgICAgTXVsdGlQb2ludDogV0tCR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5ULFxuICAgICAgTXVsdGlMaW5lU3RyaW5nOiBXS0JHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcsXG4gICAgICBNdWx0aVBvbHlnb246IFdLQkdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OLFxuICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBXS0JHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTixcbiAgICB9O1xuICAgIGNvbnN0IGdlb21UeXBlID0gZ2VvbS5nZXRUeXBlKCk7XG4gICAgY29uc3QgdHlwZUlkID0gd2tibHV0W2dlb21UeXBlXTtcblxuICAgIGlmICghdHlwZUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5VHlwZSAnICsgZ2VvbVR5cGUgKyAnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBjYWxsIG9mIHdyaXRlR2VvbWV0cnkoKSB0cmF2ZXJzZSB3aG9sZSBnZW9tZXRyaWVzIHRvIGRldGVybWluZSBpdHMgb3V0cHV0IGxheW91dCBpZiBub3Qgc3BlY2lmaWVkIG9uIGNvbnN0cnVjdG9yLlxuICAgIGlmICghdGhpcy5sYXlvdXRfKSB7XG4gICAgICB0aGlzLmxheW91dF8gPSB0aGlzLmZpbmRNaW5pbXVtTGF5b3V0KGdlb20pO1xuICAgIH1cblxuICAgIHRoaXMud3JpdGVXa2JIZWFkZXIodHlwZUlkLCBzcmlkKTtcblxuICAgIGlmIChnZW9tIGluc3RhbmNlb2YgU2ltcGxlR2VvbWV0cnkpIHtcbiAgICAgIGNvbnN0IHdyaXRlckxVVCA9IHtcbiAgICAgICAgUG9pbnQ6IHRoaXMud3JpdGVQb2ludCxcbiAgICAgICAgTGluZVN0cmluZzogdGhpcy53cml0ZUxpbmVTdHJpbmcsXG4gICAgICAgIFBvbHlnb246IHRoaXMud3JpdGVQb2x5Z29uLFxuICAgICAgICBNdWx0aVBvaW50OiB0aGlzLndyaXRlTXVsdGlQb2ludCxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiB0aGlzLndyaXRlTXVsdGlMaW5lU3RyaW5nLFxuICAgICAgICBNdWx0aVBvbHlnb246IHRoaXMud3JpdGVNdWx0aVBvbHlnb24sXG4gICAgICB9O1xuICAgICAgd3JpdGVyTFVUW2dlb21UeXBlXS5jYWxsKHRoaXMsIGdlb20uZ2V0Q29vcmRpbmF0ZXMoKSwgZ2VvbS5nZXRMYXlvdXQoKSk7XG4gICAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLndyaXRlR2VvbWV0cnlDb2xsZWN0aW9uKGdlb20uZ2V0R2VvbWV0cmllc0FycmF5KCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldEJ1ZmZlcigpIHtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy53cml0ZVF1ZXVlXy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgaXRlbVswXSwgMCk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICAgIGxldCBwb3MgPSAwO1xuICAgIHRoaXMud3JpdGVRdWV1ZV8uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgc3dpdGNoIChpdGVtWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2aWV3LnNldFVpbnQ4KHBvcywgaXRlbVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB2aWV3LnNldFVpbnQzMihwb3MsIGl0ZW1bMV0sIHRoaXMuaXNMaXR0bGVFbmRpYW5fKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NChwb3MsIGl0ZW1bMV0sIHRoaXMuaXNMaXR0bGVFbmRpYW5fKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcG9zICs9IGl0ZW1bMF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbc3BsaXRDb2xsZWN0aW9uPWZhbHNlXSBXaGV0aGVyIHRvIHNwbGl0IEdlb21ldHJ5Q29sbGVjdGlvbnMgaW50byBtdWx0aXBsZSBmZWF0dXJlcyBvbiByZWFkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaGV4PXRydWVdIFJldHVybnMgaGV4IHN0cmluZyBpbnN0ZWFkIG9mIEFycmF5QnVmZmVyIGZvciBvdXRwdXQuIFRoaXMgYWxzbyBpcyB1c2VkIGFzIGEgaGludCBpbnRlcm5hbGx5IHdoZXRoZXIgaXQgc2hvdWxkIGxvYWQgY29udGVudHMgYXMgdGV4dCBvciBBcnJheUJ1ZmZlciBvbiByZWFkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbGl0dGxlRW5kaWFuPXRydWVdIFVzZSBsaXR0bGVFbmRpYW4gZm9yIG91dHB1dC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2V3a2I9dHJ1ZV0gVXNlIEVXS0IgZm9ybWF0IGZvciBvdXRwdXQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtnZW9tZXRyeUxheW91dD1udWxsXSBVc2Ugc3BlY2lmaWMgY29vcmRpbmF0ZSBsYXlvdXQgZm9yIG91dHB1dCBmZWF0dXJlcyAobnVsbDogYXV0byBkZXRlY3QpXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25vZGF0YVo9MF0gSWYgdGhlIGBnZW9tZXRyeUxheW91dGAgZG9lc24ndCBtYXRjaCB3aXRoIGdlb21ldHJ5IHRvIGJlIG91dHB1dCwgdGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGZpbGwgbWlzc2luZyBjb29yZGluYXRlIHZhbHVlIG9mIFouXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25vZGF0YU09MF0gSWYgdGhlIGBnZW9tZXRyeUxheW91dGAgZG9lc24ndCBtYXRjaCB3aXRoIGdlb21ldHJ5IHRvIGJlIG91dHB1dCwgdGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGZpbGwgbWlzc2luZyBjb29yZGluYXRlIHZhbHVlIG9mIE0uXG4gKiBAcHJvcGVydHkge251bWJlcnxib29sZWFufSBbc3JpZD10cnVlXSBTUklEIGZvciBvdXRwdXQuIFNwZWNpZnkgaW50ZWdlciB2YWx1ZSB0byBlbmZvcmNlIHRoZSB2YWx1ZSBhcyBhIFNSSUQuIFNwZWNpZnkgYHRydWVgIHRvIGV4dHJhY3QgZnJvbSBgZGF0YVByb2plY3Rpb25gLiBgZmFsc2VgIHRvIHN1cHByZXNzIHRoZSBvdXRwdXQuIFRoaXMgb3B0aW9uIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gYGV3a2JgIGlzIGB0cnVlYC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEdlb21ldHJ5IGZvcm1hdCBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBkYXRhIGluIHRoZSBgV2VsbC1Lbm93biBCaW5hcnlgIChXS0IpIGZvcm1hdC5cbiAqIEFsc28gc3VwcG9ydHMgYEV4dGVuZGVkIFdlbGwtS25vd24gQmluYXJ5YCAoRVdLQikgZm9ybWF0LCB1c2VkIGluIFBvc3RHSVMgZm9yIGV4YW1wbGUuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBXS0IgZXh0ZW5kcyBGZWF0dXJlRm9ybWF0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHRoaXMuc3BsaXRDb2xsZWN0aW9uID0gQm9vbGVhbihvcHRpb25zLnNwbGl0Q29sbGVjdGlvbik7XG5cbiAgICB0aGlzLnZpZXdDYWNoZV8gPSBudWxsO1xuXG4gICAgdGhpcy5oZXhfID0gb3B0aW9ucy5oZXggIT09IGZhbHNlO1xuICAgIHRoaXMubGl0dGxlRW5kaWFuXyA9IG9wdGlvbnMubGl0dGxlRW5kaWFuICE9PSBmYWxzZTtcbiAgICB0aGlzLmV3a2JfID0gb3B0aW9ucy5ld2tiICE9PSBmYWxzZTtcblxuICAgIHRoaXMubGF5b3V0XyA9IG9wdGlvbnMuZ2VvbWV0cnlMYXlvdXQ7IC8vIG51bGwgZm9yIGF1dG8gZGV0ZWN0XG4gICAgdGhpcy5ub2RhdGFaXyA9IG9wdGlvbnMubm9kYXRhWiB8fCAwO1xuICAgIHRoaXMubm9kYXRhTV8gPSBvcHRpb25zLm5vZGF0YU0gfHwgMDtcblxuICAgIHRoaXMuc3JpZF8gPSBvcHRpb25zLnNyaWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlR5cGV9IEZvcm1hdC5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGV4XyA/ICd0ZXh0JyA6ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNpbmdsZSBmZWF0dXJlIGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmUoc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLnJlYWRHZW9tZXRyeShzb3VyY2UsIG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYWxsIGZlYXR1cmVzIGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkRmVhdHVyZXMoc291cmNlLCBvcHRpb25zKSB7XG4gICAgbGV0IGdlb21ldHJpZXMgPSBbXTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucmVhZEdlb21ldHJ5KHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc3BsaXRDb2xsZWN0aW9uICYmIGdlb21ldHJ5IGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb21ldHJpZXMgPSBbZ2VvbWV0cnldO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cmllcy5tYXAoKGdlb21ldHJ5KSA9PiBuZXcgRmVhdHVyZSh7Z2VvbWV0cnl9KSk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNpbmdsZSBnZW9tZXRyeSBmcm9tIGEgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkR2VvbWV0cnkoc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdmlldyA9IGdldERhdGFWaWV3KHNvdXJjZSk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgV2tiUmVhZGVyKHZpZXcpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gcmVhZGVyLnJlYWRHZW9tZXRyeSgpO1xuXG4gICAgdGhpcy52aWV3Q2FjaGVfID0gdmlldzsgLy8gY2FjaGUgZm9yIGludGVybmFsIHN1YnNlcXVlbnQgY2FsbCBvZiByZWFkUHJvamVjdGlvbigpXG4gICAgb3B0aW9ucyA9IHRoaXMuZ2V0UmVhZE9wdGlvbnMoc291cmNlLCBvcHRpb25zKTtcbiAgICB0aGlzLnZpZXdDYWNoZV8gPSBudWxsOyAvLyByZWxlYXNlXG5cbiAgICByZXR1cm4gdHJhbnNmb3JtR2VvbWV0cnlXaXRoT3B0aW9ucyhnZW9tZXRyeSwgZmFsc2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHByb2plY3Rpb24gZnJvbSBhIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBzb3VyY2UgU291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRQcm9qZWN0aW9uKHNvdXJjZSkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZpZXdDYWNoZV8gfHwgZ2V0RGF0YVZpZXcoc291cmNlKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFdrYlJlYWRlcih2aWV3KTtcbiAgICByZWFkZXIucmVhZFdrYkhlYWRlcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChyZWFkZXIuZ2V0U3JpZCgpICYmIGdldFByb2plY3Rpb24oJ0VQU0c6JyArIHJlYWRlci5nZXRTcmlkKCkpKSB8fFxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBmZWF0dXJlIGluIHRoaXMgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlKGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy53cml0ZUdlb21ldHJ5KGZlYXR1cmUuZ2V0R2VvbWV0cnkoKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIHRoaXMgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlcyhmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLndyaXRlR2VvbWV0cnkoXG4gICAgICBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGZlYXR1cmVzLm1hcCgoZikgPT4gZi5nZXRHZW9tZXRyeSgpKSksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpbmdsZSBnZW9tZXRyeSBpbiB0aGlzIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXa2JXcml0ZXIoe1xuICAgICAgbGF5b3V0OiB0aGlzLmxheW91dF8sXG4gICAgICBsaXR0bGVFbmRpYW46IHRoaXMubGl0dGxlRW5kaWFuXyxcbiAgICAgIGV3a2I6IHRoaXMuZXdrYl8sXG5cbiAgICAgIG5vZGF0YToge1xuICAgICAgICBaOiB0aGlzLm5vZGF0YVpfLFxuICAgICAgICBNOiB0aGlzLm5vZGF0YU1fLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIGV4dHJhY3QgU1JJRCBmcm9tIGBkYXRhUHJvamVjdGlvbmBcbiAgICBsZXQgc3JpZCA9IE51bWJlci5pc0ludGVnZXIodGhpcy5zcmlkXykgPyBOdW1iZXIodGhpcy5zcmlkXykgOiBudWxsO1xuICAgIGlmICh0aGlzLnNyaWRfICE9PSBmYWxzZSAmJiAhTnVtYmVyLmlzSW50ZWdlcih0aGlzLnNyaWRfKSkge1xuICAgICAgY29uc3QgZGF0YVByb2plY3Rpb24gPVxuICAgICAgICBvcHRpb25zLmRhdGFQcm9qZWN0aW9uICYmIGdldFByb2plY3Rpb24ob3B0aW9ucy5kYXRhUHJvamVjdGlvbik7XG4gICAgICBpZiAoZGF0YVByb2plY3Rpb24pIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGFQcm9qZWN0aW9uLmdldENvZGUoKTtcbiAgICAgICAgaWYgKGNvZGUuc3RhcnRzV2l0aCgnRVBTRzonKSkge1xuICAgICAgICAgIHNyaWQgPSBOdW1iZXIoY29kZS5zdWJzdHJpbmcoNSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLndyaXRlR2VvbWV0cnkoXG4gICAgICB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCB0cnVlLCBvcHRpb25zKSxcbiAgICAgIHNyaWRcbiAgICApO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHdyaXRlci5nZXRCdWZmZXIoKTtcblxuICAgIHJldHVybiB0aGlzLmhleF8gPyBlbmNvZGVIZXhTdHJpbmcoYnVmZmVyKSA6IGJ1ZmZlcjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBzb3VyY2UgYnVmZmVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGVuY29kZWQgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBlbmNvZGVIZXhTdHJpbmcoYnVmZmVyKSB7XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh2aWV3LnZhbHVlcygpKVxuICAgIC5tYXAoKHgpID0+ICh4IDwgMTYgPyAnMCcgOiAnJykgKyBOdW1iZXIoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpXG4gICAgLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IHNvdXJjZSB0ZXh0XG4gKiBAcmV0dXJuIHtEYXRhVmlld30gZGVjb2RlZCBiaW5hcnkgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUhleFN0cmluZyh0ZXh0KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRleHQubGVuZ3RoIC8gMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBidWZmZXJbaV0gPSBwYXJzZUludCh0ZXh0LnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGFWaWV3KGJ1ZmZlci5idWZmZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXd9IHNvdXJjZSBzb3VyY2VcbiAqIEByZXR1cm4ge0RhdGFWaWV3fSBkYXRhIHZpZXdcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YVZpZXcoc291cmNlKSB7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZWNvZGVIZXhTdHJpbmcoc291cmNlKTtcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgfVxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdLQjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvV0tUXG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBmcm9tICcuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL0xpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL011bHRpTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlQb2ludCBmcm9tICcuLi9nZW9tL011bHRpUG9pbnQuanMnO1xuaW1wb3J0IE11bHRpUG9seWdvbiBmcm9tICcuLi9nZW9tL011bHRpUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IFRleHRGZWF0dXJlIGZyb20gJy4vVGV4dEZlYXR1cmUuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEdlb21ldHJ5IGNvbnN0cnVjdG9yc1xuICogQGVudW0ge2Z1bmN0aW9uIChuZXc6aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0LCBBcnJheSwgaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dCl9XG4gKi9cbmNvbnN0IEdlb21ldHJ5Q29uc3RydWN0b3IgPSB7XG4gICdQT0lOVCc6IFBvaW50LFxuICAnTElORVNUUklORyc6IExpbmVTdHJpbmcsXG4gICdQT0xZR09OJzogUG9seWdvbixcbiAgJ01VTFRJUE9JTlQnOiBNdWx0aVBvaW50LFxuICAnTVVMVElMSU5FU1RSSU5HJzogTXVsdGlMaW5lU3RyaW5nLFxuICAnTVVMVElQT0xZR09OJzogTXVsdGlQb2x5Z29uLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzcGxpdENvbGxlY3Rpb249ZmFsc2VdIFdoZXRoZXIgdG8gc3BsaXQgR2VvbWV0cnlDb2xsZWN0aW9ucyBpbnRvXG4gKiBtdWx0aXBsZSBmZWF0dXJlcyBvbiByZWFkaW5nLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVG9rZW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlIFR5cGUuXG4gKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IFt2YWx1ZV0gVmFsdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb24gUG9zaXRpb24uXG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IEVNUFRZID0gJ0VNUFRZJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFogPSAnWic7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5jb25zdCBNID0gJ00nO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgWk0gPSAnWk0nO1xuXG4vKipcbiAqIEBjb25zdFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgVG9rZW5UeXBlID0ge1xuICBTVEFSVDogMCxcbiAgVEVYVDogMSxcbiAgTEVGVF9QQVJFTjogMixcbiAgUklHSFRfUEFSRU46IDMsXG4gIE5VTUJFUjogNCxcbiAgQ09NTUE6IDUsXG4gIEVPRjogNixcbn07XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIHN0cmluZz59XG4gKi9cbmNvbnN0IHdrdFR5cGVMb29rdXAgPSB7XG4gIFBvaW50OiAnUE9JTlQnLFxuICBMaW5lU3RyaW5nOiAnTElORVNUUklORycsXG4gIFBvbHlnb246ICdQT0xZR09OJyxcbiAgTXVsdGlQb2ludDogJ01VTFRJUE9JTlQnLFxuICBNdWx0aUxpbmVTdHJpbmc6ICdNVUxUSUxJTkVTVFJJTkcnLFxuICBNdWx0aVBvbHlnb246ICdNVUxUSVBPTFlHT04nLFxuICBHZW9tZXRyeUNvbGxlY3Rpb246ICdHRU9NRVRSWUNPTExFQ1RJT04nLFxuICBDaXJjbGU6ICdDSVJDTEUnLFxufTtcblxuLyoqXG4gKiBDbGFzcyB0byB0b2tlbml6ZSBhIFdLVCBzdHJpbmcuXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3a3QgV0tUIHN0cmluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdrdCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy53a3QgPSB3a3Q7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbmRleF8gPSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYyBDaGFyYWN0ZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbHBoYWJldGljLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNBbHBoYV8oYykge1xuICAgIHJldHVybiAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8IChjID49ICdBJyAmJiBjIDw9ICdaJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGMgQ2hhcmFjdGVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNpbWFsXSBXaGV0aGVyIHRoZSBzdHJpbmcgbnVtYmVyXG4gICAqICAgICBjb250YWlucyBhIGRvdCwgaS5lLiBpcyBhIGRlY2ltYWwgbnVtYmVyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgbnVtZXJpYy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTnVtZXJpY18oYywgZGVjaW1hbCkge1xuICAgIGRlY2ltYWwgPSBkZWNpbWFsICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsIDogZmFsc2U7XG4gICAgcmV0dXJuIChjID49ICcwJyAmJiBjIDw9ICc5JykgfHwgKGMgPT0gJy4nICYmICFkZWNpbWFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYyBDaGFyYWN0ZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyB3aGl0ZXNwYWNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNXaGl0ZVNwYWNlXyhjKSB7XG4gICAgcmV0dXJuIGMgPT0gJyAnIHx8IGMgPT0gJ1xcdCcgfHwgYyA9PSAnXFxyJyB8fCBjID09ICdcXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBzdHJpbmcgY2hhcmFjdGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbmV4dENoYXJfKCkge1xuICAgIHJldHVybiB0aGlzLndrdC5jaGFyQXQoKyt0aGlzLmluZGV4Xyk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHJldHVybiB0aGUgbmV4dCB0b2tlbi5cbiAgICogQHJldHVybiB7VG9rZW59IE5leHQgc3RyaW5nIHRva2VuLlxuICAgKi9cbiAgbmV4dFRva2VuKCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLm5leHRDaGFyXygpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleF87XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfSAqL1xuICAgIGxldCB2YWx1ZSA9IGM7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBpZiAoYyA9PSAnKCcpIHtcbiAgICAgIHR5cGUgPSBUb2tlblR5cGUuTEVGVF9QQVJFTjtcbiAgICB9IGVsc2UgaWYgKGMgPT0gJywnKSB7XG4gICAgICB0eXBlID0gVG9rZW5UeXBlLkNPTU1BO1xuICAgIH0gZWxzZSBpZiAoYyA9PSAnKScpIHtcbiAgICAgIHR5cGUgPSBUb2tlblR5cGUuUklHSFRfUEFSRU47XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTnVtZXJpY18oYykgfHwgYyA9PSAnLScpIHtcbiAgICAgIHR5cGUgPSBUb2tlblR5cGUuTlVNQkVSO1xuICAgICAgdmFsdWUgPSB0aGlzLnJlYWROdW1iZXJfKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQWxwaGFfKGMpKSB7XG4gICAgICB0eXBlID0gVG9rZW5UeXBlLlRFWFQ7XG4gICAgICB2YWx1ZSA9IHRoaXMucmVhZFRleHRfKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzV2hpdGVTcGFjZV8oYykpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gJycpIHtcbiAgICAgIHR5cGUgPSBUb2tlblR5cGUuRU9GO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnICsgYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtwb3NpdGlvbjogcG9zaXRpb24sIHZhbHVlOiB2YWx1ZSwgdHlwZTogdHlwZX07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1lcmljIHRva2VuIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVhZE51bWJlcl8oKSB7XG4gICAgbGV0IGM7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4XztcbiAgICBsZXQgZGVjaW1hbCA9IGZhbHNlO1xuICAgIGxldCBzY2llbnRpZmljTm90YXRpb24gPSBmYWxzZTtcbiAgICBkbyB7XG4gICAgICBpZiAoYyA9PSAnLicpIHtcbiAgICAgICAgZGVjaW1hbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGMgPT0gJ2UnIHx8IGMgPT0gJ0UnKSB7XG4gICAgICAgIHNjaWVudGlmaWNOb3RhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBjID0gdGhpcy5uZXh0Q2hhcl8oKTtcbiAgICB9IHdoaWxlIChcbiAgICAgIHRoaXMuaXNOdW1lcmljXyhjLCBkZWNpbWFsKSB8fFxuICAgICAgLy8gaWYgd2UgaGF2ZW4ndCBkZXRlY3RlZCBhIHNjaWVudGlmaWMgbnVtYmVyIGJlZm9yZSwgJ2UnIG9yICdFJ1xuICAgICAgLy8gaGludCB0aGF0IHdlIHNob3VsZCBjb250aW51ZSB0byByZWFkXG4gICAgICAoIXNjaWVudGlmaWNOb3RhdGlvbiAmJiAoYyA9PSAnZScgfHwgYyA9PSAnRScpKSB8fFxuICAgICAgLy8gb25jZSB3ZSBrbm93IHRoYXQgd2UgaGF2ZSBhIHNjaWVudGlmaWMgbnVtYmVyLCBib3RoICctJyBhbmQgJysnXG4gICAgICAvLyBhcmUgYWxsb3dlZFxuICAgICAgKHNjaWVudGlmaWNOb3RhdGlvbiAmJiAoYyA9PSAnLScgfHwgYyA9PSAnKycpKVxuICAgICk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy53a3Quc3Vic3RyaW5nKGluZGV4LCB0aGlzLmluZGV4Xy0tKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgdG9rZW4gdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWFkVGV4dF8oKSB7XG4gICAgbGV0IGM7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4XztcbiAgICBkbyB7XG4gICAgICBjID0gdGhpcy5uZXh0Q2hhcl8oKTtcbiAgICB9IHdoaWxlICh0aGlzLmlzQWxwaGFfKGMpKTtcbiAgICByZXR1cm4gdGhpcy53a3Quc3Vic3RyaW5nKGluZGV4LCB0aGlzLmluZGV4Xy0tKS50b1VwcGVyQ2FzZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdG8gcGFyc2UgdGhlIHRva2VucyBmcm9tIHRoZSBXS1Qgc3RyaW5nLlxuICovXG5jbGFzcyBQYXJzZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMZXhlcn0gbGV4ZXIgVGhlIGxleGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGV4ZXIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TGV4ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxleGVyXyA9IGxleGVyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Rva2VufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50b2tlbl8gPSB7XG4gICAgICBwb3NpdGlvbjogMCxcbiAgICAgIHR5cGU6IFRva2VuVHlwZS5TVEFSVCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxheW91dF8gPSAnWFknO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBuZXh0IHRva2VuIGZvcm0gdGhlIGxleGVyIGFuZCByZXBsYWNlIHRoZSBhY3RpdmUgdG9rZW4uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lXygpIHtcbiAgICB0aGlzLnRva2VuXyA9IHRoaXMubGV4ZXJfLm5leHRUb2tlbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoZSBnaXZlbiB0eXBlIG1hdGNoZXMgdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAqIEBwYXJhbSB7VG9rZW5UeXBlfSB0eXBlIFRva2VuIHR5cGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIG1hdGNoZXMgdGhlIGdpdmVuIHR5cGUuXG4gICAqL1xuICBpc1Rva2VuVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5fLnR5cGUgPT0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgZ2l2ZW4gdHlwZSBtYXRjaGVzIHRoZSBjdXJyZW50IHRva2VuLCBjb25zdW1lIGl0LlxuICAgKiBAcGFyYW0ge1Rva2VuVHlwZX0gdHlwZSBUb2tlbiB0eXBlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0b2tlbiBtYXRjaGVzIHRoZSBnaXZlbiB0eXBlLlxuICAgKi9cbiAgbWF0Y2godHlwZSkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0aGlzLmlzVG9rZW5UeXBlKHR5cGUpO1xuICAgIGlmIChpc01hdGNoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVfKCk7XG4gICAgfVxuICAgIHJldHVybiBpc01hdGNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBwYXJzZSB0aGUgdG9rZW5zIHByb3ZpZGVkIGJ5IHRoZSBsZXhlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBUaGUgZ2VvbWV0cnkuXG4gICAqL1xuICBwYXJzZSgpIHtcbiAgICB0aGlzLmNvbnN1bWVfKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VHZW9tZXRyeV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gcGFyc2UgdGhlIGRpbWVuc2lvbmFsIGluZm8uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFRoZSBsYXlvdXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZUdlb21ldHJ5TGF5b3V0XygpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9ICovXG4gICAgbGV0IGxheW91dCA9ICdYWSc7XG4gICAgY29uc3QgZGltVG9rZW4gPSB0aGlzLnRva2VuXztcbiAgICBpZiAodGhpcy5pc1Rva2VuVHlwZShUb2tlblR5cGUuVEVYVCkpIHtcbiAgICAgIGNvbnN0IGRpbUluZm8gPSBkaW1Ub2tlbi52YWx1ZTtcbiAgICAgIGlmIChkaW1JbmZvID09PSBaKSB7XG4gICAgICAgIGxheW91dCA9ICdYWVonO1xuICAgICAgfSBlbHNlIGlmIChkaW1JbmZvID09PSBNKSB7XG4gICAgICAgIGxheW91dCA9ICdYWU0nO1xuICAgICAgfSBlbHNlIGlmIChkaW1JbmZvID09PSBaTSkge1xuICAgICAgICBsYXlvdXQgPSAnWFlaTSc7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0ICE9PSAnWFknKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZV8oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHQ+fSBBIGNvbGxlY3Rpb24gb2YgZ2VvbWV0cmllcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlR2VvbWV0cnlDb2xsZWN0aW9uVGV4dF8oKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goVG9rZW5UeXBlLkxFRlRfUEFSRU4pKSB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gW107XG4gICAgICBkbyB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaCh0aGlzLnBhcnNlR2VvbWV0cnlfKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5tYXRjaChUb2tlblR5cGUuQ09NTUEpKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5SSUdIVF9QQVJFTikpIHtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJpZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQWxsIHZhbHVlcyBpbiBhIHBvaW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2VQb2ludFRleHRfKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5MRUZUX1BBUkVOKSkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlUG9pbnRfKCk7XG4gICAgICBpZiAodGhpcy5tYXRjaChUb2tlblR5cGUuUklHSFRfUEFSRU4pKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZm9ybWF0RXJyb3JNZXNzYWdlXygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQWxsIHBvaW50cyBpbiBhIGxpbmVzdHJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZUxpbmVTdHJpbmdUZXh0XygpIHtcbiAgICBpZiAodGhpcy5tYXRjaChUb2tlblR5cGUuTEVGVF9QQVJFTikpIHtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZVBvaW50TGlzdF8oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5SSUdIVF9QQVJFTikpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gQWxsIHBvaW50cyBpbiBhIHBvbHlnb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZVBvbHlnb25UZXh0XygpIHtcbiAgICBpZiAodGhpcy5tYXRjaChUb2tlblR5cGUuTEVGVF9QQVJFTikpIHtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0TGlzdF8oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5SSUdIVF9QQVJFTikpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBBbGwgcG9pbnRzIGluIGEgbXVsdGlwb2ludC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlTXVsdGlQb2ludFRleHRfKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5MRUZUX1BBUkVOKSkge1xuICAgICAgbGV0IGNvb3JkaW5hdGVzO1xuICAgICAgaWYgKHRoaXMudG9rZW5fLnR5cGUgPT0gVG9rZW5UeXBlLkxFRlRfUEFSRU4pIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlUG9pbnRUZXh0TGlzdF8oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZVBvaW50TGlzdF8oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5SSUdIVF9QQVJFTikpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gQWxsIGxpbmVzdHJpbmcgcG9pbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gYSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZU11bHRpTGluZVN0cmluZ1RleHRfKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5MRUZUX1BBUkVOKSkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goVG9rZW5UeXBlLlJJR0hUX1BBUkVOKSkge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gQWxsIHBvbHlnb24gcG9pbnRzIGluIGEgbXVsdGlwb2x5Z29uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcGFyc2VNdWx0aVBvbHlnb25UZXh0XygpIHtcbiAgICBpZiAodGhpcy5tYXRjaChUb2tlblR5cGUuTEVGVF9QQVJFTikpIHtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZVBvbHlnb25UZXh0TGlzdF8oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKFRva2VuVHlwZS5SSUdIVF9QQVJFTikpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEEgcG9pbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZVBvaW50XygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmxheW91dF8ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltZW5zaW9uczsgKytpKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5fO1xuICAgICAgaWYgKHRoaXMubWF0Y2goVG9rZW5UeXBlLk5VTUJFUikpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaCgvKiogQHR5cGUge251bWJlcn0gKi8gKHRva2VuLnZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PSBkaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yTWVzc2FnZV8oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEFuIGFycmF5IG9mIHBvaW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlUG9pbnRMaXN0XygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFt0aGlzLnBhcnNlUG9pbnRfKCldO1xuICAgIHdoaWxlICh0aGlzLm1hdGNoKFRva2VuVHlwZS5DT01NQSkpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2godGhpcy5wYXJzZVBvaW50XygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBBbiBhcnJheSBvZiBwb2ludHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZVBvaW50VGV4dExpc3RfKCkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW3RoaXMucGFyc2VQb2ludFRleHRfKCldO1xuICAgIHdoaWxlICh0aGlzLm1hdGNoKFRva2VuVHlwZS5DT01NQSkpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2godGhpcy5wYXJzZVBvaW50VGV4dF8oKSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IEFuIGFycmF5IG9mIHBvaW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlTGluZVN0cmluZ1RleHRMaXN0XygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFt0aGlzLnBhcnNlTGluZVN0cmluZ1RleHRfKCldO1xuICAgIHdoaWxlICh0aGlzLm1hdGNoKFRva2VuVHlwZS5DT01NQSkpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2godGhpcy5wYXJzZUxpbmVTdHJpbmdUZXh0XygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pj59IEFuIGFycmF5IG9mIHBvaW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlUG9seWdvblRleHRMaXN0XygpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IFt0aGlzLnBhcnNlUG9seWdvblRleHRfKCldO1xuICAgIHdoaWxlICh0aGlzLm1hdGNoKFRva2VuVHlwZS5DT01NQSkpIHtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2godGhpcy5wYXJzZVBvbHlnb25UZXh0XygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIGltcGxpZXMgYW4gZW1wdHkgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0VtcHR5R2VvbWV0cnlfKCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPVxuICAgICAgdGhpcy5pc1Rva2VuVHlwZShUb2tlblR5cGUuVEVYVCkgJiYgdGhpcy50b2tlbl8udmFsdWUgPT0gRU1QVFk7XG4gICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgIHRoaXMuY29uc3VtZV8oKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRW1wdHk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVycm9yIG1lc3NhZ2UgZm9yIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRXJyb3IgbWVzc2FnZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZvcm1hdEVycm9yTWVzc2FnZV8oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdVbmV4cGVjdGVkIGAnICtcbiAgICAgIHRoaXMudG9rZW5fLnZhbHVlICtcbiAgICAgICdgIGF0IHBvc2l0aW9uICcgK1xuICAgICAgdGhpcy50b2tlbl8ucG9zaXRpb24gK1xuICAgICAgJyBpbiBgJyArXG4gICAgICB0aGlzLmxleGVyXy53a3QgK1xuICAgICAgJ2AnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IFRoZSBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBhcnNlR2VvbWV0cnlfKCkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbl87XG4gICAgaWYgKHRoaXMubWF0Y2goVG9rZW5UeXBlLlRFWFQpKSB7XG4gICAgICBjb25zdCBnZW9tVHlwZSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodG9rZW4udmFsdWUpO1xuICAgICAgdGhpcy5sYXlvdXRfID0gdGhpcy5wYXJzZUdlb21ldHJ5TGF5b3V0XygpO1xuICAgICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuaXNFbXB0eUdlb21ldHJ5XygpO1xuICAgICAgaWYgKGdlb21UeXBlID09ICdHRU9NRVRSWUNPTExFQ1RJT04nKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cnlDb2xsZWN0aW9uVGV4dF8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdG9yID0gR2VvbWV0cnlDb25zdHJ1Y3RvcltnZW9tVHlwZV07XG4gICAgICBpZiAoIWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdlb21ldHJ5IHR5cGU6ICcgKyBnZW9tVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb29yZGluYXRlcztcblxuICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgaWYgKGdlb21UeXBlID09ICdQT0lOVCcpIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IFtOYU4sIE5hTl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChnZW9tVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ1BPSU5UJzoge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlUG9pbnRUZXh0XygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0xJTkVTVFJJTkcnOiB7XG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHRoaXMucGFyc2VMaW5lU3RyaW5nVGV4dF8oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQT0xZR09OJzoge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlUG9seWdvblRleHRfKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnTVVMVElQT0lOVCc6IHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZU11bHRpUG9pbnRUZXh0XygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ01VTFRJTElORVNUUklORyc6IHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZU11bHRpTGluZVN0cmluZ1RleHRfKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnTVVMVElQT0xZR09OJzoge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnBhcnNlTXVsdGlQb2x5Z29uVGV4dF8oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjdG9yKGNvb3JkaW5hdGVzLCB0aGlzLmxheW91dF8pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5mb3JtYXRFcnJvck1lc3NhZ2VfKCkpO1xuICB9XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogR2VvbWV0cnkgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIGBXZWxsS25vd25UZXh0YCAoV0tUKVxuICogZm9ybWF0LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgV0tUIGV4dGVuZHMgVGV4dEZlYXR1cmUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBHZW9tZXRyeUNvbGxlY3Rpb24gaW50byBtdWx0aXBsZSBmZWF0dXJlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3BsaXRDb2xsZWN0aW9uXyA9XG4gICAgICBvcHRpb25zLnNwbGl0Q29sbGVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zcGxpdENvbGxlY3Rpb24gOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIFdLVCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3a3QgV0tUIHN0cmluZy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fVxuICAgKiAgICAgVGhlIGdlb21ldHJ5IGNyZWF0ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwYXJzZV8od2t0KSB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIod2t0KTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxleGVyKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZ2VvbSA9IHRoaXMucmVhZEdlb21ldHJ5RnJvbVRleHQodGV4dCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKCk7XG4gICAgZmVhdHVyZS5zZXRHZW9tZXRyeShnZW9tKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxGZWF0dXJlPn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGdlb21ldHJpZXMgPSBbXTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucmVhZEdlb21ldHJ5RnJvbVRleHQodGV4dCwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc3BsaXRDb2xsZWN0aW9uXyAmJiBnZW9tZXRyeS5nZXRUeXBlKCkgPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge0dlb21ldHJ5Q29sbGVjdGlvbn0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvbWV0cmllcyA9IFtnZW9tZXRyeV07XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoKTtcbiAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbWV0cmllc1tpXSk7XG4gICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIHJlYWRHZW9tZXRyeUZyb21UZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucGFyc2VfKHRleHQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCBmYWxzZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUZXh0LlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlVGV4dChmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZUdlb21ldHJ5VGV4dChnZW9tZXRyeSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGV4dC5cbiAgICovXG4gIHdyaXRlRmVhdHVyZXNUZXh0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZUZlYXR1cmVUZXh0KGZlYXR1cmVzWzBdLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGdlb21ldHJpZXMucHVzaChmZWF0dXJlc1tpXS5nZXRHZW9tZXRyeSgpKTtcbiAgICB9XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcyk7XG4gICAgcmV0dXJuIHRoaXMud3JpdGVHZW9tZXRyeVRleHQoY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGV4dC5cbiAgICovXG4gIHdyaXRlR2VvbWV0cnlUZXh0KGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVuY29kZSh0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zKGdlb21ldHJ5LCB0cnVlLCBvcHRpb25zKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50fSBnZW9tIFBvaW50IGdlb21ldHJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBDb29yZGluYXRlcyBwYXJ0IG9mIFBvaW50IGFzIFdLVC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlUG9pbnRHZW9tZXRyeShnZW9tKSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2VvbS5nZXRDb29yZGluYXRlcygpO1xuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBjb29yZGluYXRlcy5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aVBvaW50fSBnZW9tIE11bHRpUG9pbnQgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvb3JkaW5hdGVzIHBhcnQgb2YgTXVsdGlQb2ludCBhcyBXS1QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZU11bHRpUG9pbnRHZW9tZXRyeShnZW9tKSB7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZW9tLmdldFBvaW50cygpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBhcnJheS5wdXNoKCcoJyArIGVuY29kZVBvaW50R2VvbWV0cnkoY29tcG9uZW50c1tpXSkgKyAnKScpO1xuICB9XG4gIHJldHVybiBhcnJheS5qb2luKCcsJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtHZW9tZXRyeUNvbGxlY3Rpb259IGdlb20gR2VvbWV0cnlDb2xsZWN0aW9uIGdlb21ldHJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBDb29yZGluYXRlcyBwYXJ0IG9mIEdlb21ldHJ5Q29sbGVjdGlvbiBhcyBXS1QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5KGdlb20pIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgY29uc3QgZ2VvbXMgPSBnZW9tLmdldEdlb21ldHJpZXMoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGFycmF5LnB1c2goZW5jb2RlKGdlb21zW2ldKSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LmpvaW4oJywnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVTdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9MaW5lYXJSaW5nLmpzXCIpLmRlZmF1bHR9IGdlb20gTGluZVN0cmluZyBnZW9tZXRyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29vcmRpbmF0ZXMgcGFydCBvZiBMaW5lU3RyaW5nIGFzIFdLVC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlTGluZVN0cmluZ0dlb21ldHJ5KGdlb20pIHtcbiAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZW9tLmdldENvb3JkaW5hdGVzKCk7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBhcnJheS5wdXNoKGNvb3JkaW5hdGVzW2ldLmpvaW4oJyAnKSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LmpvaW4oJywnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge011bHRpTGluZVN0cmluZ30gZ2VvbSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvb3JkaW5hdGVzIHBhcnQgb2YgTXVsdGlMaW5lU3RyaW5nIGFzIFdLVC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkoZ2VvbSkge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2VvbS5nZXRMaW5lU3RyaW5ncygpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBhcnJheS5wdXNoKCcoJyArIGVuY29kZUxpbmVTdHJpbmdHZW9tZXRyeShjb21wb25lbnRzW2ldKSArICcpJyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LmpvaW4oJywnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvbHlnb259IGdlb20gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29vcmRpbmF0ZXMgcGFydCBvZiBQb2x5Z29uIGFzIFdLVC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlUG9seWdvbkdlb21ldHJ5KGdlb20pIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgY29uc3QgcmluZ3MgPSBnZW9tLmdldExpbmVhclJpbmdzKCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBhcnJheS5wdXNoKCcoJyArIGVuY29kZUxpbmVTdHJpbmdHZW9tZXRyeShyaW5nc1tpXSkgKyAnKScpO1xuICB9XG4gIHJldHVybiBhcnJheS5qb2luKCcsJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aVBvbHlnb259IGdlb20gTXVsdGlQb2x5Z29uIGdlb21ldHJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBDb29yZGluYXRlcyBwYXJ0IG9mIE11bHRpUG9seWdvbiBhcyBXS1QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZU11bHRpUG9seWdvbkdlb21ldHJ5KGdlb20pIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdlb20uZ2V0UG9seWdvbnMoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgYXJyYXkucHVzaCgnKCcgKyBlbmNvZGVQb2x5Z29uR2VvbWV0cnkoY29tcG9uZW50c1tpXSkgKyAnKScpO1xuICB9XG4gIHJldHVybiBhcnJheS5qb2luKCcsJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb20gU2ltcGxlR2VvbWV0cnkgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFBvdGVudGlhbCBkaW1lbnNpb25hbCBpbmZvcm1hdGlvbiBmb3IgV0tUIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUdlb21ldHJ5TGF5b3V0KGdlb20pIHtcbiAgY29uc3QgbGF5b3V0ID0gZ2VvbS5nZXRMYXlvdXQoKTtcbiAgbGV0IGRpbUluZm8gPSAnJztcbiAgaWYgKGxheW91dCA9PT0gJ1hZWicgfHwgbGF5b3V0ID09PSAnWFlaTScpIHtcbiAgICBkaW1JbmZvICs9IFo7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gJ1hZTScgfHwgbGF5b3V0ID09PSAnWFlaTScpIHtcbiAgICBkaW1JbmZvICs9IE07XG4gIH1cbiAgcmV0dXJuIGRpbUluZm87XG59XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0KTogc3RyaW5nPn1cbiAqL1xuY29uc3QgR2VvbWV0cnlFbmNvZGVyID0ge1xuICAnUG9pbnQnOiBlbmNvZGVQb2ludEdlb21ldHJ5LFxuICAnTGluZVN0cmluZyc6IGVuY29kZUxpbmVTdHJpbmdHZW9tZXRyeSxcbiAgJ1BvbHlnb24nOiBlbmNvZGVQb2x5Z29uR2VvbWV0cnksXG4gICdNdWx0aVBvaW50JzogZW5jb2RlTXVsdGlQb2ludEdlb21ldHJ5LFxuICAnTXVsdGlMaW5lU3RyaW5nJzogZW5jb2RlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksXG4gICdNdWx0aVBvbHlnb24nOiBlbmNvZGVNdWx0aVBvbHlnb25HZW9tZXRyeSxcbiAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IGVuY29kZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5LFxufTtcblxuLyoqXG4gKiBFbmNvZGUgYSBnZW9tZXRyeSBhcyBXS1QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbSBUaGUgZ2VvbWV0cnkgdG8gZW5jb2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBXS1Qgc3RyaW5nIGZvciB0aGUgZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShnZW9tKSB7XG4gIGNvbnN0IHR5cGUgPSBnZW9tLmdldFR5cGUoKTtcbiAgY29uc3QgZ2VvbWV0cnlFbmNvZGVyID0gR2VvbWV0cnlFbmNvZGVyW3R5cGVdO1xuICBjb25zdCBlbmMgPSBnZW9tZXRyeUVuY29kZXIoZ2VvbSk7XG4gIGxldCB3a3RUeXBlID0gd2t0VHlwZUxvb2t1cFt0eXBlXTtcbiAgaWYgKHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbSkuZ2V0RmxhdENvb3JkaW5hdGVzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGRpbUluZm8gPSBlbmNvZGVHZW9tZXRyeUxheW91dChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbSlcbiAgICApO1xuICAgIGlmIChkaW1JbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgIHdrdFR5cGUgKz0gJyAnICsgZGltSW5mbztcbiAgICB9XG4gIH1cbiAgaWYgKGVuYy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gd2t0VHlwZSArICcgJyArIEVNUFRZO1xuICB9XG4gIHJldHVybiB3a3RUeXBlICsgJygnICsgZW5jICsgJyknO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXS1Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L1dNU0NhcGFiaWxpdGllc1xuICovXG5pbXBvcnQgWE1MIGZyb20gJy4vWE1MLmpzJztcbmltcG9ydCB7XG4gIG1ha2VBcnJheVB1c2hlcixcbiAgbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyLFxuICBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIsXG4gIG1ha2VTdHJ1Y3R1cmVOUyxcbiAgcHVzaFBhcnNlQW5kUG9wLFxufSBmcm9tICcuLi94bWwuanMnO1xuaW1wb3J0IHtcbiAgcmVhZEJvb2xlYW5TdHJpbmcsXG4gIHJlYWREZWNpbWFsLFxuICByZWFkRGVjaW1hbFN0cmluZyxcbiAgcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyxcbiAgcmVhZFBvc2l0aXZlSW50ZWdlcixcbiAgcmVhZFN0cmluZyxcbn0gZnJvbSAnLi94c2QuanMnO1xuaW1wb3J0IHtyZWFkSHJlZn0gZnJvbSAnLi94bGluay5qcyc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8bnVsbHxzdHJpbmc+fVxuICovXG5jb25zdCBOQU1FU1BBQ0VfVVJJUyA9IFtudWxsLCAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93bXMnXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFBBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ1NlcnZpY2UnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFNlcnZpY2UpLFxuICAnQ2FwYWJpbGl0eSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQ2FwYWJpbGl0eSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IENBUEFCSUxJVFlfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnUmVxdWVzdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUmVxdWVzdCksXG4gICdFeGNlcHRpb24nOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEV4Y2VwdGlvbiksXG4gICdMYXllcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQ2FwYWJpbGl0eUxheWVyKSxcbn0pO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvcm1hdCBmb3IgcmVhZGluZyBXTVMgY2FwYWJpbGl0aWVzIGRhdGFcbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFdNU0NhcGFiaWxpdGllcyBleHRlbmRzIFhNTCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0XG4gICAqL1xuICByZWFkRnJvbU5vZGUobm9kZSkge1xuICAgIHRoaXMudmVyc2lvbiA9IG5vZGUuZ2V0QXR0cmlidXRlKCd2ZXJzaW9uJykudHJpbSgpO1xuICAgIGNvbnN0IHdtc0NhcGFiaWxpdHlPYmplY3QgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICB7XG4gICAgICAgICd2ZXJzaW9uJzogdGhpcy52ZXJzaW9uLFxuICAgICAgfSxcbiAgICAgIFBBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgW11cbiAgICApO1xuICAgIHJldHVybiB3bXNDYXBhYmlsaXR5T2JqZWN0ID8gd21zQ2FwYWJpbGl0eU9iamVjdCA6IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFNFUlZJQ0VfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTmFtZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ1RpdGxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQWJzdHJhY3QnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdLZXl3b3JkTGlzdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkS2V5d29yZExpc3QpLFxuICAnT25saW5lUmVzb3VyY2UnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEhyZWYpLFxuICAnQ29udGFjdEluZm9ybWF0aW9uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb250YWN0SW5mb3JtYXRpb24pLFxuICAnRmVlcyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ0FjY2Vzc0NvbnN0cmFpbnRzJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnTGF5ZXJMaW1pdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgJ01heFdpZHRoJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAnTWF4SGVpZ2h0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBDT05UQUNUX0lORk9STUFUSU9OX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0NvbnRhY3RQZXJzb25QcmltYXJ5JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb250YWN0UGVyc29uUHJpbWFyeSksXG4gICdDb250YWN0UG9zaXRpb24nOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdDb250YWN0QWRkcmVzcyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkQ29udGFjdEFkZHJlc3MpLFxuICAnQ29udGFjdFZvaWNlVGVsZXBob25lJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQ29udGFjdEZhY3NpbWlsZVRlbGVwaG9uZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ0NvbnRhY3RFbGVjdHJvbmljTWFpbEFkZHJlc3MnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IENPTlRBQ1RfUEVSU09OX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0NvbnRhY3RQZXJzb24nOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdDb250YWN0T3JnYW5pemF0aW9uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBDT05UQUNUX0FERFJFU1NfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnQWRkcmVzc1R5cGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdBZGRyZXNzJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQ2l0eSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ1N0YXRlT3JQcm92aW5jZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ1Bvc3RDb2RlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQ291bnRyeSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgRVhDRVBUSU9OX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0Zvcm1hdCc6IG1ha2VBcnJheVB1c2hlcihyZWFkU3RyaW5nKSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgTEFZRVJfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTmFtZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ1RpdGxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnQWJzdHJhY3QnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdLZXl3b3JkTGlzdCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkS2V5d29yZExpc3QpLFxuICAnQ1JTJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRTdHJpbmcpLFxuICAnRVhfR2VvZ3JhcGhpY0JvdW5kaW5nQm94JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKFxuICAgIHJlYWRFWEdlb2dyYXBoaWNCb3VuZGluZ0JveFxuICApLFxuICAnQm91bmRpbmdCb3gnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZEJvdW5kaW5nQm94KSxcbiAgJ0RpbWVuc2lvbic6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkRGltZW5zaW9uKSxcbiAgJ0F0dHJpYnV0aW9uJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRBdHRyaWJ1dGlvbiksXG4gICdBdXRob3JpdHlVUkwnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZEF1dGhvcml0eVVSTCksXG4gICdJZGVudGlmaWVyJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRTdHJpbmcpLFxuICAnTWV0YWRhdGFVUkwnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZE1ldGFkYXRhVVJMKSxcbiAgJ0RhdGFVUkwnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZEZvcm1hdE9ubGluZXJlc291cmNlKSxcbiAgJ0ZlYXR1cmVMaXN0VVJMJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRGb3JtYXRPbmxpbmVyZXNvdXJjZSksXG4gICdTdHlsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkU3R5bGUpLFxuICAnTWluU2NhbGVEZW5vbWluYXRvcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdNYXhTY2FsZURlbm9taW5hdG9yJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ0xheWVyJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRMYXllciksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEFUVFJJQlVUSU9OX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ1RpdGxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnT25saW5lUmVzb3VyY2UnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEhyZWYpLFxuICAnTG9nb1VSTCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU2l6ZWRGb3JtYXRPbmxpbmVyZXNvdXJjZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEVYX0dFT0dSQVBISUNfQk9VTkRJTkdfQk9YX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ3dlc3RCb3VuZExvbmdpdHVkZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG4gICdlYXN0Qm91bmRMb25naXR1ZGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAnc291dGhCb3VuZExhdGl0dWRlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWREZWNpbWFsKSxcbiAgJ25vcnRoQm91bmRMYXRpdHVkZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkRGVjaW1hbCksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFJFUVVFU1RfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnR2V0Q2FwYWJpbGl0aWVzJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRPcGVyYXRpb25UeXBlKSxcbiAgJ0dldE1hcCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkT3BlcmF0aW9uVHlwZSksXG4gICdHZXRGZWF0dXJlSW5mbyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkT3BlcmF0aW9uVHlwZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IE9QRVJBVElPTlRZUEVfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnRm9ybWF0JzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRTdHJpbmcpLFxuICAnRENQVHlwZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkRENQVHlwZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IERDUFRZUEVfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnSFRUUCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkSFRUUCksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEhUVFBfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnR2V0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRGb3JtYXRPbmxpbmVyZXNvdXJjZSksXG4gICdQb3N0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRGb3JtYXRPbmxpbmVyZXNvdXJjZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFNUWUxFX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ05hbWUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdUaXRsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ0Fic3RyYWN0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnTGVnZW5kVVJMJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRTaXplZEZvcm1hdE9ubGluZXJlc291cmNlKSxcbiAgJ1N0eWxlU2hlZXRVUkwnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEZvcm1hdE9ubGluZXJlc291cmNlKSxcbiAgJ1N0eWxlVVJMJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRGb3JtYXRPbmxpbmVyZXNvdXJjZSksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEZPUk1BVF9PTkxJTkVSRVNPVVJDRV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdGb3JtYXQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICdPbmxpbmVSZXNvdXJjZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkSHJlZiksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IEtFWVdPUkRMSVNUX1BBUlNFUlMgPSBtYWtlU3RydWN0dXJlTlMoTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0tleXdvcmQnOiBtYWtlQXJyYXlQdXNoZXIocmVhZFN0cmluZyksXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IEF0dHJpYnV0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEF0dHJpYnV0aW9uKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIEFUVFJJQlVUSU9OX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdH0gQm91bmRpbmcgYm94IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEJvdW5kaW5nQm94KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGV4dGVudCA9IFtcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbWlueCcpKSxcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbWlueScpKSxcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbWF4eCcpKSxcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbWF4eScpKSxcbiAgXTtcblxuICBjb25zdCByZXNvbHV0aW9ucyA9IFtcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgncmVzeCcpKSxcbiAgICByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgncmVzeScpKSxcbiAgXTtcblxuICByZXR1cm4ge1xuICAgICdjcnMnOiBub2RlLmdldEF0dHJpYnV0ZSgnQ1JTJyksXG4gICAgJ2V4dGVudCc6IGV4dGVudCxcbiAgICAncmVzJzogcmVzb2x1dGlvbnMsXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gQm91bmRpbmcgYm94IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEVYR2VvZ3JhcGhpY0JvdW5kaW5nQm94KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGdlb2dyYXBoaWNCb3VuZGluZ0JveCA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICB7fSxcbiAgICBFWF9HRU9HUkFQSElDX0JPVU5ESU5HX0JPWF9QQVJTRVJTLFxuICAgIG5vZGUsXG4gICAgb2JqZWN0U3RhY2tcbiAgKTtcbiAgaWYgKCFnZW9ncmFwaGljQm91bmRpbmdCb3gpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHdlc3RCb3VuZExvbmdpdHVkZSA9XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgIChnZW9ncmFwaGljQm91bmRpbmdCb3hbJ3dlc3RCb3VuZExvbmdpdHVkZSddKTtcbiAgY29uc3Qgc291dGhCb3VuZExhdGl0dWRlID1cbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgKGdlb2dyYXBoaWNCb3VuZGluZ0JveFsnc291dGhCb3VuZExhdGl0dWRlJ10pO1xuICBjb25zdCBlYXN0Qm91bmRMb25naXR1ZGUgPVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICAoZ2VvZ3JhcGhpY0JvdW5kaW5nQm94WydlYXN0Qm91bmRMb25naXR1ZGUnXSk7XG4gIGNvbnN0IG5vcnRoQm91bmRMYXRpdHVkZSA9XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgIChnZW9ncmFwaGljQm91bmRpbmdCb3hbJ25vcnRoQm91bmRMYXRpdHVkZSddKTtcbiAgaWYgKFxuICAgIHdlc3RCb3VuZExvbmdpdHVkZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgc291dGhCb3VuZExhdGl0dWRlID09PSB1bmRlZmluZWQgfHxcbiAgICBlYXN0Qm91bmRMb25naXR1ZGUgPT09IHVuZGVmaW5lZCB8fFxuICAgIG5vcnRoQm91bmRMYXRpdHVkZSA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB3ZXN0Qm91bmRMb25naXR1ZGUsXG4gICAgc291dGhCb3VuZExhdGl0dWRlLFxuICAgIGVhc3RCb3VuZExvbmdpdHVkZSxcbiAgICBub3J0aEJvdW5kTGF0aXR1ZGUsXG4gIF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBDYXBhYmlsaXR5IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZENhcGFiaWxpdHkobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgQ0FQQUJJTElUWV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBTZXJ2aWNlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFNlcnZpY2Uobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgU0VSVklDRV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBDb250YWN0IGluZm9ybWF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZENvbnRhY3RJbmZvcm1hdGlvbihub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBDT05UQUNUX0lORk9STUFUSU9OX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IENvbnRhY3QgcGVyc29uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZENvbnRhY3RQZXJzb25QcmltYXJ5KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIENPTlRBQ1RfUEVSU09OX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IENvbnRhY3QgYWRkcmVzcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRDb250YWN0QWRkcmVzcyhub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBDT05UQUNUX0FERFJFU1NfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IEZvcm1hdCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVhZEV4Y2VwdGlvbihub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKFtdLCBFWENFUFRJT05fUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gTGF5ZXIgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkQ2FwYWJpbGl0eUxheWVyKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGxheWVyT2JqZWN0ID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBMQVlFUl9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG5cbiAgaWYgKGxheWVyT2JqZWN0WydMYXllciddID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihsYXllck9iamVjdCwgcmVhZExheWVyKG5vZGUsIG9iamVjdFN0YWNrKSk7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJPYmplY3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBMYXllciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRMYXllcihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBwYXJlbnRMYXllck9iamVjdCA9IC8qKiAgQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCo+fSAqLyAoXG4gICAgb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV1cbiAgKTtcblxuICBjb25zdCBsYXllck9iamVjdCA9IHB1c2hQYXJzZUFuZFBvcCh7fSwgTEFZRVJfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xuXG4gIGlmICghbGF5ZXJPYmplY3QpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBxdWVyeWFibGUgPSByZWFkQm9vbGVhblN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgncXVlcnlhYmxlJykpO1xuICBpZiAocXVlcnlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICBxdWVyeWFibGUgPSBwYXJlbnRMYXllck9iamVjdFsncXVlcnlhYmxlJ107XG4gIH1cbiAgbGF5ZXJPYmplY3RbJ3F1ZXJ5YWJsZSddID0gcXVlcnlhYmxlICE9PSB1bmRlZmluZWQgPyBxdWVyeWFibGUgOiBmYWxzZTtcblxuICBsZXQgY2FzY2FkZWQgPSByZWFkTm9uTmVnYXRpdmVJbnRlZ2VyU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdjYXNjYWRlZCcpKTtcbiAgaWYgKGNhc2NhZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICBjYXNjYWRlZCA9IHBhcmVudExheWVyT2JqZWN0WydjYXNjYWRlZCddO1xuICB9XG4gIGxheWVyT2JqZWN0WydjYXNjYWRlZCddID0gY2FzY2FkZWQ7XG5cbiAgbGV0IG9wYXF1ZSA9IHJlYWRCb29sZWFuU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdvcGFxdWUnKSk7XG4gIGlmIChvcGFxdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYXF1ZSA9IHBhcmVudExheWVyT2JqZWN0WydvcGFxdWUnXTtcbiAgfVxuICBsYXllck9iamVjdFsnb3BhcXVlJ10gPSBvcGFxdWUgIT09IHVuZGVmaW5lZCA/IG9wYXF1ZSA6IGZhbHNlO1xuXG4gIGxldCBub1N1YnNldHMgPSByZWFkQm9vbGVhblN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbm9TdWJzZXRzJykpO1xuICBpZiAobm9TdWJzZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub1N1YnNldHMgPSBwYXJlbnRMYXllck9iamVjdFsnbm9TdWJzZXRzJ107XG4gIH1cbiAgbGF5ZXJPYmplY3RbJ25vU3Vic2V0cyddID0gbm9TdWJzZXRzICE9PSB1bmRlZmluZWQgPyBub1N1YnNldHMgOiBmYWxzZTtcblxuICBsZXQgZml4ZWRXaWR0aCA9IHJlYWREZWNpbWFsU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdmaXhlZFdpZHRoJykpO1xuICBpZiAoIWZpeGVkV2lkdGgpIHtcbiAgICBmaXhlZFdpZHRoID0gcGFyZW50TGF5ZXJPYmplY3RbJ2ZpeGVkV2lkdGgnXTtcbiAgfVxuICBsYXllck9iamVjdFsnZml4ZWRXaWR0aCddID0gZml4ZWRXaWR0aDtcblxuICBsZXQgZml4ZWRIZWlnaHQgPSByZWFkRGVjaW1hbFN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnZml4ZWRIZWlnaHQnKSk7XG4gIGlmICghZml4ZWRIZWlnaHQpIHtcbiAgICBmaXhlZEhlaWdodCA9IHBhcmVudExheWVyT2JqZWN0WydmaXhlZEhlaWdodCddO1xuICB9XG4gIGxheWVyT2JqZWN0WydmaXhlZEhlaWdodCddID0gZml4ZWRIZWlnaHQ7XG5cbiAgLy8gU2VlIDcuMi40LjhcbiAgY29uc3QgYWRkS2V5cyA9IFsnU3R5bGUnLCAnQ1JTJywgJ0F1dGhvcml0eVVSTCddO1xuICBhZGRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gcGFyZW50TGF5ZXJPYmplY3QpIHtcbiAgICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBsYXllck9iamVjdFtrZXldIHx8IFtdO1xuICAgICAgbGF5ZXJPYmplY3Rba2V5XSA9IGNoaWxkVmFsdWUuY29uY2F0KHBhcmVudExheWVyT2JqZWN0W2tleV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgcmVwbGFjZUtleXMgPSBbXG4gICAgJ0VYX0dlb2dyYXBoaWNCb3VuZGluZ0JveCcsXG4gICAgJ0JvdW5kaW5nQm94JyxcbiAgICAnRGltZW5zaW9uJyxcbiAgICAnQXR0cmlidXRpb24nLFxuICAgICdNaW5TY2FsZURlbm9taW5hdG9yJyxcbiAgICAnTWF4U2NhbGVEZW5vbWluYXRvcicsXG4gIF07XG4gIHJlcGxhY2VLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghKGtleSBpbiBsYXllck9iamVjdCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFZhbHVlID0gcGFyZW50TGF5ZXJPYmplY3Rba2V5XTtcbiAgICAgIGxheWVyT2JqZWN0W2tleV0gPSBwYXJlbnRWYWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsYXllck9iamVjdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdH0gRGltZW5zaW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZERpbWVuc2lvbihub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBkaW1lbnNpb25PYmplY3QgPSB7XG4gICAgJ25hbWUnOiBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpLFxuICAgICd1bml0cyc6IG5vZGUuZ2V0QXR0cmlidXRlKCd1bml0cycpLFxuICAgICd1bml0U3ltYm9sJzogbm9kZS5nZXRBdHRyaWJ1dGUoJ3VuaXRTeW1ib2wnKSxcbiAgICAnZGVmYXVsdCc6IG5vZGUuZ2V0QXR0cmlidXRlKCdkZWZhdWx0JyksXG4gICAgJ211bHRpcGxlVmFsdWVzJzogcmVhZEJvb2xlYW5TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlVmFsdWVzJykpLFxuICAgICduZWFyZXN0VmFsdWUnOiByZWFkQm9vbGVhblN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnbmVhcmVzdFZhbHVlJykpLFxuICAgICdjdXJyZW50JzogcmVhZEJvb2xlYW5TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoJ2N1cnJlbnQnKSksXG4gICAgJ3ZhbHVlcyc6IHJlYWRTdHJpbmcobm9kZSksXG4gIH07XG4gIHJldHVybiBkaW1lbnNpb25PYmplY3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBPbmxpbmUgcmVzb3VyY2Ugb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkRm9ybWF0T25saW5lcmVzb3VyY2Uobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgRk9STUFUX09OTElORVJFU09VUkNFX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFJlcXVlc3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkUmVxdWVzdChub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBSRVFVRVNUX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IERDUCB0eXBlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZERDUFR5cGUobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgRENQVFlQRV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBIVFRQIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEhUVFAobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgSFRUUF9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBPcGVyYXRpb24gdHlwZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRPcGVyYXRpb25UeXBlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIE9QRVJBVElPTlRZUEVfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gT25saW5lIHJlc291cmNlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFNpemVkRm9ybWF0T25saW5lcmVzb3VyY2Uobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgZm9ybWF0T25saW5lcmVzb3VyY2UgPSByZWFkRm9ybWF0T25saW5lcmVzb3VyY2Uobm9kZSwgb2JqZWN0U3RhY2spO1xuICBpZiAoZm9ybWF0T25saW5lcmVzb3VyY2UpIHtcbiAgICBjb25zdCBzaXplID0gW1xuICAgICAgcmVhZE5vbk5lZ2F0aXZlSW50ZWdlclN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSksXG4gICAgICByZWFkTm9uTmVnYXRpdmVJbnRlZ2VyU3RyaW5nKG5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSksXG4gICAgXTtcbiAgICBmb3JtYXRPbmxpbmVyZXNvdXJjZVsnc2l6ZSddID0gc2l6ZTtcbiAgICByZXR1cm4gZm9ybWF0T25saW5lcmVzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IEF1dGhvcml0eSBVUkwgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkQXV0aG9yaXR5VVJMKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGF1dGhvcml0eU9iamVjdCA9IHJlYWRGb3JtYXRPbmxpbmVyZXNvdXJjZShub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmIChhdXRob3JpdHlPYmplY3QpIHtcbiAgICBhdXRob3JpdHlPYmplY3RbJ25hbWUnXSA9IG5vZGUuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgcmV0dXJuIGF1dGhvcml0eU9iamVjdDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gTWV0YWRhdGEgVVJMIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZE1ldGFkYXRhVVJMKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IG1ldGFkYXRhT2JqZWN0ID0gcmVhZEZvcm1hdE9ubGluZXJlc291cmNlKG5vZGUsIG9iamVjdFN0YWNrKTtcbiAgaWYgKG1ldGFkYXRhT2JqZWN0KSB7XG4gICAgbWV0YWRhdGFPYmplY3RbJ3R5cGUnXSA9IG5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgcmV0dXJuIG1ldGFkYXRhT2JqZWN0O1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBTdHlsZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRTdHlsZShub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBTVFlMRV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fHVuZGVmaW5lZH0gS2V5d29yZCBsaXN0LlxuICovXG5mdW5jdGlvbiByZWFkS2V5d29yZExpc3Qobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcChbXSwgS0VZV09SRExJU1RfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXTVNDYXBhYmlsaXRpZXM7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L1dNU0dldEZlYXR1cmVJbmZvXG4gKi9cbmltcG9ydCBHTUwyIGZyb20gJy4vR01MMi5qcyc7XG5pbXBvcnQgWE1MRmVhdHVyZSBmcm9tICcuL1hNTEZlYXR1cmUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7bWFrZUFycmF5UHVzaGVyLCBtYWtlU3RydWN0dXJlTlMsIHB1c2hQYXJzZUFuZFBvcH0gZnJvbSAnLi4veG1sLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtsYXllcnNdIElmIHNldCwgb25seSBmZWF0dXJlcyBvZiB0aGUgZ2l2ZW4gbGF5ZXJzIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhlIGZvcm1hdCB3aGVuIHJlYWQuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGZlYXR1cmVJZGVudGlmaWVyID0gJ19mZWF0dXJlJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGxheWVySWRlbnRpZmllciA9ICdfbGF5ZXInO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvcm1hdCBmb3IgcmVhZGluZyBXTVNHZXRGZWF0dXJlSW5mbyBmb3JtYXQuIEl0IHVzZXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZm9ybWF0L0dNTDJ+R01MMn0gdG8gcmVhZCBmZWF0dXJlcy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFdNU0dldEZlYXR1cmVJbmZvIGV4dGVuZHMgWE1MRmVhdHVyZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVOU18gPSAnaHR0cDovL21hcHNlcnZlci5naXMudW1uLmVkdS9tYXBzZXJ2ZXInO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7R01MMn1cbiAgICAgKi9cbiAgICB0aGlzLmdtbEZvcm1hdF8gPSBuZXcgR01MMigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzXyA9IG9wdGlvbnMubGF5ZXJzID8gb3B0aW9ucy5sYXllcnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz58bnVsbH0gbGF5ZXJzXG4gICAqL1xuICBnZXRMYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz58bnVsbH0gbGF5ZXJzIExheWVycyB0byBwYXJzZS5cbiAgICovXG4gIHNldExheWVycyhsYXllcnMpIHtcbiAgICB0aGlzLmxheWVyc18gPSBsYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWFkRmVhdHVyZXNfKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ25hbWVzcGFjZVVSSScsIHRoaXMuZmVhdHVyZU5TXyk7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICAgIGxldCBmZWF0dXJlcyA9IFtdO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuICAgIGlmIChsb2NhbE5hbWUgPT0gJ21zR01MT3V0cHV0Jykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChsYXllci5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxheWVyRWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGxheWVyKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IG9iamVjdFN0YWNrWzBdO1xuXG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gbGF5ZXJJZGVudGlmaWVyO1xuICAgICAgICBjb25zdCBsYXllck5hbWUgPSBsYXllckVsZW1lbnQubG9jYWxOYW1lLnJlcGxhY2UodG9SZW1vdmUsICcnKTtcblxuICAgICAgICBpZiAodGhpcy5sYXllcnNfICYmICF0aGlzLmxheWVyc18uaW5jbHVkZXMobGF5ZXJOYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmVhdHVyZVR5cGUgPSBsYXllck5hbWUgKyBmZWF0dXJlSWRlbnRpZmllcjtcblxuICAgICAgICBjb250ZXh0WydmZWF0dXJlVHlwZSddID0gZmVhdHVyZVR5cGU7XG4gICAgICAgIGNvbnRleHRbJ2ZlYXR1cmVOUyddID0gdGhpcy5mZWF0dXJlTlNfO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj59ICovXG4gICAgICAgIGNvbnN0IHBhcnNlcnMgPSB7fTtcbiAgICAgICAgcGFyc2Vyc1tmZWF0dXJlVHlwZV0gPSBtYWtlQXJyYXlQdXNoZXIoXG4gICAgICAgICAgdGhpcy5nbWxGb3JtYXRfLnJlYWRGZWF0dXJlRWxlbWVudCxcbiAgICAgICAgICB0aGlzLmdtbEZvcm1hdF9cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcGFyc2Vyc05TID0gbWFrZVN0cnVjdHVyZU5TKFxuICAgICAgICAgIFtjb250ZXh0WydmZWF0dXJlTlMnXSwgbnVsbF0sXG4gICAgICAgICAgcGFyc2Vyc1xuICAgICAgICApO1xuICAgICAgICBsYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCduYW1lc3BhY2VVUkknLCB0aGlzLmZlYXR1cmVOU18pO1xuICAgICAgICBjb25zdCBsYXllckZlYXR1cmVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBwYXJzZXJzTlMsXG4gICAgICAgICAgbGF5ZXJFbGVtZW50LFxuICAgICAgICAgIG9iamVjdFN0YWNrLFxuICAgICAgICAgIHRoaXMuZ21sRm9ybWF0X1xuICAgICAgICApO1xuICAgICAgICBpZiAobGF5ZXJGZWF0dXJlcykge1xuICAgICAgICAgIGV4dGVuZChmZWF0dXJlcywgbGF5ZXJGZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvY2FsTmFtZSA9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICBjb25zdCBnbWxGZWF0dXJlcyA9IHB1c2hQYXJzZUFuZFBvcChcbiAgICAgICAgW10sXG4gICAgICAgIHRoaXMuZ21sRm9ybWF0Xy5GRUFUVVJFX0NPTExFQ1RJT05fUEFSU0VSUyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgW3t9XSxcbiAgICAgICAgdGhpcy5nbWxGb3JtYXRfXG4gICAgICApO1xuICAgICAgaWYgKGdtbEZlYXR1cmVzKSB7XG4gICAgICAgIGZlYXR1cmVzID0gZ21sRmVhdHVyZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVzRnJvbU5vZGUobm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGludGVybmFsT3B0aW9ucywgdGhpcy5nZXRSZWFkT3B0aW9ucyhub2RlLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlc18obm9kZSwgW2ludGVybmFsT3B0aW9uc10pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdNU0dldEZlYXR1cmVJbmZvO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9XTVRTQ2FwYWJpbGl0aWVzXG4gKi9cbmltcG9ydCBPV1MgZnJvbSAnLi9PV1MuanMnO1xuaW1wb3J0IFhNTCBmcm9tICcuL1hNTC5qcyc7XG5pbXBvcnQge2JvdW5kaW5nRXh0ZW50fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtcbiAgbWFrZUFycmF5UHVzaGVyLFxuICBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIsXG4gIG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcixcbiAgbWFrZVN0cnVjdHVyZU5TLFxuICBwdXNoUGFyc2VBbmRQb3AsXG59IGZyb20gJy4uL3htbC5qcyc7XG5pbXBvcnQge3JlYWREZWNpbWFsLCByZWFkUG9zaXRpdmVJbnRlZ2VyLCByZWFkU3RyaW5nfSBmcm9tICcuL3hzZC5qcyc7XG5pbXBvcnQge3JlYWRIcmVmfSBmcm9tICcuL3hsaW5rLmpzJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudWxsfHN0cmluZz59XG4gKi9cbmNvbnN0IE5BTUVTUEFDRV9VUklTID0gW251bGwsICdodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dtdHMvMS4wJ107XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8bnVsbHxzdHJpbmc+fVxuICovXG5jb25zdCBPV1NfTkFNRVNQQUNFX1VSSVMgPSBbbnVsbCwgJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvb3dzLzEuMSddO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnQ29udGVudHMnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZENvbnRlbnRzKSxcbn0pO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvcm1hdCBmb3IgcmVhZGluZyBXTVRTIGNhcGFiaWxpdGllcyBkYXRhLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgV01UU0NhcGFiaWxpdGllcyBleHRlbmRzIFhNTCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T1dTfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vd3NQYXJzZXJfID0gbmV3IE9XUygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdFxuICAgKi9cbiAgcmVhZEZyb21Ob2RlKG5vZGUpIHtcbiAgICBsZXQgdmVyc2lvbiA9IG5vZGUuZ2V0QXR0cmlidXRlKCd2ZXJzaW9uJyk7XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnRyaW0oKTtcbiAgICB9XG4gICAgbGV0IFdNVFNDYXBhYmlsaXR5T2JqZWN0ID0gdGhpcy5vd3NQYXJzZXJfLnJlYWRGcm9tTm9kZShub2RlKTtcbiAgICBpZiAoIVdNVFNDYXBhYmlsaXR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgV01UU0NhcGFiaWxpdHlPYmplY3RbJ3ZlcnNpb24nXSA9IHZlcnNpb247XG4gICAgV01UU0NhcGFiaWxpdHlPYmplY3QgPSBwdXNoUGFyc2VBbmRQb3AoXG4gICAgICBXTVRTQ2FwYWJpbGl0eU9iamVjdCxcbiAgICAgIFBBUlNFUlMsXG4gICAgICBub2RlLFxuICAgICAgW11cbiAgICApO1xuICAgIHJldHVybiBXTVRTQ2FwYWJpbGl0eU9iamVjdCA/IFdNVFNDYXBhYmlsaXR5T2JqZWN0IDogbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgQ09OVEVOVFNfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnTGF5ZXInOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZExheWVyKSxcbiAgJ1RpbGVNYXRyaXhTZXQnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZFRpbGVNYXRyaXhTZXQpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBMQVlFUl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdTdHlsZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkU3R5bGUpLFxuICAgICdGb3JtYXQnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZFN0cmluZyksXG4gICAgJ1RpbGVNYXRyaXhTZXRMaW5rJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRUaWxlTWF0cml4U2V0TGluayksXG4gICAgJ0RpbWVuc2lvbic6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkRGltZW5zaW9ucyksXG4gICAgJ1Jlc291cmNlVVJMJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRSZXNvdXJjZVVybCksXG4gIH0sXG4gIG1ha2VTdHJ1Y3R1cmVOUyhPV1NfTkFNRVNQQUNFX1VSSVMsIHtcbiAgICAnVGl0bGUnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICAgJ0Fic3RyYWN0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAgICdXR1M4NEJvdW5kaW5nQm94JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRCb3VuZGluZ0JveCksXG4gICAgJ0lkZW50aWZpZXInOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gIH0pXG4pO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3htbC5qc1wiKS5QYXJzZXI+Pn1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgU1RZTEVfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhcbiAgTkFNRVNQQUNFX1VSSVMsXG4gIHtcbiAgICAnTGVnZW5kVVJMJzogbWFrZU9iamVjdFByb3BlcnR5UHVzaGVyKHJlYWRMZWdlbmRVcmwpLFxuICB9LFxuICBtYWtlU3RydWN0dXJlTlMoT1dTX05BTUVTUEFDRV9VUklTLCB7XG4gICAgJ1RpdGxlJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAgICdJZGVudGlmaWVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICB9KVxuKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFRNU19MSU5LU19QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKE5BTUVTUEFDRV9VUklTLCB7XG4gICdUaWxlTWF0cml4U2V0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAnVGlsZU1hdHJpeFNldExpbWl0cyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkVGlsZU1hdHJpeExpbWl0c0xpc3QpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBUTVNfTElNSVRTX0xJU1RfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnVGlsZU1hdHJpeExpbWl0cyc6IG1ha2VBcnJheVB1c2hlcihyZWFkVGlsZU1hdHJpeExpbWl0cyksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFRNU19MSU1JVFNfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhOQU1FU1BBQ0VfVVJJUywge1xuICAnVGlsZU1hdHJpeCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgJ01pblRpbGVSb3cnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gICdNYXhUaWxlUm93JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAnTWluVGlsZUNvbCc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkUG9zaXRpdmVJbnRlZ2VyKSxcbiAgJ01heFRpbGVDb2wnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG59KTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IERJTUVOU0lPTl9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdEZWZhdWx0JzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICAgICdWYWx1ZSc6IG1ha2VPYmplY3RQcm9wZXJ0eVB1c2hlcihyZWFkU3RyaW5nKSxcbiAgfSxcbiAgbWFrZVN0cnVjdHVyZU5TKE9XU19OQU1FU1BBQ0VfVVJJUywge1xuICAgICdJZGVudGlmaWVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRTdHJpbmcpLFxuICB9KVxuKTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi94bWwuanNcIikuUGFyc2VyPj59XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFdHUzg0X0JCT1hfUkVBREVSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhPV1NfTkFNRVNQQUNFX1VSSVMsIHtcbiAgJ0xvd2VyQ29ybmVyJzogbWFrZUFycmF5UHVzaGVyKHJlYWRDb29yZGluYXRlcyksXG4gICdVcHBlckNvcm5lcic6IG1ha2VBcnJheVB1c2hlcihyZWFkQ29vcmRpbmF0ZXMpLFxufSk7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBUTVNfUEFSU0VSUyA9IG1ha2VTdHJ1Y3R1cmVOUyhcbiAgTkFNRVNQQUNFX1VSSVMsXG4gIHtcbiAgICAnV2VsbEtub3duU2NhbGVTZXQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFN0cmluZyksXG4gICAgJ1RpbGVNYXRyaXgnOiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIocmVhZFRpbGVNYXRyaXgpLFxuICB9LFxuICBtYWtlU3RydWN0dXJlTlMoT1dTX05BTUVTUEFDRV9VUklTLCB7XG4gICAgJ1N1cHBvcnRlZENSUyc6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgICAnSWRlbnRpZmllcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgICAnQm91bmRpbmdCb3gnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZEJvdW5kaW5nQm94KSxcbiAgfSlcbik7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4veG1sLmpzXCIpLlBhcnNlcj4+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBUTV9QQVJTRVJTID0gbWFrZVN0cnVjdHVyZU5TKFxuICBOQU1FU1BBQ0VfVVJJUyxcbiAge1xuICAgICdUb3BMZWZ0Q29ybmVyJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRDb29yZGluYXRlcyksXG4gICAgJ1NjYWxlRGVub21pbmF0b3InOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZERlY2ltYWwpLFxuICAgICdUaWxlV2lkdGgnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gICAgJ1RpbGVIZWlnaHQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gICAgJ01hdHJpeFdpZHRoJzogbWFrZU9iamVjdFByb3BlcnR5U2V0dGVyKHJlYWRQb3NpdGl2ZUludGVnZXIpLFxuICAgICdNYXRyaXhIZWlnaHQnOiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIocmVhZFBvc2l0aXZlSW50ZWdlciksXG4gIH0sXG4gIG1ha2VTdHJ1Y3R1cmVOUyhPV1NfTkFNRVNQQUNFX1VSSVMsIHtcbiAgICAnSWRlbnRpZmllcic6IG1ha2VPYmplY3RQcm9wZXJ0eVNldHRlcihyZWFkU3RyaW5nKSxcbiAgfSlcbik7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBBdHRyaWJ1dGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRDb250ZW50cyhub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBDT05URU5UU19QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBMYXllcnMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkTGF5ZXIobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgTEFZRVJfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGlsZSBNYXRyaXggU2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFRpbGVNYXRyaXhTZXQobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcCh7fSwgVE1TX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFN0eWxlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFN0eWxlKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IHN0eWxlID0gcHVzaFBhcnNlQW5kUG9wKHt9LCBTVFlMRV9QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGlzRGVmYXVsdCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpc0RlZmF1bHQnKSA9PT0gJ3RydWUnO1xuICBzdHlsZVsnaXNEZWZhdWx0J10gPSBpc0RlZmF1bHQ7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRpbGUgTWF0cml4IFNldCBMaW5rIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFRpbGVNYXRyaXhTZXRMaW5rKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIFRNU19MSU5LU19QQVJTRVJTLCBub2RlLCBvYmplY3RTdGFjayk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBEaW1lbnNpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkRGltZW5zaW9ucyhub2RlLCBvYmplY3RTdGFjaykge1xuICByZXR1cm4gcHVzaFBhcnNlQW5kUG9wKHt9LCBESU1FTlNJT05fUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gUmVzb3VyY2UgVVJMIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZFJlc291cmNlVXJsKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdmb3JtYXQnKTtcbiAgY29uc3QgdGVtcGxhdGUgPSBub2RlLmdldEF0dHJpYnV0ZSgndGVtcGxhdGUnKTtcbiAgY29uc3QgcmVzb3VyY2VUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3Jlc291cmNlVHlwZScpO1xuICBjb25zdCByZXNvdXJjZSA9IHt9O1xuICBpZiAoZm9ybWF0KSB7XG4gICAgcmVzb3VyY2VbJ2Zvcm1hdCddID0gZm9ybWF0O1xuICB9XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJlc291cmNlWyd0ZW1wbGF0ZSddID0gdGVtcGxhdGU7XG4gIH1cbiAgaWYgKHJlc291cmNlVHlwZSkge1xuICAgIHJlc291cmNlWydyZXNvdXJjZVR5cGUnXSA9IHJlc291cmNlVHlwZTtcbiAgfVxuICByZXR1cm4gcmVzb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBCQm94IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVhZEJvdW5kaW5nQm94KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gcHVzaFBhcnNlQW5kUG9wKFxuICAgIFtdLFxuICAgIFdHUzg0X0JCT1hfUkVBREVSUyxcbiAgICBub2RlLFxuICAgIG9iamVjdFN0YWNrXG4gICk7XG4gIGlmIChjb29yZGluYXRlcy5sZW5ndGggIT0gMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGJvdW5kaW5nRXh0ZW50KGNvb3JkaW5hdGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IExlZ2VuZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRMZWdlbmRVcmwobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgY29uc3QgbGVnZW5kID0ge307XG4gIGxlZ2VuZFsnZm9ybWF0J10gPSBub2RlLmdldEF0dHJpYnV0ZSgnZm9ybWF0Jyk7XG4gIGxlZ2VuZFsnaHJlZiddID0gcmVhZEhyZWYobm9kZSk7XG4gIHJldHVybiBsZWdlbmQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSBDb29yZGluYXRlcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRDb29yZGluYXRlcyhub2RlLCBvYmplY3RTdGFjaykge1xuICBjb25zdCBjb29yZGluYXRlcyA9IHJlYWRTdHJpbmcobm9kZSkuc3BsaXQoL1xccysvKTtcbiAgaWYgKCFjb29yZGluYXRlcyB8fCBjb29yZGluYXRlcy5sZW5ndGggIT0gMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgeCA9ICtjb29yZGluYXRlc1swXTtcbiAgY29uc3QgeSA9ICtjb29yZGluYXRlc1sxXTtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gVGlsZU1hdHJpeCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRUaWxlTWF0cml4KG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIFRNX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRpbGVNYXRyaXhTZXRMaW1pdHMgT2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkVGlsZU1hdHJpeExpbWl0c0xpc3Qobm9kZSwgb2JqZWN0U3RhY2spIHtcbiAgcmV0dXJuIHB1c2hQYXJzZUFuZFBvcChbXSwgVE1TX0xJTUlUU19MSVNUX1BBUlNFUlMsIG5vZGUsIG9iamVjdFN0YWNrKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IFRpbGVNYXRyaXhMaW1pdHMgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRUaWxlTWF0cml4TGltaXRzKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gIHJldHVybiBwdXNoUGFyc2VBbmRQb3Aoe30sIFRNU19MSU1JVFNfUEFSU0VSUywgbm9kZSwgb2JqZWN0U3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXTVRTQ2FwYWJpbGl0aWVzO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9YTUxcbiAqL1xuaW1wb3J0IHtpc0RvY3VtZW50LCBwYXJzZX0gZnJvbSAnLi4veG1sLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBHZW5lcmljIGZvcm1hdCBmb3IgcmVhZGluZyBub24tZmVhdHVyZSBYTUwgZGF0YVxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBYTUwge1xuICAvKipcbiAgICogUmVhZCB0aGUgc291cmNlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8c3RyaW5nfSBzb3VyY2UgVGhlIFhNTCBzb3VyY2UuXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc291cmNlLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21Eb2N1bWVudChkb2MpO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbURvY3VtZW50KC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChzb3VyY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZEZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHNvdXJjZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3RcbiAgICovXG4gIHJlYWRGcm9tRG9jdW1lbnQoZG9jKSB7XG4gICAgZm9yIChsZXQgbiA9IGRvYy5maXJzdENoaWxkOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdFxuICAgKi9cbiAgcmVhZEZyb21Ob2RlKG5vZGUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFhNTDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvWE1MRmVhdHVyZVxuICovXG5pbXBvcnQgRmVhdHVyZUZvcm1hdCBmcm9tICcuLi9mb3JtYXQvRmVhdHVyZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2dldFhNTFNlcmlhbGl6ZXIsIGlzRG9jdW1lbnQsIHBhcnNlfSBmcm9tICcuLi94bWwuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIFhNTCBmZWF0dXJlIGZvcm1hdHMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFhNTEZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlRm9ybWF0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtYTUxTZXJpYWxpemVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy54bWxTZXJpYWxpemVyXyA9IGdldFhNTFNlcmlhbGl6ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuVHlwZX0gRm9ybWF0LlxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3htbCc7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNpbmdsZSBmZWF0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmUoc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkRmVhdHVyZUZyb21Eb2N1bWVudChkb2MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkRmVhdHVyZUZyb21Eb2N1bWVudChcbiAgICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoc291cmNlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIERvY3VtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZS5cbiAgICovXG4gIHJlYWRGZWF0dXJlRnJvbURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5yZWFkRmVhdHVyZXNGcm9tRG9jdW1lbnQoZG9jLCBvcHRpb25zKTtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZlYXR1cmVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqL1xuICByZWFkRmVhdHVyZUZyb21Ob2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGltcGxlbWVudGVkXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhbGwgZmVhdHVyZXMgZnJvbSBhIGZlYXR1cmUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRGZWF0dXJlcyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkRmVhdHVyZXNGcm9tRG9jdW1lbnQoZG9jLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEZlYXR1cmVzRnJvbURvY3VtZW50KFxuICAgICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAoc291cmNlKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZEZlYXR1cmVzRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoc291cmNlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIERvY3VtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tRG9jdW1lbnQoZG9jLCBvcHRpb25zKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgbiA9IGRvYy5maXJzdENoaWxkOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIHRoaXMucmVhZEZlYXR1cmVzRnJvbU5vZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobiksIG9wdGlvbnMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21Ob2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2luZ2xlIGdlb21ldHJ5IGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIHJlYWRHZW9tZXRyeShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZG9jID0gcGFyc2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRHZW9tZXRyeUZyb21Eb2N1bWVudChkb2MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkR2VvbWV0cnlGcm9tRG9jdW1lbnQoXG4gICAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChzb3VyY2UpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkR2VvbWV0cnlGcm9tTm9kZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChzb3VyY2UpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgRG9jdW1lbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKi9cbiAgcmVhZEdlb21ldHJ5RnJvbURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIHJldHVybiBudWxsOyAvLyBub3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICByZWFkR2VvbWV0cnlGcm9tTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBpbXBsZW1lbnRlZFxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHByb2plY3Rpb24gZnJvbSB0aGUgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRQcm9qZWN0aW9uKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkb2MgPSBwYXJzZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFByb2plY3Rpb25Gcm9tRG9jdW1lbnQoZG9jKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFByb2plY3Rpb25Gcm9tRG9jdW1lbnQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHNvdXJjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkUHJvamVjdGlvbkZyb21Ob2RlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHNvdXJjZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBEb2N1bWVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gUHJvamVjdGlvbi5cbiAgICovXG4gIHJlYWRQcm9qZWN0aW9uRnJvbURvY3VtZW50KGRvYykge1xuICAgIHJldHVybiB0aGlzLmRhdGFQcm9qZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgcmVhZFByb2plY3Rpb25Gcm9tTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVByb2plY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGEgZmVhdHVyZSBhcyBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBmZWF0dXJlLlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlKGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy53cml0ZUZlYXR1cmVOb2RlKGZlYXR1cmUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnhtbFNlcmlhbGl6ZXJfLnNlcmlhbGl6ZVRvU3RyaW5nKG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7Tm9kZX0gTm9kZS5cbiAgICovXG4gIHdyaXRlRmVhdHVyZU5vZGUoZmVhdHVyZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBudWxsOyAvLyBub3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gYXJyYXkgb2YgZmVhdHVyZXMgYXMgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlcyhmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLndyaXRlRmVhdHVyZXNOb2RlKGZlYXR1cmVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy54bWxTZXJpYWxpemVyXy5zZXJpYWxpemVUb1N0cmluZyhub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlLlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlc05vZGUoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGltcGxlbWVudGVkXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGEgZ2VvbWV0cnkgYXMgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBnZW9tZXRyeS5cbiAgICovXG4gIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy53cml0ZUdlb21ldHJ5Tm9kZShnZW9tZXRyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMueG1sU2VyaWFsaXplcl8uc2VyaWFsaXplVG9TdHJpbmcobm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBOb2RlLlxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeU5vZGUoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGltcGxlbWVudGVkXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWE1MRmVhdHVyZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyXG4gKi9cbmltcG9ydCBBbmQgZnJvbSAnLi9maWx0ZXIvQW5kLmpzJztcbmltcG9ydCBCYm94IGZyb20gJy4vZmlsdGVyL0Jib3guanMnO1xuaW1wb3J0IENvbnRhaW5zIGZyb20gJy4vZmlsdGVyL0NvbnRhaW5zLmpzJztcbmltcG9ydCBEV2l0aGluIGZyb20gJy4vZmlsdGVyL0RXaXRoaW4uanMnO1xuaW1wb3J0IERpc2pvaW50IGZyb20gJy4vZmlsdGVyL0Rpc2pvaW50LmpzJztcbmltcG9ydCBEdXJpbmcgZnJvbSAnLi9maWx0ZXIvRHVyaW5nLmpzJztcbmltcG9ydCBFcXVhbFRvIGZyb20gJy4vZmlsdGVyL0VxdWFsVG8uanMnO1xuaW1wb3J0IEdyZWF0ZXJUaGFuIGZyb20gJy4vZmlsdGVyL0dyZWF0ZXJUaGFuLmpzJztcbmltcG9ydCBHcmVhdGVyVGhhbk9yRXF1YWxUbyBmcm9tICcuL2ZpbHRlci9HcmVhdGVyVGhhbk9yRXF1YWxUby5qcyc7XG5pbXBvcnQgSW50ZXJzZWN0cyBmcm9tICcuL2ZpbHRlci9JbnRlcnNlY3RzLmpzJztcbmltcG9ydCBJc0JldHdlZW4gZnJvbSAnLi9maWx0ZXIvSXNCZXR3ZWVuLmpzJztcbmltcG9ydCBJc0xpa2UgZnJvbSAnLi9maWx0ZXIvSXNMaWtlLmpzJztcbmltcG9ydCBJc051bGwgZnJvbSAnLi9maWx0ZXIvSXNOdWxsLmpzJztcbmltcG9ydCBMZXNzVGhhbiBmcm9tICcuL2ZpbHRlci9MZXNzVGhhbi5qcyc7XG5pbXBvcnQgTGVzc1RoYW5PckVxdWFsVG8gZnJvbSAnLi9maWx0ZXIvTGVzc1RoYW5PckVxdWFsVG8uanMnO1xuaW1wb3J0IE5vdCBmcm9tICcuL2ZpbHRlci9Ob3QuanMnO1xuaW1wb3J0IE5vdEVxdWFsVG8gZnJvbSAnLi9maWx0ZXIvTm90RXF1YWxUby5qcyc7XG5pbXBvcnQgT3IgZnJvbSAnLi9maWx0ZXIvT3IuanMnO1xuaW1wb3J0IFJlc291cmNlSWQgZnJvbSAnLi9maWx0ZXIvUmVzb3VyY2VJZC5qcyc7XG5pbXBvcnQgV2l0aGluIGZyb20gJy4vZmlsdGVyL1dpdGhpbi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbG9naWNhbCBgPEFuZD5gIG9wZXJhdG9yIGJldHdlZW4gdHdvIG9yIG1vcmUgZmlsdGVyIGNvbmRpdGlvbnMuXG4gKlxuICogQHBhcmFtIHsuLi5pbXBvcnQoXCIuL2ZpbHRlci9GaWx0ZXIuanNcIikuZGVmYXVsdH0gY29uZGl0aW9ucyBGaWx0ZXIgY29uZGl0aW9ucy5cbiAqIEByZXR1cm4geyFBbmR9IGA8QW5kPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmQoY29uZGl0aW9ucykge1xuICBjb25zdCBwYXJhbXMgPSBbbnVsbF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShBbmQsIHBhcmFtcykpKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbG9naWNhbCBgPE9yPmAgb3BlcmF0b3IgYmV0d2VlbiB0d28gb3IgbW9yZSBmaWx0ZXIgY29uZGl0aW9ucy5cbiAqXG4gKiBAcGFyYW0gey4uLmltcG9ydChcIi4vZmlsdGVyL0ZpbHRlci5qc1wiKS5kZWZhdWx0fSBjb25kaXRpb25zIEZpbHRlciBjb25kaXRpb25zLlxuICogQHJldHVybiB7IU9yfSBgPE9yPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcihjb25kaXRpb25zKSB7XG4gIGNvbnN0IHBhcmFtcyA9IFtudWxsXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KE9yLCBwYXJhbXMpKSgpO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2dpY2FsIGA8Tm90PmAgb3BlcmF0b3IgZm9yIGEgZmlsdGVyIGNvbmRpdGlvbi5cbiAqXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuL2ZpbHRlci9GaWx0ZXIuanNcIikuZGVmYXVsdH0gY29uZGl0aW9uIEZpbHRlciBjb25kaXRpb24uXG4gKiBAcmV0dXJuIHshTm90fSBgPE5vdD5gIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm90KGNvbmRpdGlvbikge1xuICByZXR1cm4gbmV3IE5vdChjb25kaXRpb24pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGA8QkJPWD5gIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIGdlb21ldHJ5LXZhbHVlZCBwcm9wZXJ0eVxuICogaW50ZXJzZWN0cyBhIGZpeGVkIGJvdW5kaW5nIGJveFxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHshQmJveH0gYDxCQk9YPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYm94KGdlb21ldHJ5TmFtZSwgZXh0ZW50LCBzcnNOYW1lKSB7XG4gIHJldHVybiBuZXcgQmJveChnZW9tZXRyeU5hbWUsIGV4dGVudCwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxDb250YWlucz5gIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIGdlb21ldHJ5LXZhbHVlZCBwcm9wZXJ0eVxuICogY29udGFpbnMgYSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGdlb21ldHJ5TmFtZSBHZW9tZXRyeSBuYW1lIHRvIHVzZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gKiAgICBzZXQgb24gZ2VvbWV0cmllcyB3aGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7IUNvbnRhaW5zfSBgPENvbnRhaW5zPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWlucyhnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gIHJldHVybiBuZXcgQ29udGFpbnMoZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxJbnRlcnNlY3RzPmAgb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGEgZ2VvbWV0cnktdmFsdWVkIHByb3BlcnR5XG4gKiBpbnRlcnNlY3RzIGEgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBnZW9tZXRyeU5hbWUgR2VvbWV0cnkgbmFtZSB0byB1c2UuXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcnNOYW1lXSBTUlMgbmFtZS4gTm8gc3JzTmFtZSBhdHRyaWJ1dGUgd2lsbCBiZVxuICogICAgc2V0IG9uIGdlb21ldHJpZXMgd2hlbiB0aGlzIGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4geyFJbnRlcnNlY3RzfSBgPEludGVyc2VjdHM+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHMoZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSkge1xuICByZXR1cm4gbmV3IEludGVyc2VjdHMoZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxEaXNqb2ludD5gIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIGdlb21ldHJ5LXZhbHVlZCBwcm9wZXJ0eVxuICogaXMgZGlzam9pbnQgdG8gYSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGdlb21ldHJ5TmFtZSBHZW9tZXRyeSBuYW1lIHRvIHVzZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gKiAgICBzZXQgb24gZ2VvbWV0cmllcyB3aGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7IURpc2pvaW50fSBgPERpc2pvaW50PmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNqb2ludChnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gIHJldHVybiBuZXcgRGlzam9pbnQoZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxXaXRoaW4+YCBvcGVyYXRvciB0byB0ZXN0IHdoZXRoZXIgYSBnZW9tZXRyeS12YWx1ZWQgcHJvcGVydHlcbiAqIGlzIHdpdGhpbiBhIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHshV2l0aGlufSBgPFdpdGhpbj5gIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKGdlb21ldHJ5TmFtZSwgZ2VvbWV0cnksIHNyc05hbWUpIHtcbiAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxEV2l0aGluPmAgb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGEgZ2VvbWV0cnktdmFsdWVkIHByb3BlcnR5XG4gKiBpcyB3aXRoaW4gYSBkaXN0YW5jZSB0byBhIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHVuaXQgVW5pdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmVcbiAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHshRFdpdGhpbn0gYDxEV2l0aGluPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkd2l0aGluKGdlb21ldHJ5TmFtZSwgZ2VvbWV0cnksIGRpc3RhbmNlLCB1bml0LCBzcnNOYW1lKSB7XG4gIHJldHVybiBuZXcgRFdpdGhpbihnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBkaXN0YW5jZSwgdW5pdCwgc3JzTmFtZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGA8UHJvcGVydHlJc0VxdWFsVG8+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7IShzdHJpbmd8bnVtYmVyKX0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGNoQ2FzZV0gQ2FzZS1zZW5zaXRpdmU/XG4gKiBAcmV0dXJuIHshRXF1YWxUb30gYDxQcm9wZXJ0eUlzRXF1YWxUbz5gIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxUbyhwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24sIG1hdGNoQ2FzZSkge1xuICByZXR1cm4gbmV3IEVxdWFsVG8ocHJvcGVydHlOYW1lLCBleHByZXNzaW9uLCBtYXRjaENhc2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgPFByb3BlcnR5SXNOb3RFcXVhbFRvPmAgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyEoc3RyaW5nfG51bWJlcil9IGV4cHJlc3Npb24gVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFttYXRjaENhc2VdIENhc2Utc2Vuc2l0aXZlP1xuICogQHJldHVybiB7IU5vdEVxdWFsVG99IGA8UHJvcGVydHlJc05vdEVxdWFsVG8+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdEVxdWFsVG8ocHJvcGVydHlOYW1lLCBleHByZXNzaW9uLCBtYXRjaENhc2UpIHtcbiAgcmV0dXJuIG5ldyBOb3RFcXVhbFRvKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbiwgbWF0Y2hDYXNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYDxQcm9wZXJ0eUlzTGVzc1RoYW4+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4geyFMZXNzVGhhbn0gYDxQcm9wZXJ0eUlzTGVzc1RoYW4+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlc3NUaGFuKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbikge1xuICByZXR1cm4gbmV3IExlc3NUaGFuKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGA8UHJvcGVydHlJc0xlc3NUaGFuT3JFcXVhbFRvPmAgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGV4cHJlc3Npb24gVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJuIHshTGVzc1RoYW5PckVxdWFsVG99IGA8UHJvcGVydHlJc0xlc3NUaGFuT3JFcXVhbFRvPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWxUbyhwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIG5ldyBMZXNzVGhhbk9yRXF1YWxUbyhwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgPFByb3BlcnR5SXNHcmVhdGVyVGhhbj5gIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgTmFtZSBvZiB0aGUgY29udGV4dCBwcm9wZXJ0eSB0byBjb21wYXJlLlxuICogQHBhcmFtIHshbnVtYmVyfSBleHByZXNzaW9uIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybiB7IUdyZWF0ZXJUaGFufSBgPFByb3BlcnR5SXNHcmVhdGVyVGhhbj5gIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JlYXRlclRoYW4ocHJvcGVydHlOYW1lLCBleHByZXNzaW9uKSB7XG4gIHJldHVybiBuZXcgR3JlYXRlclRoYW4ocHJvcGVydHlOYW1lLCBleHByZXNzaW9uKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYDxQcm9wZXJ0eUlzR3JlYXRlclRoYW5PckVxdWFsVG8+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4geyFHcmVhdGVyVGhhbk9yRXF1YWxUb30gYDxQcm9wZXJ0eUlzR3JlYXRlclRoYW5PckVxdWFsVG8+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbFRvKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbikge1xuICByZXR1cm4gbmV3IEdyZWF0ZXJUaGFuT3JFcXVhbFRvKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGA8UHJvcGVydHlJc051bGw+YCBjb21wYXJpc29uIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlXG4gKiBpcyBudWxsLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4geyFJc051bGx9IGA8UHJvcGVydHlJc051bGw+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbChwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIG5ldyBJc051bGwocHJvcGVydHlOYW1lKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYDxQcm9wZXJ0eUlzQmV0d2Vlbj5gIGNvbXBhcmlzb24gb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGFuIGV4cHJlc3Npb25cbiAqIHZhbHVlIGxpZXMgd2l0aGluIGEgcmFuZ2UgZ2l2ZW4gYnkgYSBsb3dlciBhbmQgdXBwZXIgYm91bmQgKGluY2x1c2l2ZSkuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgTmFtZSBvZiB0aGUgY29udGV4dCBwcm9wZXJ0eSB0byBjb21wYXJlLlxuICogQHBhcmFtIHshbnVtYmVyfSBsb3dlckJvdW5kYXJ5IFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHVwcGVyQm91bmRhcnkgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAqIEByZXR1cm4geyFJc0JldHdlZW59IGA8UHJvcGVydHlJc0JldHdlZW4+YCBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJldHdlZW4ocHJvcGVydHlOYW1lLCBsb3dlckJvdW5kYXJ5LCB1cHBlckJvdW5kYXJ5KSB7XG4gIHJldHVybiBuZXcgSXNCZXR3ZWVuKHByb3BlcnR5TmFtZSwgbG93ZXJCb3VuZGFyeSwgdXBwZXJCb3VuZGFyeSk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGA8UHJvcGVydHlJc0xpa2U+YCBjb21wYXJpc29uIG9wZXJhdG9yIHRoYXQgbWF0Y2hlcyBhIHN0cmluZyBwcm9wZXJ0eVxuICogdmFsdWUgYWdhaW5zdCBhIHRleHQgcGF0dGVybi5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdHRlcm4gVGV4dCBwYXR0ZXJuLlxuICogQHBhcmFtIHtzdHJpbmd9IFt3aWxkQ2FyZF0gUGF0dGVybiBjaGFyYWN0ZXIgd2hpY2ggbWF0Y2hlcyBhbnkgc2VxdWVuY2Ugb2ZcbiAqICAgIHplcm8gb3IgbW9yZSBzdHJpbmcgY2hhcmFjdGVycy4gRGVmYXVsdCBpcyAnKicuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NpbmdsZUNoYXJdIHBhdHRlcm4gY2hhcmFjdGVyIHdoaWNoIG1hdGNoZXMgYW55IHNpbmdsZVxuICogICAgc3RyaW5nIGNoYXJhY3Rlci4gRGVmYXVsdCBpcyAnLicuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VzY2FwZUNoYXJdIEVzY2FwZSBjaGFyYWN0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZXNjYXBlXG4gKiAgICB0aGUgcGF0dGVybiBjaGFyYWN0ZXJzLiBEZWZhdWx0IGlzICchJy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGNoQ2FzZV0gQ2FzZS1zZW5zaXRpdmU/XG4gKiBAcmV0dXJuIHshSXNMaWtlfSBgPFByb3BlcnR5SXNMaWtlPmAgb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWtlKFxuICBwcm9wZXJ0eU5hbWUsXG4gIHBhdHRlcm4sXG4gIHdpbGRDYXJkLFxuICBzaW5nbGVDaGFyLFxuICBlc2NhcGVDaGFyLFxuICBtYXRjaENhc2Vcbikge1xuICByZXR1cm4gbmV3IElzTGlrZShcbiAgICBwcm9wZXJ0eU5hbWUsXG4gICAgcGF0dGVybixcbiAgICB3aWxkQ2FyZCxcbiAgICBzaW5nbGVDaGFyLFxuICAgIGVzY2FwZUNoYXIsXG4gICAgbWF0Y2hDYXNlXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYDxEdXJpbmc+YCB0ZW1wb3JhbCBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGJlZ2luIFRoZSBiZWdpbiBkYXRlIGluIElTTy04NjAxIGZvcm1hdC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZW5kIFRoZSBlbmQgZGF0ZSBpbiBJU08tODYwMSBmb3JtYXQuXG4gKiBAcmV0dXJuIHshRHVyaW5nfSBgPER1cmluZz5gIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZHVyaW5nKHByb3BlcnR5TmFtZSwgYmVnaW4sIGVuZCkge1xuICByZXR1cm4gbmV3IER1cmluZyhwcm9wZXJ0eU5hbWUsIGJlZ2luLCBlbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb3VyY2VJZChyaWQpIHtcbiAgcmV0dXJuIG5ldyBSZXNvdXJjZUlkKHJpZCk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9BbmRcbiAqL1xuaW1wb3J0IExvZ2ljYWxOYXJ5IGZyb20gJy4vTG9naWNhbE5hcnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBsb2dpY2FsIGA8QW5kPmAgb3BlcmF0b3IgYmV0d2VlbiB0d28gb3IgbW9yZSBmaWx0ZXIgY29uZGl0aW9ucy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgQW5kIGV4dGVuZHMgTG9naWNhbE5hcnkge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi5pbXBvcnQoXCIuL0ZpbHRlci5qc1wiKS5kZWZhdWx0fSBjb25kaXRpb25zIENvbmRpdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25kaXRpb25zKSB7XG4gICAgc3VwZXIoJ0FuZCcsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuZDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0Jib3hcbiAqL1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL0ZpbHRlci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGA8QkJPWD5gIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIGdlb21ldHJ5LXZhbHVlZCBwcm9wZXJ0eVxuICogaW50ZXJzZWN0cyBhIGZpeGVkIGJvdW5kaW5nIGJveFxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQmJveCBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGdlb21ldHJ5TmFtZSBHZW9tZXRyeSBuYW1lIHRvIHVzZS5cbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcnNOYW1lXSBTUlMgbmFtZS4gTm8gc3JzTmFtZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXRcbiAgICogb24gZ2VvbWV0cmllcyB3aGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VvbWV0cnlOYW1lLCBleHRlbnQsIHNyc05hbWUpIHtcbiAgICBzdXBlcignQkJPWCcpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeU5hbWUgPSBnZW9tZXRyeU5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICBpZiAoZXh0ZW50Lmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYW4gZXh0ZW50IHdpdGggZm91ciB2YWx1ZXMgKFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSknXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3JzTmFtZSA9IHNyc05hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmJveDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0NvbXBhcmlzb25cbiAqL1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL0ZpbHRlci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90IGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgV0ZTIEdldEZlYXR1cmUgcHJvcGVydHkgY29tcGFyaXNvbiBmaWx0ZXJzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBDb21wYXJpc29uIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFnTmFtZSBUaGUgWE1MIHRhZyBuYW1lIGZvciB0aGlzIGZpbHRlci5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgTmFtZSBvZiB0aGUgY29udGV4dCBwcm9wZXJ0eSB0byBjb21wYXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGFnTmFtZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgc3VwZXIodGFnTmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wYXJpc29uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvQ29tcGFyaXNvbkJpbmFyeVxuICovXG5pbXBvcnQgQ29tcGFyaXNvbiBmcm9tICcuL0NvbXBhcmlzb24uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdCBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIFdGUyBHZXRGZWF0dXJlIHByb3BlcnR5IGJpbmFyeSBjb21wYXJpc29uIGZpbHRlcnMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIENvbXBhcmlzb25CaW5hcnkgZXh0ZW5kcyBDb21wYXJpc29uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFnTmFtZSBUaGUgWE1MIHRhZyBuYW1lIGZvciB0aGlzIGZpbHRlci5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgTmFtZSBvZiB0aGUgY29udGV4dCBwcm9wZXJ0eSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyEoc3RyaW5nfG51bWJlcil9IGV4cHJlc3Npb24gVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGNoQ2FzZV0gQ2FzZS1zZW5zaXRpdmU/XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24sIG1hdGNoQ2FzZSkge1xuICAgIHN1cGVyKHRhZ05hbWUsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IShzdHJpbmd8bnVtYmVyKX1cbiAgICAgKi9cbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubWF0Y2hDYXNlID0gbWF0Y2hDYXNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBhcmlzb25CaW5hcnk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9Db250YWluc1xuICovXG5pbXBvcnQgU3BhdGlhbCBmcm9tICcuL1NwYXRpYWwuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBgPENvbnRhaW5zPmAgb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGEgZ2VvbWV0cnktdmFsdWVkIHByb3BlcnR5XG4gKiBjb250YWlucyBhIGdpdmVuIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5jbGFzcyBDb250YWlucyBleHRlbmRzIFNwYXRpYWwge1xuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBnZW9tZXRyeU5hbWUgR2VvbWV0cnkgbmFtZSB0byB1c2UuXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmVcbiAgICogICAgc2V0IG9uIGdlb21ldHJpZXMgd2hlbiB0aGlzIGlzIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5TmFtZSwgZ2VvbWV0cnksIHNyc05hbWUpIHtcbiAgICBzdXBlcignQ29udGFpbnMnLCBnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWlucztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0RXaXRoaW5cbiAqL1xuaW1wb3J0IFNwYXRpYWwgZnJvbSAnLi9TcGF0aWFsLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxEV2l0aGluPmAgb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGEgZ2VvbWV0cnktdmFsdWVkIHByb3BlcnR5XG4gKiBpcyB3aXRoaW4gYSBkaXN0YW5jZSB0byBhIGdpdmVuIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5jbGFzcyBEV2l0aGluIGV4dGVuZHMgU3BhdGlhbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGdlb21ldHJ5TmFtZSBHZW9tZXRyeSBuYW1lIHRvIHVzZS5cbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHshbnVtYmVyfSBkaXN0YW5jZSBEaXN0YW5jZS5cbiAgICogQHBhcmFtIHshc3RyaW5nfSB1bml0IFVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3JzTmFtZV0gU1JTIG5hbWUuIE5vIHNyc05hbWUgYXR0cmlidXRlIHdpbGwgYmVcbiAgICogICAgc2V0IG9uIGdlb21ldHJpZXMgd2hlbiB0aGlzIGlzIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlb21ldHJ5TmFtZSwgZ2VvbWV0cnksIGRpc3RhbmNlLCB1bml0LCBzcnNOYW1lKSB7XG4gICAgc3VwZXIoJ0RXaXRoaW4nLCBnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAdHlwZSB7IW51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHR5cGUgeyFzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEV2l0aGluO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvRGlzam9pbnRcbiAqL1xuaW1wb3J0IFNwYXRpYWwgZnJvbSAnLi9TcGF0aWFsLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxEaXNqb2ludD5gIG9wZXJhdG9yIHRvIHRlc3Qgd2hldGhlciBhIGdlb21ldHJ5LXZhbHVlZCBwcm9wZXJ0eVxuICogaXMgZGlzam9pbnQgdG8gYSBnaXZlbiBnZW9tZXRyeS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRGlzam9pbnQgZXh0ZW5kcyBTcGF0aWFsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gICAgc3VwZXIoJ0Rpc2pvaW50JywgZ2VvbWV0cnlOYW1lLCBnZW9tZXRyeSwgc3JzTmFtZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzam9pbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9EdXJpbmdcbiAqL1xuaW1wb3J0IENvbXBhcmlzb24gZnJvbSAnLi9Db21wYXJpc29uLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxEdXJpbmc+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5jbGFzcyBEdXJpbmcgZXh0ZW5kcyBDb21wYXJpc29uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBiZWdpbiBUaGUgYmVnaW4gZGF0ZSBpbiBJU08tODYwMSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZW5kIFRoZSBlbmQgZGF0ZSBpbiBJU08tODYwMSBmb3JtYXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWUsIGJlZ2luLCBlbmQpIHtcbiAgICBzdXBlcignRHVyaW5nJywgcHJvcGVydHlOYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshc3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshc3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IER1cmluZztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0VxdWFsVG9cbiAqL1xuaW1wb3J0IENvbXBhcmlzb25CaW5hcnkgZnJvbSAnLi9Db21wYXJpc29uQmluYXJ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxQcm9wZXJ0eUlzRXF1YWxUbz5gIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEVxdWFsVG8gZXh0ZW5kcyBDb21wYXJpc29uQmluYXJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHshKHN0cmluZ3xudW1iZXIpfSBleHByZXNzaW9uIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYXRjaENhc2VdIENhc2Utc2Vuc2l0aXZlP1xuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydHlOYW1lLCBleHByZXNzaW9uLCBtYXRjaENhc2UpIHtcbiAgICBzdXBlcignUHJvcGVydHlJc0VxdWFsVG8nLCBwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24sIG1hdGNoQ2FzZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXF1YWxUbztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0ZpbHRlclxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90IGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgV0ZTIEdldEZlYXR1cmUgZmlsdGVycy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFnTmFtZSBUaGUgWE1MIHRhZyBuYW1lIGZvciB0aGlzIGZpbHRlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhZ05hbWUpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshc3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGFnTmFtZV8gPSB0YWdOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBYTUwgdGFnIG5hbWUgZm9yIGEgZmlsdGVyLlxuICAgKiBAcmV0dXJuIHshc3RyaW5nfSBOYW1lLlxuICAgKi9cbiAgZ2V0VGFnTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdOYW1lXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9HcmVhdGVyVGhhblxuICovXG5pbXBvcnQgQ29tcGFyaXNvbkJpbmFyeSBmcm9tICcuL0NvbXBhcmlzb25CaW5hcnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBgPFByb3BlcnR5SXNHcmVhdGVyVGhhbj5gIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdyZWF0ZXJUaGFuIGV4dGVuZHMgQ29tcGFyaXNvbkJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbikge1xuICAgIHN1cGVyKCdQcm9wZXJ0eUlzR3JlYXRlclRoYW4nLCBwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyZWF0ZXJUaGFuO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvR3JlYXRlclRoYW5PckVxdWFsVG9cbiAqL1xuaW1wb3J0IENvbXBhcmlzb25CaW5hcnkgZnJvbSAnLi9Db21wYXJpc29uQmluYXJ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxQcm9wZXJ0eUlzR3JlYXRlclRoYW5PckVxdWFsVG8+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5jbGFzcyBHcmVhdGVyVGhhbk9yRXF1YWxUbyBleHRlbmRzIENvbXBhcmlzb25CaW5hcnkge1xuICAvKipcbiAgICogQHBhcmFtIHshc3RyaW5nfSBwcm9wZXJ0eU5hbWUgTmFtZSBvZiB0aGUgY29udGV4dCBwcm9wZXJ0eSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IGV4cHJlc3Npb24gVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24pIHtcbiAgICBzdXBlcignUHJvcGVydHlJc0dyZWF0ZXJUaGFuT3JFcXVhbFRvJywgcHJvcGVydHlOYW1lLCBleHByZXNzaW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcmVhdGVyVGhhbk9yRXF1YWxUbztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0ludGVyc2VjdHNcbiAqL1xuaW1wb3J0IFNwYXRpYWwgZnJvbSAnLi9TcGF0aWFsLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxJbnRlcnNlY3RzPmAgb3BlcmF0b3IgdG8gdGVzdCB3aGV0aGVyIGEgZ2VvbWV0cnktdmFsdWVkIHByb3BlcnR5XG4gKiBpbnRlcnNlY3RzIGEgZ2l2ZW4gZ2VvbWV0cnkuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEludGVyc2VjdHMgZXh0ZW5kcyBTcGF0aWFsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gICAgc3VwZXIoJ0ludGVyc2VjdHMnLCBnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcnNlY3RzO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvSXNCZXR3ZWVuXG4gKi9cbmltcG9ydCBDb21wYXJpc29uIGZyb20gJy4vQ29tcGFyaXNvbi5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGA8UHJvcGVydHlJc0JldHdlZW4+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5jbGFzcyBJc0JldHdlZW4gZXh0ZW5kcyBDb21wYXJpc29uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHshbnVtYmVyfSBsb3dlckJvdW5kYXJ5IFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gdXBwZXJCb3VuZGFyeSBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydHlOYW1lLCBsb3dlckJvdW5kYXJ5LCB1cHBlckJvdW5kYXJ5KSB7XG4gICAgc3VwZXIoJ1Byb3BlcnR5SXNCZXR3ZWVuJywgcHJvcGVydHlOYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshbnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJCb3VuZGFyeSA9IGxvd2VyQm91bmRhcnk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IW51bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyQm91bmRhcnkgPSB1cHBlckJvdW5kYXJ5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElzQmV0d2VlbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0lzTGlrZVxuICovXG5pbXBvcnQgQ29tcGFyaXNvbiBmcm9tICcuL0NvbXBhcmlzb24uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBgPFByb3BlcnR5SXNMaWtlPmAgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSXNMaWtlIGV4dGVuZHMgQ29tcGFyaXNvbiB7XG4gIC8qKlxuICAgKiBbY29uc3RydWN0b3IgZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBwYXR0ZXJuIFRleHQgcGF0dGVybi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt3aWxkQ2FyZF0gUGF0dGVybiBjaGFyYWN0ZXIgd2hpY2ggbWF0Y2hlcyBhbnkgc2VxdWVuY2Ugb2ZcbiAgICogICAgemVybyBvciBtb3JlIHN0cmluZyBjaGFyYWN0ZXJzLiBEZWZhdWx0IGlzICcqJy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzaW5nbGVDaGFyXSBwYXR0ZXJuIGNoYXJhY3RlciB3aGljaCBtYXRjaGVzIGFueSBzaW5nbGVcbiAgICogICAgc3RyaW5nIGNoYXJhY3Rlci4gRGVmYXVsdCBpcyAnLicuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXNjYXBlQ2hhcl0gRXNjYXBlIGNoYXJhY3RlciB3aGljaCBjYW4gYmUgdXNlZCB0byBlc2NhcGVcbiAgICogICAgdGhlIHBhdHRlcm4gY2hhcmFjdGVycy4gRGVmYXVsdCBpcyAnIScuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGNoQ2FzZV0gQ2FzZS1zZW5zaXRpdmU/XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm9wZXJ0eU5hbWUsXG4gICAgcGF0dGVybixcbiAgICB3aWxkQ2FyZCxcbiAgICBzaW5nbGVDaGFyLFxuICAgIGVzY2FwZUNoYXIsXG4gICAgbWF0Y2hDYXNlXG4gICkge1xuICAgIHN1cGVyKCdQcm9wZXJ0eUlzTGlrZScsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy53aWxkQ2FyZCA9IHdpbGRDYXJkICE9PSB1bmRlZmluZWQgPyB3aWxkQ2FyZCA6ICcqJztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshc3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc2luZ2xlQ2hhciA9IHNpbmdsZUNoYXIgIT09IHVuZGVmaW5lZCA/IHNpbmdsZUNoYXIgOiAnLic7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmVzY2FwZUNoYXIgPSBlc2NhcGVDaGFyICE9PSB1bmRlZmluZWQgPyBlc2NhcGVDaGFyIDogJyEnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubWF0Y2hDYXNlID0gbWF0Y2hDYXNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElzTGlrZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0lzTnVsbFxuICovXG5pbXBvcnQgQ29tcGFyaXNvbiBmcm9tICcuL0NvbXBhcmlzb24uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBgPFByb3BlcnR5SXNOdWxsPmAgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSXNOdWxsIGV4dGVuZHMgQ29tcGFyaXNvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWUpIHtcbiAgICBzdXBlcignUHJvcGVydHlJc051bGwnLCBwcm9wZXJ0eU5hbWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElzTnVsbDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL0xlc3NUaGFuXG4gKi9cbmltcG9ydCBDb21wYXJpc29uQmluYXJ5IGZyb20gJy4vQ29tcGFyaXNvbkJpbmFyeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGA8UHJvcGVydHlJc0xlc3NUaGFuPmAgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGVzc1RoYW4gZXh0ZW5kcyBDb21wYXJpc29uQmluYXJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcGVydHlOYW1lIE5hbWUgb2YgdGhlIGNvbnRleHQgcHJvcGVydHkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHshbnVtYmVyfSBleHByZXNzaW9uIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydHlOYW1lLCBleHByZXNzaW9uKSB7XG4gICAgc3VwZXIoJ1Byb3BlcnR5SXNMZXNzVGhhbicsIHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGVzc1RoYW47XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9MZXNzVGhhbk9yRXF1YWxUb1xuICovXG5pbXBvcnQgQ29tcGFyaXNvbkJpbmFyeSBmcm9tICcuL0NvbXBhcmlzb25CaW5hcnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBgPFByb3BlcnR5SXNMZXNzVGhhbk9yRXF1YWxUbz5gIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExlc3NUaGFuT3JFcXVhbFRvIGV4dGVuZHMgQ29tcGFyaXNvbkJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbikge1xuICAgIHN1cGVyKCdQcm9wZXJ0eUlzTGVzc1RoYW5PckVxdWFsVG8nLCBwcm9wZXJ0eU5hbWUsIGV4cHJlc3Npb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExlc3NUaGFuT3JFcXVhbFRvO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvTG9naWNhbE5hcnlcbiAqL1xuaW1wb3J0IEZpbHRlciBmcm9tICcuL0ZpbHRlci5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vLi4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90IGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgV0ZTIEdldEZlYXR1cmUgbi1hcnkgbG9naWNhbCBmaWx0ZXJzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBMb2dpY2FsTmFyeSBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhZ05hbWUgVGhlIFhNTCB0YWcgbmFtZSBmb3IgdGhpcyBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9GaWx0ZXIuanNcIikuZGVmYXVsdD59IGNvbmRpdGlvbnMgQ29uZGl0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhZ05hbWUsIGNvbmRpdGlvbnMpIHtcbiAgICBzdXBlcih0YWdOYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL0ZpbHRlci5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBjb25kaXRpb25zO1xuICAgIGFzc2VydCh0aGlzLmNvbmRpdGlvbnMubGVuZ3RoID49IDIsIDU3KTsgLy8gQXQgbGVhc3QgMiBjb25kaXRpb25zIGFyZSByZXF1aXJlZC5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2dpY2FsTmFyeTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvZmlsdGVyL05vdFxuICovXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vRmlsdGVyLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgbG9naWNhbCBgPE5vdD5gIG9wZXJhdG9yIGZvciBhIGZpbHRlciBjb25kaXRpb24uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE5vdCBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuL0ZpbHRlci5qc1wiKS5kZWZhdWx0fSBjb25kaXRpb24gRmlsdGVyIGNvbmRpdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmRpdGlvbikge1xuICAgIHN1cGVyKCdOb3QnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshaW1wb3J0KFwiLi9GaWx0ZXIuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb3Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9Ob3RFcXVhbFRvXG4gKi9cbmltcG9ydCBDb21wYXJpc29uQmluYXJ5IGZyb20gJy4vQ29tcGFyaXNvbkJpbmFyeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGA8UHJvcGVydHlJc05vdEVxdWFsVG8+YCBjb21wYXJpc29uIG9wZXJhdG9yLlxuICogQGFwaVxuICovXG5jbGFzcyBOb3RFcXVhbFRvIGV4dGVuZHMgQ29tcGFyaXNvbkJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BlcnR5TmFtZSBOYW1lIG9mIHRoZSBjb250ZXh0IHByb3BlcnR5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7IShzdHJpbmd8bnVtYmVyKX0gZXhwcmVzc2lvbiBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbWF0Y2hDYXNlXSBDYXNlLXNlbnNpdGl2ZT9cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZSwgZXhwcmVzc2lvbiwgbWF0Y2hDYXNlKSB7XG4gICAgc3VwZXIoJ1Byb3BlcnR5SXNOb3RFcXVhbFRvJywgcHJvcGVydHlOYW1lLCBleHByZXNzaW9uLCBtYXRjaENhc2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vdEVxdWFsVG87XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9PclxuICovXG5pbXBvcnQgTG9naWNhbE5hcnkgZnJvbSAnLi9Mb2dpY2FsTmFyeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGxvZ2ljYWwgYDxPcj5gIG9wZXJhdG9yIGJldHdlZW4gdHdvIG9yIG1vcmUgZmlsdGVyIGNvbmRpdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE9yIGV4dGVuZHMgTG9naWNhbE5hcnkge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi5pbXBvcnQoXCIuL0ZpbHRlci5qc1wiKS5kZWZhdWx0fSBjb25kaXRpb25zIENvbmRpdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25kaXRpb25zKSB7XG4gICAgc3VwZXIoJ09yJywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3I7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9SZXNvdXJjZUlkXG4gKi9cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9GaWx0ZXIuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgUmVzb3VyY2VJZCBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHJpZCBSZXNvdXJjZSBJRC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJpZCkge1xuICAgIHN1cGVyKCdSZXNvdXJjZUlkJyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJpZCA9IHJpZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXNvdXJjZUlkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9maWx0ZXIvU3BhdGlhbFxuICovXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vRmlsdGVyLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBSZXByZXNlbnRzIGEgc3BhdGlhbCBvcGVyYXRvciB0byB0ZXN0IHdoZXRoZXIgYSBnZW9tZXRyeS12YWx1ZWQgcHJvcGVydHlcbiAqIHJlbGF0ZXMgdG8gYSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgU3BhdGlhbCBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhZ05hbWUgVGhlIFhNTCB0YWcgbmFtZSBmb3IgdGhpcyBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gICAgc3VwZXIodGFnTmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IXN0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5TmFtZSA9IGdlb21ldHJ5TmFtZSB8fCAndGhlX2dlb20nO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNyc05hbWUgPSBzcnNOYW1lO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwYXRpYWw7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L2ZpbHRlci9XaXRoaW5cbiAqL1xuaW1wb3J0IFNwYXRpYWwgZnJvbSAnLi9TcGF0aWFsLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgYDxXaXRoaW4+YCBvcGVyYXRvciB0byB0ZXN0IHdoZXRoZXIgYSBnZW9tZXRyeS12YWx1ZWQgcHJvcGVydHlcbiAqIGlzIHdpdGhpbiBhIGdpdmVuIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5jbGFzcyBXaXRoaW4gZXh0ZW5kcyBTcGF0aWFsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZ2VvbWV0cnlOYW1lIEdlb21ldHJ5IG5hbWUgdG8gdXNlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nyc05hbWVdIFNSUyBuYW1lLiBObyBzcnNOYW1lIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqICAgIHNldCBvbiBnZW9tZXRyaWVzIHdoZW4gdGhpcyBpcyBub3QgcHJvdmlkZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZW9tZXRyeU5hbWUsIGdlb21ldHJ5LCBzcnNOYW1lKSB7XG4gICAgc3VwZXIoJ1dpdGhpbicsIGdlb21ldHJ5TmFtZSwgZ2VvbWV0cnksIHNyc05hbWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdpdGhpbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQveGxpbmtcbiAqL1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgTkFNRVNQQUNFX1VSSSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IGhyZWYuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkSHJlZihub2RlKSB7XG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZU5TKE5BTUVTUEFDRV9VUkksICdocmVmJyk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L3hzZFxuICovXG5pbXBvcnQge2dldEFsbFRleHRDb250ZW50LCBnZXREb2N1bWVudH0gZnJvbSAnLi4veG1sLmpzJztcbmltcG9ydCB7cGFkTnVtYmVyfSBmcm9tICcuLi9zdHJpbmcuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IEJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkQm9vbGVhbihub2RlKSB7XG4gIGNvbnN0IHMgPSBnZXRBbGxUZXh0Q29udGVudChub2RlLCBmYWxzZSk7XG4gIHJldHVybiByZWFkQm9vbGVhblN0cmluZyhzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBCb29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEJvb2xlYW5TdHJpbmcoc3RyaW5nKSB7XG4gIGNvbnN0IG0gPSAvXlxccyoodHJ1ZXwxKXwoZmFsc2V8MClcXHMqJC8uZXhlYyhzdHJpbmcpO1xuICBpZiAobSkge1xuICAgIHJldHVybiBtWzFdICE9PSB1bmRlZmluZWQgfHwgZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IERhdGVUaW1lIGluIHNlY29uZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkRGF0ZVRpbWUobm9kZSkge1xuICBjb25zdCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpO1xuICBjb25zdCBkYXRlVGltZSA9IERhdGUucGFyc2Uocyk7XG4gIHJldHVybiBpc05hTihkYXRlVGltZSkgPyB1bmRlZmluZWQgOiBkYXRlVGltZSAvIDEwMDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBEZWNpbWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZERlY2ltYWwobm9kZSkge1xuICBjb25zdCBzID0gZ2V0QWxsVGV4dENvbnRlbnQobm9kZSwgZmFsc2UpO1xuICByZXR1cm4gcmVhZERlY2ltYWxTdHJpbmcocyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBEZWNpbWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZERlY2ltYWxTdHJpbmcoc3RyaW5nKSB7XG4gIC8vIEZJWE1FIGNoZWNrIHNwZWNcbiAgY29uc3QgbSA9IC9eXFxzKihbK1xcLV0/XFxkKlxcLj9cXGQrKD86ZVsrXFwtXT9cXGQrKT8pXFxzKiQvaS5leGVjKHN0cmluZyk7XG4gIGlmIChtKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobVsxXSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE5vbiBuZWdhdGl2ZSBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFBvc2l0aXZlSW50ZWdlcihub2RlKSB7XG4gIGNvbnN0IHMgPSBnZXRBbGxUZXh0Q29udGVudChub2RlLCBmYWxzZSk7XG4gIHJldHVybiByZWFkTm9uTmVnYXRpdmVJbnRlZ2VyU3RyaW5nKHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTm9uIG5lZ2F0aXZlIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkTm9uTmVnYXRpdmVJbnRlZ2VyU3RyaW5nKHN0cmluZykge1xuICBjb25zdCBtID0gL15cXHMqKFxcZCspXFxzKiQvLmV4ZWMoc3RyaW5nKTtcbiAgaWYgKG0pIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobVsxXSwgMTApO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nKG5vZGUpIHtcbiAgcmV0dXJuIGdldEFsbFRleHRDb250ZW50KG5vZGUsIGZhbHNlKS50cmltKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYXBwZW5kIGEgVGV4dE5vZGUgd2l0aCB0aGUgYm9vbGVhbiB0by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYm9vbCBCb29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVCb29sZWFuVGV4dE5vZGUobm9kZSwgYm9vbCkge1xuICB3cml0ZVN0cmluZ1RleHROb2RlKG5vZGUsIGJvb2wgPyAnMScgOiAnMCcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFwcGVuZCBhIENEQVRBIFNlY3Rpb24gd2l0aCB0aGUgc3RyaW5nIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUNEQVRBU2VjdGlvbihub2RlLCBzdHJpbmcpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChnZXREb2N1bWVudCgpLmNyZWF0ZUNEQVRBU2VjdGlvbihzdHJpbmcpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBkYXRlVGltZSB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRlVGltZSBEYXRlVGltZSBpbiBzZWNvbmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVEYXRlVGltZVRleHROb2RlKG5vZGUsIGRhdGVUaW1lKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlVGltZSAqIDEwMDApO1xuICBjb25zdCBzdHJpbmcgPVxuICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArXG4gICAgJy0nICtcbiAgICBwYWROdW1iZXIoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgK1xuICAgICctJyArXG4gICAgcGFkTnVtYmVyKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKSArXG4gICAgJ1QnICtcbiAgICBwYWROdW1iZXIoZGF0ZS5nZXRVVENIb3VycygpLCAyKSArXG4gICAgJzonICtcbiAgICBwYWROdW1iZXIoZGF0ZS5nZXRVVENNaW51dGVzKCksIDIpICtcbiAgICAnOicgK1xuICAgIHBhZE51bWJlcihkYXRlLmdldFVUQ1NlY29uZHMoKSwgMikgK1xuICAgICdaJztcbiAgbm9kZS5hcHBlbmRDaGlsZChnZXREb2N1bWVudCgpLmNyZWF0ZVRleHROb2RlKHN0cmluZykpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFwcGVuZCBhIFRleHROb2RlIHdpdGggdGhlIGRlY2ltYWwgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbCBEZWNpbWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVEZWNpbWFsVGV4dE5vZGUobm9kZSwgZGVjaW1hbCkge1xuICBjb25zdCBzdHJpbmcgPSBkZWNpbWFsLnRvUHJlY2lzaW9uKCk7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoZ2V0RG9jdW1lbnQoKS5jcmVhdGVUZXh0Tm9kZShzdHJpbmcpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhcHBlbmQgYSBUZXh0Tm9kZSB3aXRoIHRoZSBkZWNpbWFsIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IG5vbk5lZ2F0aXZlSW50ZWdlciBOb24gbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTm9uTmVnYXRpdmVJbnRlZ2VyVGV4dE5vZGUobm9kZSwgbm9uTmVnYXRpdmVJbnRlZ2VyKSB7XG4gIGNvbnN0IHN0cmluZyA9IG5vbk5lZ2F0aXZlSW50ZWdlci50b1N0cmluZygpO1xuICBub2RlLmFwcGVuZENoaWxkKGdldERvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYXBwZW5kIGEgVGV4dE5vZGUgd2l0aCB0aGUgc3RyaW5nIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVN0cmluZ1RleHROb2RlKG5vZGUsIHN0cmluZykge1xuICBub2RlLmFwcGVuZENoaWxkKGdldERvY3VtZW50KCkuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKSk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ZsaXBcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVzdE9mZnNldF0gRGVzdGluYXRpb24gb2Zmc2V0LlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsaXBYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGRlc3QsIGRlc3RPZmZzZXQpIHtcbiAgaWYgKGRlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3QgPSBkZXN0O1xuICAgIGRlc3RPZmZzZXQgPSBkZXN0T2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBkZXN0T2Zmc2V0IDogMDtcbiAgfSBlbHNlIHtcbiAgICBkZXN0ID0gW107XG4gICAgZGVzdE9mZnNldCA9IDA7XG4gIH1cbiAgbGV0IGogPSBvZmZzZXQ7XG4gIHdoaWxlIChqIDwgZW5kKSB7XG4gICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tqKytdO1xuICAgIGRlc3RbZGVzdE9mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1tqKytdO1xuICAgIGRlc3RbZGVzdE9mZnNldCsrXSA9IHg7XG4gICAgZm9yIChsZXQgayA9IDI7IGsgPCBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW2orK107XG4gICAgfVxuICB9XG4gIGRlc3QubGVuZ3RoID0gZGVzdE9mZnNldDtcbiAgcmV0dXJuIGRlc3Q7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb25cbiAqL1xuZXhwb3J0IHtkZWZhdWx0IGFzIERvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERibENsaWNrRHJhZ1pvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vRGJsQ2xpY2tEcmFnWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ0FuZERyb3B9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3AuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdCb3h9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ1Bhbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnUm90YXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdSb3RhdGVBbmRab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhd30gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmF3LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFeHRlbnR9IGZyb20gJy4vaW50ZXJhY3Rpb24vRXh0ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbnRlcmFjdGlvbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS2V5Ym9hcmRQYW59IGZyb20gJy4vaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEtleWJvYXJkWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIExpbmt9IGZyb20gJy4vaW50ZXJhY3Rpb24vTGluay5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTW9kaWZ5fSBmcm9tICcuL2ludGVyYWN0aW9uL01vZGlmeS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTW91c2VXaGVlbFpvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBpbmNoUm90YXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQaW5jaFpvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vUGluY2hab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQb2ludGVyfSBmcm9tICcuL2ludGVyYWN0aW9uL1BvaW50ZXIuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNlbGVjdH0gZnJvbSAnLi9pbnRlcmFjdGlvbi9TZWxlY3QuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNuYXB9IGZyb20gJy4vaW50ZXJhY3Rpb24vU25hcC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVHJhbnNsYXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL1RyYW5zbGF0ZS5qcyc7XG5leHBvcnQge2RlZmF1bHRzfSBmcm9tICcuL2ludGVyYWN0aW9uL2RlZmF1bHRzLmpzJztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EYmxDbGlja0RyYWdab29tXG4gKi9cbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gbW92ZSBvZiBvbmUgcGl4ZWwuICpcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oYm9vbGVhbik6Ym9vbGVhbn0gW3N0b3BEb3duXVxuICogU2hvdWxkIHRoZSBkb3duIGV2ZW50IGJlIHByb3BhZ2F0ZWQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zLCBvciBzaG91bGQgYmVcbiAqIHN0b3BwZWQ/XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IGRvdWJsZSB0YXAvY2xpayB0aGVuIGRyYWcgdXAvZG93blxuICogd2l0aCBvbmUgZmluZ2VyL2xlZnQgbW91c2UuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIERibENsaWNrRHJhZ1pvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRfb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLkludGVyYWN0aW9uT3B0aW9uc30gKi8gKG9wdGlvbnMpXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICB0aGlzLnN0b3BEb3duID0gb3B0aW9ucy5zdG9wRG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZURlbHRhQnlQaXhlbF8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDAuMDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2VfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxpbmdEb3VibGVEb3duU2VxdWVuY2VfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIFBvaW50ZXJFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZWRQb2ludGVyc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2ludGVyRXZlbnQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50ICBtYXAgYnJvd3NlciBldmVudH0gYW5kIG1heSBjYWxsIGludG9cbiAgICogb3RoZXIgZnVuY3Rpb25zLCBpZiBldmVudCBzZXF1ZW5jZXMgbGlrZSBlLmcuICdkcmFnJyBvciAnZG93bi11cCcgZXRjLiBhcmVcbiAgICogZGV0ZWN0ZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgaWYgKHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZV8pIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIC8vIHByZXZlbnQgcGFnZSBzY3JvbGxpbmcgZHVyaW5nIGRyYWdnaW5nXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWRVcCA9IHRoaXMuaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2VfID0gaGFuZGxlZFVwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGluZ0RvdWJsZURvd25TZXF1ZW5jZV8pIHtcbiAgICAgICAgICB0aGlzLmhhbmRsaW5nRG91YmxlRG93blNlcXVlbmNlXyA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZWQgPSB0aGlzLmhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZV8gPSBoYW5kbGVkO1xuICAgICAgICAgIHN0b3BFdmVudCA9IHRoaXMuc3RvcERvd24oaGFuZGxlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcEV2ZW50ID0gdGhpcy5zdG9wRG93bihmYWxzZSk7XG4gICAgICAgICAgdGhpcy53YWl0Rm9yRGJsVGFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc2NhbGVEZWx0YSA9IDEuMDtcblxuICAgIGNvbnN0IHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgY29uc3QgdG91Y2gxID0gdGhpcy5kb3duXy5vcmlnaW5hbEV2ZW50O1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIGlmICh0aGlzLmxhc3REaXN0YW5jZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NhbGVEZWx0YSA9XG4gICAgICAgIDEgLSAodGhpcy5sYXN0RGlzdGFuY2VfIC0gZGlzdGFuY2UpICogdGhpcy5zY2FsZURlbHRhQnlQaXhlbF87XG4gICAgfVxuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IGRpc3RhbmNlO1xuXG4gICAgaWYgKHNjYWxlRGVsdGEgIT0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IHNjYWxlRGVsdGE7XG4gICAgfVxuXG4gICAgLy8gc2NhbGUsIGJ5cGFzcyB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50XG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBtYXAucmVuZGVyKCk7XG4gICAgdmlldy5hZGp1c3RSZXNvbHV0aW9uSW50ZXJuYWwoc2NhbGVEZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gICAgICB0aGlzLmRvd25fID0gbWFwQnJvd3NlckV2ZW50O1xuICAgICAgaWYgKCF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2VfKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMgem9vbWluZyBvdXQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09IDApIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMubGFzdFNjYWxlRGVsdGFfID4gMSA/IDEgOiAtMTtcbiAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24odGhpcy5kdXJhdGlvbl8sIGRpcmVjdGlvbik7XG4gICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2VfID0gZmFsc2U7XG4gICAgICB0aGlzLmhhbmRsaW5nRG91YmxlRG93blNlcXVlbmNlXyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIFwiZG93blwiIGV2ZW50cyBzaG91bGQgYmUgcHJvcGFnYXRlZFxuICAgKiB0byBvdGhlciBpbnRlcmFjdGlvbnMgb3Igc2hvdWxkIGJlIHN0b3BwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBTaG91bGQgdGhlIGBkb3duYCBldmVudCBiZSBzdG9wcGVkP1xuICAgKi9cbiAgc3RvcERvd24oaGFuZGxlZCkge1xuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVRyYWNrZWRQb2ludGVyc18obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKGlzUG9pbnRlckRyYWdnaW5nRXZlbnQobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudDtcblxuICAgICAgY29uc3QgaWQgPSBldmVudC5wb2ludGVySWQudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgICBkZWxldGUgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVyc19baWRdID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKGlkIGluIHRoaXMudHJhY2tlZFBvaW50ZXJzXykge1xuICAgICAgICAvLyB1cGRhdGUgb25seSB3aGVuIHRoZXJlIHdhcyBhIHBvaW50ZXJkb3duIGV2ZW50IGZvciB0aGlzIHBvaW50ZXJcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXSA9IGV2ZW50O1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXRQb2ludGVycyA9IE9iamVjdC52YWx1ZXModGhpcy50cmFja2VkUG9pbnRlcnNfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FpdCB0aGUgc2Vjb25kIGRvdWJsZSBmaW5nZXIgdGFwLlxuICAgKi9cbiAgd2FpdEZvckRibFRhcCgpIHtcbiAgICBpZiAodGhpcy5kb3VibGVUYXBUaW1lb3V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRvdWJsZS1jbGlja1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlVGFwVGltZW91dElkXyk7XG4gICAgICB0aGlzLmRvdWJsZVRhcFRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxpbmdEb3VibGVEb3duU2VxdWVuY2VfID0gdHJ1ZTtcbiAgICAgIHRoaXMuZG91YmxlVGFwVGltZW91dElkXyA9IHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgMjUwXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5kSW50ZXJhY3Rpb24oKSB7XG4gICAgdGhpcy5oYW5kbGluZ0RvdWJsZURvd25TZXF1ZW5jZV8gPSBmYWxzZTtcbiAgICB0aGlzLmRvdWJsZVRhcFRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBldmVudCBpcyBhIHBvaW50ZXJkb3duLCBwb2ludGVyZHJhZ1xuICogICAgIG9yIHBvaW50ZXJ1cCBldmVudC5cbiAqL1xuZnVuY3Rpb24gaXNQb2ludGVyRHJhZ2dpbmdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgdHlwZSA9IG1hcEJyb3dzZXJFdmVudC50eXBlO1xuICByZXR1cm4gKFxuICAgIHR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICB0eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHIHx8XG4gICAgdHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVBcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRGJsQ2xpY2tEcmFnWm9vbTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcFxuICovXG4vLyBGSVhNRSBzaG91bGQgaGFuZGxlIGFsbCBnZW8tcmVmZXJlbmNlZCBkYXRhLCBub3QganVzdCB2ZWN0b3IgZGF0YVxuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBnZXRVc2VyUHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PHR5cGVvZiBpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZm9ybWF0Q29uc3RydWN0b3JzXSBGb3JtYXQgY29uc3RydWN0b3JzXG4gKiAoYW5kL29yIGZvcm1hdHMgcHJlLWNvbnN0cnVjdGVkIHdpdGggb3B0aW9ucykuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gT3B0aW9uYWwgdmVjdG9yIHNvdXJjZSB3aGVyZSBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkLiAgSWYgYSBzb3VyY2UgaXMgcHJvdmlkZWRcbiAqIGFsbCBleGlzdGluZyBmZWF0dXJlcyB3aWxsIGJlIHJlbW92ZWQgYW5kIG5ldyBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkIHdoZW5cbiAqIHRoZXkgYXJlIGRyb3BwZWQgb24gdGhlIHRhcmdldC4gIElmIHlvdSB3YW50IHRvIGFkZCBmZWF0dXJlcyB0byBhIHZlY3RvclxuICogc291cmNlIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGV4aXN0aW5nIGZlYXR1cmVzIChhcHBlbmQgb25seSksIGluc3RlYWQgb2ZcbiAqIHByb3ZpZGluZyB0aGUgc291cmNlIG9wdGlvbiBsaXN0ZW4gZm9yIHRoZSBcImFkZGZlYXR1cmVzXCIgZXZlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBUYXJnZXQgcHJvamVjdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1hcCdzIHZpZXcncyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbdGFyZ2V0XSBUaGUgZWxlbWVudCB0aGF0IGlzIHVzZWQgYXMgdGhlIGRyb3AgdGFyZ2V0LCBkZWZhdWx0IGlzIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgRHJhZ0FuZERyb3BFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlcyBhcmUgYWRkZWRcbiAgICogQGV2ZW50IERyYWdBbmREcm9wRXZlbnQjYWRkZmVhdHVyZXNcbiAgICogQGFwaVxuICAgKi9cbiAgQUREX0ZFQVRVUkVTOiAnYWRkZmVhdHVyZXMnLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdBbmREcm9wfkRyYWdBbmREcm9wfSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlc1xuICogb2YgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgRHJhZ0FuZERyb3BFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RHJhZ0FuZERyb3BFdmVudFR5cGV9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIEZpbGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gW2ZlYXR1cmVzXSBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmaWxlLCBmZWF0dXJlcywgcHJvamVjdGlvbikge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIHBhcnNlZCBmcm9tIGRyb3BwZWQgZGF0YS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT58dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJvcHBlZCBmaWxlLlxuICAgICAqIEB0eXBlIHtGaWxlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmUgcHJvamVjdGlvbi5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZScsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8J2FkZGZlYXR1cmVzJywgRHJhZ0FuZERyb3BFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJ3wnYWRkZmVhdHVyZXMnLCBSZXR1cm4+fSBEcmFnQW5kRHJvcE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIYW5kbGVzIGlucHV0IG9mIHZlY3RvciBkYXRhIGJ5IGRyYWcgYW5kIGRyb3AuXG4gKlxuICogQGFwaVxuICpcbiAqIEBmaXJlcyBEcmFnQW5kRHJvcEV2ZW50XG4gKi9cbmNsYXNzIERyYWdBbmREcm9wIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGhhbmRsZUV2ZW50OiBUUlVFLFxuICAgIH0pO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQW5kRHJvcE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0RyYWdBbmREcm9wT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQW5kRHJvcE9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVhZEFzQnVmZmVyXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRzXyA9IFtdO1xuICAgIGNvbnN0IGZvcm1hdENvbnN0cnVjdG9ycyA9IG9wdGlvbnMuZm9ybWF0Q29uc3RydWN0b3JzXG4gICAgICA/IG9wdGlvbnMuZm9ybWF0Q29uc3RydWN0b3JzXG4gICAgICA6IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZvcm1hdENvbnN0cnVjdG9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBsZXQgZm9ybWF0ID0gZm9ybWF0Q29uc3RydWN0b3JzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9ybWF0ID0gbmV3IGZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXRzXy5wdXNoKGZvcm1hdCk7XG4gICAgICB0aGlzLnJlYWRBc0J1ZmZlcl8gPVxuICAgICAgICB0aGlzLnJlYWRBc0J1ZmZlcl8gfHwgZm9ybWF0LmdldFR5cGUoKSA9PT0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb25fID0gb3B0aW9ucy5wcm9qZWN0aW9uXG4gICAgICA/IGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuZHJvcExpc3RlbktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBvcHRpb25zLnNvdXJjZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0ID8gb3B0aW9ucy50YXJnZXQgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBMb2FkIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUmVzdWx0XyhmaWxlLCBldmVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBsZXQgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbl87XG4gICAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgICBwcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICghcHJvamVjdGlvbikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgcHJvamVjdGlvbiA9IHZpZXcuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0ZXh0O1xuICAgIGNvbnN0IGZvcm1hdHMgPSB0aGlzLmZvcm1hdHNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZvcm1hdHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tpXTtcbiAgICAgIGxldCBpbnB1dCA9IHJlc3VsdDtcbiAgICAgIGlmICh0aGlzLnJlYWRBc0J1ZmZlcl8gJiYgZm9ybWF0LmdldFR5cGUoKSAhPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy50cnlSZWFkRmVhdHVyZXNfKGZvcm1hdCwgaW5wdXQsIHtcbiAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICB9KTtcbiAgICAgIGlmIChmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZV8uY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLnNvdXJjZV8uYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgRHJhZ0FuZERyb3BFdmVudChcbiAgICAgICAgICAgIERyYWdBbmREcm9wRXZlbnRUeXBlLkFERF9GRUFUVVJFUyxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgIHByb2plY3Rpb25cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVnaXN0ZXJMaXN0ZW5lcnNfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgY29uc3QgZHJvcEFyZWEgPSB0aGlzLnRhcmdldCA/IHRoaXMudGFyZ2V0IDogbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJPUCwgdGhpcy5oYW5kbGVEcm9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJBR0VOVEVSLCB0aGlzLmhhbmRsZVN0b3AsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oZHJvcEFyZWEsIEV2ZW50VHlwZS5EUkFHT1ZFUiwgdGhpcy5oYW5kbGVTdG9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJPUCwgdGhpcy5oYW5kbGVTdG9wLCB0aGlzKSxcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0QWN0aXZlKCkgJiYgYWN0aXZlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRBY3RpdmUoKSAmJiAhYWN0aXZlKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnNfKCk7XG4gICAgfVxuICAgIHN1cGVyLnNldEFjdGl2ZShhY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnNfKCk7XG4gICAgc3VwZXIuc2V0TWFwKG1hcCk7XG4gICAgaWYgKHRoaXMuZ2V0QWN0aXZlKCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnNfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZvcm1hdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gb3B0aW9ucyBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKi9cbiAgdHJ5UmVhZEZlYXR1cmVzXyhmb3JtYXQsIHRleHQsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICAgICAgICAoZm9ybWF0LnJlYWRGZWF0dXJlcyh0ZXh0LCBvcHRpb25zKSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bnJlZ2lzdGVyTGlzdGVuZXJzXygpIHtcbiAgICBpZiAodGhpcy5kcm9wTGlzdGVuS2V5c18pIHtcbiAgICAgIHRoaXMuZHJvcExpc3RlbktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBldmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyb3AoZXZlbnQpIHtcbiAgICBjb25zdCBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmaWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXMuaXRlbShpKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLkxPQUQsXG4gICAgICAgIHRoaXMuaGFuZGxlUmVzdWx0Xy5iaW5kKHRoaXMsIGZpbGUpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMucmVhZEFzQnVmZmVyXykge1xuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlU3RvcChldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0FuZERyb3A7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb21cbiAqL1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHttb3VzZU9ubHksIHNoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uc2hpZnRLZXlPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gYW5kIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZ1xuICogb24gdGhlIG1hcC4gIEJ5IGRlZmF1bHQsIHRoaXMgaW50ZXJhY3Rpb24gaXMgbGltaXRlZCB0byB3aGVuIHRoZSBzaGlmdFxuICoga2V5IGlzIGhlbGQgZG93bi5cbiAqXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICpcbiAqIEFuZCB0aGlzIGludGVyYWN0aW9uIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGVmYXVsdCBpbnRlcmFjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIERyYWdSb3RhdGVBbmRab29tIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcigvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RNYWduaXR1ZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCBzaXplID0gbWFwLmdldFNpemUoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgY29uc3QgZGVsdGFYID0gb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDI7XG4gICAgY29uc3QgZGVsdGFZID0gc2l6ZVsxXSAvIDIgLSBvZmZzZXRbMV07XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKGRlbHRhWSwgZGVsdGFYKTtcbiAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodGhpcy5sYXN0QW5nbGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGFuZ2xlRGVsdGEgPSB0aGlzLmxhc3RBbmdsZV8gLSB0aGV0YTtcbiAgICAgIHZpZXcuYWRqdXN0Um90YXRpb25JbnRlcm5hbChhbmdsZURlbHRhKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdGhldGE7XG4gICAgaWYgKHRoaXMubGFzdE1hZ25pdHVkZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmlldy5hZGp1c3RSZXNvbHV0aW9uSW50ZXJuYWwodGhpcy5sYXN0TWFnbml0dWRlXyAvIG1hZ25pdHVkZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RNYWduaXR1ZGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gdGhpcy5sYXN0TWFnbml0dWRlXyAvIG1hZ25pdHVkZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IG1hZ25pdHVkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyA+IDEgPyAxIDogLTE7XG4gICAgdmlldy5lbmRJbnRlcmFjdGlvbih0aGlzLmR1cmF0aW9uXywgZGlyZWN0aW9uKTtcbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgbWFwQnJvd3NlckV2ZW50Lm1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1JvdGF0ZUFuZFpvb207XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhd1xuICovXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL2dlb20vQ2lyY2xlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBmcm9tICcuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4uL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi4vZ2VvbS9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBNdWx0aVBvbHlnb24gZnJvbSAnLi4vZ2VvbS9NdWx0aVBvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFBvbHlnb24sIHtmcm9tQ2lyY2xlLCBtYWtlUmVndWxhcn0gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yLmpzJztcbmltcG9ydCB7RkFMU0UsIFRSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhbHdheXMsXG4gIG5ldmVyLFxuICBub01vZGlmaWVyS2V5cyxcbiAgc2hpZnRLZXlPbmx5LFxufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7XG4gIGJvdW5kaW5nRXh0ZW50LFxuICBnZXRCb3R0b21MZWZ0LFxuICBnZXRCb3R0b21SaWdodCxcbiAgZ2V0VG9wTGVmdCxcbiAgZ2V0VG9wUmlnaHQsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wLCBzcXVhcmVkRGlzdGFuY2UsIHRvRml4ZWR9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVFZGl0aW5nU3R5bGV9IGZyb20gJy4uL3N0eWxlL1N0eWxlLmpzJztcbmltcG9ydCB7XG4gIGRpc3RhbmNlLFxuICBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSxcbn0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2Zyb21Vc2VyQ29vcmRpbmF0ZSwgZ2V0VXNlclByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRTdHJpZGVGb3JMYXlvdXR9IGZyb20gJy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5UeXBlfSB0eXBlIEdlb21ldHJ5IHR5cGUgb2ZcbiAqIHRoZSBnZW9tZXRyaWVzIGJlaW5nIGRyYXduIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2xpY2tUb2xlcmFuY2U9Nl0gVGhlIG1heGltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW5cbiAqIFwiZG93blwiIGFuZCBcInVwXCIgZm9yIGEgXCJ1cFwiIGV2ZW50IHRvIGJlIGNvbnNpZGVyZWQgYSBcImNsaWNrXCIgZXZlbnQgYW5kXG4gKiBhY3R1YWxseSBhZGQgYSBwb2ludC92ZXJ0ZXggdG8gdGhlIGdlb21ldHJ5IGJlaW5nIGRyYXduLiAgVGhlIGRlZmF1bHQgb2YgYDZgXG4gKiB3YXMgY2hvc2VuIGZvciB0aGUgZHJhdyBpbnRlcmFjdGlvbiB0byBiZWhhdmUgY29ycmVjdGx5IG9uIG1vdXNlIGFzIHdlbGwgYXNcbiAqIG9uIHRvdWNoIGRldmljZXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxGZWF0dXJlPn0gW2ZlYXR1cmVzXVxuICogRGVzdGluYXRpb24gY29sbGVjdGlvbiBmb3IgdGhlIGRyYXduIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtWZWN0b3JTb3VyY2V9IFtzb3VyY2VdIERlc3RpbmF0aW9uIHNvdXJjZSBmb3JcbiAqIHRoZSBkcmF3biBmZWF0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhZ1ZlcnRleERlbGF5PTUwMF0gRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHBvaW50ZXJkb3duXG4gKiBiZWZvcmUgdGhlIGN1cnJlbnQgdmVydGV4IGNhbiBiZSBkcmFnZ2VkIHRvIGl0cyBleGFjdCBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc25hcFRvbGVyYW5jZT0xMl0gUGl4ZWwgZGlzdGFuY2UgZm9yIHNuYXBwaW5nIHRvIHRoZVxuICogZHJhd2luZyBmaW5pc2guIE11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N0b3BDbGljaz1mYWxzZV0gU3RvcCBjbGljaywgc2luZ2xlY2xpY2ssIGFuZFxuICogZG91YmxlY2xpY2sgZXZlbnRzIGZyb20gZmlyaW5nIGR1cmluZyBkcmF3aW5nLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhQb2ludHNdIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgY2FuIGJlIGRyYXduIGJlZm9yZVxuICogYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmcgaXMgZmluaXNoZWQuIEJ5IGRlZmF1bHQgdGhlcmUgaXMgbm9cbiAqIHJlc3RyaWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5Qb2ludHNdIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgbXVzdCBiZSBkcmF3blxuICogYmVmb3JlIGEgcG9seWdvbiByaW5nIG9yIGxpbmUgc3RyaW5nIGNhbiBiZSBmaW5pc2hlZC4gRGVmYXVsdCBpcyBgM2AgZm9yXG4gKiBwb2x5Z29uIHJpbmdzIGFuZCBgMmAgZm9yIGxpbmUgc3RyaW5ncy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtmaW5pc2hDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGRyYXdpbmcgY2FuIGJlIGZpbmlzaGVkLiBOb3QgdXNlZCB3aGVuIGRyYXdpbmdcbiAqIFBPSU5UIG9yIE1VTFRJX1BPSU5UIGdlb21ldHJpZXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V9IFtzdHlsZV1cbiAqIFN0eWxlIGZvciBza2V0Y2ggZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge0dlb21ldHJ5RnVuY3Rpb259IFtnZW9tZXRyeUZ1bmN0aW9uXVxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGdlb21ldHJ5J3MgY29vcmRpbmF0ZXMgYXJlIHVwZGF0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dlb21ldHJ5TmFtZV0gR2VvbWV0cnkgbmFtZSB0byB1c2UgZm9yIGZlYXR1cmVzIGNyZWF0ZWRcbiAqIGJ5IHRoZSBkcmF3IGludGVyYWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogQnkgZGVmYXVsdCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ubm9Nb2RpZmllcktleXN9LCBpLmUuIGEgY2xpY2ssXG4gKiBhZGRzIGEgdmVydGV4IG9yIGRlYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmcmVlaGFuZD1mYWxzZV0gT3BlcmF0ZSBpbiBmcmVlaGFuZCBtb2RlIGZvciBsaW5lcyxcbiAqIHBvbHlnb25zLCBhbmQgY2lyY2xlcy4gIFRoaXMgbWFrZXMgdGhlIGludGVyYWN0aW9uIGFsd2F5cyBvcGVyYXRlIGluIGZyZWVoYW5kXG4gKiBtb2RlIGFuZCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IGBmcmVlaGFuZENvbmRpdGlvbmAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2ZyZWVoYW5kQ29uZGl0aW9uXVxuICogQ29uZGl0aW9uIHRoYXQgYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcgZm9yIGxpbmVzIGFuZCBwb2x5Z29ucy4gVGhpc1xuICogZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmRcbiAqIHJldHVybnMgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gVGhlXG4gKiBkZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5zaGlmdEtleU9ubHl9LCBtZWFuaW5nIHRoYXQgdGhlXG4gKiBTaGlmdCBrZXkgYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFt0cmFjZT1mYWxzZV0gVHJhY2UgYSBwb3J0aW9uIG9mIGFub3RoZXIgZ2VvbWV0cnkuXG4gKiBJZ25vcmVkIHdoZW4gaW4gZnJlZWhhbmQgbW9kZS5cbiAqIEBwcm9wZXJ0eSB7VmVjdG9yU291cmNlfSBbdHJhY2VTb3VyY2VdIFNvdXJjZSBmb3IgZmVhdHVyZXMgdG8gdHJhY2UuICBJZiB0cmFjaW5nIGlzIGFjdGl2ZSBhbmQgYSBgdHJhY2VTb3VyY2VgIGlzXG4gKiBub3QgcHJvdmlkZWQsIHRoZSBpbnRlcmFjdGlvbidzIGBzb3VyY2VgIHdpbGwgYmUgdXNlZC4gIFRyYWNpbmcgcmVxdWlyZXMgdGhhdCB0aGUgaW50ZXJhY3Rpb24gaXMgY29uZmlndXJlZCB3aXRoXG4gKiBlaXRoZXIgYSBgdHJhY2VTb3VyY2VgIG9yIGEgYHNvdXJjZWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBza2V0Y2hcbiAqIG92ZXJsYXkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtnZW9tZXRyeUxheW91dD0nWFknXSBMYXlvdXQgb2YgdGhlXG4gKiBmZWF0dXJlIGdlb21ldHJpZXMgY3JlYXRlZCBieSB0aGUgZHJhdyBpbnRlcmFjdGlvbi5cbiAqL1xuXG4vKipcbiAqIENvb3JkaW5hdGUgdHlwZSB3aGVuIGRyYXdpbmcgcG9pbnRzLlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnRDb29yZFR5cGVcbiAqL1xuXG4vKipcbiAqIENvb3JkaW5hdGUgdHlwZSB3aGVuIGRyYXdpbmcgbGluZXMuXG4gKiBAdHlwZWRlZiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gTGluZUNvb3JkVHlwZVxuICovXG5cbi8qKlxuICogQ29vcmRpbmF0ZSB0eXBlIHdoZW4gZHJhd2luZyBwb2x5Z29ucy5cbiAqIEB0eXBlZGVmIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gUG9seUNvb3JkVHlwZVxuICovXG5cbi8qKlxuICogVHlwZXMgdXNlZCBmb3IgZHJhd2luZyBjb29yZGluYXRlcy5cbiAqIEB0eXBlZGVmIHtQb2ludENvb3JkVHlwZXxMaW5lQ29vcmRUeXBlfFBvbHlDb29yZFR5cGV9IFNrZXRjaENvb3JkVHlwZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhY2VTdGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBhY3RpdmUgVHJhY2luZyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBbc3RhcnRQeF0gVGhlIGluaXRpYWxseSBjbGlja2VkIHBpeGVsIGxvY2F0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxUcmFjZVRhcmdldD59IFt0YXJnZXRzXSBUYXJnZXRzIGF2YWlsYWJsZSBmb3IgdHJhY2luZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0SW5kZXhdIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHRyYWNlZCB0YXJnZXQuICBBIHZhbHVlIG9mIC0xIGluZGljYXRlc1xuICogdGhhdCBubyB0cmFjZSB0YXJnZXQgaXMgYWN0aXZlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhY2VUYXJnZXRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgVGFyZ2V0IGNvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSByaW5nIFRoZSB0YXJnZXQgY29vcmRpbmF0ZXMgYXJlIGEgbGluZWFyIHJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRJbmRleCBUaGUgaW5kZXggb2YgZmlyc3QgdHJhY2VkIGNvb3JkaW5hdGUuICBBIGZyYWN0aW9uYWwgaW5kZXggcmVwcmVzZW50cyBhblxuICogZWRnZSBpbnRlcnNlY3Rpb24uICBJbmRleCB2YWx1ZXMgZm9yIHJpbmdzIHdpbGwgd3JhcCAobWF5IGJlIG5lZ2F0aXZlIG9yIGxhcmdlciB0aGFuIGNvb3JkaW5hdGVzIGxlbmd0aCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kSW5kZXggVGhlIGluZGV4IG9mIGxhc3QgdHJhY2VkIGNvb3JkaW5hdGUuICBEZXRhaWxzIGZyb20gc3RhcnRJbmRleCBhbHNvIGFwcGx5IGhlcmUuXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIGFuZCBhbiBvcHRpb25hbCBleGlzdGluZyBnZW9tZXRyeVxuICogYW5kIGEgcHJvamVjdGlvbiBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIGEgZ2VvbWV0cnkuIFRoZSBvcHRpb25hbCBleGlzdGluZ1xuICogZ2VvbWV0cnkgaXMgdGhlIGdlb21ldHJ5IHRoYXQgaXMgcmV0dXJuZWQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGhvdXRcbiAqIGEgc2Vjb25kIGFyZ3VtZW50LlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKCFTa2V0Y2hDb29yZFR5cGUsIGltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdCxcbiAqICAgICBpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6XG4gKiAgICAgaW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J1BvaW50JyB8ICdMaW5lU3RyaW5nJyB8ICdQb2x5Z29uJyB8ICdDaXJjbGUnfSBNb2RlXG4gKiBEcmF3IG1vZGUuICBUaGlzIGNvbGxhcHNlcyBtdWx0aS1wYXJ0IGdlb21ldHJ5IHR5cGVzIHdpdGggdGhlaXIgc2luZ2xlLXBhcnRcbiAqIGNvdXNpbnMuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBEcmF3RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSBkcmF3IHN0YXJ0XG4gICAqIEBldmVudCBEcmF3RXZlbnQjZHJhd3N0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIERSQVdTVEFSVDogJ2RyYXdzdGFydCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIGRyYXcgZW5kXG4gICAqIEBldmVudCBEcmF3RXZlbnQjZHJhd2VuZFxuICAgKiBAYXBpXG4gICAqL1xuICBEUkFXRU5EOiAnZHJhd2VuZCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIGRyYXcgYWJvcnRpb25cbiAgICogQGV2ZW50IERyYXdFdmVudCNkcmF3YWJvcnRcbiAgICogQGFwaVxuICAgKi9cbiAgRFJBV0FCT1JUOiAnZHJhd2Fib3J0Jyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkRyYXd9IGluc3RhbmNlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBEcmF3RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RyYXdFdmVudFR5cGV9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIFRoZSBmZWF0dXJlIGRyYXduLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgZmVhdHVyZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmUgYmVpbmcgZHJhd24uXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8RmVhdHVyZT59IGZlYXR1cmVzIFRoZSBjYW5kaWRhdGUgZmVhdHVyZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxUcmFjZVRhcmdldD59IFRoZSB0cmFjZSB0YXJnZXRzLlxuICovXG5mdW5jdGlvbiBnZXRUcmFjZVRhcmdldHMoY29vcmRpbmF0ZSwgZmVhdHVyZXMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxUcmFjZVRhcmdldD59XG4gICAqL1xuICBjb25zdCB0YXJnZXRzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBhcHBlbmRHZW9tZXRyeVRyYWNlVGFyZ2V0cyhjb29yZGluYXRlLCBnZW9tZXRyeSwgdGFyZ2V0cyk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0cztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBPbmUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIEFub3RoZXIgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBnZXRTcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKGFbMF0sIGFbMV0sIGJbMF0sIGJbMV0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgVGhlIHJpbmcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4LiAgTWF5IGJlIHdyYXBwZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlKGNvb3JkaW5hdGVzLCBpbmRleCkge1xuICBjb25zdCBjb3VudCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBjb29yZGluYXRlc1tpbmRleCArIGNvdW50XTtcbiAgfVxuICBpZiAoaW5kZXggPj0gY291bnQpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbaW5kZXggLSBjb3VudF07XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGVzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1bXVsYXRpdmUgc3F1YXJlZCBkaXN0YW5jZSBhbG9uZyBhIHJpbmcgcGF0aC4gIFRoZSBlbmQgaW5kZXggaW5kZXggbWF5IGJlIFwid3JhcHBlZFwiIGFuZCBpdCBtYXlcbiAqIGJlIGxlc3MgdGhhbiB0aGUgc3RhcnQgaW5kZXggdG8gaW5kaWNhdGUgdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwuICBUaGUgc3RhcnQgYW5kIGVuZCBpbmRleCBtYXkgaGF2ZVxuICogYSBmcmFjdGlvbmFsIHBhcnQgdG8gaW5kaWNhdGUgYSBwb2ludCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7TGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgUmluZyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleCBUaGUgZW5kIGluZGV4LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VtdWxhdGl2ZSBzcXVhcmVkIGRpc3RhbmNlIGFsb25nIHRoZSByaW5nIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldEN1bXVsYXRpdmVTcXVhcmVkRGlzdGFuY2UoY29vcmRpbmF0ZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGxldCBsb3dJbmRleCwgaGlnaEluZGV4O1xuICBpZiAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgbG93SW5kZXggPSBzdGFydEluZGV4O1xuICAgIGhpZ2hJbmRleCA9IGVuZEluZGV4O1xuICB9IGVsc2Uge1xuICAgIGxvd0luZGV4ID0gZW5kSW5kZXg7XG4gICAgaGlnaEluZGV4ID0gc3RhcnRJbmRleDtcbiAgfVxuICBjb25zdCBsb3dXaG9sZUluZGV4ID0gTWF0aC5jZWlsKGxvd0luZGV4KTtcbiAgY29uc3QgaGlnaFdob2xlSW5kZXggPSBNYXRoLmZsb29yKGhpZ2hJbmRleCk7XG5cbiAgaWYgKGxvd1dob2xlSW5kZXggPiBoaWdoV2hvbGVJbmRleCkge1xuICAgIC8vIGJvdGggc3RhcnQgYW5kIGVuZCBhcmUgb24gdGhlIHNhbWUgc2VnbWVudFxuICAgIGNvbnN0IHN0YXJ0ID0gaW50ZXJwb2xhdGVDb29yZGluYXRlKGNvb3JkaW5hdGVzLCBsb3dJbmRleCk7XG4gICAgY29uc3QgZW5kID0gaW50ZXJwb2xhdGVDb29yZGluYXRlKGNvb3JkaW5hdGVzLCBoaWdoSW5kZXgpO1xuICAgIHJldHVybiBnZXRTcXVhcmVkRGlzdGFuY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBsZXQgc2QgPSAwO1xuXG4gIGlmIChsb3dJbmRleCA8IGxvd1dob2xlSW5kZXgpIHtcbiAgICBjb25zdCBzdGFydCA9IGludGVycG9sYXRlQ29vcmRpbmF0ZShjb29yZGluYXRlcywgbG93SW5kZXgpO1xuICAgIGNvbnN0IGVuZCA9IGdldENvb3JkaW5hdGUoY29vcmRpbmF0ZXMsIGxvd1dob2xlSW5kZXgpO1xuICAgIHNkICs9IGdldFNxdWFyZWREaXN0YW5jZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIGlmIChoaWdoV2hvbGVJbmRleCA8IGhpZ2hJbmRleCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q29vcmRpbmF0ZShjb29yZGluYXRlcywgaGlnaFdob2xlSW5kZXgpO1xuICAgIGNvbnN0IGVuZCA9IGludGVycG9sYXRlQ29vcmRpbmF0ZShjb29yZGluYXRlcywgaGlnaEluZGV4KTtcbiAgICBzZCArPSBnZXRTcXVhcmVkRGlzdGFuY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gbG93V2hvbGVJbmRleDsgaSA8IGhpZ2hXaG9sZUluZGV4IC0gMTsgKytpKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDb29yZGluYXRlKGNvb3JkaW5hdGVzLCBpKTtcbiAgICBjb25zdCBlbmQgPSBnZXRDb29yZGluYXRlKGNvb3JkaW5hdGVzLCBpICsgMSk7XG4gICAgc2QgKz0gZ2V0U3F1YXJlZERpc3RhbmNlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgcmV0dXJuIHNkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBjYW5kaWRhdGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5PFRyYWNlVGFyZ2V0Pn0gdGFyZ2V0cyBUaGUgdHJhY2UgdGFyZ2V0cy5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kR2VvbWV0cnlUcmFjZVRhcmdldHMoY29vcmRpbmF0ZSwgZ2VvbWV0cnksIHRhcmdldHMpIHtcbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIGFwcGVuZFRyYWNlVGFyZ2V0KGNvb3JkaW5hdGUsIGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCksIGZhbHNlLCB0YXJnZXRzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGFwcGVuZFRyYWNlVGFyZ2V0KGNvb3JkaW5hdGUsIGNvb3JkaW5hdGVzW2ldLCBmYWxzZSwgdGFyZ2V0cyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGFwcGVuZFRyYWNlVGFyZ2V0KGNvb3JkaW5hdGUsIGNvb3JkaW5hdGVzW2ldLCB0cnVlLCB0YXJnZXRzKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikge1xuICAgIGNvbnN0IHBvbHlzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2x5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHBvbHlzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBhcHBlbmRUcmFjZVRhcmdldChjb29yZGluYXRlLCBjb29yZGluYXRlc1tqXSwgdHJ1ZSwgdGFyZ2V0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgYXBwZW5kR2VvbWV0cnlUcmFjZVRhcmdldHMoY29vcmRpbmF0ZSwgZ2VvbWV0cmllc1tpXSwgdGFyZ2V0cyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBvdGhlciB0eXBlcyBjYW5ub3QgYmUgdHJhY2VkXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhY2VUYXJnZXRVcGRhdGVJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggVGhlIG5ldyB0YXJnZXQgaW5kZXguXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kSW5kZXggVGhlIG5ldyBzZWdtZW50IGVuZCBpbmRleC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtUcmFjZVRhcmdldFVwZGF0ZUluZm99XG4gKi9cbmNvbnN0IHNoYXJlZFVwZGF0ZUluZm8gPSB7aW5kZXg6IC0xLCBlbmRJbmRleDogTmFOfTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7VHJhY2VTdGF0ZX0gdHJhY2VTdGF0ZSBUaGUgdHJhY2Ugc3RhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgVGhlIG1hcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzbmFwVG9sZXJhbmNlIFRoZSBzbmFwIHRvbGVyYW5jZS5cbiAqIEByZXR1cm4ge1RyYWNlVGFyZ2V0VXBkYXRlSW5mb30gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG5ldyB0cmFjZSB0YXJnZXQuICBUaGUgcmV0dXJuZWRcbiAqIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBjYWxscyBhbmQgbXVzdCBub3QgYmUgbW9kaWZpZWQgYnkgdGhlIGNhbGxlci5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhY2VUYXJnZXRVcGRhdGUoY29vcmRpbmF0ZSwgdHJhY2VTdGF0ZSwgbWFwLCBzbmFwVG9sZXJhbmNlKSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcblxuICBsZXQgY2xvc2VzdFRhcmdldERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgbGV0IG5ld1RhcmdldEluZGV4ID0gLTE7XG4gIGxldCBuZXdFbmRJbmRleCA9IE5hTjtcblxuICBmb3IgKFxuICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgdGFyZ2V0SW5kZXggPCB0cmFjZVN0YXRlLnRhcmdldHMubGVuZ3RoO1xuICAgICsrdGFyZ2V0SW5kZXhcbiAgKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdHJhY2VTdGF0ZS50YXJnZXRzW3RhcmdldEluZGV4XTtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHRhcmdldC5jb29yZGluYXRlcztcblxuICAgIGxldCBtaW5TZWdtZW50RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgZW5kSW5kZXg7XG4gICAgZm9yIChcbiAgICAgIGxldCBjb29yZGluYXRlSW5kZXggPSAwO1xuICAgICAgY29vcmRpbmF0ZUluZGV4IDwgY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICsrY29vcmRpbmF0ZUluZGV4XG4gICAgKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVJbmRleF07XG4gICAgICBjb25zdCBlbmQgPSBjb29yZGluYXRlc1tjb29yZGluYXRlSW5kZXggKyAxXTtcbiAgICAgIGNvbnN0IHJlbCA9IGdldFBvaW50U2VnbWVudFJlbGF0aW9uc2hpcCh4LCB5LCBzdGFydCwgZW5kKTtcbiAgICAgIGlmIChyZWwuc3F1YXJlZERpc3RhbmNlIDwgbWluU2VnbWVudERpc3RhbmNlKSB7XG4gICAgICAgIG1pblNlZ21lbnREaXN0YW5jZSA9IHJlbC5zcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIGVuZEluZGV4ID0gY29vcmRpbmF0ZUluZGV4ICsgcmVsLmFsb25nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW5TZWdtZW50RGlzdGFuY2UgPCBjbG9zZXN0VGFyZ2V0RGlzdGFuY2UpIHtcbiAgICAgIGNsb3Nlc3RUYXJnZXREaXN0YW5jZSA9IG1pblNlZ21lbnREaXN0YW5jZTtcbiAgICAgIGlmICh0YXJnZXQucmluZyAmJiB0cmFjZVN0YXRlLnRhcmdldEluZGV4ID09PSB0YXJnZXRJbmRleCkge1xuICAgICAgICAvLyBzYW1lIHRhcmdldCwgbWFpbnRhaW4gdGhlIHNhbWUgdHJhY2UgZGlyZWN0aW9uXG4gICAgICAgIGlmICh0YXJnZXQuZW5kSW5kZXggPiB0YXJnZXQuc3RhcnRJbmRleCkge1xuICAgICAgICAgIC8vIGZvcndhcmQgdHJhY2VcbiAgICAgICAgICBpZiAoZW5kSW5kZXggPCB0YXJnZXQuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgZW5kSW5kZXggKz0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuZW5kSW5kZXggPCB0YXJnZXQuc3RhcnRJbmRleCkge1xuICAgICAgICAgIC8vIHJldmVyc2UgdHJhY2VcbiAgICAgICAgICBpZiAoZW5kSW5kZXggPiB0YXJnZXQuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgZW5kSW5kZXggLT0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3RW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgIG5ld1RhcmdldEluZGV4ID0gdGFyZ2V0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3VGFyZ2V0ID0gdHJhY2VTdGF0ZS50YXJnZXRzW25ld1RhcmdldEluZGV4XTtcbiAgbGV0IGNvbnNpZGVyQm90aERpcmVjdGlvbnMgPSBuZXdUYXJnZXQucmluZztcbiAgaWYgKHRyYWNlU3RhdGUudGFyZ2V0SW5kZXggPT09IG5ld1RhcmdldEluZGV4ICYmIGNvbnNpZGVyQm90aERpcmVjdGlvbnMpIHtcbiAgICAvLyBvbmx5IGNvbnNpZGVyIHN3aXRjaGluZyB0cmFjZSBkaXJlY3Rpb24gaWYgY2xvc2UgdG8gdGhlIHN0YXJ0XG4gICAgY29uc3QgbmV3Q29vcmRpbmF0ZSA9IGludGVycG9sYXRlQ29vcmRpbmF0ZShcbiAgICAgIG5ld1RhcmdldC5jb29yZGluYXRlcyxcbiAgICAgIG5ld0VuZEluZGV4XG4gICAgKTtcbiAgICBjb25zdCBwaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKG5ld0Nvb3JkaW5hdGUpO1xuICAgIGlmIChkaXN0YW5jZShwaXhlbCwgdHJhY2VTdGF0ZS5zdGFydFB4KSA+IHNuYXBUb2xlcmFuY2UpIHtcbiAgICAgIGNvbnNpZGVyQm90aERpcmVjdGlvbnMgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29uc2lkZXJCb3RoRGlyZWN0aW9ucykge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gbmV3VGFyZ2V0LmNvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGNvdW50ID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBuZXdUYXJnZXQuc3RhcnRJbmRleDtcbiAgICBjb25zdCBlbmRJbmRleCA9IG5ld0VuZEluZGV4O1xuICAgIGlmIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgIGNvbnN0IGZvcndhcmREaXN0YW5jZSA9IGdldEN1bXVsYXRpdmVTcXVhcmVkRGlzdGFuY2UoXG4gICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICBlbmRJbmRleFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJldmVyc2VEaXN0YW5jZSA9IGdldEN1bXVsYXRpdmVTcXVhcmVkRGlzdGFuY2UoXG4gICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICBlbmRJbmRleCAtIGNvdW50XG4gICAgICApO1xuICAgICAgaWYgKHJldmVyc2VEaXN0YW5jZSA8IGZvcndhcmREaXN0YW5jZSkge1xuICAgICAgICBuZXdFbmRJbmRleCAtPSBjb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmV2ZXJzZURpc3RhbmNlID0gZ2V0Q3VtdWxhdGl2ZVNxdWFyZWREaXN0YW5jZShcbiAgICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZERpc3RhbmNlID0gZ2V0Q3VtdWxhdGl2ZVNxdWFyZWREaXN0YW5jZShcbiAgICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgIGVuZEluZGV4ICsgY291bnRcbiAgICAgICk7XG4gICAgICBpZiAoZm9yd2FyZERpc3RhbmNlIDwgcmV2ZXJzZURpc3RhbmNlKSB7XG4gICAgICAgIG5ld0VuZEluZGV4ICs9IGNvdW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNoYXJlZFVwZGF0ZUluZm8uaW5kZXggPSBuZXdUYXJnZXRJbmRleDtcbiAgc2hhcmVkVXBkYXRlSW5mby5lbmRJbmRleCA9IG5ld0VuZEluZGV4O1xuICByZXR1cm4gc2hhcmVkVXBkYXRlSW5mbztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY2xpY2tlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBUaGUgZ2VvbWV0cnkgY29tcG9uZW50IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtib29sZWFufSByaW5nIFRoZSBjb29yZGluYXRlcyByZXByZXNlbnQgYSBsaW5lYXIgcmluZy5cbiAqIEBwYXJhbSB7QXJyYXk8VHJhY2VUYXJnZXQ+fSB0YXJnZXRzIFRoZSB0cmFjZSB0YXJnZXRzLlxuICovXG5mdW5jdGlvbiBhcHBlbmRUcmFjZVRhcmdldChjb29yZGluYXRlLCBjb29yZGluYXRlcywgcmluZywgdGFyZ2V0cykge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBjb29yZGluYXRlc1tpXTtcbiAgICBjb25zdCBlbmQgPSBjb29yZGluYXRlc1tpICsgMV07XG4gICAgY29uc3QgcmVsID0gZ2V0UG9pbnRTZWdtZW50UmVsYXRpb25zaGlwKHgsIHksIHN0YXJ0LCBlbmQpO1xuICAgIGlmIChyZWwuc3F1YXJlZERpc3RhbmNlID09PSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKyByZWwuYWxvbmc7XG4gICAgICB0YXJnZXRzLnB1c2goe1xuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgICAgIHJpbmc6IHJpbmcsXG4gICAgICAgIHN0YXJ0SW5kZXg6IGluZGV4LFxuICAgICAgICBlbmRJbmRleDogaW5kZXgsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFNlZ21lbnRSZWxhdGlvbnNoaXBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbG9uZyBUaGUgY2xvc2VzdCBwb2ludCBleHByZXNzZWQgYXMgYSBmcmFjdGlvbiBhbG9uZyB0aGUgc2VnbWVudCBsZW5ndGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3F1YXJlZERpc3RhbmNlIFRoZSBzcXVhcmVkIGRpc3RhbmNlIG9mIHRoZSBwb2ludCB0byB0aGUgc2VnbWVudC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtQb2ludFNlZ21lbnRSZWxhdGlvbnNoaXB9XG4gKi9cbmNvbnN0IHNoYXJlZFJlbCA9IHthbG9uZzogMCwgc3F1YXJlZERpc3RhbmNlOiAwfTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgcG9pbnQgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBwb2ludCB5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHN0YXJ0IFRoZSBzZWdtZW50IHN0YXJ0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGVuZCBUaGUgc2VnbWVudCBlbmQuXG4gKiBAcmV0dXJuIHtQb2ludFNlZ21lbnRSZWxhdGlvbnNoaXB9IFRoZSBwb2ludCBzZWdtZW50IHJlbGF0aW9uc2hpcC4gIFRoZSByZXR1cm5lZCBvYmplY3QgaXNcbiAqIHNoYXJlZCBiZXR3ZWVuIGNhbGxzIGFuZCBtdXN0IG5vdCBiZSBtb2RpZmllZCBieSB0aGUgY2FsbGVyLlxuICovXG5mdW5jdGlvbiBnZXRQb2ludFNlZ21lbnRSZWxhdGlvbnNoaXAoeCwgeSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCB4MSA9IHN0YXJ0WzBdO1xuICBjb25zdCB5MSA9IHN0YXJ0WzFdO1xuICBjb25zdCB4MiA9IGVuZFswXTtcbiAgY29uc3QgeTIgPSBlbmRbMV07XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBsZXQgYWxvbmcgPSAwO1xuICBsZXQgcHggPSB4MTtcbiAgbGV0IHB5ID0geTE7XG4gIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgIGFsb25nID0gY2xhbXAoKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSksIDAsIDEpO1xuICAgIHB4ICs9IGR4ICogYWxvbmc7XG4gICAgcHkgKz0gZHkgKiBhbG9uZztcbiAgfVxuXG4gIHNoYXJlZFJlbC5hbG9uZyA9IGFsb25nO1xuICBzaGFyZWRSZWwuc3F1YXJlZERpc3RhbmNlID0gdG9GaXhlZChzcXVhcmVkRGlzdGFuY2UoeCwgeSwgcHgsIHB5KSwgMTApO1xuICByZXR1cm4gc2hhcmVkUmVsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgVGhlIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleC4gIE1heSBiZSBmcmFjdGlvbmFsIGFuZCBtYXkgd3JhcC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIGludGVycG9sYXRlZCBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvb3JkaW5hdGUoY29vcmRpbmF0ZXMsIGluZGV4KSB7XG4gIGNvbnN0IGNvdW50ID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gIGxldCBzdGFydEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XG4gIGNvbnN0IGFsb25nID0gaW5kZXggLSBzdGFydEluZGV4O1xuICBpZiAoc3RhcnRJbmRleCA+PSBjb3VudCkge1xuICAgIHN0YXJ0SW5kZXggLT0gY291bnQ7XG4gIH0gZWxzZSBpZiAoc3RhcnRJbmRleCA8IDApIHtcbiAgICBzdGFydEluZGV4ICs9IGNvdW50O1xuICB9XG5cbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDE7XG4gIGlmIChlbmRJbmRleCA+PSBjb3VudCkge1xuICAgIGVuZEluZGV4IC09IGNvdW50O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjb29yZGluYXRlc1tzdGFydEluZGV4XTtcbiAgY29uc3QgeDAgPSBzdGFydFswXTtcbiAgY29uc3QgeTAgPSBzdGFydFsxXTtcbiAgY29uc3QgZW5kID0gY29vcmRpbmF0ZXNbZW5kSW5kZXhdO1xuICBjb25zdCBkeCA9IGVuZFswXSAtIHgwO1xuICBjb25zdCBkeSA9IGVuZFsxXSAtIHkwO1xuXG4gIHJldHVybiBbeDAgKyBkeCAqIGFsb25nLCB5MCArIGR5ICogYWxvbmddO1xufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdkcmF3YWJvcnQnfCdkcmF3ZW5kJ3wnZHJhd3N0YXJ0JywgRHJhd0V2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnfCdkcmF3YWJvcnQnfCdkcmF3ZW5kJ3wnZHJhd3N0YXJ0JywgUmV0dXJuPn0gRHJhd09uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgZHJhd2luZyBmZWF0dXJlIGdlb21ldHJpZXMuXG4gKlxuICogQGZpcmVzIERyYXdFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBEcmF3IGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHBvaW50ZXJPcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0RyYXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmF3T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmF3T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zaG91bGRIYW5kbGVfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25QeF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25UaW1lb3V0XztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0RHJhZ1RpbWVfO1xuXG4gICAgLyoqXG4gICAgICogUG9pbnRlciB0eXBlIG9mIHRoZSBsYXN0IHBvaW50ZXJtb3ZlIGV2ZW50XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlclR5cGVfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyZWVoYW5kXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IHNvdXJjZSBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge1ZlY3RvclNvdXJjZXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgY29sbGVjdGlvbiBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxGZWF0dXJlPnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc18gPSBvcHRpb25zLmZlYXR1cmVzID8gb3B0aW9ucy5mZWF0dXJlcyA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQaXhlbCBkaXN0YW5jZSBmb3Igc25hcHBpbmcuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc25hcFRvbGVyYW5jZV8gPSBvcHRpb25zLnNuYXBUb2xlcmFuY2UgPyBvcHRpb25zLnNuYXBUb2xlcmFuY2UgOiAxMjtcblxuICAgIC8qKlxuICAgICAqIEdlb21ldHJ5IHR5cGUuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuVHlwZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHlwZV8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuVHlwZX0gKi8gKFxuICAgICAgb3B0aW9ucy50eXBlXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIERyYXdpbmcgbW9kZSAoZGVyaXZlZCBmcm9tIGdlb21ldHJ5IHR5cGUuXG4gICAgICogQHR5cGUge01vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gZ2V0TW9kZSh0aGlzLnR5cGVfKTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgY2xpY2ssIHNpbmdsZWNsaWNrLCBhbmQgZG91YmxlY2xpY2sgZXZlbnRzIGZyb20gZmlyaW5nIGR1cmluZyBkcmF3aW5nLlxuICAgICAqIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RvcENsaWNrXyA9ICEhb3B0aW9ucy5zdG9wQ2xpY2s7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IG11c3QgYmUgZHJhd24gYmVmb3JlIGEgcG9seWdvbiByaW5nIG9yIGxpbmVcbiAgICAgKiBzdHJpbmcgY2FuIGJlIGZpbmlzaGVkLiAgVGhlIGRlZmF1bHQgaXMgMyBmb3IgcG9seWdvbiByaW5ncyBhbmQgMiBmb3JcbiAgICAgKiBsaW5lIHN0cmluZ3MuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWluUG9pbnRzXyA9IG9wdGlvbnMubWluUG9pbnRzXG4gICAgICA/IG9wdGlvbnMubWluUG9pbnRzXG4gICAgICA6IHRoaXMubW9kZV8gPT09ICdQb2x5Z29uJ1xuICAgICAgPyAzXG4gICAgICA6IDI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IGNhbiBiZSBkcmF3biBiZWZvcmUgYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmdcbiAgICAgKiBpcyBmaW5pc2hlZC4gVGhlIGRlZmF1bHQgaXMgbm8gcmVzdHJpY3Rpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4UG9pbnRzXyA9XG4gICAgICB0aGlzLm1vZGVfID09PSAnQ2lyY2xlJ1xuICAgICAgICA/IDJcbiAgICAgICAgOiBvcHRpb25zLm1heFBvaW50c1xuICAgICAgICA/IG9wdGlvbnMubWF4UG9pbnRzXG4gICAgICAgIDogSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRlY2lkZSBpZiBhIHBvdGVudGlhbCBmaW5pc2ggY29vcmRpbmF0ZSBpcyBwZXJtaXNzaWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZmluaXNoQ29uZGl0aW9uXyA9IG9wdGlvbnMuZmluaXNoQ29uZGl0aW9uXG4gICAgICA/IG9wdGlvbnMuZmluaXNoQ29uZGl0aW9uXG4gICAgICA6IFRSVUU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlMYXlvdXRfID0gb3B0aW9ucy5nZW9tZXRyeUxheW91dFxuICAgICAgPyBvcHRpb25zLmdlb21ldHJ5TGF5b3V0XG4gICAgICA6ICdYWSc7XG5cbiAgICBsZXQgZ2VvbWV0cnlGdW5jdGlvbiA9IG9wdGlvbnMuZ2VvbWV0cnlGdW5jdGlvbjtcbiAgICBpZiAoIWdlb21ldHJ5RnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGVfO1xuICAgICAgaWYgKG1vZGUgPT09ICdDaXJjbGUnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFMaW5lQ29vcmRUeXBlfSBjb29yZGluYXRlcyBUaGUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gZ2VvbWV0cnkgT3B0aW9uYWwgZ2VvbWV0cnkuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gVGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBBIGdlb21ldHJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2VvbWV0cnlGdW5jdGlvbiA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgZ2VvbWV0cnksIHByb2plY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBjaXJjbGUgPSBnZW9tZXRyeVxuICAgICAgICAgICAgPyAvKiogQHR5cGUge0NpcmNsZX0gKi8gKGdlb21ldHJ5KVxuICAgICAgICAgICAgOiBuZXcgQ2lyY2xlKFtOYU4sIE5hTl0pO1xuICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGZyb21Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlc1swXSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgY29uc3Qgc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgICBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0sIHByb2plY3Rpb24pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjaXJjbGUuc2V0Q2VudGVyQW5kUmFkaXVzKFxuICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRMZW5ndGgpLFxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeUxheW91dF9cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgICAgICBpZiAodXNlclByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIGNpcmNsZS50cmFuc2Zvcm0ocHJvamVjdGlvbiwgdXNlclByb2plY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IENvbnN0cnVjdG9yO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gUG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gUG9seWdvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgVGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IGdlb21ldHJ5IE9wdGlvbmFsIGdlb21ldHJ5LlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAgICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gQSBnZW9tZXRyeS5cbiAgICAgICAgICovXG4gICAgICAgIGdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGdlb21ldHJ5LCBwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjbG9zaW5nIGNvb3JkaW5hdGUgdG8gbWF0Y2ggdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgICAgICAgICAgICBbY29vcmRpbmF0ZXNbMF0uY29uY2F0KFtjb29yZGluYXRlc1swXVswXV0pXSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnlMYXlvdXRfXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhbXSwgdGhpcy5nZW9tZXRyeUxheW91dF8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgdGhpcy5nZW9tZXRyeUxheW91dF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBDb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgdGhpcy5nZW9tZXRyeUxheW91dF8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0dlb21ldHJ5RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZ2VvbWV0cnlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8gPVxuICAgICAgb3B0aW9ucy5kcmFnVmVydGV4RGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHJhZ1ZlcnRleERlbGF5IDogNTAwO1xuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGNvb3JkaW5hdGUgZm9yIHRoZSBmZWF0dXJlIChmaXJzdCBwb2ludCBmb3IgcG9seWdvbnMsIGxhc3QgcG9pbnQgZm9yXG4gICAgICogbGluZXN0cmluZ3MpLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBmZWF0dXJlLlxuICAgICAqIEB0eXBlIHtGZWF0dXJlPGltcG9ydCgnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcycpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hGZWF0dXJlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggcG9pbnQuXG4gICAgICogQHR5cGUge0ZlYXR1cmU8UG9pbnQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hQb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIGNvb3JkaW5hdGVzLiBVc2VkIHdoZW4gZHJhd2luZyBhIGxpbmUgb3IgcG9seWdvbi5cbiAgICAgKiBAdHlwZSB7U2tldGNoQ29vcmRUeXBlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hDb29yZHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBsaW5lLiBVc2VkIHdoZW4gZHJhd2luZyBwb2x5Z29uLlxuICAgICAqIEB0eXBlIHtGZWF0dXJlPExpbmVTdHJpbmc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hMaW5lXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggbGluZSBjb29yZGluYXRlcy4gVXNlZCB3aGVuIGRyYXdpbmcgYSBwb2x5Z29uIG9yIGNpcmNsZS5cbiAgICAgKiBAdHlwZSB7TGluZUNvb3JkVHlwZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoTGluZUNvb3Jkc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3F1YXJlZCB0b2xlcmFuY2UgZm9yIGhhbmRsaW5nIHVwIGV2ZW50cy4gIElmIHRoZSBzcXVhcmVkIGRpc3RhbmNlXG4gICAgICogYmV0d2VlbiBhIGRvd24gYW5kIHVwIGV2ZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGlzIHRvbGVyYW5jZSwgdXAgZXZlbnRzXG4gICAgICogd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfID0gb3B0aW9ucy5jbGlja1RvbGVyYW5jZVxuICAgICAgPyBvcHRpb25zLmNsaWNrVG9sZXJhbmNlICogb3B0aW9ucy5jbGlja1RvbGVyYW5jZVxuICAgICAgOiAzNjtcblxuICAgIC8qKlxuICAgICAqIERyYXcgb3ZlcmxheSB3aGVyZSBvdXIgc2tldGNoIGZlYXR1cmVzIGFyZSBkcmF3bi5cbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlLFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSA/IG9wdGlvbnMuc3R5bGUgOiBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZSBmb3IgbmV3bHkgY3JlYXRlZCBmZWF0dXJlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9IG9wdGlvbnMuZ2VvbWV0cnlOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IG5vTW9kaWZpZXJLZXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5mcmVlaGFuZENvbmRpdGlvbl87XG4gICAgaWYgKG9wdGlvbnMuZnJlZWhhbmQpIHtcbiAgICAgIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fID0gYWx3YXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyZWVoYW5kQ29uZGl0aW9uXyA9IG9wdGlvbnMuZnJlZWhhbmRDb25kaXRpb25cbiAgICAgICAgPyBvcHRpb25zLmZyZWVoYW5kQ29uZGl0aW9uXG4gICAgICAgIDogc2hpZnRLZXlPbmx5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2VDb25kaXRpb25fO1xuICAgIHRoaXMuc2V0VHJhY2Uob3B0aW9ucy50cmFjZSB8fCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhY2VTdGF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2VTdGF0ZV8gPSB7YWN0aXZlOiBmYWxzZX07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VmVjdG9yU291cmNlfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNlU291cmNlXyA9IG9wdGlvbnMudHJhY2VTb3VyY2UgfHwgb3B0aW9ucy5zb3VyY2UgfHwgbnVsbDtcblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUsIHRoaXMudXBkYXRlU3RhdGVfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdHJhY2luZyBtb2RlIG9yIHNldCBhIHRyYWNpbmcgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IHRyYWNlIEEgYm9vbGVhbiB0byB0b2dnbGUgdHJhY2luZyBtb2RlIG9yIGFuIGV2ZW50XG4gICAqICAgICBjb25kaXRpb24gdGhhdCB3aWxsIGJlIGNoZWNrZWQgd2hlbiBhIGZlYXR1cmUgaXMgY2xpY2tlZCB0byBkZXRlcm1pbmUgaWYgdHJhY2luZyBzaG91bGQgYmUgYWN0aXZlLlxuICAgKi9cbiAgc2V0VHJhY2UodHJhY2UpIHtcbiAgICBsZXQgY29uZGl0aW9uO1xuICAgIGlmICghdHJhY2UpIHtcbiAgICAgIGNvbmRpdGlvbiA9IG5ldmVyO1xuICAgIH0gZWxzZSBpZiAodHJhY2UgPT09IHRydWUpIHtcbiAgICAgIGNvbmRpdGlvbiA9IGFsd2F5cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZGl0aW9uID0gdHJhY2U7XG4gICAgfVxuICAgIHRoaXMudHJhY2VDb25kaXRpb25fID0gY29uZGl0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBzdXBlci5zZXRNYXAobWFwKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3ZlcmxheSBsYXllciB0aGF0IHRoaXMgaW50ZXJhY3Rpb24gcmVuZGVycyBza2V0Y2ggZmVhdHVyZXMgdG8uXG4gICAqIEByZXR1cm4ge1ZlY3RvckxheWVyfSBPdmVybGF5IGxheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVybGF5KCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gYW5kIG1heSBhY3R1YWxseSBkcmF3IG9yIGZpbmlzaCB0aGUgZHJhd2luZy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC50eXBlID09PSBFdmVudFR5cGUuQ09OVEVYVE1FTlUpIHtcbiAgICAgIC8vIEF2b2lkIGNvbnRleHQgbWVudSBmb3IgbG9uZyB0YXBzIHdoZW4gZHJhd2luZyBvbiBtb2JpbGVcbiAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5mcmVlaGFuZF8gPSB0aGlzLm1vZGVfICE9PSAnUG9pbnQnICYmIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fKGV2ZW50KTtcbiAgICBsZXQgbW92ZSA9IGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkU7XG4gICAgbGV0IHBhc3MgPSB0cnVlO1xuICAgIGlmIChcbiAgICAgICF0aGlzLmZyZWVoYW5kXyAmJlxuICAgICAgdGhpcy5sYXN0RHJhZ1RpbWVfICYmXG4gICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHXG4gICAgKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdERyYWdUaW1lXyA+PSB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8pIHtcbiAgICAgICAgdGhpcy5kb3duUHhfID0gZXZlbnQucGl4ZWw7XG4gICAgICAgIHRoaXMuc2hvdWxkSGFuZGxlXyA9ICF0aGlzLmZyZWVoYW5kXztcbiAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3REcmFnVGltZV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVfICYmIHRoaXMuZG93blRpbWVvdXRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG93blRpbWVvdXRfKTtcbiAgICAgICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMuZnJlZWhhbmRfICYmXG4gICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHICYmXG4gICAgICB0aGlzLnNrZXRjaEZlYXR1cmVfICE9PSBudWxsXG4gICAgKSB7XG4gICAgICB0aGlzLmFkZFRvRHJhd2luZ18oZXZlbnQuY29vcmRpbmF0ZSk7XG4gICAgICBwYXNzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuZnJlZWhhbmRfICYmXG4gICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOXG4gICAgKSB7XG4gICAgICBwYXNzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChtb3ZlICYmIHRoaXMuZ2V0UG9pbnRlckNvdW50KCkgPCAyKSB7XG4gICAgICBwYXNzID0gZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRTtcbiAgICAgIGlmIChwYXNzICYmIHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkSGFuZGxlXykge1xuICAgICAgICAgIC8vIEF2b2lkIHBhZ2Ugc2Nyb2xsaW5nIHdoZW4gZnJlZWhhbmQgZHJhd2luZyBvbiBtb2JpbGVcbiAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcbiAgICAgICAgKGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcgJiZcbiAgICAgICAgICB0aGlzLmRvd25UaW1lb3V0XyA9PT0gdW5kZWZpbmVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0spIHtcbiAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpICYmIHBhc3M7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5zaG91bGRIYW5kbGVfID0gIXRoaXMuZnJlZWhhbmRfO1xuXG4gICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICB0aGlzLmRvd25QeF8gPSBldmVudC5waXhlbDtcbiAgICAgIGlmICghdGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ18oZXZlbnQuY29vcmRpbmF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgIHRoaXMubGFzdERyYWdUaW1lXyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3REcmFnVGltZV8gPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZG93blRpbWVvdXRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhcbiAgICAgICAgbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgICAgIGV2ZW50Lm1hcCxcbiAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGV2ZW50LmZyYW1lU3RhdGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LCB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8pO1xuICAgIHRoaXMuZG93blB4XyA9IGV2ZW50LnBpeGVsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlVHJhY2VfKCkge1xuICAgIHRoaXMudHJhY2VTdGF0ZV8gPSB7YWN0aXZlOiBmYWxzZX07XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0cmFjZSBzdGF0ZSBiYXNlZCBvbiBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9nZ2xlVHJhY2VTdGF0ZV8oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudHJhY2VTb3VyY2VfIHx8ICF0aGlzLnRyYWNlQ29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFjZVN0YXRlXy5hY3RpdmUpIHtcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZVRyYWNlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3QgbG93ZXJMZWZ0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoW1xuICAgICAgZXZlbnQucGl4ZWxbMF0gLSB0aGlzLnNuYXBUb2xlcmFuY2VfLFxuICAgICAgZXZlbnQucGl4ZWxbMV0gKyB0aGlzLnNuYXBUb2xlcmFuY2VfLFxuICAgIF0pO1xuICAgIGNvbnN0IHVwcGVyUmlnaHQgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChbXG4gICAgICBldmVudC5waXhlbFswXSArIHRoaXMuc25hcFRvbGVyYW5jZV8sXG4gICAgICBldmVudC5waXhlbFsxXSAtIHRoaXMuc25hcFRvbGVyYW5jZV8sXG4gICAgXSk7XG4gICAgY29uc3QgZXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2xvd2VyTGVmdCwgdXBwZXJSaWdodF0pO1xuICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy50cmFjZVNvdXJjZV8uZ2V0RmVhdHVyZXNJbkV4dGVudChleHRlbnQpO1xuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRzID0gZ2V0VHJhY2VUYXJnZXRzKGV2ZW50LmNvb3JkaW5hdGUsIGZlYXR1cmVzKTtcbiAgICBpZiAodGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudHJhY2VTdGF0ZV8gPSB7XG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgc3RhcnRQeDogZXZlbnQucGl4ZWwuc2xpY2UoKSxcbiAgICAgICAgdGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgdGFyZ2V0SW5kZXg6IC0xLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFjZVRhcmdldH0gdGFyZ2V0IFRoZSB0cmFjZSB0YXJnZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleCBUaGUgbmV3IGVuZCBpbmRleCBvZiB0aGUgdHJhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRPclJlbW92ZVRyYWNlZENvb3JkaW5hdGVzXyh0YXJnZXQsIGVuZEluZGV4KSB7XG4gICAgLy8gdGhyZWUgY2FzZXMgdG8gaGFuZGxlOlxuICAgIC8vICAxLiB0cmFjZWQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIGFuZCBwb2ludHMgbmVlZCBhZGRpbmdcbiAgICAvLyAgMi4gdHJhY2VkIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhbmQgcG9pbnRzIG5lZWQgcmVtb3ZpbmdcbiAgICAvLyAgMy4gdHJhY2VkIGluIGEgbmV3IGRpcmVjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzbHlGb3J3YXJkID0gdGFyZ2V0LnN0YXJ0SW5kZXggPD0gdGFyZ2V0LmVuZEluZGV4O1xuICAgIGNvbnN0IGN1cnJlbnRseUZvcndhcmQgPSB0YXJnZXQuc3RhcnRJbmRleCA8PSBlbmRJbmRleDtcbiAgICBpZiAocHJldmlvdXNseUZvcndhcmQgPT09IGN1cnJlbnRseUZvcndhcmQpIHtcbiAgICAgIC8vIHNhbWUgZGlyZWN0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIChwcmV2aW91c2x5Rm9yd2FyZCAmJiBlbmRJbmRleCA+IHRhcmdldC5lbmRJbmRleCkgfHxcbiAgICAgICAgKCFwcmV2aW91c2x5Rm9yd2FyZCAmJiBlbmRJbmRleCA8IHRhcmdldC5lbmRJbmRleClcbiAgICAgICkge1xuICAgICAgICAvLyBjYXNlIDEgLSBhZGQgbmV3IHBvaW50c1xuICAgICAgICB0aGlzLmFkZFRyYWNlZENvb3JkaW5hdGVzXyh0YXJnZXQsIHRhcmdldC5lbmRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHByZXZpb3VzbHlGb3J3YXJkICYmIGVuZEluZGV4IDwgdGFyZ2V0LmVuZEluZGV4KSB8fFxuICAgICAgICAoIXByZXZpb3VzbHlGb3J3YXJkICYmIGVuZEluZGV4ID4gdGFyZ2V0LmVuZEluZGV4KVxuICAgICAgKSB7XG4gICAgICAgIC8vIGNhc2UgMiAtIHJlbW92ZSBvbGQgcG9pbnRzXG4gICAgICAgIHRoaXMucmVtb3ZlVHJhY2VkQ29vcmRpbmF0ZXNfKGVuZEluZGV4LCB0YXJnZXQuZW5kSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYXNlIDMgLSByZW1vdmUgb2xkIHBvaW50cywgYWRkIG5ldyBwb2ludHNcbiAgICAgIHRoaXMucmVtb3ZlVHJhY2VkQ29vcmRpbmF0ZXNfKHRhcmdldC5zdGFydEluZGV4LCB0YXJnZXQuZW5kSW5kZXgpO1xuICAgICAgdGhpcy5hZGRUcmFjZWRDb29yZGluYXRlc18odGFyZ2V0LCB0YXJnZXQuc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggVGhlIGVuZCBpbmRleC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZVRyYWNlZENvb3JkaW5hdGVzXyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlbW92ZSA9IDA7XG4gICAgaWYgKGZyb21JbmRleCA8IHRvSW5kZXgpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5jZWlsKGZyb21JbmRleCk7XG4gICAgICBsZXQgZW5kID0gTWF0aC5mbG9vcih0b0luZGV4KTtcbiAgICAgIGlmIChlbmQgPT09IHRvSW5kZXgpIHtcbiAgICAgICAgZW5kIC09IDE7XG4gICAgICB9XG4gICAgICByZW1vdmUgPSBlbmQgLSBzdGFydCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihmcm9tSW5kZXgpO1xuICAgICAgbGV0IGVuZCA9IE1hdGguY2VpbCh0b0luZGV4KTtcbiAgICAgIGlmIChlbmQgPT09IHRvSW5kZXgpIHtcbiAgICAgICAgZW5kICs9IDE7XG4gICAgICB9XG4gICAgICByZW1vdmUgPSBzdGFydCAtIGVuZCArIDE7XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZSA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlTGFzdFBvaW50c18ocmVtb3ZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFjZVRhcmdldH0gdGFyZ2V0IFRoZSB0cmFjZSB0YXJnZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkVHJhY2VkQ29vcmRpbmF0ZXNfKHRhcmdldCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gICAgaWYgKGZyb21JbmRleCA8IHRvSW5kZXgpIHtcbiAgICAgIC8vIGZvcndhcmQgdHJhY2VcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5jZWlsKGZyb21JbmRleCk7XG4gICAgICBsZXQgZW5kID0gTWF0aC5mbG9vcih0b0luZGV4KTtcbiAgICAgIGlmIChlbmQgPT09IHRvSW5kZXgpIHtcbiAgICAgICAgLy8gaWYgZW5kIGlzIHNuYXBwZWQgdG8gYSB2ZXJ0ZXgsIGl0IHdpbGwgYmUgYWRkZWQgbGF0ZXJcbiAgICAgICAgZW5kIC09IDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChnZXRDb29yZGluYXRlKHRhcmdldC5jb29yZGluYXRlcywgaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXZlcnNlIHRyYWNlXG4gICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoZnJvbUluZGV4KTtcbiAgICAgIGxldCBlbmQgPSBNYXRoLmNlaWwodG9JbmRleCk7XG4gICAgICBpZiAoZW5kID09PSB0b0luZGV4KSB7XG4gICAgICAgIGVuZCArPSAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpID49IGVuZDsgLS1pKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzLnB1c2goZ2V0Q29vcmRpbmF0ZSh0YXJnZXQuY29vcmRpbmF0ZXMsIGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5hcHBlbmRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdHJhY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVHJhY2VfKGV2ZW50KSB7XG4gICAgY29uc3QgdHJhY2VTdGF0ZSA9IHRoaXMudHJhY2VTdGF0ZV87XG4gICAgaWYgKCF0cmFjZVN0YXRlLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0cmFjZVN0YXRlLnRhcmdldEluZGV4ID09PSAtMSkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIHJlYWR5IHRvIHBpY2sgYSB0YXJnZXRcbiAgICAgIGlmIChkaXN0YW5jZSh0cmFjZVN0YXRlLnN0YXJ0UHgsIGV2ZW50LnBpeGVsKSA8IHRoaXMuc25hcFRvbGVyYW5jZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRUcmFjZVRhcmdldCA9IGdldFRyYWNlVGFyZ2V0VXBkYXRlKFxuICAgICAgZXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgIHRyYWNlU3RhdGUsXG4gICAgICB0aGlzLmdldE1hcCgpLFxuICAgICAgdGhpcy5zbmFwVG9sZXJhbmNlX1xuICAgICk7XG5cbiAgICBpZiAodHJhY2VTdGF0ZS50YXJnZXRJbmRleCAhPT0gdXBkYXRlZFRyYWNlVGFyZ2V0LmluZGV4KSB7XG4gICAgICAvLyB0YXJnZXQgY2hhbmdlZFxuICAgICAgaWYgKHRyYWNlU3RhdGUudGFyZ2V0SW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIHJlbW92ZSBwb2ludHMgYWRkZWQgZHVyaW5nIHByZXZpb3VzIHRyYWNlXG4gICAgICAgIGNvbnN0IG9sZFRhcmdldCA9IHRyYWNlU3RhdGUudGFyZ2V0c1t0cmFjZVN0YXRlLnRhcmdldEluZGV4XTtcbiAgICAgICAgdGhpcy5yZW1vdmVUcmFjZWRDb29yZGluYXRlc18ob2xkVGFyZ2V0LnN0YXJ0SW5kZXgsIG9sZFRhcmdldC5lbmRJbmRleCk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgcG9pbnRzIGZvciB0aGUgbmV3IHRhcmdldFxuICAgICAgY29uc3QgbmV3VGFyZ2V0ID0gdHJhY2VTdGF0ZS50YXJnZXRzW3VwZGF0ZWRUcmFjZVRhcmdldC5pbmRleF07XG4gICAgICB0aGlzLmFkZFRyYWNlZENvb3JkaW5hdGVzXyhcbiAgICAgICAgbmV3VGFyZ2V0LFxuICAgICAgICBuZXdUYXJnZXQuc3RhcnRJbmRleCxcbiAgICAgICAgdXBkYXRlZFRyYWNlVGFyZ2V0LmVuZEluZGV4XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0YXJnZXQgc3RheWVkIHRoZSBzYW1lXG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmFjZVN0YXRlLnRhcmdldHNbdHJhY2VTdGF0ZS50YXJnZXRJbmRleF07XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlVHJhY2VkQ29vcmRpbmF0ZXNfKHRhcmdldCwgdXBkYXRlZFRyYWNlVGFyZ2V0LmVuZEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBtb2RpZnkgdGhlIHN0YXRlIHdpdGggdXBkYXRlZCBpbmZvXG4gICAgdHJhY2VTdGF0ZS50YXJnZXRJbmRleCA9IHVwZGF0ZWRUcmFjZVRhcmdldC5pbmRleDtcbiAgICBjb25zdCB0YXJnZXQgPSB0cmFjZVN0YXRlLnRhcmdldHNbdHJhY2VTdGF0ZS50YXJnZXRJbmRleF07XG4gICAgdGFyZ2V0LmVuZEluZGV4ID0gdXBkYXRlZFRyYWNlVGFyZ2V0LmVuZEluZGV4O1xuXG4gICAgLy8gdXBkYXRlIGV2ZW50IGNvb3JkaW5hdGUgYW5kIHBpeGVsIHRvIG1hdGNoIGVuZCBwb2ludCBvZiBmaW5hbCBzZWdtZW50XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGludGVycG9sYXRlQ29vcmRpbmF0ZShcbiAgICAgIHRhcmdldC5jb29yZGluYXRlcyxcbiAgICAgIHRhcmdldC5lbmRJbmRleFxuICAgICk7XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLmdldE1hcCgpLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSk7XG4gICAgZXZlbnQuY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGU7XG4gICAgZXZlbnQucGl4ZWwgPSBbTWF0aC5yb3VuZChwaXhlbFswXSksIE1hdGgucm91bmQocGl4ZWxbMV0pXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChldmVudCkge1xuICAgIGxldCBwYXNzID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmdldFBvaW50ZXJDb3VudCgpID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5kb3duVGltZW91dF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG93blRpbWVvdXRfKTtcbiAgICAgICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcbiAgICAgIGNvbnN0IHRyYWNpbmcgPSB0aGlzLnRyYWNlU3RhdGVfLmFjdGl2ZTtcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2VTdGF0ZV8oZXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVfKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0aW5nVG9EcmF3ID0gIXRoaXMuZmluaXNoQ29vcmRpbmF0ZV87XG4gICAgICAgIGlmIChzdGFydGluZ1RvRHJhdykge1xuICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nXyhldmVudC5jb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXJ0aW5nVG9EcmF3ICYmIHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hEcmF3aW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgIXRoaXMuZnJlZWhhbmRfICYmXG4gICAgICAgICAgKCFzdGFydGluZ1RvRHJhdyB8fCB0aGlzLm1vZGVfID09PSAnUG9pbnQnKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy5hdEZpbmlzaF8oZXZlbnQucGl4ZWwsIHRyYWNpbmcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maW5pc2hDb25kaXRpb25fKGV2ZW50KSkge1xuICAgICAgICAgICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRUb0RyYXdpbmdfKGV2ZW50LmNvb3JkaW5hdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXNzID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgIHRoaXMuYWJvcnREcmF3aW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXNzICYmIHRoaXMuc3RvcENsaWNrXykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3M7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG1vdmUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBBIG1vdmUgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyTW92ZV8oZXZlbnQpIHtcbiAgICB0aGlzLnBvaW50ZXJUeXBlXyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGU7XG4gICAgaWYgKFxuICAgICAgdGhpcy5kb3duUHhfICYmXG4gICAgICAoKCF0aGlzLmZyZWVoYW5kXyAmJiB0aGlzLnNob3VsZEhhbmRsZV8pIHx8XG4gICAgICAgICh0aGlzLmZyZWVoYW5kXyAmJiAhdGhpcy5zaG91bGRIYW5kbGVfKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGRvd25QeCA9IHRoaXMuZG93blB4XztcbiAgICAgIGNvbnN0IGNsaWNrUHggPSBldmVudC5waXhlbDtcbiAgICAgIGNvbnN0IGR4ID0gZG93blB4WzBdIC0gY2xpY2tQeFswXTtcbiAgICAgIGNvbnN0IGR5ID0gZG93blB4WzFdIC0gY2xpY2tQeFsxXTtcbiAgICAgIGNvbnN0IHNxdWFyZWREaXN0YW5jZSA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgdGhpcy5zaG91bGRIYW5kbGVfID0gdGhpcy5mcmVlaGFuZF9cbiAgICAgICAgPyBzcXVhcmVkRGlzdGFuY2UgPiB0aGlzLnNxdWFyZWRDbGlja1RvbGVyYW5jZV9cbiAgICAgICAgOiBzcXVhcmVkRGlzdGFuY2UgPD0gdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfO1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVNrZXRjaFBvaW50XyhldmVudC5jb29yZGluYXRlLnNsaWNlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJhY2VfKGV2ZW50KTtcbiAgICB0aGlzLm1vZGlmeURyYXdpbmdfKGV2ZW50LmNvb3JkaW5hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBldmVudCBpcyB3aXRoaW4gdGhlIHNuYXBwaW5nIHRvbGVyYW5jZSBvZiB0aGUgc3RhcnQgY29vcmQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFjaW5nXSBEcmF3aW5nIGluIHRyYWNlIG1vZGUgKG9ubHkgc3RvcCBpZiBhdCB0aGUgc3RhcnRpbmcgcG9pbnQpLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZXZlbnQgaXMgd2l0aGluIHRoZSBzbmFwcGluZyB0b2xlcmFuY2Ugb2YgdGhlIHN0YXJ0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXRGaW5pc2hfKHBpeGVsLCB0cmFjaW5nKSB7XG4gICAgbGV0IGF0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuc2tldGNoRmVhdHVyZV8pIHtcbiAgICAgIGxldCBwb3RlbnRpYWxseURvbmUgPSBmYWxzZTtcbiAgICAgIGxldCBwb3RlbnRpYWxseUZpbmlzaENvb3JkaW5hdGVzID0gW3RoaXMuZmluaXNoQ29vcmRpbmF0ZV9dO1xuICAgICAgY29uc3QgbW9kZSA9IHRoaXMubW9kZV87XG4gICAgICBpZiAobW9kZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBhdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdDaXJjbGUnKSB7XG4gICAgICAgIGF0ID0gdGhpcy5za2V0Y2hDb29yZHNfLmxlbmd0aCA9PT0gMjtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIHBvdGVudGlhbGx5RG9uZSA9XG4gICAgICAgICAgIXRyYWNpbmcgJiYgdGhpcy5za2V0Y2hDb29yZHNfLmxlbmd0aCA+IHRoaXMubWluUG9pbnRzXztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGNvbnN0IHNrZXRjaENvb3JkcyA9IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXyk7XG4gICAgICAgIHBvdGVudGlhbGx5RG9uZSA9IHNrZXRjaENvb3Jkc1swXS5sZW5ndGggPiB0aGlzLm1pblBvaW50c187XG4gICAgICAgIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbXG4gICAgICAgICAgc2tldGNoQ29vcmRzWzBdWzBdLFxuICAgICAgICAgIHNrZXRjaENvb3Jkc1swXVtza2V0Y2hDb29yZHNbMF0ubGVuZ3RoIC0gMl0sXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0cmFjaW5nKSB7XG4gICAgICAgICAgcG90ZW50aWFsbHlGaW5pc2hDb29yZGluYXRlcyA9IFtza2V0Y2hDb29yZHNbMF1bMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbXG4gICAgICAgICAgICBza2V0Y2hDb29yZHNbMF1bMF0sXG4gICAgICAgICAgICBza2V0Y2hDb29yZHNbMF1bc2tldGNoQ29vcmRzWzBdLmxlbmd0aCAtIDJdLFxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3RlbnRpYWxseURvbmUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG90ZW50aWFsbHlGaW5pc2hDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZmluaXNoQ29vcmRpbmF0ZSA9IHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgY29uc3QgZmluaXNoUGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShmaW5pc2hDb29yZGluYXRlKTtcbiAgICAgICAgICBjb25zdCBkeCA9IHBpeGVsWzBdIC0gZmluaXNoUGl4ZWxbMF07XG4gICAgICAgICAgY29uc3QgZHkgPSBwaXhlbFsxXSAtIGZpbmlzaFBpeGVsWzFdO1xuICAgICAgICAgIGNvbnN0IHNuYXBUb2xlcmFuY2UgPSB0aGlzLmZyZWVoYW5kXyA/IDEgOiB0aGlzLnNuYXBUb2xlcmFuY2VfO1xuICAgICAgICAgIGF0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSA8PSBzbmFwVG9sZXJhbmNlO1xuICAgICAgICAgIGlmIChhdCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGZpbmlzaENvb3JkaW5hdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZVwiKS5Db29yZGluYXRlfSBjb29yZGluYXRlcyBDb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8oY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoIXRoaXMuc2tldGNoUG9pbnRfKSB7XG4gICAgICB0aGlzLnNrZXRjaFBvaW50XyA9IG5ldyBGZWF0dXJlKG5ldyBQb2ludChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy51cGRhdGVTa2V0Y2hGZWF0dXJlc18oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2tldGNoUG9pbnRHZW9tID0gdGhpcy5za2V0Y2hQb2ludF8uZ2V0R2VvbWV0cnkoKTtcbiAgICAgIHNrZXRjaFBvaW50R2VvbS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVPclVwZGF0ZUN1c3RvbVNrZXRjaExpbmVfKGdlb21ldHJ5KSB7XG4gICAgaWYgKCF0aGlzLnNrZXRjaExpbmVfKSB7XG4gICAgICB0aGlzLnNrZXRjaExpbmVfID0gbmV3IEZlYXR1cmUoKTtcbiAgICB9XG4gICAgY29uc3QgcmluZyA9IGdlb21ldHJ5LmdldExpbmVhclJpbmcoMCk7XG4gICAgbGV0IHNrZXRjaExpbmVHZW9tID0gdGhpcy5za2V0Y2hMaW5lXy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmICghc2tldGNoTGluZUdlb20pIHtcbiAgICAgIHNrZXRjaExpbmVHZW9tID0gbmV3IExpbmVTdHJpbmcoXG4gICAgICAgIHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIHJpbmcuZ2V0TGF5b3V0KClcbiAgICAgICk7XG4gICAgICB0aGlzLnNrZXRjaExpbmVfLnNldEdlb21ldHJ5KHNrZXRjaExpbmVHZW9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2tldGNoTGluZUdlb20uc2V0RmxhdENvb3JkaW5hdGVzKFxuICAgICAgICByaW5nLmdldExheW91dCgpLFxuICAgICAgICByaW5nLmdldEZsYXRDb29yZGluYXRlcygpXG4gICAgICApO1xuICAgICAgc2tldGNoTGluZUdlb20uY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgZHJhd2luZy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHN0YXJ0IFN0YXJ0IGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydERyYXdpbmdfKHN0YXJ0KSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQodGhpcy5nZW9tZXRyeUxheW91dF8pO1xuICAgIHdoaWxlIChzdGFydC5sZW5ndGggPCBzdHJpZGUpIHtcbiAgICAgIHN0YXJ0LnB1c2goMCk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBzdGFydDtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ1BvaW50Jykge1xuICAgICAgdGhpcy5za2V0Y2hDb29yZHNfID0gc3RhcnQuc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09ICdQb2x5Z29uJykge1xuICAgICAgdGhpcy5za2V0Y2hDb29yZHNfID0gW1tzdGFydC5zbGljZSgpLCBzdGFydC5zbGljZSgpXV07XG4gICAgICB0aGlzLnNrZXRjaExpbmVDb29yZHNfID0gdGhpcy5za2V0Y2hDb29yZHNfWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBbc3RhcnQuc2xpY2UoKSwgc3RhcnQuc2xpY2UoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnNrZXRjaExpbmVDb29yZHNfKSB7XG4gICAgICB0aGlzLnNrZXRjaExpbmVfID0gbmV3IEZlYXR1cmUobmV3IExpbmVTdHJpbmcodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oXG4gICAgICB0aGlzLnNrZXRjaENvb3Jkc18sXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBwcm9qZWN0aW9uXG4gICAgKTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gbmV3IEZlYXR1cmUoKTtcbiAgICBpZiAodGhpcy5nZW9tZXRyeU5hbWVfKSB7XG4gICAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdlb21ldHJ5TmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmF3RXZlbnQoRHJhd0V2ZW50VHlwZS5EUkFXU1RBUlQsIHRoaXMuc2tldGNoRmVhdHVyZV8pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGRyYXdpbmcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtb2RpZnlEcmF3aW5nXyhjb29yZGluYXRlKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gbWFwLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gZ2V0U3RyaWRlRm9yTGF5b3V0KHRoaXMuZ2VvbWV0cnlMYXlvdXRfKTtcbiAgICBsZXQgY29vcmRpbmF0ZXMsIGxhc3Q7XG4gICAgd2hpbGUgKGNvb3JkaW5hdGUubGVuZ3RoIDwgc3RyaWRlKSB7XG4gICAgICBjb29yZGluYXRlLnB1c2goMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGVfID09PSAnUG9pbnQnKSB7XG4gICAgICBsYXN0ID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXylbMF07XG4gICAgICBsYXN0ID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodGhpcy5hdEZpbmlzaF8obWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSkpKSB7XG4gICAgICAgIC8vIHNuYXAgdG8gZmluaXNoXG4gICAgICAgIGNvb3JkaW5hdGUgPSB0aGlzLmZpbmlzaENvb3JkaW5hdGVfLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgICAgbGFzdCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBsYXN0WzBdID0gY29vcmRpbmF0ZVswXTtcbiAgICBsYXN0WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKFxuICAgICAgLyoqIEB0eXBlIHshTGluZUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXyksXG4gICAgICBnZW9tZXRyeSxcbiAgICAgIHByb2plY3Rpb25cbiAgICApO1xuICAgIGlmICh0aGlzLnNrZXRjaFBvaW50Xykge1xuICAgICAgY29uc3Qgc2tldGNoUG9pbnRHZW9tID0gdGhpcy5za2V0Y2hQb2ludF8uZ2V0R2VvbWV0cnkoKTtcbiAgICAgIHNrZXRjaFBvaW50R2VvbS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlKTtcbiAgICB9XG4gICAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gJ1BvbHlnb24nICYmIHRoaXMubW9kZV8gIT09ICdQb2x5Z29uJykge1xuICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZUN1c3RvbVNrZXRjaExpbmVfKC8qKiBAdHlwZSB7UG9seWdvbn0gKi8gKGdlb21ldHJ5KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNrZXRjaExpbmVDb29yZHNfKSB7XG4gICAgICBjb25zdCBza2V0Y2hMaW5lR2VvbSA9IHRoaXMuc2tldGNoTGluZV8uZ2V0R2VvbWV0cnkoKTtcbiAgICAgIHNrZXRjaExpbmVHZW9tLnNldENvb3JkaW5hdGVzKHRoaXMuc2tldGNoTGluZUNvb3Jkc18pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBjb29yZGluYXRlIHRvIHRoZSBkcmF3aW5nLlxuICAgKiBAcGFyYW0geyFQb2ludENvb3JkVHlwZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRUb0RyYXdpbmdfKGNvb3JkaW5hdGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpO1xuICAgIGxldCBkb25lO1xuICAgIGxldCBjb29yZGluYXRlcztcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlXztcbiAgICBpZiAobW9kZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IG1vZGUgPT09ICdDaXJjbGUnKSB7XG4gICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSB0aGlzLm1heFBvaW50c18pIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5LCBwcm9qZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pWzBdO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSB0aGlzLm1heFBvaW50c18pIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBjb29yZGluYXRlc1swXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8odGhpcy5za2V0Y2hDb29yZHNfLCBnZW9tZXRyeSwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8oY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBwb2ludHMgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlTGFzdFBvaW50c18obikge1xuICAgIGlmICghdGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGVfO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBsZXQgY29vcmRpbmF0ZXM7XG4gICAgICBpZiAobW9kZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IG1vZGUgPT09ICdDaXJjbGUnKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICAgICAgY29vcmRpbmF0ZXMuc3BsaWNlKC0yLCAxKTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDJdLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgZmluaXNoQ29vcmRpbmF0ZSA9IHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8uc2xpY2UoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXSA9IGZpbmlzaENvb3JkaW5hdGU7XG4gICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVNrZXRjaFBvaW50XyhmaW5pc2hDb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSwgcHJvamVjdGlvbik7XG4gICAgICAgIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT09ICdQb2x5Z29uJyAmJiB0aGlzLnNrZXRjaExpbmVfKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZUN1c3RvbVNrZXRjaExpbmVfKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQb2x5Z29ufSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pWzBdO1xuICAgICAgICBjb29yZGluYXRlcy5zcGxpY2UoLTIsIDEpO1xuICAgICAgICBjb25zdCBza2V0Y2hMaW5lR2VvbSA9IHRoaXMuc2tldGNoTGluZV8uZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgY29uc3QgZmluaXNoQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDJdLnNsaWNlKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0gPSBmaW5pc2hDb29yZGluYXRlO1xuICAgICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8oZmluaXNoQ29vcmRpbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2tldGNoTGluZUdlb20uc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKHRoaXMuc2tldGNoQ29vcmRzXywgZ2VvbWV0cnksIHByb2plY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuYWJvcnREcmF3aW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGxhc3QgcG9pbnQgb2YgdGhlIGZlYXR1cmUgY3VycmVudGx5IGJlaW5nIGRyYXduLiBEb2VzIG5vdCBkbyBhbnl0aGluZyB3aGVuXG4gICAqIGRyYXdpbmcgUE9JTlQgb3IgTVVMVElfUE9JTlQgZ2VvbWV0cmllcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlTGFzdFBvaW50KCkge1xuICAgIHRoaXMucmVtb3ZlTGFzdFBvaW50c18oMSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBkcmF3aW5nIGFuZCBhZGQgdGhlIHNrZXRjaCBmZWF0dXJlIHRvIHRoZSB0YXJnZXQgbGF5ZXIuXG4gICAqIFRoZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd+RHJhd0V2ZW50VHlwZS5EUkFXRU5EfSBldmVudCBpc1xuICAgKiBkaXNwYXRjaGVkIGJlZm9yZSBpbnNlcnRpbmcgdGhlIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGZpbmlzaERyYXdpbmcoKSB7XG4gICAgY29uc3Qgc2tldGNoRmVhdHVyZSA9IHRoaXMuYWJvcnREcmF3aW5nXygpO1xuICAgIGlmICghc2tldGNoRmVhdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29vcmRpbmF0ZXMgPSB0aGlzLnNrZXRjaENvb3Jkc187XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBza2V0Y2hGZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIHJlZHVuZGFudCBsYXN0IHBvaW50XG4gICAgICBjb29yZGluYXRlcy5wb3AoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5LCBwcm9qZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09ICdQb2x5Z29uJykge1xuICAgICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgbGFzdCBwb2ludCBpbiByaW5nXG4gICAgICAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovIChjb29yZGluYXRlcylbMF0ucG9wKCk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSwgcHJvamVjdGlvbik7XG4gICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBtdWx0aS1wYXJ0IGdlb21ldHJpZXNcbiAgICBpZiAodGhpcy50eXBlXyA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlLnNldEdlb21ldHJ5KFxuICAgICAgICBuZXcgTXVsdGlQb2ludChbLyoqIEB0eXBlIHtQb2ludENvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKV0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlXyA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgIHNrZXRjaEZlYXR1cmUuc2V0R2VvbWV0cnkoXG4gICAgICAgIG5ldyBNdWx0aUxpbmVTdHJpbmcoWy8qKiBAdHlwZSB7TGluZUNvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKV0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlXyA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgIHNrZXRjaEZlYXR1cmUuc2V0R2VvbWV0cnkoXG4gICAgICAgIG5ldyBNdWx0aVBvbHlnb24oWy8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKV0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGRpc3BhdGNoIGV2ZW50IHRvIGFsbG93IGZ1bGwgc2V0IHVwIG9mIGZlYXR1cmVcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYXdFdmVudChEcmF3RXZlbnRUeXBlLkRSQVdFTkQsIHNrZXRjaEZlYXR1cmUpKTtcblxuICAgIC8vIFRoZW4gaW5zZXJ0IGZlYXR1cmVcbiAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNfLnB1c2goc2tldGNoRmVhdHVyZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIHRoaXMuc291cmNlXy5hZGRGZWF0dXJlKHNrZXRjaEZlYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGRyYXdpbmcgd2l0aG91dCBhZGRpbmcgdGhlIHNrZXRjaCBmZWF0dXJlIHRvIHRoZSB0YXJnZXQgbGF5ZXIuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmU8aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0PnxudWxsfSBUaGUgc2tldGNoIGZlYXR1cmUgKG9yIG51bGwgaWYgbm9uZSkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhYm9ydERyYXdpbmdfKCkge1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuICAgIGNvbnN0IHNrZXRjaEZlYXR1cmUgPSB0aGlzLnNrZXRjaEZlYXR1cmVfO1xuICAgIHRoaXMuc2tldGNoRmVhdHVyZV8gPSBudWxsO1xuICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbnVsbDtcbiAgICB0aGlzLnNrZXRjaExpbmVfID0gbnVsbDtcbiAgICB0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpLmNsZWFyKHRydWUpO1xuICAgIHRoaXMuZGVhY3RpdmF0ZVRyYWNlXygpO1xuICAgIHJldHVybiBza2V0Y2hGZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgZHJhd2luZyB3aXRob3V0IGFkZGluZyB0aGUgc2tldGNoIGZlYXR1cmUgdG8gdGhlIHRhcmdldCBsYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgYWJvcnREcmF3aW5nKCkge1xuICAgIGNvbnN0IHNrZXRjaEZlYXR1cmUgPSB0aGlzLmFib3J0RHJhd2luZ18oKTtcbiAgICBpZiAoc2tldGNoRmVhdHVyZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmF3RXZlbnQoRHJhd0V2ZW50VHlwZS5EUkFXQUJPUlQsIHNrZXRjaEZlYXR1cmUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGNvb3JkaW5hdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGdlb21ldHJ5IHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGRyYXduLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gZHJhd2luZyBMaW5lU3RyaW5ncyBvciBQb2x5Z29ucy4gQ29vcmRpbmF0ZXMgd2lsbFxuICAgKiBlaXRoZXIgYmUgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgTGluZVN0cmluZyBvciB0aGUgb3V0ZXIgcmluZyBvZiB0aGUgY3VycmVudFxuICAgKiBQb2x5Z29uLiBJZiBubyBnZW9tZXRyeSBpcyBiZWluZyBkcmF3biwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHshTGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgTGluZWFyIGNvb3JkaW5hdGVzIHRvIGJlIGFwcGVuZGVkIHRvXG4gICAqIHRoZSBjb29yZGluYXRlIGFycmF5LlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRDb29yZGluYXRlcyhjb29yZGluYXRlcykge1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGVfO1xuICAgIGNvbnN0IG5ld0RyYXdpbmcgPSAhdGhpcy5za2V0Y2hGZWF0dXJlXztcbiAgICBpZiAobmV3RHJhd2luZykge1xuICAgICAgdGhpcy5zdGFydERyYXdpbmdfKGNvb3JkaW5hdGVzWzBdKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqL1xuICAgIGxldCBza2V0Y2hDb29yZHM7XG4gICAgaWYgKG1vZGUgPT09ICdMaW5lU3RyaW5nJyB8fCBtb2RlID09PSAnQ2lyY2xlJykge1xuICAgICAgc2tldGNoQ29vcmRzID0gLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgc2tldGNoQ29vcmRzID1cbiAgICAgICAgdGhpcy5za2V0Y2hDb29yZHNfICYmIHRoaXMuc2tldGNoQ29vcmRzXy5sZW5ndGhcbiAgICAgICAgICA/IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXylbMF1cbiAgICAgICAgICA6IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5ld0RyYXdpbmcpIHtcbiAgICAgIHNrZXRjaENvb3Jkcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBsYXN0IGNvb3JkaW5hdGUgZnJvbSBza2V0Y2ggZHJhd2luZyAodGhpcyBjb29yZGluYXRlIGZvbGxvd3MgY3Vyc29yIHBvc2l0aW9uKVxuICAgIHNrZXRjaENvb3Jkcy5wb3AoKTtcblxuICAgIC8vIEFwcGVuZCBjb29yZGluYXRlIGxpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZFRvRHJhd2luZ18oY29vcmRpbmF0ZXNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZGluZyA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIC8vIER1cGxpY2F0ZSBsYXN0IGNvb3JkaW5hdGUgZm9yIHNrZXRjaCBkcmF3aW5nIChjdXJzb3IgcG9zaXRpb24pXG4gICAgdGhpcy5hZGRUb0RyYXdpbmdfKGVuZGluZyk7XG4gICAgdGhpcy5tb2RpZnlEcmF3aW5nXyhlbmRpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGRyYXcgbW9kZSBieSBzdGFydGluZyBmcm9tIGFuIGV4aXN0aW5nIGdlb21ldHJ5IHdoaWNoIHdpbGxcbiAgICogcmVjZWl2ZSBuZXcgYWRkaXRpb25hbCBwb2ludHMuIFRoaXMgb25seSB3b3JrcyBvbiBmZWF0dXJlcyB3aXRoXG4gICAqIGBMaW5lU3RyaW5nYCBnZW9tZXRyaWVzLCB3aGVyZSB0aGUgaW50ZXJhY3Rpb24gd2lsbCBleHRlbmQgbGluZXMgYnkgYWRkaW5nXG4gICAqIHBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBjb29yZGluYXRlcyBhcnJheS5cbiAgICogVGhpcyB3aWxsIGNoYW5nZSB0aGUgb3JpZ2luYWwgZmVhdHVyZSwgaW5zdGVhZCBvZiBkcmF3aW5nIGEgY29weS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIHdpbGwgZGlzcGF0Y2ggYSBgZHJhd3N0YXJ0YCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHshRmVhdHVyZTxMaW5lU3RyaW5nPn0gZmVhdHVyZSBGZWF0dXJlIHRvIGJlIGV4dGVuZGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBleHRlbmQoZmVhdHVyZSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGNvbnN0IGxpbmVTdHJpbmcgPSBnZW9tZXRyeTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gZmVhdHVyZTtcbiAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBsaW5lU3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuc2tldGNoQ29vcmRzX1t0aGlzLnNrZXRjaENvb3Jkc18ubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGxhc3Quc2xpY2UoKTtcbiAgICB0aGlzLnNrZXRjaENvb3Jkc18ucHVzaChsYXN0LnNsaWNlKCkpO1xuICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KGxhc3QpKTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmF3RXZlbnQoRHJhd0V2ZW50VHlwZS5EUkFXU1RBUlQsIHRoaXMuc2tldGNoRmVhdHVyZV8pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIHNrZXRjaCBmZWF0dXJlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpIHtcbiAgICBjb25zdCBza2V0Y2hGZWF0dXJlcyA9IFtdO1xuICAgIGlmICh0aGlzLnNrZXRjaEZlYXR1cmVfKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlcy5wdXNoKHRoaXMuc2tldGNoRmVhdHVyZV8pO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2V0Y2hMaW5lXykge1xuICAgICAgc2tldGNoRmVhdHVyZXMucHVzaCh0aGlzLnNrZXRjaExpbmVfKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tldGNoUG9pbnRfKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlcy5wdXNoKHRoaXMuc2tldGNoUG9pbnRfKTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxheVNvdXJjZSA9IHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCk7XG4gICAgb3ZlcmxheVNvdXJjZS5jbGVhcih0cnVlKTtcbiAgICBvdmVybGF5U291cmNlLmFkZEZlYXR1cmVzKHNrZXRjaEZlYXR1cmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlU3RhdGVfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICBpZiAoIW1hcCB8fCAhYWN0aXZlKSB7XG4gICAgICB0aGlzLmFib3J0RHJhd2luZygpO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlfLnNldE1hcChhY3RpdmUgPyBtYXAgOiBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0eWxlcyA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBnZW9tZXRyeUZ1bmN0aW9uYCBmb3IgYHR5cGU6ICdDaXJjbGUnYCB0aGF0IHdpbGwgY3JlYXRlIGEgcmVndWxhclxuICogcG9seWdvbiB3aXRoIGEgdXNlciBzcGVjaWZpZWQgbnVtYmVyIG9mIHNpZGVzIGFuZCBzdGFydCBhbmdsZSBpbnN0ZWFkIG9mIGFcbiAqIHtAbGluayBpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5DaXJjbGV9IGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWRlc10gTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiAgICAgRGVmYXVsdCBpcyAzMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGVdIEFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCBpbiBjb3VudGVyLWNsb2Nrd2lzZVxuICogICAgIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC5cbiAqICAgICBEZWZhdWx0IGlzIHRoZSBhbmdsZSBkZWZpbmVkIGJ5IHRoZSBoZWFkaW5nIGZyb20gdGhlIGNlbnRlciBvZiB0aGVcbiAqICAgICByZWd1bGFyIHBvbHlnb24gdG8gdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAqIEByZXR1cm4ge0dlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZHJhd3MgYSBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVndWxhclBvbHlnb24oc2lkZXMsIGFuZ2xlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGdlb21ldHJ5LCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3QgY2VudGVyID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAoY29vcmRpbmF0ZXMpWzBdLFxuICAgICAgcHJvamVjdGlvblxuICAgICk7XG4gICAgY29uc3QgZW5kID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAoY29vcmRpbmF0ZXMpW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdLFxuICAgICAgcHJvamVjdGlvblxuICAgICk7XG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoY2VudGVyLCBlbmQpKTtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5IHx8IGZyb21DaXJjbGUobmV3IENpcmNsZShjZW50ZXIpLCBzaWRlcyk7XG5cbiAgICBsZXQgaW50ZXJuYWxBbmdsZSA9IGFuZ2xlO1xuICAgIGlmICghYW5nbGUgJiYgYW5nbGUgIT09IDApIHtcbiAgICAgIGNvbnN0IHggPSBlbmRbMF0gLSBjZW50ZXJbMF07XG4gICAgICBjb25zdCB5ID0gZW5kWzFdIC0gY2VudGVyWzFdO1xuICAgICAgaW50ZXJuYWxBbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgfVxuICAgIG1ha2VSZWd1bGFyKFxuICAgICAgLyoqIEB0eXBlIHtQb2x5Z29ufSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgY2VudGVyLFxuICAgICAgcmFkaXVzLFxuICAgICAgaW50ZXJuYWxBbmdsZVxuICAgICk7XG5cbiAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICBnZW9tZXRyeS50cmFuc2Zvcm0ocHJvamVjdGlvbiwgdXNlclByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYGdlb21ldHJ5RnVuY3Rpb25gIHRoYXQgd2lsbCBjcmVhdGUgYSBib3gtc2hhcGVkIHBvbHlnb24gKGFsaWduZWRcbiAqIHdpdGggdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGF4ZXMpLiAgVXNlIHRoaXMgd2l0aCB0aGUgZHJhdyBpbnRlcmFjdGlvbiBhbmRcbiAqIGB0eXBlOiAnQ2lyY2xlJ2AgdG8gcmV0dXJuIGEgYm94IGluc3RlYWQgb2YgYSBjaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHtHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGRyYXdzIGEgYm94LXNoYXBlZCBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm94KCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSwgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IGV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFxuICAgICAgLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAoW1xuICAgICAgICBjb29yZGluYXRlc1swXSxcbiAgICAgICAgY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0sXG4gICAgICBdKS5tYXAoZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlLCBwcm9qZWN0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBib3hDb29yZGluYXRlcyA9IFtcbiAgICAgIFtcbiAgICAgICAgZ2V0Qm90dG9tTGVmdChleHRlbnQpLFxuICAgICAgICBnZXRCb3R0b21SaWdodChleHRlbnQpLFxuICAgICAgICBnZXRUb3BSaWdodChleHRlbnQpLFxuICAgICAgICBnZXRUb3BMZWZ0KGV4dGVudCksXG4gICAgICAgIGdldEJvdHRvbUxlZnQoZXh0ZW50KSxcbiAgICAgIF0sXG4gICAgXTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKGJveENvb3JkaW5hdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvbWV0cnkgPSBuZXcgUG9seWdvbihib3hDb29yZGluYXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICBpZiAodXNlclByb2plY3Rpb24pIHtcbiAgICAgIGdlb21ldHJ5LnRyYW5zZm9ybShwcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRyYXdpbmcgbW9kZS4gIFRoZSBtb2RlIGZvciBtdWx0aS1wYXJ0IGdlb21ldHJpZXMgaXMgdGhlIHNhbWUgYXMgZm9yXG4gKiB0aGVpciBzaW5nbGUtcGFydCBjb3VzaW5zLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGV9IHR5cGUgR2VvbWV0cnkgdHlwZS5cbiAqIEByZXR1cm4ge01vZGV9IERyYXdpbmcgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgIHJldHVybiAnUG9pbnQnO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICByZXR1cm4gJ0xpbmVTdHJpbmcnO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICByZXR1cm4gJ1BvbHlnb24nO1xuICAgIGNhc2UgJ0NpcmNsZSc6XG4gICAgICByZXR1cm4gJ0NpcmNsZSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlOiAnICsgdHlwZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhdztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9FeHRlbnRcbiAqL1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3IuanMnO1xuaW1wb3J0IHthbHdheXN9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgZ2V0QXJlYX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7XG4gIGNsb3Nlc3RPblNlZ21lbnQsXG4gIGRpc3RhbmNlIGFzIGNvb3JkaW5hdGVEaXN0YW5jZSxcbiAgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UsXG4gIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCxcbn0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IHtmcm9tRXh0ZW50IGFzIHBvbHlnb25Gcm9tRXh0ZW50fSBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IHt0b1VzZXJFeHRlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsd2F5c30uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEluaXRpYWwgZXh0ZW50LiBEZWZhdWx0cyB0byBub1xuICogaW5pdGlhbCBleHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gW2JveFN0eWxlXVxuICogU3R5bGUgZm9yIHRoZSBkcmF3biBleHRlbnQgYm94LiBEZWZhdWx0cyB0byB0aGUgYFBvbHlnb25gIGVkaXRpbmcgc3R5bGVcbiAqIGRvY3VtZW50ZWQgaW4ge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxUb2xlcmFuY2U9MTBdIFBpeGVsIHRvbGVyYW5jZSBmb3IgY29uc2lkZXJpbmcgdGhlXG4gKiBwb2ludGVyIGNsb3NlIGVub3VnaCB0byBhIHNlZ21lbnQgb3IgdmVydGV4IGZvciBlZGl0aW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtwb2ludGVyU3R5bGVdXG4gKiBTdHlsZSBmb3IgdGhlIGN1cnNvciB1c2VkIHRvIGRyYXcgdGhlIGV4dGVudC4gRGVmYXVsdHMgdG8gdGhlIGBQb2ludGAgZWRpdGluZyBzdHlsZVxuICogZG9jdW1lbnRlZCBpbiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXAgdGhlIGRyYXduIGV4dGVudCBhY3Jvc3MgbXVsdGlwbGUgbWFwc1xuICogaW4gdGhlIFggZGlyZWN0aW9uPyBPbmx5IGFmZmVjdHMgdmlzdWFscywgbm90IGZ1bmN0aW9uYWxpdHkuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBFeHRlbnRFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV4dGVudCBpcyBjaGFuZ2VkXG4gICAqIEBldmVudCBFeHRlbnRFdmVudCNleHRlbnRjaGFuZ2VkXG4gICAqIEBhcGlcbiAgICovXG4gIEVYVEVOVENIQU5HRUQ6ICdleHRlbnRjaGFuZ2VkJyxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50fSBpbnN0YW5jZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgRXh0ZW50RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCB0aGUgbmV3IGV4dGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoZXh0ZW50KSB7XG4gICAgc3VwZXIoRXh0ZW50RXZlbnRUeXBlLkVYVEVOVENIQU5HRUQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZXh0ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdleHRlbnRjaGFuZ2VkJywgRXh0ZW50RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZSd8J2V4dGVudGNoYW5nZWQnLCBSZXR1cm4+fSBFeHRlbnRPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYXcgYSB2ZWN0b3IgYm94IGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLlxuICogT25jZSBkcmF3biwgdGhlIHZlY3RvciBib3ggY2FuIGJlIG1vZGlmaWVkIGJ5IGRyYWdnaW5nIGl0cyB2ZXJ0aWNlcyBvciBlZGdlcy5cbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKlxuICogQGZpcmVzIEV4dGVudEV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEV4dGVudCBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgc3VwZXIoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKG9wdGlvbnMpKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RXh0ZW50T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RXh0ZW50T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtFeHRlbnRPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgZHJhd24gYm94XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgcG9pbnRlciBtb3ZlIGV2ZW50c1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbiAoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGl4ZWwgdGhyZXNob2xkIHRvIHNuYXAgdG8gZXh0ZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID1cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwb2ludGVyIHNuYXBwZWQgdG8gYW4gZXh0ZW50IHZlcnRleFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGZvciBkaXNwbGF5aW5nIHRoZSB2aXNpYmxlIGV4dGVudFxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRGZWF0dXJlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGZvciBkaXNwbGF5aW5nIHRoZSB2aXNpYmxlIHBvaW50ZXJcbiAgICAgKiBAdHlwZSB7RmVhdHVyZTxQb2ludD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExheWVyIGZvciB0aGUgZXh0ZW50RmVhdHVyZVxuICAgICAqIEB0eXBlIHtWZWN0b3JMYXllcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50T3ZlcmxheV8gPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgd3JhcFg6ICEhb3B0aW9ucy53cmFwWCxcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuYm94U3R5bGVcbiAgICAgICAgPyBvcHRpb25zLmJveFN0eWxlXG4gICAgICAgIDogZ2V0RGVmYXVsdEV4dGVudFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIExheWVyIGZvciB0aGUgdmVydGV4RmVhdHVyZVxuICAgICAqIEB0eXBlIHtWZWN0b3JMYXllcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4T3ZlcmxheV8gPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgd3JhcFg6ICEhb3B0aW9ucy53cmFwWCxcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMucG9pbnRlclN0eWxlXG4gICAgICAgID8gb3B0aW9ucy5wb2ludGVyU3R5bGVcbiAgICAgICAgOiBnZXREZWZhdWx0UG9pbnRlclN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmV4dGVudCkge1xuICAgICAgdGhpcy5zZXRFeHRlbnQob3B0aW9ucy5leHRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBjdXJzb3IgbG9jYXRpb25cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIG1hcFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8bnVsbH0gc25hcHBlZCB2ZXJ0ZXggb24gZXh0ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzbmFwVG9WZXJ0ZXhfKHBpeGVsLCBtYXApIHtcbiAgICBjb25zdCBwaXhlbENvb3JkaW5hdGUgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKTtcbiAgICBjb25zdCBzb3J0QnlEaXN0YW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQocGl4ZWxDb29yZGluYXRlLCBhKSAtXG4gICAgICAgIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChwaXhlbENvb3JkaW5hdGUsIGIpXG4gICAgICApO1xuICAgIH07XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnRJbnRlcm5hbCgpO1xuICAgIGlmIChleHRlbnQpIHtcbiAgICAgIC8vY29udmVydCBleHRlbnRzIHRvIGxpbmUgc2VnbWVudHMgYW5kIGZpbmQgdGhlIHNlZ21lbnQgY2xvc2VzdCB0byBwaXhlbENvb3JkaW5hdGVcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gZ2V0U2VnbWVudHMoZXh0ZW50KTtcbiAgICAgIHNlZ21lbnRzLnNvcnQoc29ydEJ5RGlzdGFuY2UpO1xuICAgICAgY29uc3QgY2xvc2VzdFNlZ21lbnQgPSBzZWdtZW50c1swXTtcblxuICAgICAgbGV0IHZlcnRleCA9IGNsb3Nlc3RPblNlZ21lbnQocGl4ZWxDb29yZGluYXRlLCBjbG9zZXN0U2VnbWVudCk7XG4gICAgICBjb25zdCB2ZXJ0ZXhQaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwodmVydGV4KTtcblxuICAgICAgLy9pZiB0aGUgZGlzdGFuY2UgaXMgd2l0aGluIHRvbGVyYW5jZSwgc25hcCB0byB0aGUgc2VnbWVudFxuICAgICAgaWYgKGNvb3JkaW5hdGVEaXN0YW5jZShwaXhlbCwgdmVydGV4UGl4ZWwpIDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgIC8vdGVzdCBpZiB3ZSBzaG91bGQgZnVydGhlciBzbmFwIHRvIGEgdmVydGV4XG4gICAgICAgIGNvbnN0IHBpeGVsMSA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICBjb25zdCBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKGNsb3Nlc3RTZWdtZW50WzFdKTtcbiAgICAgICAgY29uc3Qgc3F1YXJlZERpc3QxID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwxKTtcbiAgICAgICAgY29uc3Qgc3F1YXJlZERpc3QyID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwyKTtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihzcXVhcmVkRGlzdDEsIHNxdWFyZWREaXN0MikpO1xuICAgICAgICB0aGlzLnNuYXBwZWRUb1ZlcnRleF8gPSBkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgICAgICBpZiAodGhpcy5zbmFwcGVkVG9WZXJ0ZXhfKSB7XG4gICAgICAgICAgdmVydGV4ID1cbiAgICAgICAgICAgIHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/IGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IHBvaW50ZXIgbW92ZSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9pbnRlck1vdmVfKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IHBpeGVsID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG5cbiAgICBsZXQgdmVydGV4ID0gdGhpcy5zbmFwVG9WZXJ0ZXhfKHBpeGVsLCBtYXApO1xuICAgIGlmICghdmVydGV4KSB7XG4gICAgICB2ZXJ0ZXggPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyh2ZXJ0ZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IGV4dGVudFxuICAgKiBAcmV0dXJuIHtGZWF0dXJlfSBleHRlbnQgYXMgZmVhdHJ1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlT3JVcGRhdGVFeHRlbnRGZWF0dXJlXyhleHRlbnQpIHtcbiAgICBsZXQgZXh0ZW50RmVhdHVyZSA9IHRoaXMuZXh0ZW50RmVhdHVyZV87XG5cbiAgICBpZiAoIWV4dGVudEZlYXR1cmUpIHtcbiAgICAgIGlmICghZXh0ZW50KSB7XG4gICAgICAgIGV4dGVudEZlYXR1cmUgPSBuZXcgRmVhdHVyZSh7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnRGZWF0dXJlID0gbmV3IEZlYXR1cmUocG9seWdvbkZyb21FeHRlbnQoZXh0ZW50KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4dGVudEZlYXR1cmVfID0gZXh0ZW50RmVhdHVyZTtcbiAgICAgIHRoaXMuZXh0ZW50T3ZlcmxheV8uZ2V0U291cmNlKCkuYWRkRmVhdHVyZShleHRlbnRGZWF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleHRlbnQpIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZS5zZXRHZW9tZXRyeSh1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZS5zZXRHZW9tZXRyeShwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVudEZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHZlcnRleCBsb2NhdGlvbiBvZiBmZWF0dXJlXG4gICAqIEByZXR1cm4ge0ZlYXR1cmV9IHZlcnRleCBhcyBmZWF0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyh2ZXJ0ZXgpIHtcbiAgICBsZXQgdmVydGV4RmVhdHVyZSA9IHRoaXMudmVydGV4RmVhdHVyZV87XG4gICAgaWYgKCF2ZXJ0ZXhGZWF0dXJlKSB7XG4gICAgICB2ZXJ0ZXhGZWF0dXJlID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KHZlcnRleCkpO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IHZlcnRleEZlYXR1cmU7XG4gICAgICB0aGlzLnZlcnRleE92ZXJsYXlfLmdldFNvdXJjZSgpLmFkZEZlYXR1cmUodmVydGV4RmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdmVydGV4RmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXModmVydGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleEZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50IHx8ICF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vZGlzcGxheSBwb2ludGVyIChpZiBub3QgZHJhZ2dpbmcpXG4gICAgaWYgKFxuICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSAmJlxuICAgICAgIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZVxuICAgICkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8obWFwQnJvd3NlckV2ZW50KTtcbiAgICB9XG4gICAgLy9jYWxsIHBvaW50ZXIgdG8gZGV0ZXJtaW5lIHVwL2Rvd24vZHJhZ1xuICAgIHN1cGVyLmhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgLy9yZXR1cm4gZmFsc2UgdG8gc3RvcCBwcm9wYWdhdGlvblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IHBpeGVsID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG5cbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmdldEV4dGVudEludGVybmFsKCk7XG4gICAgbGV0IHZlcnRleCA9IHRoaXMuc25hcFRvVmVydGV4XyhwaXhlbCwgbWFwKTtcblxuICAgIC8vZmluZCB0aGUgZXh0ZW50IGNvcm5lciBvcHBvc2l0ZSB0aGUgcGFzc2VkIGNvcm5lclxuICAgIGNvbnN0IGdldE9wcG9zaW5nUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIGxldCB4XyA9IG51bGw7XG4gICAgICBsZXQgeV8gPSBudWxsO1xuICAgICAgaWYgKHBvaW50WzBdID09IGV4dGVudFswXSkge1xuICAgICAgICB4XyA9IGV4dGVudFsyXTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRbMF0gPT0gZXh0ZW50WzJdKSB7XG4gICAgICAgIHhfID0gZXh0ZW50WzBdO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50WzFdID09IGV4dGVudFsxXSkge1xuICAgICAgICB5XyA9IGV4dGVudFszXTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRbMV0gPT0gZXh0ZW50WzNdKSB7XG4gICAgICAgIHlfID0gZXh0ZW50WzFdO1xuICAgICAgfVxuICAgICAgaWYgKHhfICE9PSBudWxsICYmIHlfICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbeF8sIHlfXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgaWYgKHZlcnRleCAmJiBleHRlbnQpIHtcbiAgICAgIGNvbnN0IHggPVxuICAgICAgICB2ZXJ0ZXhbMF0gPT0gZXh0ZW50WzBdIHx8IHZlcnRleFswXSA9PSBleHRlbnRbMl0gPyB2ZXJ0ZXhbMF0gOiBudWxsO1xuICAgICAgY29uc3QgeSA9XG4gICAgICAgIHZlcnRleFsxXSA9PSBleHRlbnRbMV0gfHwgdmVydGV4WzFdID09IGV4dGVudFszXSA/IHZlcnRleFsxXSA6IG51bGw7XG5cbiAgICAgIC8vc25hcCB0byBwb2ludFxuICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldFBvaW50SGFuZGxlcihnZXRPcHBvc2luZ1BvaW50KHZlcnRleCkpO1xuICAgICAgICAvL3NuYXAgdG8gZWRnZVxuICAgICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gZ2V0RWRnZUhhbmRsZXIoXG4gICAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbeCwgZXh0ZW50WzFdXSksXG4gICAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbeCwgZXh0ZW50WzNdXSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldEVkZ2VIYW5kbGVyKFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW2V4dGVudFswXSwgeV0pLFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW2V4dGVudFsyXSwgeV0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvL25vIHNuYXAgLSBuZXcgYmJveFxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0ZXggPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKHBpeGVsKTtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KFt2ZXJ0ZXhbMF0sIHZlcnRleFsxXSwgdmVydGV4WzBdLCB2ZXJ0ZXhbMV1dKTtcbiAgICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gZ2V0UG9pbnRIYW5kbGVyKHZlcnRleCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvL2V2ZW50IGhhbmRsZWQ7IHN0YXJ0IGRvd251cCBzZXF1ZW5jZVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMucG9pbnRlckhhbmRsZXJfKSB7XG4gICAgICBjb25zdCBwaXhlbENvb3JkaW5hdGUgPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KHRoaXMucG9pbnRlckhhbmRsZXJfKHBpeGVsQ29vcmRpbmF0ZSkpO1xuICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyhwaXhlbENvb3JkaW5hdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBudWxsO1xuICAgIC8vSWYgYmJveCBpcyB6ZXJvIGFyZWEsIHNldCB0byBudWxsO1xuICAgIGNvbnN0IGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50SW50ZXJuYWwoKTtcbiAgICBpZiAoIWV4dGVudCB8fCBnZXRBcmVhKGV4dGVudCkgPT09IDApIHtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7IC8vU3RvcCBoYW5kbGluZyBkb3dudXAgc2VxdWVuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgdGhpcy5leHRlbnRPdmVybGF5Xy5zZXRNYXAobWFwKTtcbiAgICB0aGlzLnZlcnRleE92ZXJsYXlfLnNldE1hcChtYXApO1xuICAgIHN1cGVyLnNldE1hcChtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZHJhd24gZXh0ZW50IGluIHRoZSB2aWV3IHByb2plY3Rpb24gKG9yIHVzZXIgcHJvamVjdGlvbiBpZiBzZXQpXG4gICAqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IERyYXduIGV4dGVudCBpbiB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRvVXNlckV4dGVudChcbiAgICAgIHRoaXMuZ2V0RXh0ZW50SW50ZXJuYWwoKSxcbiAgICAgIHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkcmF3biBleHRlbnQgaW4gdGhlIHZpZXcgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBEcmF3biBleHRlbnQgaW4gdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50SW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSBzZXRzIHRoZSBkcmF3biBleHRlbnQsIHVzaW5nIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudFxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRFeHRlbnQoZXh0ZW50KSB7XG4gICAgLy9OdWxsIGV4dGVudCBtZWFucyBubyBiYm94XG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50ID8gZXh0ZW50IDogbnVsbDtcbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlRXh0ZW50RmVhdHVyZV8oZXh0ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV4dGVudEV2ZW50KHRoaXMuZXh0ZW50XykpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBzdHlsZSBmb3IgdGhlIGRyYXduIGJib3hcbiAqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBEZWZhdWx0IEV4dGVudCBzdHlsZVxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0RXh0ZW50U3R5bGVGdW5jdGlvbigpIHtcbiAgY29uc3Qgc3R5bGUgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHN0eWxlWydQb2x5Z29uJ107XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBzdHlsZSBmb3IgdGhlIHBvaW50ZXJcbiAqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBEZWZhdWx0IHBvaW50ZXIgc3R5bGVcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50ZXJTdHlsZUZ1bmN0aW9uKCkge1xuICBjb25zdCBzdHlsZSA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVbJ1BvaW50J107XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZpeGVkUG9pbnQgY29ybmVyIHRoYXQgd2lsbCBiZSB1bmNoYW5nZWQgaW4gdGhlIG5ldyBleHRlbnRcbiAqIEByZXR1cm4ge2Z1bmN0aW9uIChpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBldmVudCBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50SGFuZGxlcihmaXhlZFBvaW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUG9pbnQsIHBvaW50XSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZpeGVkUDEgZmlyc3QgY29ybmVyIHRoYXQgd2lsbCBiZSB1bmNoYW5nZWQgaW4gdGhlIG5ldyBleHRlbnRcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmaXhlZFAyIHNlY29uZCBjb3JuZXIgdGhhdCB3aWxsIGJlIHVuY2hhbmdlZCBpbiB0aGUgbmV3IGV4dGVudFxuICogQHJldHVybiB7ZnVuY3Rpb24gKGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8bnVsbH0gZXZlbnQgaGFuZGxlclxuICovXG5mdW5jdGlvbiBnZXRFZGdlSGFuZGxlcihmaXhlZFAxLCBmaXhlZFAyKSB7XG4gIGlmIChmaXhlZFAxWzBdID09IGZpeGVkUDJbMF0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUDEsIFtwb2ludFswXSwgZml4ZWRQMlsxXV1dKTtcbiAgICB9O1xuICB9XG4gIGlmIChmaXhlZFAxWzFdID09IGZpeGVkUDJbMV0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUDEsIFtmaXhlZFAyWzBdLCBwb2ludFsxXV1dKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IGV4dGVudFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGV4dGVudCBsaW5lIHNlZ21lbnRzXG4gKi9cbmZ1bmN0aW9uIGdldFNlZ21lbnRzKGV4dGVudCkge1xuICByZXR1cm4gW1xuICAgIFtcbiAgICAgIFtleHRlbnRbMF0sIGV4dGVudFsxXV0sXG4gICAgICBbZXh0ZW50WzBdLCBleHRlbnRbM11dLFxuICAgIF0sXG4gICAgW1xuICAgICAgW2V4dGVudFswXSwgZXh0ZW50WzNdXSxcbiAgICAgIFtleHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgXSxcbiAgICBbXG4gICAgICBbZXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgW2V4dGVudFsyXSwgZXh0ZW50WzFdXSxcbiAgICBdLFxuICAgIFtcbiAgICAgIFtleHRlbnRbMl0sIGV4dGVudFsxXV0sXG4gICAgICBbZXh0ZW50WzBdLCBleHRlbnRbMV1dLFxuICAgIF0sXG4gIF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVudDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9MaW5rXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4uL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7dG9GaXhlZH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBBIG51bWJlci5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgd2l0aCBhdCBtb3N0IDUgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmZ1bmN0aW9uIHRvNShudW1iZXIpIHtcbiAgcmV0dXJuIHRvRml4ZWQobnVtYmVyLCA1KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVhZE51bWJlcihzdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIEEgbnVtYmVyLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gd3JpdGVOdW1iZXIobnVtYmVyKSB7XG4gIHJldHVybiB0bzUobnVtYmVyKS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIEEgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgQSBudW1iZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbnVtYmVycyBhcmUgZGlmZmVyZW50LlxuICovXG5mdW5jdGlvbiBkaWZmZXJlbnROdW1iZXIoYSwgYikge1xuICBpZiAoaXNOYU4oYSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGEgIT09IHJlYWROdW1iZXIod3JpdGVOdW1iZXIoYikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB0d28gbnVtYmVycy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYiBBbiBhcnJheSBvZiB0d28gbnVtYmVycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBhcnJheXMgYXJlIGRpZmZlcmVudC5cbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW50QXJyYXkoYSwgYikge1xuICByZXR1cm4gZGlmZmVyZW50TnVtYmVyKGFbMF0sIGJbMF0pIHx8IGRpZmZlcmVudE51bWJlcihhWzFdLCBiWzFdKTtcbn1cblxuLyoqIEB0eXBlZGVmIHsneCd8J3knfCd6J3wncid8J2wnfSBQYXJhbXMgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58aW1wb3J0KCcuLi9WaWV3LmpzJykuQW5pbWF0aW9uT3B0aW9uc30gW2FuaW1hdGU9dHJ1ZV0gQW5pbWF0ZSB2aWV3IHRyYW5zaXRpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTxQYXJhbXM+fSBbcGFyYW1zPVsneCcsICd5JywgJ3onLCAncicsICdsJ11dIFByb3BlcnRpZXMgdG8gdHJhY2suIERlZmF1bHQgaXMgdG8gdHJhY2tcbiAqIGB4YCAoY2VudGVyIHgpLCBgeWAgKGNlbnRlciB5KSwgYHpgICh6b29tKSwgYHJgIChyb3RhdGlvbikgYW5kIGBsYCAobGF5ZXJzKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcGxhY2U9ZmFsc2VdIFJlcGxhY2UgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgY3JlYXRpbmcgdGhlIG5ldyBlbnRyeSBpbiBicm93c2VyIGhpc3RvcnkuXG4gKiBCeSBkZWZhdWx0LCBjaGFuZ2VzIGluIHRoZSBtYXAgc3RhdGUgcmVzdWx0IGluIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3ByZWZpeD0nJ10gQnkgZGVmYXVsdCwgdGhlIFVSTCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBzZWFyY2ggcGFyYW1ldGVycyB4LCB5LCB6LCBhbmQgci4gIFRvXG4gKiBhdm9pZCBjb2xsaXNpb25zIHdpdGggZXhpc3Rpbmcgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCB5b3VyIGFwcGxpY2F0aW9uIHVzZXMsIHlvdSBjYW4gc3VwcGx5IGEgY3VzdG9tIHByZWZpeCBmb3JcbiAqIHRoZSBvbmVzIHVzZWQgYnkgdGhpcyBpbnRlcmFjdGlvbiAoZS5nLiAnb2w6JykuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBpbnRlcmFjdGlvbiB0aGF0IHN5bmNocm9uaXplcyB0aGUgbWFwIHN0YXRlIHdpdGggdGhlIFVSTC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExpbmsgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBMaW5rIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICBwYXJhbXM6IFsneCcsICd5JywgJ3onLCAncicsICdsJ10sXG4gICAgICAgIHJlcGxhY2U6IGZhbHNlLFxuICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnMgfHwge31cbiAgICApO1xuXG4gICAgbGV0IGFuaW1hdGlvbk9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgYW5pbWF0aW9uT3B0aW9ucyA9IHtkdXJhdGlvbjogMjUwfTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb25PcHRpb25zID0gb3B0aW9ucy5hbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uL1ZpZXcuanMnKS5BbmltYXRpb25PcHRpb25zfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbk9wdGlvbnNfID0gYW5pbWF0aW9uT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8UGFyYW1zLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGFyYW1zXyA9IG9wdGlvbnMucGFyYW1zLnJlZHVjZSgoYWNjLCB2YWx1ZSkgPT4ge1xuICAgICAgYWNjW3ZhbHVlXSA9IHRydWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBsYWNlXyA9IG9wdGlvbnMucmVwbGFjZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnByZWZpeF8gPSBvcHRpb25zLnByZWZpeDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsXyA9IHRydWU7XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXRlXyA9IHRoaXMudXBkYXRlU3RhdGVfLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBwYXJhbWV0ZXIgbmFtZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIG5hbWUgd2l0aCB0aGUgcHJlZml4IGFwcGxpZWQuXG4gICAqL1xuICBnZXRQYXJhbU5hbWVfKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMucHJlZml4Xykge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VVJMU2VhcmNoUGFyYW1zfSBwYXJhbXMgVGhlIHNlYXJjaCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSB1bnByZWZpeGVkIHBhcmFtZXRlciBuYW1lLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAgICovXG4gIGdldF8ocGFyYW1zLCBuYW1lKSB7XG4gICAgcmV0dXJuIHBhcmFtcy5nZXQodGhpcy5nZXRQYXJhbU5hbWVfKG5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1VSTFNlYXJjaFBhcmFtc30gcGFyYW1zIFRoZSBzZWFyY2ggcGFyYW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgdW5wcmVmaXhlZCBwYXJhbWV0ZXIgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBwYXJhbSB2YWx1ZS5cbiAgICovXG4gIHNldF8ocGFyYW1zLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcy5wYXJhbXNfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJhbXMuc2V0KHRoaXMuZ2V0UGFyYW1OYW1lXyhuYW1lKSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VVJMU2VhcmNoUGFyYW1zfSBwYXJhbXMgVGhlIHNlYXJjaCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSB1bnByZWZpeGVkIHBhcmFtZXRlciBuYW1lLlxuICAgKi9cbiAgZGVsZXRlXyhwYXJhbXMsIG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMucGFyYW1zXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyYW1zLmRlbGV0ZSh0aGlzLmdldFBhcmFtTmFtZV8obmFtZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBjb25zdCBvbGRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHN1cGVyLnNldE1hcChtYXApO1xuICAgIGlmIChtYXAgPT09IG9sZE1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2xkTWFwKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnNfKG9sZE1hcCk7XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMuaW5pdGlhbF8gPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZV8oKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnNfKG1hcCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3Rlckxpc3RlbmVyc18obWFwKSB7XG4gICAgdGhpcy5saXN0ZW5lcktleXNfLnB1c2goXG4gICAgICBsaXN0ZW4obWFwLCBNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcy51cGRhdGVVcmxfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihtYXAuZ2V0TGF5ZXJHcm91cCgpLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLnVwZGF0ZVVybF8sIHRoaXMpLFxuICAgICAgbGlzdGVuKG1hcCwgJ2NoYW5nZTpsYXllcmdyb3VwJywgdGhpcy5oYW5kbGVDaGFuZ2VMYXllckdyb3VwXywgdGhpcylcbiAgICApO1xuXG4gICAgaWYgKCF0aGlzLnJlcGxhY2VfKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMudXBkYXRlU3RhdGVfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnNfKG1hcCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMubGlzdGVuZXJLZXlzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubGlzdGVuZXJLZXlzX1tpXSk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0aGlzLnJlcGxhY2VfKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMudXBkYXRlU3RhdGVfKTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIHRoaXMuZGVsZXRlXyhwYXJhbXMsICd4Jyk7XG4gICAgdGhpcy5kZWxldGVfKHBhcmFtcywgJ3knKTtcbiAgICB0aGlzLmRlbGV0ZV8ocGFyYW1zLCAneicpO1xuICAgIHRoaXMuZGVsZXRlXyhwYXJhbXMsICdyJyk7XG4gICAgdGhpcy5kZWxldGVfKHBhcmFtcywgJ2wnKTtcbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgJycsIHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNoYW5nZUxheWVyR3JvdXBfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzXyhtYXApO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnNfKG1hcCk7XG4gICAgdGhpcy5pbml0aWFsXyA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVVcmxfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVN0YXRlXygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmICghbWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuXG4gICAgbGV0IHVwZGF0ZVZpZXcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uL1ZpZXcuanMnKS5BbmltYXRpb25PcHRpb25zfVxuICAgICAqL1xuICAgIGNvbnN0IHZpZXdQcm9wZXJ0aWVzID0ge307XG5cbiAgICBjb25zdCB6b29tID0gcmVhZE51bWJlcih0aGlzLmdldF8ocGFyYW1zLCAneicpKTtcbiAgICBpZiAoJ3onIGluIHRoaXMucGFyYW1zXyAmJiBkaWZmZXJlbnROdW1iZXIoem9vbSwgdmlldy5nZXRab29tKCkpKSB7XG4gICAgICB1cGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgIHZpZXdQcm9wZXJ0aWVzLnpvb20gPSB6b29tO1xuICAgIH1cblxuICAgIGNvbnN0IHJvdGF0aW9uID0gcmVhZE51bWJlcih0aGlzLmdldF8ocGFyYW1zLCAncicpKTtcbiAgICBpZiAoJ3InIGluIHRoaXMucGFyYW1zXyAmJiBkaWZmZXJlbnROdW1iZXIocm90YXRpb24sIHZpZXcuZ2V0Um90YXRpb24oKSkpIHtcbiAgICAgIHVwZGF0ZVZpZXcgPSB0cnVlO1xuICAgICAgdmlld1Byb3BlcnRpZXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSBbXG4gICAgICByZWFkTnVtYmVyKHRoaXMuZ2V0XyhwYXJhbXMsICd4JykpLFxuICAgICAgcmVhZE51bWJlcih0aGlzLmdldF8ocGFyYW1zLCAneScpKSxcbiAgICBdO1xuICAgIGlmIChcbiAgICAgICgneCcgaW4gdGhpcy5wYXJhbXNfIHx8ICd5JyBpbiB0aGlzLnBhcmFtc18pICYmXG4gICAgICBkaWZmZXJlbnRBcnJheShjZW50ZXIsIHZpZXcuZ2V0Q2VudGVyKCkpXG4gICAgKSB7XG4gICAgICB1cGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgIHZpZXdQcm9wZXJ0aWVzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlVmlldykge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxfICYmIHRoaXMuYW5pbWF0aW9uT3B0aW9uc18pIHtcbiAgICAgICAgdmlldy5hbmltYXRlKE9iamVjdC5hc3NpZ24odmlld1Byb3BlcnRpZXMsIHRoaXMuYW5pbWF0aW9uT3B0aW9uc18pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3UHJvcGVydGllcy5jZW50ZXIpIHtcbiAgICAgICAgICB2aWV3LnNldENlbnRlcih2aWV3UHJvcGVydGllcy5jZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnem9vbScgaW4gdmlld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICB2aWV3LnNldFpvb20odmlld1Byb3BlcnRpZXMuem9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyb3RhdGlvbicgaW4gdmlld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICB2aWV3LnNldFJvdGF0aW9uKHZpZXdQcm9wZXJ0aWVzLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxheWVycyA9IG1hcC5nZXRBbGxMYXllcnMoKTtcbiAgICBjb25zdCBsYXllcnNQYXJhbSA9IHRoaXMuZ2V0XyhwYXJhbXMsICdsJyk7XG4gICAgaWYgKFxuICAgICAgJ2wnIGluIHRoaXMucGFyYW1zXyAmJlxuICAgICAgbGF5ZXJzUGFyYW0gJiZcbiAgICAgIGxheWVyc1BhcmFtLmxlbmd0aCA9PT0gbGF5ZXJzLmxlbmd0aFxuICAgICkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChsYXllcnNQYXJhbVtpXSk7XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgdmlzaWJsZSA9IEJvb2xlYW4odmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgIGlmIChsYXllci5nZXRWaXNpYmxlKCkgIT09IHZpc2libGUpIHtcbiAgICAgICAgICAgIGxheWVyLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVVcmxfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSB0aGlzLmluaXRpYWxfO1xuICAgIHRoaXMuaW5pdGlhbF8gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuXG4gICAgY29uc3QgbGF5ZXJzID0gbWFwLmdldEFsbExheWVycygpO1xuICAgIGNvbnN0IHZpc2liaWxpdGllcyA9IG5ldyBBcnJheShsYXllcnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmlzaWJpbGl0aWVzW2ldID0gbGF5ZXJzW2ldLmdldFZpc2libGUoKSA/ICcxJyA6ICcwJztcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuXG4gICAgdGhpcy5zZXRfKHBhcmFtcywgJ3gnLCB3cml0ZU51bWJlcihjZW50ZXJbMF0pKTtcbiAgICB0aGlzLnNldF8ocGFyYW1zLCAneScsIHdyaXRlTnVtYmVyKGNlbnRlclsxXSkpO1xuICAgIHRoaXMuc2V0XyhwYXJhbXMsICd6Jywgd3JpdGVOdW1iZXIoem9vbSkpO1xuICAgIHRoaXMuc2V0XyhwYXJhbXMsICdyJywgd3JpdGVOdW1iZXIocm90YXRpb24pKTtcbiAgICB0aGlzLnNldF8ocGFyYW1zLCAnbCcsIHZpc2liaWxpdGllcy5qb2luKCcnKSk7XG5cbiAgICBpZiAodXJsLmhyZWYgIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICBpZiAoaW5pdGlhbCB8fCB0aGlzLnJlcGxhY2VfKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5LnN0YXRlLCAnJywgdXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnJywgdXJsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluaztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Nb2RpZnlcbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAnLi4vc3RydWN0cy9SQnVzaC5qcyc7XG5pbXBvcnQgVmVjdG9yRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3IuanMnO1xuaW1wb3J0IHtcbiAgYWx0S2V5T25seSxcbiAgYWx3YXlzLFxuICBwcmltYXJ5QWN0aW9uLFxuICBzaW5nbGVDbGljayxcbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge1xuICBib3VuZGluZ0V4dGVudCxcbiAgYnVmZmVyIGFzIGJ1ZmZlckV4dGVudCxcbiAgY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZSBhcyBjcmVhdGVFeHRlbnQsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBjbG9zZXN0T25TZWdtZW50LFxuICBkaXN0YW5jZSBhcyBjb29yZGluYXRlRGlzdGFuY2UsXG4gIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLFxuICBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSxcbiAgc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50LFxufSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtmcm9tQ2lyY2xlfSBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IHtcbiAgZnJvbVVzZXJDb29yZGluYXRlLFxuICBmcm9tVXNlckV4dGVudCxcbiAgZ2V0VXNlclByb2plY3Rpb24sXG4gIHRvVXNlckNvb3JkaW5hdGUsXG4gIHRvVXNlckV4dGVudCxcbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogVGhlIHNlZ21lbnQgaW5kZXggYXNzaWduZWQgdG8gYSBjaXJjbGUncyBjZW50ZXIgd2hlblxuICogYnJlYWtpbmcgdXAgYSBjaXJjbGUgaW50byBNb2RpZnlTZWdtZW50RGF0YVR5cGUgc2VnbWVudHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBDSVJDTEVfQ0VOVEVSX0lOREVYID0gMDtcblxuLyoqXG4gKiBUaGUgc2VnbWVudCBpbmRleCBhc3NpZ25lZCB0byBhIGNpcmNsZSdzIGNpcmN1bWZlcmVuY2Ugd2hlblxuICogYnJlYWtpbmcgdXAgYSBjaXJjbGUgaW50byBNb2RpZnlTZWdtZW50RGF0YVR5cGUgc2VnbWVudHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCA9IDE7XG5cbmNvbnN0IHRlbXBFeHRlbnQgPSBbMCwgMCwgMCwgMF07XG5jb25zdCB0ZW1wU2VnbWVudCA9IFtdO1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IE1vZGlmeUV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgbW9kaWZpY2F0aW9uIHN0YXJ0XG4gICAqIEBldmVudCBNb2RpZnlFdmVudCNtb2RpZnlzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBNT0RJRllTVEFSVDogJ21vZGlmeXN0YXJ0JyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgbW9kaWZpY2F0aW9uIGVuZFxuICAgKiBAZXZlbnQgTW9kaWZ5RXZlbnQjbW9kaWZ5ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIE1PRElGWUVORDogJ21vZGlmeWVuZCcsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnREYXRhXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkZXB0aF0gRGVwdGguXG4gKiBAcHJvcGVydHkge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW5kZXhdIEluZGV4LlxuICogQHByb3BlcnR5IHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2VnbWVudCBTZWdtZW50LlxuICogQHByb3BlcnR5IHtBcnJheTxTZWdtZW50RGF0YT59IFtmZWF0dXJlU2VnbWVudHNdIEZlYXR1cmVTZWdtZW50cy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gYWRkIG9yIG1vdmUgYVxuICogdmVydGV4IHRvIHRoZSBza2V0Y2guIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5wcmltYXJ5QWN0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtkZWxldGVDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gQnkgZGVmYXVsdCxcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5zaW5nbGVDbGlja30gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsdEtleU9ubHl9IHJlc3VsdHMgaW4gYSB2ZXJ0ZXggZGVsZXRpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbaW5zZXJ0VmVydGV4Q29uZGl0aW9uXSBBXG4gKiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kXG4gKiByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgbmV3IHZlcnRleCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHNrZXRjaFxuICogZmVhdHVyZXMuIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsd2F5c30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsVG9sZXJhbmNlPTEwXSBQaXhlbCB0b2xlcmFuY2UgZm9yIGNvbnNpZGVyaW5nIHRoZVxuICogcG9pbnRlciBjbG9zZSBlbm91Z2ggdG8gYSBzZWdtZW50IG9yIHZlcnRleCBmb3IgZWRpdGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZX0gW3N0eWxlXVxuICogU3R5bGUgdXNlZCBmb3IgdGhlIG1vZGlmaWNhdGlvbiBwb2ludCBvciB2ZXJ0ZXguIEZvciBsaW5lc3RyaW5ncyBhbmQgcG9seWdvbnMsIHRoaXMgd2lsbFxuICogYmUgdGhlIGFmZmVjdGVkIHZlcnRleCwgZm9yIGNpcmNsZXMgYSBwb2ludCBhbG9uZyB0aGUgY2lyY2xlLCBhbmQgZm9yIHBvaW50cyB0aGUgYWN0dWFsXG4gKiBwb2ludC4gSWYgbm90IGNvbmZpZ3VyZWQsIHRoZSBkZWZhdWx0IGVkaXQgc3R5bGUgaXMgdXNlZCAoc2VlIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGV9KS5cbiAqIFdoZW4gdXNpbmcgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIHBvaW50IGZlYXR1cmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiB3aWxsIGhhdmUgYSBgZmVhdHVyZXNgXG4gKiBwcm9wZXJ0eSAtIGFuIGFycmF5IHdob3NlIGVudHJpZXMgYXJlIHRoZSBmZWF0dXJlcyB0aGF0IGFyZSBiZWluZyBtb2RpZmllZCwgYW5kIGEgYGdlb21ldHJpZXNgXG4gKiBwcm9wZXJ0eSAtIGFuIGFycmF5IHdob3NlIGVudHJpZXMgYXJlIHRoZSBnZW9tZXRyaWVzIHRoYXQgYXJlIGJlaW5nIG1vZGlmaWVkLiBCb3RoIGFycmF5cyBhcmVcbiAqIGluIHRoZSBzYW1lIG9yZGVyLiBUaGUgYGdlb21ldHJpZXNgIGFyZSBvbmx5IHVzZWZ1bCB3aGVuIG1vZGlmeWluZyBnZW9tZXRyeSBjb2xsZWN0aW9ucywgd2hlcmVcbiAqIHRoZSBnZW9tZXRyeSB3aWxsIGJlIHRoZSBwYXJ0aWN1bGFyIGdlb21ldHJ5IGZyb20gdGhlIGNvbGxlY3Rpb24gdGhhdCBpcyBiZWluZyBtb2RpZmllZC5cbiAqIEBwcm9wZXJ0eSB7VmVjdG9yU291cmNlfSBbc291cmNlXSBUaGUgdmVjdG9yIHNvdXJjZSB3aXRoXG4gKiBmZWF0dXJlcyB0byBtb2RpZnkuICBJZiBhIHZlY3RvciBzb3VyY2UgaXMgbm90IHByb3ZpZGVkLCBhIGZlYXR1cmUgY29sbGVjdGlvblxuICogbXVzdCBiZSBwcm92aWRlZCB3aXRoIHRoZSBgZmVhdHVyZXNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxpbXBvcnQoXCIuLi9sYXllci9CYXNlVmVjdG9yXCIpLmRlZmF1bHR9IFtoaXREZXRlY3Rpb25dIFdoZW4gY29uZmlndXJlZCwgcG9pbnRcbiAqIGZlYXR1cmVzIHdpbGwgYmUgY29uc2lkZXJlZCBmb3IgbW9kaWZpY2F0aW9uIGJhc2VkIG9uIHRoZWlyIHZpc3VhbCBhcHBlYXJhbmNlLCBpbnN0ZWFkIG9mIGJlaW5nIHdpdGhpblxuICogdGhlIGBwaXhlbFRvbGVyYW5jZWAgZnJvbSB0aGUgcG9pbnRlciBsb2NhdGlvbi4gV2hlbiBhIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZVZlY3Rvcn5CYXNlVmVjdG9yTGF5ZXJ9IGlzXG4gKiBwcm92aWRlZCwgb25seSB0aGUgcmVuZGVyZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZlYXR1cmVzIG9uIHRoYXQgbGF5ZXIgd2lsbCBiZSBjb25zaWRlcmVkLlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPEZlYXR1cmU+fSBbZmVhdHVyZXNdXG4gKiBUaGUgZmVhdHVyZXMgdGhlIGludGVyYWN0aW9uIHdvcmtzIG9uLiAgSWYgYSBmZWF0dXJlIGNvbGxlY3Rpb24gaXMgbm90XG4gKiBwcm92aWRlZCwgYSB2ZWN0b3Igc291cmNlIG11c3QgYmUgcHJvdmlkZWQgd2l0aCB0aGUgYHNvdXJjZWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseSBvbiB0aGUgc2tldGNoXG4gKiBvdmVybGF5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc25hcFRvUG9pbnRlcj0haGl0RGV0ZWN0aW9uXSBUaGUgdmVydGV4LCBwb2ludCBvciBzZWdtZW50IGJlaW5nIG1vZGlmaWVkIHNuYXBzIHRvIHRoZVxuICogcG9pbnRlciBjb29yZGluYXRlIHdoZW4gY2xpY2tlZCB3aXRoaW4gdGhlIGBwaXhlbFRvbGVyYW5jZWAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5Nb2RpZnl9IGluc3RhbmNlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RpZnlFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kaWZ5RXZlbnRUeXBlfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbjxGZWF0dXJlPn0gZmVhdHVyZXNcbiAgICogVGhlIGZlYXR1cmVzIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnRcbiAgICogQXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgZmVhdHVyZXMsIG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPEZlYXR1cmU+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdtb2RpZnllbmQnfCdtb2RpZnlzdGFydCcsIE1vZGlmeUV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnfCdtb2RpZnllbmQnfCdtb2RpZnlzdGFydCcsIFJldHVybj59IE1vZGlmeU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgbW9kaWZ5aW5nIGZlYXR1cmUgZ2VvbWV0cmllcy4gIFRvIG1vZGlmeSBmZWF0dXJlcyB0aGF0IGhhdmVcbiAqIGJlZW4gYWRkZWQgdG8gYW4gZXhpc3Rpbmcgc291cmNlLCBjb25zdHJ1Y3QgdGhlIG1vZGlmeSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICogYHNvdXJjZWAgb3B0aW9uLiAgSWYgeW91IHdhbnQgdG8gbW9kaWZ5IGZlYXR1cmVzIGluIGEgY29sbGVjdGlvbiAoZm9yIGV4YW1wbGUsXG4gKiB0aGUgY29sbGVjdGlvbiB1c2VkIGJ5IGEgc2VsZWN0IGludGVyYWN0aW9uKSwgY29uc3RydWN0IHRoZSBpbnRlcmFjdGlvbiB3aXRoXG4gKiB0aGUgYGZlYXR1cmVzYCBvcHRpb24uICBUaGUgaW50ZXJhY3Rpb24gbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGVpdGhlciBhXG4gKiBgc291cmNlYCBvciBgZmVhdHVyZXNgIG9wdGlvbi5cbiAqXG4gKiBDYXJ0ZXNpYW4gZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnRlciBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgZmVhdHVyZXMgdGhhdFxuICogd2lsbCBiZSBtb2RpZmllZC4gVGhpcyBtZWFucyB0aGF0IGdlb21ldHJpZXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yXG4gKiBtb2RpZmljYXRpb24gd2hlbiB0aGV5IGFyZSB3aXRoaW4gdGhlIGNvbmZpZ3VyZWQgYHBpeGVsVG9sZXJhbmNlYC4gRm9yIHBvaW50XG4gKiBnZW9tZXRyaWVzLCB0aGUgYGhpdERldGVjdGlvbmAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZWlyIHZpc3VhbFxuICogYXBwZWFyYW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgaW50ZXJhY3Rpb24gd2lsbCBhbGxvdyBkZWxldGlvbiBvZiB2ZXJ0aWNlcyB3aGVuIHRoZSBgYWx0YFxuICoga2V5IGlzIHByZXNzZWQuICBUbyBjb25maWd1cmUgdGhlIGludGVyYWN0aW9uIHdpdGggYSBkaWZmZXJlbnQgY29uZGl0aW9uXG4gKiBmb3IgZGVsZXRpb24sIHVzZSB0aGUgYGRlbGV0ZUNvbmRpdGlvbmAgb3B0aW9uLlxuICogQGZpcmVzIE1vZGlmeUV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIE1vZGlmeSBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucykpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb2RpZnlPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNb2RpZnlPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01vZGlmeU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlRmVhdHVyZUNoYW5nZV8gPSB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogcHJpbWFyeUFjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHREZWxldGVDb25kaXRpb25fID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgICAgcmV0dXJuIGFsdEtleU9ubHkobWFwQnJvd3NlckV2ZW50KSAmJiBzaW5nbGVDbGljayhtYXBCcm93c2VyRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUNvbmRpdGlvbl8gPSBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvblxuICAgICAgOiB0aGlzLmRlZmF1bHREZWxldGVDb25kaXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25fID0gb3B0aW9ucy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25cbiAgICAgID8gb3B0aW9ucy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25cbiAgICAgIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogRWRpdGluZyB2ZXJ0ZXguXG4gICAgICogQHR5cGUge0ZlYXR1cmU8UG9pbnQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50cyBpbnRlcnNlY3Rpbmcge0BsaW5rIHRoaXMudmVydGV4RmVhdHVyZV99IGJ5IHNlZ21lbnQgdWlkLlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U2VnbWVudHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBpeGVsXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyBpZiB0aGUgbmV4dCBgc2luZ2xlY2xpY2tgIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIHRvIHByZXZlbnRcbiAgICAgKiBhY2NpZGVudGFsIGRlbGV0aW9uIHJpZ2h0IGFmdGVyIHZlcnRleCBjcmVhdGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248RmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCBSVHJlZSBmb3IgZWFjaCBsYXllclxuICAgICAqIEB0eXBlIHtSQnVzaDxTZWdtZW50RGF0YT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJCdXNoXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID1cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoZSBpbnRlcmFjdGlvbiBpcyBjdXJyZW50bHkgY2hhbmdpbmcgYSBmZWF0dXJlJ3NcbiAgICAgKiBjb29yZGluYXRlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnU2VnbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IG92ZXJsYXkgd2hlcmUgc2tldGNoIGZlYXR1cmVzIGFyZSBkcmF3bi5cbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiAhIW9wdGlvbnMud3JhcFgsXG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlID8gb3B0aW9ucy5zdHlsZSA6IGdldERlZmF1bHRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRmVhdHVyZSwgaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0KTogdm9pZD59XG4gICAgICovXG4gICAgdGhpcy5TRUdNRU5UX1dSSVRFUlNfID0ge1xuICAgICAgJ1BvaW50JzogdGhpcy53cml0ZVBvaW50R2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnTGluZVN0cmluZyc6IHRoaXMud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnTGluZWFyUmluZyc6IHRoaXMud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnUG9seWdvbic6IHRoaXMud3JpdGVQb2x5Z29uR2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnTXVsdGlQb2ludCc6IHRoaXMud3JpdGVNdWx0aVBvaW50R2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnTXVsdGlMaW5lU3RyaW5nJzogdGhpcy53cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ011bHRpUG9seWdvbic6IHRoaXMud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8uYmluZCh0aGlzKSxcbiAgICAgICdDaXJjbGUnOiB0aGlzLndyaXRlQ2lyY2xlR2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogdGhpcy53cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VmVjdG9yU291cmNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufGltcG9ydChcIi4uL2xheWVyL0Jhc2VWZWN0b3JcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbl8gPSBudWxsO1xuXG4gICAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPEZlYXR1cmU+fSAqL1xuICAgIGxldCBmZWF0dXJlcztcbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlXyA9IG9wdGlvbnMuc291cmNlO1xuICAgICAgZmVhdHVyZXMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLnNvdXJjZV8uZ2V0RmVhdHVyZXMoKSk7XG4gICAgICB0aGlzLnNvdXJjZV8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsXG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlQWRkXy5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgICAgdGhpcy5zb3VyY2VfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZVJlbW92ZV8uYmluZCh0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFmZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIG1vZGlmeSBpbnRlcmFjdGlvbiByZXF1aXJlcyBmZWF0dXJlcywgYSBzb3VyY2Ugb3IgYSBsYXllcidcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhpdERldGVjdGlvbikge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25fID0gb3B0aW9ucy5oaXREZXRlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248RmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IGZlYXR1cmVzO1xuXG4gICAgdGhpcy5mZWF0dXJlc18uZm9yRWFjaCh0aGlzLmFkZEZlYXR1cmVfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZmVhdHVyZXNfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUFkZF8uYmluZCh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5mZWF0dXJlc18uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXy5iaW5kKHRoaXMpXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBvaW50ZXJFdmVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGVsdGEgKHgsIHkgaW4gbWFwIHVuaXRzKSBiZXR3ZWVuIG1hdGNoZWQgcnRyZWUgdmVydGV4IGFuZCBwb2ludGVyIHZlcnRleC5cbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwVG9Qb2ludGVyXyA9XG4gICAgICBvcHRpb25zLnNuYXBUb1BvaW50ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICF0aGlzLmhpdERldGVjdGlvbl9cbiAgICAgICAgOiBvcHRpb25zLnNuYXBUb1BvaW50ZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRGZWF0dXJlXyhmZWF0dXJlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBjb25zdCB3cml0ZXIgPSB0aGlzLlNFR01FTlRfV1JJVEVSU19bZ2VvbWV0cnkuZ2V0VHlwZSgpXTtcbiAgICAgIGlmICh3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyKGZlYXR1cmUsIGdlb21ldHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwICYmIG1hcC5pc1JlbmRlcmVkKCkgJiYgdGhpcy5nZXRBY3RpdmUoKSkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyQXRQaXhlbF8odGhpcy5sYXN0UGl4ZWxfLCBtYXApO1xuICAgIH1cbiAgICBmZWF0dXJlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5ib3VuZEhhbmRsZUZlYXR1cmVDaGFuZ2VfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8U2VnbWVudERhdGE+Pn0gc2VnbWVudHMgVGhlIHNlZ21lbnRzIHN1YmplY3QgdG8gbW9kaWZpY2F0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd2lsbE1vZGlmeUZlYXR1cmVzXyhldnQsIHNlZ21lbnRzKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNCZWluZ01vZGlmaWVkXyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNCZWluZ01vZGlmaWVkXy5nZXRBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgIGZvciAobGV0IHMgPSAwLCBzcyA9IHNlZ21lbnQubGVuZ3RoOyBzIDwgc3M7ICsrcykge1xuICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSBzZWdtZW50W3NdLmZlYXR1cmU7XG4gICAgICAgICAgaWYgKGZlYXR1cmUgJiYgIWZlYXR1cmVzLmluY2x1ZGVzKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8ucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8uZ2V0TGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc0JlaW5nTW9kaWZpZWRfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgTW9kaWZ5RXZlbnQoXG4gICAgICAgICAgICBNb2RpZnlFdmVudFR5cGUuTU9ESUZZU1RBUlQsXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8sXG4gICAgICAgICAgICBldnRcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZV8oZmVhdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyhmZWF0dXJlKTtcbiAgICAvLyBSZW1vdmUgdGhlIHZlcnRleCBmZWF0dXJlIGlmIHRoZSBjb2xsZWN0aW9uIG9mIGNhbmRpZGF0ZSBmZWF0dXJlcyBpcyBlbXB0eS5cbiAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXyAmJiB0aGlzLmZlYXR1cmVzXy5nZXRMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKS5yZW1vdmVGZWF0dXJlKHRoaXMudmVydGV4RmVhdHVyZV8pO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgfVxuICAgIGZlYXR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICB0aGlzLmJvdW5kSGFuZGxlRmVhdHVyZUNoYW5nZV9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyhmZWF0dXJlKSB7XG4gICAgY29uc3QgckJ1c2ggPSB0aGlzLnJCdXNoXztcbiAgICAvKiogQHR5cGUge0FycmF5PFNlZ21lbnREYXRhPn0gKi9cbiAgICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgckJ1c2guZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtTZWdtZW50RGF0YX0gbm9kZSBSVHJlZSBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSA9PT0gbm9kZS5mZWF0dXJlKSB7XG4gICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gbm9kZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgbm9kZVRvUmVtb3ZlID0gbm9kZXNUb1JlbW92ZVtpXTtcbiAgICAgIGZvciAobGV0IGogPSB0aGlzLmRyYWdTZWdtZW50c18ubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1NlZ21lbnRzX1tqXVswXSA9PT0gbm9kZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgdGhpcy5kcmFnU2VnbWVudHNfLnNwbGljZShqLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgckJ1c2gucmVtb3ZlKG5vZGVUb1JlbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXyAmJiAhYWN0aXZlKSB7XG4gICAgICB0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIHRoaXMub3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgc3VwZXIuc2V0TWFwKG1hcCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdmVybGF5IGxheWVyIHRoYXQgdGhpcyBpbnRlcmFjdGlvbiByZW5kZXJzIHRoZSBtb2RpZmljYXRpb24gcG9pbnQgb3IgdmVydGV4IHRvLlxuICAgKiBAcmV0dXJuIHtWZWN0b3JMYXllcn0gT3ZlcmxheSBsYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3ZlcmxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU291cmNlQWRkXyhldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5wdXNoKGV2ZW50LmZlYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU291cmNlUmVtb3ZlXyhldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5yZW1vdmUoZXZlbnQuZmVhdHVyZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8RmVhdHVyZT59IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVBZGRfKGV2dCkge1xuICAgIHRoaXMuYWRkRmVhdHVyZV8oZXZ0LmVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVDaGFuZ2VfKGV2dCkge1xuICAgIGlmICghdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfKSB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gLyoqIEB0eXBlIHtGZWF0dXJlfSAqLyAoZXZ0LnRhcmdldCk7XG4gICAgICB0aGlzLnJlbW92ZUZlYXR1cmVfKGZlYXR1cmUpO1xuICAgICAgdGhpcy5hZGRGZWF0dXJlXyhmZWF0dXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxGZWF0dXJlPn0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRmVhdHVyZVJlbW92ZV8oZXZ0KSB7XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlXyhldnQuZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtQb2ludH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZVBvaW50R2VvbWV0cnlfKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuXG4gICAgLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi9cbiAgICBjb25zdCBzZWdtZW50RGF0YSA9IHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXSxcbiAgICB9O1xuXG4gICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGdlb21ldHJ5LmdldEV4dGVudCgpLCBzZWdtZW50RGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8oZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBwb2ludHMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHBvaW50c1tpXTtcblxuICAgICAgLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi9cbiAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0ge1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIGRlcHRoOiBbaV0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyhmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcblxuICAgICAgLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi9cbiAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0ge1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzZWdtZW50OiBzZWdtZW50LFxuICAgICAgfTtcblxuICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyhmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IGxpbmVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamogPSBsaW5lcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IGxpbmVzW2pdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcblxuICAgICAgICAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqL1xuICAgICAgICBjb25zdCBzZWdtZW50RGF0YSA9IHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICBkZXB0aDogW2pdLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnQsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVQb2x5Z29uR2VvbWV0cnlfKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgY29uc3QgcmluZ3MgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovXG4gICAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0ge1xuICAgICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgIGRlcHRoOiBbal0sXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9seWdvbnMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrayA9IHBvbHlnb25zLmxlbmd0aDsgayA8IGtrOyArK2spIHtcbiAgICAgIGNvbnN0IHJpbmdzID0gcG9seWdvbnNba107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSByaW5ncy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcblxuICAgICAgICAgIC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovXG4gICAgICAgICAgY29uc3Qgc2VnbWVudERhdGEgPSB7XG4gICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgICAgZGVwdGg6IFtqLCBrXSxcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2UgY29udmVydCBhIGNpcmNsZSBpbnRvIHR3byBzZWdtZW50cy4gIFRoZSBzZWdtZW50IGF0IGluZGV4XG4gICAqIHtAbGluayBDSVJDTEVfQ0VOVEVSX0lOREVYfSBpcyB0aGVcbiAgICogY2lyY2xlJ3MgY2VudGVyIChhIHBvaW50KS4gIFRoZSBzZWdtZW50IGF0IGluZGV4XG4gICAqIHtAbGluayBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWH0gaXNcbiAgICogdGhlIGNpcmN1bWZlcmVuY2UsIGFuZCBpcyBub3QgYSBsaW5lIHNlZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd3JpdGVDaXJjbGVHZW9tZXRyeV8oZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENlbnRlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi9cbiAgICBjb25zdCBjZW50ZXJTZWdtZW50RGF0YSA9IHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBpbmRleDogQ0lSQ0xFX0NFTlRFUl9JTkRFWCxcbiAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdLFxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqL1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YSA9IHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBpbmRleDogQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgsXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXSxcbiAgICB9O1xuXG4gICAgY29uc3QgZmVhdHVyZVNlZ21lbnRzID0gW2NlbnRlclNlZ21lbnREYXRhLCBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGFdO1xuICAgIGNlbnRlclNlZ21lbnREYXRhLmZlYXR1cmVTZWdtZW50cyA9IGZlYXR1cmVTZWdtZW50cztcbiAgICBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzID0gZmVhdHVyZVNlZ21lbnRzO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChjcmVhdGVFeHRlbnQoY29vcmRpbmF0ZXMpLCBjZW50ZXJTZWdtZW50RGF0YSk7XG4gICAgbGV0IGNpcmNsZUdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgIGdlb21ldHJ5XG4gICAgKTtcbiAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHVzZXJQcm9qZWN0aW9uICYmIHRoaXMuZ2V0TWFwKCkpIHtcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLmdldE1hcCgpLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICBjaXJjbGVHZW9tZXRyeSA9IGNpcmNsZUdlb21ldHJ5XG4gICAgICAgIC5jbG9uZSgpXG4gICAgICAgIC50cmFuc2Zvcm0odXNlclByb2plY3Rpb24sIHByb2plY3Rpb24pO1xuICAgICAgY2lyY2xlR2VvbWV0cnkgPSBmcm9tQ2lyY2xlKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChjaXJjbGVHZW9tZXRyeSlcbiAgICAgICkudHJhbnNmb3JtKHByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGNpcmNsZUdlb21ldHJ5LmdldEV4dGVudCgpLCBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyhmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHRoaXMuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgICAgd3JpdGVyKGZlYXR1cmUsIGdlb21ldHJ5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0FycmF5PEZlYXR1cmU+fSBmZWF0dXJlcyBUaGUgZmVhdHVyZXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0Pn0gZ2VvbWV0cmllcyBUaGUgZ2VvbWV0cmllcyBiZWluZyBtb2RpZmllZC5cbiAgICogQHJldHVybiB7RmVhdHVyZX0gVmVydGV4IGZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfKGNvb3JkaW5hdGVzLCBmZWF0dXJlcywgZ2VvbWV0cmllcykge1xuICAgIGxldCB2ZXJ0ZXhGZWF0dXJlID0gdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgICBpZiAoIXZlcnRleEZlYXR1cmUpIHtcbiAgICAgIHZlcnRleEZlYXR1cmUgPSBuZXcgRmVhdHVyZShuZXcgUG9pbnQoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSB2ZXJ0ZXhGZWF0dXJlO1xuICAgICAgdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlKHZlcnRleEZlYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IHZlcnRleEZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgdmVydGV4RmVhdHVyZS5zZXQoJ2ZlYXR1cmVzJywgZmVhdHVyZXMpO1xuICAgIHZlcnRleEZlYXR1cmUuc2V0KCdnZW9tZXRyaWVzJywgZ2VvbWV0cmllcyk7XG4gICAgcmV0dXJuIHZlcnRleEZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IG1vZGlmeSB0aGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMubGFzdFBvaW50ZXJFdmVudF8gPSBtYXBCcm93c2VyRXZlbnQ7XG5cbiAgICBsZXQgaGFuZGxlZDtcbiAgICBpZiAoXG4gICAgICAhbWFwQnJvd3NlckV2ZW50Lm1hcC5nZXRWaWV3KCkuZ2V0SW50ZXJhY3RpbmcoKSAmJlxuICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSAmJlxuICAgICAgIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZVxuICAgICkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8obWFwQnJvd3NlckV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8gJiYgdGhpcy5kZWxldGVDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgIT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSyB8fFxuICAgICAgICAhdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfXG4gICAgICApIHtcbiAgICAgICAgaGFuZGxlZCA9IHRoaXMucmVtb3ZlUG9pbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLKSB7XG4gICAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSAmJiAhaGFuZGxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KGV2dCkge1xuICAgIHRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXyA9IGZhbHNlO1xuICAgIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQsIHRoaXMuZHJhZ1NlZ21lbnRzXyk7XG5cbiAgICBjb25zdCB2ZXJ0ZXggPSBbXG4gICAgICBldnQuY29vcmRpbmF0ZVswXSArIHRoaXMuZGVsdGFfWzBdLFxuICAgICAgZXZ0LmNvb3JkaW5hdGVbMV0gKyB0aGlzLmRlbHRhX1sxXSxcbiAgICBdO1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuZHJhZ1NlZ21lbnRzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBkcmFnU2VnbWVudCA9IHRoaXMuZHJhZ1NlZ21lbnRzX1tpXTtcbiAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0gZHJhZ1NlZ21lbnRbMF07XG4gICAgICBjb25zdCBmZWF0dXJlID0gc2VnbWVudERhdGEuZmVhdHVyZTtcbiAgICAgIGlmICghZmVhdHVyZXMuaW5jbHVkZXMoZmVhdHVyZSkpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgICBpZiAoIWdlb21ldHJpZXMuaW5jbHVkZXMoZ2VvbWV0cnkpKSB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaChnZW9tZXRyeSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXB0aCA9IHNlZ21lbnREYXRhLmRlcHRoO1xuICAgICAgbGV0IGNvb3JkaW5hdGVzO1xuICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgICBjb25zdCBpbmRleCA9IGRyYWdTZWdtZW50WzFdO1xuXG4gICAgICB3aGlsZSAodmVydGV4Lmxlbmd0aCA8IGdlb21ldHJ5LmdldFN0cmlkZSgpKSB7XG4gICAgICAgIHZlcnRleC5wdXNoKHNlZ21lbnRbaW5kZXhdW3ZlcnRleC5sZW5ndGhdKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbMF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFsxXSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgIGNvb3JkaW5hdGVzW3NlZ21lbnREYXRhLmluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50WzBdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbMV0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tkZXB0aFsxXV1bZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDaXJjbGUnOlxuICAgICAgICAgIHNlZ21lbnRbMF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFsxXSA9IHZlcnRleDtcbiAgICAgICAgICBpZiAoc2VnbWVudERhdGEuaW5kZXggPT09IENJUkNMRV9DRU5URVJfSU5ERVgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IHRydWU7XG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRDZW50ZXIodmVydGV4KTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBkcmFnZ2luZyB0aGUgY2lyY2xlJ3MgY2lyY3VtZmVyZW5jZTpcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gZXZ0Lm1hcC5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IGNvb3JkaW5hdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgZnJvbVVzZXJDb29yZGluYXRlKGdlb21ldHJ5LmdldENlbnRlcigpLCBwcm9qZWN0aW9uKSxcbiAgICAgICAgICAgICAgZnJvbVVzZXJDb29yZGluYXRlKHZlcnRleCwgcHJvamVjdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAodXNlclByb2plY3Rpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgY2lyY2xlR2VvbWV0cnkgPSBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIC5jbG9uZSgpXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgcHJvamVjdGlvbik7XG4gICAgICAgICAgICAgIGNpcmNsZUdlb21ldHJ5LnNldFJhZGl1cyhyYWRpdXMpO1xuICAgICAgICAgICAgICByYWRpdXMgPSBjaXJjbGVHZW9tZXRyeVxuICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0ocHJvamVjdGlvbiwgdXNlclByb2plY3Rpb24pXG4gICAgICAgICAgICAgICAgLmdldFJhZGl1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHBhc3NcbiAgICAgIH1cblxuICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuc2V0R2VvbWV0cnlDb29yZGluYXRlc18oZ2VvbWV0cnksIGNvb3JkaW5hdGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfKHZlcnRleCwgZmVhdHVyZXMsIGdlb21ldHJpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmNvbmRpdGlvbl8oZXZ0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbENvb3JkaW5hdGUgPSBldnQuY29vcmRpbmF0ZTtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJBdFBpeGVsXyhldnQucGl4ZWwsIGV2dC5tYXAsIHBpeGVsQ29vcmRpbmF0ZSk7XG4gICAgdGhpcy5kcmFnU2VnbWVudHNfLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5mZWF0dXJlc0JlaW5nTW9kaWZpZWRfID0gbnVsbDtcbiAgICBjb25zdCB2ZXJ0ZXhGZWF0dXJlID0gdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgICBpZiAodmVydGV4RmVhdHVyZSkge1xuICAgICAgY29uc3QgcHJvamVjdGlvbiA9IGV2dC5tYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICAgIGNvbnN0IGluc2VydFZlcnRpY2VzID0gW107XG4gICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0ZXhGZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGNvbnN0IHZlcnRleEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFt2ZXJ0ZXhdKTtcbiAgICAgIGNvbnN0IHNlZ21lbnREYXRhTWF0Y2hlcyA9IHRoaXMuckJ1c2hfLmdldEluRXh0ZW50KHZlcnRleEV4dGVudCk7XG4gICAgICBjb25zdCBjb21wb25lbnRTZWdtZW50cyA9IHt9O1xuICAgICAgc2VnbWVudERhdGFNYXRjaGVzLnNvcnQoY29tcGFyZUluZGV4ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VnbWVudERhdGFNYXRjaGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudERhdGFNYXRjaCA9IHNlZ21lbnREYXRhTWF0Y2hlc1tpXTtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnREYXRhTWF0Y2guc2VnbWVudDtcbiAgICAgICAgbGV0IHVpZCA9IGdldFVpZChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5KTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBzZWdtZW50RGF0YU1hdGNoLmRlcHRoO1xuICAgICAgICBpZiAoZGVwdGgpIHtcbiAgICAgICAgICB1aWQgKz0gJy0nICsgZGVwdGguam9pbignLScpOyAvLyBzZXBhcmF0ZSBmZWF0dXJlIGNvbXBvbmVudHNcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudFNlZ21lbnRzW3VpZF0pIHtcbiAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdID0gbmV3IEFycmF5KDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSAnQ2lyY2xlJyAmJlxuICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guaW5kZXggPT09IENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGNsb3Nlc3RWZXJ0ZXggPSBjbG9zZXN0T25TZWdtZW50RGF0YShcbiAgICAgICAgICAgIHBpeGVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2gsXG4gICAgICAgICAgICBwcm9qZWN0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RWZXJ0ZXgsIHZlcnRleCkgJiZcbiAgICAgICAgICAgICFjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTZWdtZW50c18ucHVzaChbc2VnbWVudERhdGFNYXRjaCwgMF0pO1xuICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSA9IHNlZ21lbnREYXRhTWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvb3JkaW5hdGVzRXF1YWwoc2VnbWVudFswXSwgdmVydGV4KSAmJlxuICAgICAgICAgICFjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCAwXSk7XG4gICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSA9IHNlZ21lbnREYXRhTWF0Y2g7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgY29vcmRpbmF0ZXNFcXVhbChzZWdtZW50WzFdLCB2ZXJ0ZXgpICYmXG4gICAgICAgICAgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSAmJlxuICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXS5pbmRleCA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGVzID0gc2VnbWVudERhdGFNYXRjaC5nZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgc3dpdGNoIChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5LmdldFR5cGUoKSkge1xuICAgICAgICAgICAgICAvLyBwcmV2ZW50IGRyYWdnaW5nIGNsb3NlZCBsaW5lc3RyaW5ncyBieSB0aGUgY29ubmVjdGluZyBub2RlXG4gICAgICAgICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAvLyBpZiBkcmFnZ2luZyB0aGUgZmlyc3QgdmVydGV4IG9mIGEgcG9seWdvbiwgZW5zdXJlIHRoZSBvdGhlciBzZWdtZW50XG4gICAgICAgICAgICAgIC8vIGJlbG9uZ3MgdG8gdGhlIGNsb3NpbmcgdmVydGV4IG9mIHRoZSBsaW5lYXIgcmluZ1xuICAgICAgICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXNbZGVwdGhbMV1dO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guaW5kZXggIT09XG4gICAgICAgICAgICAgICAgICBjb29yZGluYXRlc1tkZXB0aFswXV0ubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmFnU2VnbWVudHNfLnB1c2goW3NlZ21lbnREYXRhTWF0Y2gsIDFdKTtcbiAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzFdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBnZXRVaWQoc2VnbWVudCkgaW4gdGhpcy52ZXJ0ZXhTZWdtZW50c18gJiZcbiAgICAgICAgICAhY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSAmJlxuICAgICAgICAgICFjb21wb25lbnRTZWdtZW50c1t1aWRdWzFdICYmXG4gICAgICAgICAgdGhpcy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25fKGV2dClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW5zZXJ0VmVydGljZXMucHVzaChzZWdtZW50RGF0YU1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5zZXJ0VmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQsIFtpbnNlcnRWZXJ0aWNlc10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBqID0gaW5zZXJ0VmVydGljZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgdGhpcy5pbnNlcnRWZXJ0ZXhfKGluc2VydFZlcnRpY2VzW2pdLCB2ZXJ0ZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLnZlcnRleEZlYXR1cmVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChldnQpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5kcmFnU2VnbWVudHNfLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzZWdtZW50RGF0YSA9IHRoaXMuZHJhZ1NlZ21lbnRzX1tpXVswXTtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSAnQ2lyY2xlJykge1xuICAgICAgICAvLyBVcGRhdGUgYSBjaXJjbGUgb2JqZWN0IGluIHRoZSBSKiBidXNoOlxuICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENlbnRlcigpO1xuICAgICAgICBjb25zdCBjZW50ZXJTZWdtZW50RGF0YSA9IHNlZ21lbnREYXRhLmZlYXR1cmVTZWdtZW50c1swXTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhID0gc2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzWzFdO1xuICAgICAgICBjZW50ZXJTZWdtZW50RGF0YS5zZWdtZW50WzBdID0gY29vcmRpbmF0ZXM7XG4gICAgICAgIGNlbnRlclNlZ21lbnREYXRhLnNlZ21lbnRbMV0gPSBjb29yZGluYXRlcztcbiAgICAgICAgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhLnNlZ21lbnRbMF0gPSBjb29yZGluYXRlcztcbiAgICAgICAgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhLnNlZ21lbnRbMV0gPSBjb29yZGluYXRlcztcbiAgICAgICAgdGhpcy5yQnVzaF8udXBkYXRlKGNyZWF0ZUV4dGVudChjb29yZGluYXRlcyksIGNlbnRlclNlZ21lbnREYXRhKTtcbiAgICAgICAgbGV0IGNpcmNsZUdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IGV2dC5tYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICBjaXJjbGVHZW9tZXRyeSA9IGNpcmNsZUdlb21ldHJ5XG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgcHJvamVjdGlvbik7XG4gICAgICAgICAgY2lyY2xlR2VvbWV0cnkgPSBmcm9tQ2lyY2xlKGNpcmNsZUdlb21ldHJ5KS50cmFuc2Zvcm0oXG4gICAgICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgICAgICAgdXNlclByb2plY3Rpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuckJ1c2hfLnVwZGF0ZShcbiAgICAgICAgICBjaXJjbGVHZW9tZXRyeS5nZXRFeHRlbnQoKSxcbiAgICAgICAgICBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGFcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuckJ1c2hfLnVwZGF0ZShib3VuZGluZ0V4dGVudChzZWdtZW50RGF0YS5zZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0JlaW5nTW9kaWZpZWRfKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBNb2RpZnlFdmVudChcbiAgICAgICAgICBNb2RpZnlFdmVudFR5cGUuTU9ESUZZRU5ELFxuICAgICAgICAgIHRoaXMuZmVhdHVyZXNCZWluZ01vZGlmaWVkXyxcbiAgICAgICAgICBldnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZmVhdHVyZXNCZWluZ01vZGlmaWVkXyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyTW92ZV8oZXZ0KSB7XG4gICAgdGhpcy5sYXN0UGl4ZWxfID0gZXZ0LnBpeGVsO1xuICAgIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKGV2dC5waXhlbCwgZXZ0Lm1hcCwgZXZ0LmNvb3JkaW5hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbY29vcmRpbmF0ZV0gVGhlIHBpeGVsIENvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyQXRQaXhlbF8ocGl4ZWwsIG1hcCwgY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IHBpeGVsQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgfHwgbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSBtYXAuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKTtcbiAgICBjb25zdCBzb3J0QnlEaXN0YW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwcm9qZWN0ZWREaXN0YW5jZVRvU2VnbWVudERhdGFTcXVhcmVkKHBpeGVsQ29vcmRpbmF0ZSwgYSwgcHJvamVjdGlvbikgLVxuICAgICAgICBwcm9qZWN0ZWREaXN0YW5jZVRvU2VnbWVudERhdGFTcXVhcmVkKHBpeGVsQ29vcmRpbmF0ZSwgYiwgcHJvamVjdGlvbilcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8U2VnbWVudERhdGE+fHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgbm9kZXM7XG4gICAgLyoqIEB0eXBlIHtQb2ludHx1bmRlZmluZWR9ICovXG4gICAgbGV0IGhpdFBvaW50R2VvbWV0cnk7XG4gICAgaWYgKHRoaXMuaGl0RGV0ZWN0aW9uXykge1xuICAgICAgY29uc3QgbGF5ZXJGaWx0ZXIgPVxuICAgICAgICB0eXBlb2YgdGhpcy5oaXREZXRlY3Rpb25fID09PSAnb2JqZWN0J1xuICAgICAgICAgID8gKGxheWVyKSA9PiBsYXllciA9PT0gdGhpcy5oaXREZXRlY3Rpb25fXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBtYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKFxuICAgICAgICBwaXhlbCxcbiAgICAgICAgKGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSkgPT4ge1xuICAgICAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgIHRvVXNlckNvb3JkaW5hdGUoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKSwgcHJvamVjdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGdlb20gPSBnZW9tZXRyeSB8fCBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ2VvbS5nZXRUeXBlKCkgPT09ICdQb2ludCcgJiZcbiAgICAgICAgICAgIGZlYXR1cmUgaW5zdGFuY2VvZiBGZWF0dXJlICYmXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzXy5nZXRBcnJheSgpLmluY2x1ZGVzKGZlYXR1cmUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBoaXRQb2ludEdlb21ldHJ5ID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKGdlb20pO1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IC8qKiBAdHlwZSB7UG9pbnR9ICovIChmZWF0dXJlLmdldEdlb21ldHJ5KCkpXG4gICAgICAgICAgICAgIC5nZXRGbGF0Q29vcmRpbmF0ZXMoKVxuICAgICAgICAgICAgICAuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGhpdFBvaW50R2VvbWV0cnksXG4gICAgICAgICAgICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGUsIGNvb3JkaW5hdGVdLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHtsYXllckZpbHRlcn1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghbm9kZXMpIHtcbiAgICAgIGNvbnN0IHZpZXdFeHRlbnQgPSBmcm9tVXNlckV4dGVudChcbiAgICAgICAgY3JlYXRlRXh0ZW50KHBpeGVsQ29vcmRpbmF0ZSwgdGVtcEV4dGVudCksXG4gICAgICAgIHByb2plY3Rpb25cbiAgICAgICk7XG4gICAgICBjb25zdCBidWZmZXIgPSBtYXAuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSAqIHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgICAgY29uc3QgYm94ID0gdG9Vc2VyRXh0ZW50KFxuICAgICAgICBidWZmZXJFeHRlbnQodmlld0V4dGVudCwgYnVmZmVyLCB0ZW1wRXh0ZW50KSxcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICAgIG5vZGVzID0gdGhpcy5yQnVzaF8uZ2V0SW5FeHRlbnQoYm94KTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzLnNvcnQoc29ydEJ5RGlzdGFuY2UpWzBdO1xuICAgICAgY29uc3QgY2xvc2VzdFNlZ21lbnQgPSBub2RlLnNlZ21lbnQ7XG4gICAgICBsZXQgdmVydGV4ID0gY2xvc2VzdE9uU2VnbWVudERhdGEocGl4ZWxDb29yZGluYXRlLCBub2RlLCBwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcbiAgICAgIGxldCBkaXN0ID0gY29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCB2ZXJ0ZXhQaXhlbCk7XG4gICAgICBpZiAoaGl0UG9pbnRHZW9tZXRyeSB8fCBkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59ICovXG4gICAgICAgIGNvbnN0IHZlcnRleFNlZ21lbnRzID0ge307XG4gICAgICAgIHZlcnRleFNlZ21lbnRzW2dldFVpZChjbG9zZXN0U2VnbWVudCldID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuc25hcFRvUG9pbnRlcl8pIHtcbiAgICAgICAgICB0aGlzLmRlbHRhX1swXSA9IHZlcnRleFswXSAtIHBpeGVsQ29vcmRpbmF0ZVswXTtcbiAgICAgICAgICB0aGlzLmRlbHRhX1sxXSA9IHZlcnRleFsxXSAtIHBpeGVsQ29vcmRpbmF0ZVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbm9kZS5nZW9tZXRyeS5nZXRUeXBlKCkgPT09ICdDaXJjbGUnICYmXG4gICAgICAgICAgbm9kZS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVhcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8oXG4gICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICBbbm9kZS5mZWF0dXJlXSxcbiAgICAgICAgICAgIFtub2RlLmdlb21ldHJ5XVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGl4ZWwxID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICAgIGNvbnN0IHBpeGVsMiA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzFdKTtcbiAgICAgICAgICBjb25zdCBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDEpO1xuICAgICAgICAgIGNvbnN0IHNxdWFyZWREaXN0MiA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMik7XG4gICAgICAgICAgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihzcXVhcmVkRGlzdDEsIHNxdWFyZWREaXN0MikpO1xuICAgICAgICAgIHRoaXMuc25hcHBlZFRvVmVydGV4XyA9IGRpc3QgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV87XG4gICAgICAgICAgaWYgKHRoaXMuc25hcHBlZFRvVmVydGV4Xykge1xuICAgICAgICAgICAgdmVydGV4ID1cbiAgICAgICAgICAgICAgc3F1YXJlZERpc3QxID4gc3F1YXJlZERpc3QyXG4gICAgICAgICAgICAgICAgPyBjbG9zZXN0U2VnbWVudFsxXVxuICAgICAgICAgICAgICAgIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyhcbiAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgIFtub2RlLmZlYXR1cmVdLFxuICAgICAgICAgICAgW25vZGUuZ2VvbWV0cnldXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBnZW9tZXRyaWVzID0ge307XG4gICAgICAgICAgZ2VvbWV0cmllc1tnZXRVaWQobm9kZS5nZW9tZXRyeSldID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMSwgaWkgPSBub2Rlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gbm9kZXNbaV0uc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMF0sIHNlZ21lbnRbMF0pICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXNFcXVhbChjbG9zZXN0U2VnbWVudFsxXSwgc2VnbWVudFsxXSkpIHx8XG4gICAgICAgICAgICAgIChjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RTZWdtZW50WzBdLCBzZWdtZW50WzFdKSAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMV0sIHNlZ21lbnRbMF0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5VWlkID0gZ2V0VWlkKG5vZGVzW2ldLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgaWYgKCEoZ2VvbWV0cnlVaWQgaW4gZ2VvbWV0cmllcykpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyaWVzW2dlb21ldHJ5VWlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmVydGV4U2VnbWVudHNbZ2V0VWlkKHNlZ21lbnQpXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4U2VnbWVudHNfID0gdmVydGV4U2VnbWVudHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8pIHtcbiAgICAgIHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkucmVtb3ZlRmVhdHVyZSh0aGlzLnZlcnRleEZlYXR1cmVfKTtcbiAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBzZWdtZW50RGF0YSBTZWdtZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB2ZXJ0ZXggVmVydGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5zZXJ0VmVydGV4XyhzZWdtZW50RGF0YSwgdmVydGV4KSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgY29uc3QgZmVhdHVyZSA9IHNlZ21lbnREYXRhLmZlYXR1cmU7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcbiAgICBjb25zdCBkZXB0aCA9IHNlZ21lbnREYXRhLmRlcHRoO1xuICAgIGNvbnN0IGluZGV4ID0gc2VnbWVudERhdGEuaW5kZXg7XG4gICAgbGV0IGNvb3JkaW5hdGVzO1xuXG4gICAgd2hpbGUgKHZlcnRleC5sZW5ndGggPCBnZW9tZXRyeS5nZXRTdHJpZGUoKSkge1xuICAgICAgdmVydGV4LnB1c2goMCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tkZXB0aFsxXV1bZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgdmVydGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyhnZW9tZXRyeSwgY29vcmRpbmF0ZXMpO1xuICAgIGNvbnN0IHJUcmVlID0gdGhpcy5yQnVzaF87XG4gICAgclRyZWUucmVtb3ZlKHNlZ21lbnREYXRhKTtcbiAgICB0aGlzLnVwZGF0ZVNlZ21lbnRJbmRpY2VzXyhnZW9tZXRyeSwgaW5kZXgsIGRlcHRoLCAxKTtcblxuICAgIC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovXG4gICAgY29uc3QgbmV3U2VnbWVudERhdGEgPSB7XG4gICAgICBzZWdtZW50OiBbc2VnbWVudFswXSwgdmVydGV4XSxcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBkZXB0aDogZGVwdGgsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgfTtcblxuICAgIHJUcmVlLmluc2VydChib3VuZGluZ0V4dGVudChuZXdTZWdtZW50RGF0YS5zZWdtZW50KSwgbmV3U2VnbWVudERhdGEpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YSwgMV0pO1xuXG4gICAgLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi9cbiAgICBjb25zdCBuZXdTZWdtZW50RGF0YTIgPSB7XG4gICAgICBzZWdtZW50OiBbdmVydGV4LCBzZWdtZW50WzFdXSxcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBkZXB0aDogZGVwdGgsXG4gICAgICBpbmRleDogaW5kZXggKyAxLFxuICAgIH07XG5cbiAgICByVHJlZS5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEyLnNlZ21lbnQpLCBuZXdTZWdtZW50RGF0YTIpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YTIsIDBdKTtcbiAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHZlcnRleCBjdXJyZW50bHkgYmVpbmcgcG9pbnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGEgdmVydGV4IHdhcyByZW1vdmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVQb2ludCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmxhc3RQb2ludGVyRXZlbnRfICYmXG4gICAgICB0aGlzLmxhc3RQb2ludGVyRXZlbnRfLnR5cGUgIT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBR1xuICAgICkge1xuICAgICAgY29uc3QgZXZ0ID0gdGhpcy5sYXN0UG9pbnRlckV2ZW50XztcbiAgICAgIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQsIHRoaXMuZHJhZ1NlZ21lbnRzXyk7XG4gICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5yZW1vdmVWZXJ0ZXhfKCk7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc0JlaW5nTW9kaWZpZWRfKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgTW9kaWZ5RXZlbnQoXG4gICAgICAgICAgICBNb2RpZnlFdmVudFR5cGUuTU9ESUZZRU5ELFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc0JlaW5nTW9kaWZpZWRfLFxuICAgICAgICAgICAgZXZ0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZlYXR1cmVzQmVpbmdNb2RpZmllZF8gPSBudWxsO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdmVydGV4IGZyb20gYWxsIG1hdGNoaW5nIGZlYXR1cmVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIHdoZW4gYSB2ZXJ0ZXggd2FzIHJlbW92ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVWZXJ0ZXhfKCkge1xuICAgIGNvbnN0IGRyYWdTZWdtZW50cyA9IHRoaXMuZHJhZ1NlZ21lbnRzXztcbiAgICBjb25zdCBzZWdtZW50c0J5RmVhdHVyZSA9IHt9O1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbXBvbmVudCwgY29vcmRpbmF0ZXMsIGRyYWdTZWdtZW50LCBnZW9tZXRyeSwgaSwgaW5kZXgsIGxlZnQ7XG4gICAgbGV0IG5ld0luZGV4LCByaWdodCwgc2VnbWVudERhdGEsIHVpZDtcbiAgICBmb3IgKGkgPSBkcmFnU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGRyYWdTZWdtZW50ID0gZHJhZ1NlZ21lbnRzW2ldO1xuICAgICAgc2VnbWVudERhdGEgPSBkcmFnU2VnbWVudFswXTtcbiAgICAgIHVpZCA9IGdldFVpZChzZWdtZW50RGF0YS5mZWF0dXJlKTtcbiAgICAgIGlmIChzZWdtZW50RGF0YS5kZXB0aCkge1xuICAgICAgICAvLyBzZXBhcmF0ZSBmZWF0dXJlIGNvbXBvbmVudHNcbiAgICAgICAgdWlkICs9ICctJyArIHNlZ21lbnREYXRhLmRlcHRoLmpvaW4oJy0nKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHVpZCBpbiBzZWdtZW50c0J5RmVhdHVyZSkpIHtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdTZWdtZW50WzFdID09PSAwKSB7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ucmlnaHQgPSBzZWdtZW50RGF0YTtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5pbmRleCA9IHNlZ21lbnREYXRhLmluZGV4O1xuICAgICAgfSBlbHNlIGlmIChkcmFnU2VnbWVudFsxXSA9PSAxKSB7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ubGVmdCA9IHNlZ21lbnREYXRhO1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmluZGV4ID0gc2VnbWVudERhdGEuaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHVpZCBpbiBzZWdtZW50c0J5RmVhdHVyZSkge1xuICAgICAgcmlnaHQgPSBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLnJpZ2h0O1xuICAgICAgbGVmdCA9IHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ubGVmdDtcbiAgICAgIGluZGV4ID0gc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5pbmRleDtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXggLSAxO1xuICAgICAgaWYgKGxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWdtZW50RGF0YSA9IGxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50RGF0YSA9IHJpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICBuZXdJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgY29tcG9uZW50ID0gY29vcmRpbmF0ZXM7XG4gICAgICBkZWxldGVkID0gZmFsc2U7XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5LmdldFR5cGUoKSkge1xuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgIGlmIChjb29yZGluYXRlc1tzZWdtZW50RGF0YS5kZXB0aFswXV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuZGVwdGhbMF1dLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudFtzZWdtZW50RGF0YS5kZXB0aFsxXV07XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50W3NlZ21lbnREYXRhLmRlcHRoWzBdXTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBjb21wb25lbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSByaW5nIGFnYWluXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5wb3AoKTtcbiAgICAgICAgICAgICAgY29tcG9uZW50LnB1c2goY29tcG9uZW50WzBdKTtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBjb21wb25lbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHBhc3NcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyhnZW9tZXRyeSwgY29vcmRpbmF0ZXMpO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yQnVzaF8ucmVtb3ZlKGxlZnQpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2gobGVmdC5zZWdtZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuckJ1c2hfLnJlbW92ZShyaWdodCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChyaWdodC5zZWdtZW50WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqL1xuICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnREYXRhID0ge1xuICAgICAgICAgICAgZGVwdGg6IHNlZ21lbnREYXRhLmRlcHRoLFxuICAgICAgICAgICAgZmVhdHVyZTogc2VnbWVudERhdGEuZmVhdHVyZSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzZWdtZW50RGF0YS5nZW9tZXRyeSxcbiAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRzLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoXG4gICAgICAgICAgICBib3VuZGluZ0V4dGVudChuZXdTZWdtZW50RGF0YS5zZWdtZW50KSxcbiAgICAgICAgICAgIG5ld1NlZ21lbnREYXRhXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVNlZ21lbnRJbmRpY2VzXyhnZW9tZXRyeSwgaW5kZXgsIHNlZ21lbnREYXRhLmRlcHRoLCAtMSk7XG4gICAgICAgIGlmICh0aGlzLnZlcnRleEZlYXR1cmVfKSB7XG4gICAgICAgICAgdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKS5yZW1vdmVGZWF0dXJlKHRoaXMudmVydGV4RmVhdHVyZV8pO1xuICAgICAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRyYWdTZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0R2VvbWV0cnlDb29yZGluYXRlc18oZ2VvbWV0cnksIGNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gdHJ1ZTtcbiAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IGRlcHRoIERlcHRoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEgKDEgb3IgLTEpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlU2VnbWVudEluZGljZXNfKGdlb21ldHJ5LCBpbmRleCwgZGVwdGgsIGRlbHRhKSB7XG4gICAgdGhpcy5yQnVzaF8uZm9yRWFjaEluRXh0ZW50KFxuICAgICAgZ2VvbWV0cnkuZ2V0RXh0ZW50KCksXG4gICAgICBmdW5jdGlvbiAoc2VnbWVudERhdGFNYXRjaCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2VnbWVudERhdGFNYXRjaC5nZW9tZXRyeSA9PT0gZ2VvbWV0cnkgJiZcbiAgICAgICAgICAoZGVwdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgc2VnbWVudERhdGFNYXRjaC5kZXB0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBlcXVhbHMoc2VnbWVudERhdGFNYXRjaC5kZXB0aCwgZGVwdGgpKSAmJlxuICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guaW5kZXggPiBpbmRleFxuICAgICAgICApIHtcbiAgICAgICAgICBzZWdtZW50RGF0YU1hdGNoLmluZGV4ICs9IGRlbHRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGEgVGhlIGZpcnN0IHNlZ21lbnQgZGF0YS5cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGIgVGhlIHNlY29uZCBzZWdtZW50IGRhdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaWZmZXJlbmNlIGluIGluZGV4ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnRDb29yZGluYXRlcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb21cbiAqICAgICAgICB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlLlxuICogQHBhcmFtIHtTZWdtZW50RGF0YX0gc2VnbWVudERhdGEgVGhlIG9iamVjdCBkZXNjcmliaW5nIHRoZSBsaW5lXG4gKiAgICAgICAgc2VnbWVudCB3ZSBhcmUgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIHRvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBUaGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgYW5kIGEgbGluZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBwcm9qZWN0ZWREaXN0YW5jZVRvU2VnbWVudERhdGFTcXVhcmVkKFxuICBwb2ludENvb3JkaW5hdGVzLFxuICBzZWdtZW50RGF0YSxcbiAgcHJvamVjdGlvblxuKSB7XG4gIGNvbnN0IGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG5cbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gJ0NpcmNsZScpIHtcbiAgICBsZXQgY2lyY2xlR2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgIGdlb21ldHJ5XG4gICAgKTtcblxuICAgIGlmIChzZWdtZW50RGF0YS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcbiAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICBjaXJjbGVHZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGNpcmNsZUdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHVzZXJQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzdGFuY2VUb0NlbnRlclNxdWFyZWQgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKFxuICAgICAgICBjaXJjbGVHZW9tZXRyeS5nZXRDZW50ZXIoKSxcbiAgICAgICAgZnJvbVVzZXJDb29yZGluYXRlKHBvaW50Q29vcmRpbmF0ZXMsIHByb2plY3Rpb24pXG4gICAgICApO1xuICAgICAgY29uc3QgZGlzdGFuY2VUb0NpcmN1bWZlcmVuY2UgPVxuICAgICAgICBNYXRoLnNxcnQoZGlzdGFuY2VUb0NlbnRlclNxdWFyZWQpIC0gY2lyY2xlR2VvbWV0cnkuZ2V0UmFkaXVzKCk7XG4gICAgICByZXR1cm4gZGlzdGFuY2VUb0NpcmN1bWZlcmVuY2UgKiBkaXN0YW5jZVRvQ2lyY3VtZmVyZW5jZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb29yZGluYXRlID0gZnJvbVVzZXJDb29yZGluYXRlKHBvaW50Q29vcmRpbmF0ZXMsIHByb2plY3Rpb24pO1xuICB0ZW1wU2VnbWVudFswXSA9IGZyb21Vc2VyQ29vcmRpbmF0ZShzZWdtZW50RGF0YS5zZWdtZW50WzBdLCBwcm9qZWN0aW9uKTtcbiAgdGVtcFNlZ21lbnRbMV0gPSBmcm9tVXNlckNvb3JkaW5hdGUoc2VnbWVudERhdGEuc2VnbWVudFsxXSwgcHJvamVjdGlvbik7XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQoY29vcmRpbmF0ZSwgdGVtcFNlZ21lbnQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYSBnaXZlbiBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50Q29vcmRpbmF0ZXMgVGhlIHBvaW50IHRvIHdoaWNoIGEgY2xvc2VzdCBwb2ludFxuICogICAgICAgIHNob3VsZCBiZSBmb3VuZC5cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IHNlZ21lbnREYXRhIFRoZSBvYmplY3QgZGVzY3JpYmluZyB0aGUgbGluZVxuICogICAgICAgIHNlZ21lbnQgd2hpY2ggc2hvdWxkIGNvbnRhaW4gdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSB2aWV3IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgbGluZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBjbG9zZXN0T25TZWdtZW50RGF0YShwb2ludENvb3JkaW5hdGVzLCBzZWdtZW50RGF0YSwgcHJvamVjdGlvbikge1xuICBjb25zdCBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuXG4gIGlmIChcbiAgICBnZW9tZXRyeS5nZXRUeXBlKCkgPT09ICdDaXJjbGUnICYmXG4gICAgc2VnbWVudERhdGEuaW5kZXggPT09IENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYXG4gICkge1xuICAgIGxldCBjaXJjbGVHZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgZ2VvbWV0cnlcbiAgICApO1xuICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICBpZiAodXNlclByb2plY3Rpb24pIHtcbiAgICAgIGNpcmNsZUdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGNpcmNsZUdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHVzZXJQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvVXNlckNvb3JkaW5hdGUoXG4gICAgICBjaXJjbGVHZW9tZXRyeS5nZXRDbG9zZXN0UG9pbnQoXG4gICAgICAgIGZyb21Vc2VyQ29vcmRpbmF0ZShwb2ludENvb3JkaW5hdGVzLCBwcm9qZWN0aW9uKVxuICAgICAgKSxcbiAgICAgIHByb2plY3Rpb25cbiAgICApO1xuICB9XG4gIGNvbnN0IGNvb3JkaW5hdGUgPSBmcm9tVXNlckNvb3JkaW5hdGUocG9pbnRDb29yZGluYXRlcywgcHJvamVjdGlvbik7XG4gIHRlbXBTZWdtZW50WzBdID0gZnJvbVVzZXJDb29yZGluYXRlKHNlZ21lbnREYXRhLnNlZ21lbnRbMF0sIHByb2plY3Rpb24pO1xuICB0ZW1wU2VnbWVudFsxXSA9IGZyb21Vc2VyQ29vcmRpbmF0ZShzZWdtZW50RGF0YS5zZWdtZW50WzFdLCBwcm9qZWN0aW9uKTtcbiAgcmV0dXJuIHRvVXNlckNvb3JkaW5hdGUoXG4gICAgY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCB0ZW1wU2VnbWVudCksXG4gICAgcHJvamVjdGlvblxuICApO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0eWxlID0gY3JlYXRlRWRpdGluZ1N0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBzdHlsZVsnUG9pbnQnXTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kaWZ5O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1NlbGVjdFxuICovXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtuZXZlciwgc2hpZnRLZXlPbmx5LCBzaW5nbGVDbGlja30gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgU2VsZWN0RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gZmVhdHVyZShzKSBoYXMgYmVlbiAoZGUpc2VsZWN0ZWQuXG4gICAqIEBldmVudCBTZWxlY3RFdmVudCNzZWxlY3RcbiAgICogQGFwaVxuICAgKi9cbiAgU0VMRUNUOiAnc2VsZWN0Jyxcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgbWF5IGJlXG4gKiBzZWxlY3RlZCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0Pik6Ym9vbGVhbn0gRmlsdGVyRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFthZGRDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLm5ldmVyfS4gVXNlIHRoaXMgaWYgeW91XG4gKiB3YW50IHRvIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBhZGQgYW5kIHJlbW92ZSBpbnN0ZWFkIG9mIGB0b2dnbGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGlzIGlzIHRoZSBldmVudFxuICogZm9yIHRoZSBzZWxlY3RlZCBmZWF0dXJlcyBhcyBhIHdob2xlLiBCeSBkZWZhdWx0LCB0aGlzIGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uc2luZ2xlQ2xpY2t9LiBDbGlja2luZyBvbiBhIGZlYXR1cmUgc2VsZWN0cyB0aGF0XG4gKiBmZWF0dXJlIGFuZCByZW1vdmVzIGFueSB0aGF0IHdlcmUgaW4gdGhlIHNlbGVjdGlvbi4gQ2xpY2tpbmcgb3V0c2lkZSBhbnlcbiAqIGZlYXR1cmUgcmVtb3ZlcyBhbGwgZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogU2VlIGB0b2dnbGVgLCBgYWRkYCwgYHJlbW92ZWAgb3B0aW9ucyBmb3IgYWRkaW5nL3JlbW92aW5nIGV4dHJhIGZlYXR1cmVzIHRvL1xuICogZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PnxmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2VcIikuZGVmYXVsdD4pOiBib29sZWFufSBbbGF5ZXJzXVxuICogQSBsaXN0IG9mIGxheWVycyBmcm9tIHdoaWNoIGZlYXR1cmVzIHNob3VsZCBiZSBzZWxlY3RlZC4gQWx0ZXJuYXRpdmVseSwgYVxuICogZmlsdGVyIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGxheWVyXG4gKiBpbiB0aGUgbWFwIGFuZCBzaG91bGQgcmV0dXJuIGB0cnVlYCBmb3IgbGF5ZXJzIHRoYXQgeW91IHdhbnQgdG8gYmVcbiAqIHNlbGVjdGFibGUuIElmIHRoZSBvcHRpb24gaXMgYWJzZW50LCBhbGwgdmlzaWJsZSBsYXllcnMgd2lsbCBiZSBjb25zaWRlcmVkXG4gKiBzZWxlY3RhYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8bnVsbH0gW3N0eWxlXVxuICogU3R5bGUgZm9yIHRoZSBzZWxlY3RlZCBmZWF0dXJlcy4gQnkgZGVmYXVsdCB0aGUgZGVmYXVsdCBlZGl0IHN0eWxlIGlzIHVzZWRcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0pLiBTZXQgdG8gYG51bGxgIGlmIHRoaXMgaW50ZXJhY3Rpb24gc2hvdWxkIG5vdCBhcHBseVxuICogYW55IHN0eWxlIGNoYW5nZXMgZm9yIHNlbGVjdGVkIGZlYXR1cmVzLlxuICogSWYgc2V0IHRvIGEgZmFsc2V5IHZhbHVlLCB0aGUgc2VsZWN0ZWQgZmVhdHVyZSdzIHN0eWxlIHdpbGwgbm90IGNoYW5nZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtyZW1vdmVDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLm5ldmVyfS4gVXNlIHRoaXMgaWYgeW91XG4gKiB3YW50IHRvIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBhZGQgYW5kIHJlbW92ZSBpbnN0ZWFkIG9mIGB0b2dnbGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW3RvZ2dsZUNvbmRpdGlvbl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGlzIGlzIGluIGFkZGl0aW9uXG4gKiB0byB0aGUgYGNvbmRpdGlvbmAgZXZlbnQuIEJ5IGRlZmF1bHQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uc2hpZnRLZXlPbmx5fSwgaS5lLiBwcmVzc2luZyBgc2hpZnRgIGFzXG4gKiB3ZWxsIGFzIHRoZSBgY29uZGl0aW9uYCBldmVudCwgYWRkcyB0aGF0IGZlYXR1cmUgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmXG4gKiBpdCBpcyBub3QgY3VycmVudGx5IHNlbGVjdGVkLCBhbmQgcmVtb3ZlcyBpdCBpZiBpdCBpcy4gU2VlIGBhZGRgIGFuZCBgcmVtb3ZlYFxuICogaWYgeW91IHdhbnQgdG8gdXNlIGRpZmZlcmVudCBldmVudHMgaW5zdGVhZCBvZiBhIHRvZ2dsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpPWZhbHNlXSBBIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSBkZWZhdWx0XG4gKiBiZWhhdmlvdXIgc2hvdWxkIHNlbGVjdCBvbmx5IHNpbmdsZSBmZWF0dXJlcyBvciBhbGwgKG92ZXJsYXBwaW5nKSBmZWF0dXJlcyBhdFxuICogdGhlIGNsaWNrZWQgbWFwIHBvc2l0aW9uLiBUaGUgZGVmYXVsdCBvZiBgZmFsc2VgIG1lYW5zIHNpbmdsZSBzZWxlY3QuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248RmVhdHVyZT59IFtmZWF0dXJlc11cbiAqIENvbGxlY3Rpb24gd2hlcmUgdGhlIGludGVyYWN0aW9uIHdpbGwgcGxhY2Ugc2VsZWN0ZWQgZmVhdHVyZXMuIE9wdGlvbmFsLiBJZlxuICogbm90IHNldCB0aGUgaW50ZXJhY3Rpb24gd2lsbCBjcmVhdGUgYSBjb2xsZWN0aW9uLiBJbiBhbnkgY2FzZSB0aGUgY29sbGVjdGlvblxuICogdXNlZCBieSB0aGUgaW50ZXJhY3Rpb24gaXMgcmV0dXJuZWQgYnlcbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU2VsZWN0flNlbGVjdCNnZXRGZWF0dXJlc30uXG4gKiBAcHJvcGVydHkge0ZpbHRlckZ1bmN0aW9ufSBbZmlsdGVyXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXJ9IGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmVhdHVyZSBtYXkgYmVcbiAqIHNlbGVjdGVkIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuIFBpeGVscyBpbnNpZGVcbiAqIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgU2VsZWN0RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdEV2ZW50VHlwZX0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBzZWxlY3RlZCBTZWxlY3RlZCBmZWF0dXJlcy5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBkZXNlbGVjdGVkIERlc2VsZWN0ZWQgZmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBBc3NvY2lhdGVkXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgc2VsZWN0ZWQsIGRlc2VsZWN0ZWQsIG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogU2VsZWN0ZWQgZmVhdHVyZXMgYXJyYXkuXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0ZWQgZmVhdHVyZXMgYXJyYXkuXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZGVzZWxlY3RlZCA9IGRlc2VsZWN0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcbiAgfVxufVxuXG4vKipcbiAqIE9yaWdpbmFsIGZlYXR1cmUgc3R5bGVzIHRvIHJlc2V0IHRvIHdoZW4gZmVhdHVyZXMgYXJlIG5vIGxvbmdlciBzZWxlY3RlZC5cbiAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb24+fVxuICovXG5jb25zdCBvcmlnaW5hbEZlYXR1cmVTdHlsZXMgPSB7fTtcblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTwnc2VsZWN0JywgU2VsZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZSd8J3NlbGVjdCcsIFJldHVybj59IFNlbGVjdE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3Igc2VsZWN0aW5nIHZlY3RvciBmZWF0dXJlcy4gQnkgZGVmYXVsdCwgc2VsZWN0ZWQgZmVhdHVyZXMgYXJlXG4gKiBzdHlsZWQgZGlmZmVyZW50bHksIHNvIHRoaXMgaW50ZXJhY3Rpb24gY2FuIGJlIHVzZWQgZm9yIHZpc3VhbCBoaWdobGlnaHRpbmcsXG4gKiBhcyB3ZWxsIGFzIHNlbGVjdGluZyBmZWF0dXJlcyBmb3Igb3RoZXIgYWN0aW9ucywgc3VjaCBhcyBtb2RpZmljYXRpb24gb3JcbiAqIG91dHB1dC4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgY29udHJvbGxpbmcgd2hpY2ggZmVhdHVyZXMgYXJlIHNlbGVjdGVkOlxuICogdXNpbmcgdGhlIGJyb3dzZXIgZXZlbnQgYXMgZGVmaW5lZCBieSB0aGUgYGNvbmRpdGlvbmAgYW5kIG9wdGlvbmFsbHkgdGhlXG4gKiBgdG9nZ2xlYCwgYGFkZGAvYHJlbW92ZWAsIGFuZCBgbXVsdGlgIG9wdGlvbnM7IGEgYGxheWVyc2AgZmlsdGVyOyBhbmQgYVxuICogZnVydGhlciBmZWF0dXJlIGZpbHRlciB1c2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uLlxuICpcbiAqIEBmaXJlcyBTZWxlY3RFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBTZWxlY3QgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1NlbGVjdE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1NlbGVjdE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7U2VsZWN0T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kQWRkRmVhdHVyZV8gPSB0aGlzLmFkZEZlYXR1cmVfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRSZW1vdmVGZWF0dXJlXyA9IHRoaXMucmVtb3ZlRmVhdHVyZV8uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBzaW5nbGVDbGljaztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYWRkQ29uZGl0aW9uXyA9IG9wdGlvbnMuYWRkQ29uZGl0aW9uID8gb3B0aW9ucy5hZGRDb25kaXRpb24gOiBuZXZlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlQ29uZGl0aW9uXyA9IG9wdGlvbnMucmVtb3ZlQ29uZGl0aW9uXG4gICAgICA/IG9wdGlvbnMucmVtb3ZlQ29uZGl0aW9uXG4gICAgICA6IG5ldmVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy50b2dnbGVDb25kaXRpb25fID0gb3B0aW9ucy50b2dnbGVDb25kaXRpb25cbiAgICAgID8gb3B0aW9ucy50b2dnbGVDb25kaXRpb25cbiAgICAgIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpXyA9IG9wdGlvbnMubXVsdGkgPyBvcHRpb25zLm11bHRpIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGaWx0ZXJGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcl8gPSBvcHRpb25zLmZpbHRlciA/IG9wdGlvbnMuZmlsdGVyIDogVFJVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdFRvbGVyYW5jZV8gPSBvcHRpb25zLmhpdFRvbGVyYW5jZSA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR8QXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD58aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVfID1cbiAgICAgIG9wdGlvbnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3R5bGUgOiBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlPn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IG9wdGlvbnMuZmVhdHVyZXMgfHwgbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+KTogYm9vbGVhbn0gKi9cbiAgICBsZXQgbGF5ZXJGaWx0ZXI7XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGF5ZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxheWVyRmlsdGVyID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbGF5ZXJzLmluY2x1ZGVzKGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJGaWx0ZXIgPSBUUlVFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0Pik6IGJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sYXllckZpbHRlcl8gPSBsYXllckZpbHRlcjtcblxuICAgIC8qKlxuICAgICAqIEFuIGFzc29jaWF0aW9uIGJldHdlZW4gc2VsZWN0ZWQgZmVhdHVyZSAoa2V5KVxuICAgICAqIGFuZCBsYXllciAodmFsdWUpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl9bZ2V0VWlkKGZlYXR1cmUpXSA9IGxheWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248RmVhdHVyZT59IEZlYXR1cmVzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGl0VG9sZXJhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmhpdFRvbGVyYW5jZV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn5WZWN0b3JMYXllciB2ZWN0b3IgbGF5ZXJ9IG9mXG4gICAqIGEgc2VsZWN0ZWQgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uL2xheWVyL1ZlY3Rvci5qcycpLmRlZmF1bHR9IExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllcihmZWF0dXJlKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9sYXllci9WZWN0b3IuanMnKS5kZWZhdWx0fSAqLyAoXG4gICAgICB0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uX1tnZXRVaWQoZmVhdHVyZSldXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS4gUGl4ZWxzIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SGl0VG9sZXJhbmNlKGhpdFRvbGVyYW5jZSkge1xuICAgIHRoaXMuaGl0VG9sZXJhbmNlXyA9IGhpdFRvbGVyYW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwLCBpZiBhbnksICBhbmQgYXR0YWNoIGl0IHRvIGEgbmV3XG4gICAqIG1hcCwgaWYgYW55LiBQYXNzIGBudWxsYCB0byBqdXN0IHJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGNvbnN0IGN1cnJlbnRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChjdXJyZW50TWFwICYmIHRoaXMuc3R5bGVfKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5mb3JFYWNoKHRoaXMucmVzdG9yZVByZXZpb3VzU3R5bGVfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBzdXBlci5zZXRNYXAobWFwKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgICAgdGhpcy5ib3VuZEFkZEZlYXR1cmVfXG4gICAgICApO1xuICAgICAgdGhpcy5mZWF0dXJlc18uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAgIHRoaXMuYm91bmRSZW1vdmVGZWF0dXJlX1xuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuc3R5bGVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNfLmZvckVhY2godGhpcy5hcHBseVNlbGVjdGVkU3R5bGVfLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgICAgdGhpcy5ib3VuZEFkZEZlYXR1cmVfXG4gICAgICApO1xuICAgICAgdGhpcy5mZWF0dXJlc18ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAgIHRoaXMuYm91bmRSZW1vdmVGZWF0dXJlX1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxGZWF0dXJlPn0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkRmVhdHVyZV8oZXZ0KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGV2dC5lbGVtZW50O1xuICAgIGlmICh0aGlzLnN0eWxlXykge1xuICAgICAgdGhpcy5hcHBseVNlbGVjdGVkU3R5bGVfKGZlYXR1cmUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZ2V0TGF5ZXIoZmVhdHVyZSkpIHtcbiAgICAgIGNvbnN0IGxheWVyID0gLyoqIEB0eXBlIHtWZWN0b3JMYXllcn0gKi8gKFxuICAgICAgICB0aGlzLmdldE1hcCgpXG4gICAgICAgICAgLmdldEFsbExheWVycygpXG4gICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxheWVyIGluc3RhbmNlb2YgVmVjdG9yTGF5ZXIgJiZcbiAgICAgICAgICAgICAgbGF5ZXIuZ2V0U291cmNlKCkgJiZcbiAgICAgICAgICAgICAgbGF5ZXIuZ2V0U291cmNlKCkuaGFzRmVhdHVyZShmZWF0dXJlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyhmZWF0dXJlLCBsYXllcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8RmVhdHVyZT59IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZUZlYXR1cmVfKGV2dCkge1xuICAgIGlmICh0aGlzLnN0eWxlXykge1xuICAgICAgdGhpcy5yZXN0b3JlUHJldmlvdXNTdHlsZV8oZXZ0LmVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8bnVsbH0gU2VsZWN0IHN0eWxlLlxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcHBseVNlbGVjdGVkU3R5bGVfKGZlYXR1cmUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgaWYgKCEoa2V5IGluIG9yaWdpbmFsRmVhdHVyZVN0eWxlcykpIHtcbiAgICAgIG9yaWdpbmFsRmVhdHVyZVN0eWxlc1trZXldID0gZmVhdHVyZS5nZXRTdHlsZSgpO1xuICAgIH1cbiAgICBmZWF0dXJlLnNldFN0eWxlKHRoaXMuc3R5bGVfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzdG9yZVByZXZpb3VzU3R5bGVfKGZlYXR1cmUpIHtcbiAgICBjb25zdCBpbnRlcmFjdGlvbnMgPSB0aGlzLmdldE1hcCgpLmdldEludGVyYWN0aW9ucygpLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IGludGVyYWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNbaV07XG4gICAgICBpZiAoXG4gICAgICAgIGludGVyYWN0aW9uICE9PSB0aGlzICYmXG4gICAgICAgIGludGVyYWN0aW9uIGluc3RhbmNlb2YgU2VsZWN0ICYmXG4gICAgICAgIGludGVyYWN0aW9uLmdldFN0eWxlKCkgJiZcbiAgICAgICAgaW50ZXJhY3Rpb24uZ2V0RmVhdHVyZXMoKS5nZXRBcnJheSgpLmxhc3RJbmRleE9mKGZlYXR1cmUpICE9PSAtMVxuICAgICAgKSB7XG4gICAgICAgIGZlYXR1cmUuc2V0U3R5bGUoaW50ZXJhY3Rpb24uZ2V0U3R5bGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgZmVhdHVyZS5zZXRTdHlsZShvcmlnaW5hbEZlYXR1cmVTdHlsZXNba2V5XSk7XG4gICAgZGVsZXRlIG9yaWdpbmFsRmVhdHVyZVN0eWxlc1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUpIHtcbiAgICBkZWxldGUgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl9bZ2V0VWlkKGZlYXR1cmUpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgY2hhbmdlIHRoZVxuICAgKiBzZWxlY3RlZCBzdGF0ZSBvZiBmZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWRkID0gdGhpcy5hZGRDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgY29uc3QgcmVtb3ZlID0gdGhpcy5yZW1vdmVDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgY29uc3QgdG9nZ2xlID0gdGhpcy50b2dnbGVDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgY29uc3Qgc2V0ID0gIWFkZCAmJiAhcmVtb3ZlICYmICF0b2dnbGU7XG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxGZWF0dXJlPn1cbiAgICAgKi9cbiAgICBjb25zdCBkZXNlbGVjdGVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59XG4gICAgICovXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcblxuICAgIGlmIChzZXQpIHtcbiAgICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlKHMpIHdpdGggdGhlIGZlYXR1cmUocykgYXQgdGhlXG4gICAgICAvLyBwaXhlbCwgb3IgY2xlYXIgdGhlIHNlbGVjdGVkIGZlYXR1cmUocykgaWYgdGhlcmUgaXMgbm8gZmVhdHVyZSBhdFxuICAgICAgLy8gdGhlIHBpeGVsLlxuICAgICAgY2xlYXIodGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8pO1xuICAgICAgbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LnBpeGVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBDb250aW51ZSB0byBpdGVyYXRlIG92ZXIgdGhlIGZlYXR1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgKGZlYXR1cmUsIGxheWVyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZmVhdHVyZSBpbnN0YW5jZW9mIEZlYXR1cmUpIHx8ICF0aGlzLmZpbHRlcl8oZmVhdHVyZSwgbGF5ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUsIGxheWVyKTtcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgIHJldHVybiAhdGhpcy5tdWx0aV87XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcl8sXG4gICAgICAgICAgaGl0VG9sZXJhbmNlOiB0aGlzLmhpdFRvbGVyYW5jZV8sXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gZmVhdHVyZXMuZ2V0TGVuZ3RoKCkgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXMuaXRlbShpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzZWxlY3RlZC5pbmRleE9mKGZlYXR1cmUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIC8vIGZlYXR1cmUgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmVhdHVyZXMucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgICAgIGRlc2VsZWN0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBmZWF0dXJlcy5leHRlbmQoc2VsZWN0ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb2RpZnkgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlKHMpLlxuICAgICAgbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LnBpeGVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBDb250aW51ZSB0byBpdGVyYXRlIG92ZXIgdGhlIGZlYXR1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgKGZlYXR1cmUsIGxheWVyKSA9PiB7XG4gICAgICAgICAgaWYgKCEoZmVhdHVyZSBpbnN0YW5jZW9mIEZlYXR1cmUpIHx8ICF0aGlzLmZpbHRlcl8oZmVhdHVyZSwgbGF5ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoYWRkIHx8IHRvZ2dsZSkgJiYgIWZlYXR1cmVzLmdldEFycmF5KCkuaW5jbHVkZXMoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUsIGxheWVyKTtcbiAgICAgICAgICAgIHNlbGVjdGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIChyZW1vdmUgfHwgdG9nZ2xlKSAmJlxuICAgICAgICAgICAgZmVhdHVyZXMuZ2V0QXJyYXkoKS5pbmNsdWRlcyhmZWF0dXJlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGVzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8oZmVhdHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhdGhpcy5tdWx0aV87XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcl8sXG4gICAgICAgICAgaGl0VG9sZXJhbmNlOiB0aGlzLmhpdFRvbGVyYW5jZV8sXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBqID0gZGVzZWxlY3RlZC5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICBmZWF0dXJlcy5yZW1vdmUoZGVzZWxlY3RlZFtqXSk7XG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5leHRlbmQoc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID4gMCB8fCBkZXNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IFNlbGVjdEV2ZW50KFxuICAgICAgICAgIFNlbGVjdEV2ZW50VHlwZS5TRUxFQ1QsXG4gICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgZGVzZWxlY3RlZCxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBTdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRTdHlsZUZ1bmN0aW9uKCkge1xuICBjb25zdCBzdHlsZXMgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgZXh0ZW5kKHN0eWxlc1snUG9seWdvbiddLCBzdHlsZXNbJ0xpbmVTdHJpbmcnXSk7XG4gIGV4dGVuZChzdHlsZXNbJ0dlb21ldHJ5Q29sbGVjdGlvbiddLCBzdHlsZXNbJ0xpbmVTdHJpbmcnXSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgaWYgKCFmZWF0dXJlLmdldEdlb21ldHJ5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vU25hcFxuICovXG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAnLi4vc3RydWN0cy9SQnVzaC5qcyc7XG5pbXBvcnQgVmVjdG9yRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtGQUxTRSwgVFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGJ1ZmZlciwgY3JlYXRlRW1wdHl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBjbG9zZXN0T25DaXJjbGUsXG4gIGNsb3Nlc3RPblNlZ21lbnQsXG4gIHNxdWFyZWREaXN0YW5jZSxcbn0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2Zyb21DaXJjbGV9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQge1xuICBmcm9tVXNlckNvb3JkaW5hdGUsXG4gIGdldFVzZXJQcm9qZWN0aW9uLFxuICB0b1VzZXJDb29yZGluYXRlLFxuICB0b1VzZXJFeHRlbnQsXG59IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVzdWx0XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSB2ZXJ0ZXggVmVydGV4LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbHxudWxsfSB2ZXJ0ZXhQaXhlbCBWZXJ0ZXhQaXhlbC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnREYXRhXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBzZWdtZW50IFNlZ21lbnQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZmVhdHVyZXNdIFNuYXAgdG8gdGhlc2UgZmVhdHVyZXMuIEVpdGhlciB0aGlzIG9wdGlvbiBvciBzb3VyY2Ugc2hvdWxkIGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZWRnZT10cnVlXSBTbmFwIHRvIGVkZ2VzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVydGV4PXRydWVdIFNuYXAgdG8gdmVydGljZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsVG9sZXJhbmNlPTEwXSBQaXhlbCB0b2xlcmFuY2UgZm9yIGNvbnNpZGVyaW5nIHRoZSBwb2ludGVyIGNsb3NlIGVub3VnaCB0byBhIHNlZ21lbnQgb3JcbiAqIHZlcnRleCBmb3Igc25hcHBpbmcuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU25hcCB0byBmZWF0dXJlcyBmcm9tIHRoaXMgc291cmNlLiBFaXRoZXIgdGhpcyBvcHRpb24gb3IgZmVhdHVyZXMgc2hvdWxkIGJlIHByb3ZpZGVkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGV2dCBFdmVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxudWxsfSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiBnZXRGZWF0dXJlRnJvbUV2ZW50KGV2dCkge1xuICBpZiAoXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fSAqLyAoZXZ0KS5mZWF0dXJlXG4gICkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR9ICovIChldnQpXG4gICAgICAuZmVhdHVyZTtcbiAgfVxuICBpZiAoXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoXG4gICAgICBldnRcbiAgICApLmVsZW1lbnRcbiAgKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKFxuICAgICAgZXZ0XG4gICAgKS5lbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCB0ZW1wU2VnbWVudCA9IFtdO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEhhbmRsZXMgc25hcHBpbmcgb2YgdmVjdG9yIGZlYXR1cmVzIHdoaWxlIG1vZGlmeWluZyBvciBkcmF3aW5nIHRoZW0uICBUaGVcbiAqIGZlYXR1cmVzIGNhbiBjb21lIGZyb20gYSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlfSBvciB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn1cbiAqIEFueSBpbnRlcmFjdGlvbiBvYmplY3QgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gaW50ZXJhY3RcbiAqIHdpdGggdGhlIGZlYXR1cmVzIHVzaW5nIHRoZSBtb3VzZSBjYW4gYmVuZWZpdCBmcm9tIHRoZSBzbmFwcGluZywgYXMgbG9uZ1xuICogYXMgaXQgaXMgYWRkZWQgYmVmb3JlLlxuICpcbiAqIFRoZSBzbmFwIGludGVyYWN0aW9uIG1vZGlmaWVzIG1hcCBicm93c2VyIGV2ZW50IGBjb29yZGluYXRlYCBhbmQgYHBpeGVsYFxuICogcHJvcGVydGllcyB0byBmb3JjZSB0aGUgc25hcCB0byBvY2N1ciB0byBhbnkgaW50ZXJhY3Rpb24gdGhhdCB0aGVtLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCBTbmFwIGZyb20gJ29sL2ludGVyYWN0aW9uL1NuYXAuanMnO1xuICpcbiAqICAgICBjb25zdCBzbmFwID0gbmV3IFNuYXAoe1xuICogICAgICAgc291cmNlOiBzb3VyY2VcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgbWFwLmFkZEludGVyYWN0aW9uKHNuYXApO1xuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU25hcCBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAoXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuaGFuZGxlRG93bkV2ZW50KSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5oYW5kbGVEb3duRXZlbnQgPSBUUlVFO1xuICAgIH1cblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgc3VwZXIocG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4XyA9IG9wdGlvbnMudmVydGV4ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZlcnRleCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZWRnZV8gPSBvcHRpb25zLmVkZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZWRnZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD58bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gb3B0aW9ucy5mZWF0dXJlcyA/IG9wdGlvbnMuZmVhdHVyZXMgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0xpc3RlbmVyS2V5c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudHMgYXJlIHByZXNlcnZlZCBzbyBpbmRleGVkIHNlZ21lbnQgY2FuIGJlIHF1aWNrbHkgcmVtb3ZlZFxuICAgICAqIHdoZW4gaXRzIGZlYXR1cmUgZ2VvbWV0cnkgY2hhbmdlc1xuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIGEgZmVhdHVyZSBnZW9tZXRyeSBjaGFuZ2VzIHdoaWxlIGEgcG9pbnRlciBkcmFnfG1vdmUgZXZlbnQgb2NjdXJzLCB0aGVcbiAgICAgKiBmZWF0dXJlIGRvZXNuJ3QgZ2V0IHVwZGF0ZWQgcmlnaHQgYXdheS4gIEl0IHdpbGwgYmUgYXQgdGhlIG5leHQgJ3BvaW50ZXJ1cCdcbiAgICAgKiBldmVudCBmaXJlZC5cbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9sZXJhbmNlXyA9XG4gICAgICBvcHRpb25zLnBpeGVsVG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpeGVsVG9sZXJhbmNlIDogMTA7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IFJUcmVlIGZvciBlYWNoIGxheWVyXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0cnVjdHMvUkJ1c2guanNcIikuZGVmYXVsdDxTZWdtZW50RGF0YT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJCdXNoXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oQXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+LCBpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHQpOiB2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLkdFT01FVFJZX1NFR01FTlRFUlNfID0ge1xuICAgICAgJ1BvaW50JzogdGhpcy5zZWdtZW50UG9pbnRHZW9tZXRyeV8uYmluZCh0aGlzKSxcbiAgICAgICdMaW5lU3RyaW5nJzogdGhpcy5zZWdtZW50TGluZVN0cmluZ0dlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ0xpbmVhclJpbmcnOiB0aGlzLnNlZ21lbnRMaW5lU3RyaW5nR2VvbWV0cnlfLmJpbmQodGhpcyksXG4gICAgICAnUG9seWdvbic6IHRoaXMuc2VnbWVudFBvbHlnb25HZW9tZXRyeV8uYmluZCh0aGlzKSxcbiAgICAgICdNdWx0aVBvaW50JzogdGhpcy5zZWdtZW50TXVsdGlQb2ludEdlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ011bHRpTGluZVN0cmluZyc6IHRoaXMuc2VnbWVudE11bHRpTGluZVN0cmluZ0dlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ011bHRpUG9seWdvbic6IHRoaXMuc2VnbWVudE11bHRpUG9seWdvbkdlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHRoaXMuc2VnbWVudEdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgICAgJ0NpcmNsZSc6IHRoaXMuc2VnbWVudENpcmNsZUdlb21ldHJ5Xy5iaW5kKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZmVhdHVyZSB0byB0aGUgY29sbGVjdGlvbiBvZiBmZWF0dXJlcyB0aGF0IHdlIG1heSBzbmFwIHRvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWdpc3Rlcl0gV2hldGhlciB0byBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgY2hhbmdlIG9yIG5vdFxuICAgKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRGZWF0dXJlKGZlYXR1cmUsIHJlZ2lzdGVyKSB7XG4gICAgcmVnaXN0ZXIgPSByZWdpc3RlciAhPT0gdW5kZWZpbmVkID8gcmVnaXN0ZXIgOiB0cnVlO1xuICAgIGNvbnN0IGZlYXR1cmVfdWlkID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgY29uc3Qgc2VnbWVudGVyID0gdGhpcy5HRU9NRVRSWV9TRUdNRU5URVJTX1tnZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgICAgaWYgKHNlZ21lbnRlcikge1xuICAgICAgICB0aGlzLmluZGV4ZWRGZWF0dXJlc0V4dGVudHNfW2ZlYXR1cmVfdWlkXSA9IGdlb21ldHJ5LmdldEV4dGVudChcbiAgICAgICAgICBjcmVhdGVFbXB0eSgpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID1cbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+Pn0gKi8gKFtdKTtcbiAgICAgICAgc2VnbWVudGVyKHNlZ21lbnRzLCBnZW9tZXRyeSk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudHNbMF0pLCB7XG4gICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudHNbMF0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGV4dGVudHMgPSBzZWdtZW50cy5tYXAoKHMpID0+IGJvdW5kaW5nRXh0ZW50KHMpKTtcbiAgICAgICAgICBjb25zdCBzZWdtZW50c0RhdGEgPSBzZWdtZW50cy5tYXAoKHNlZ21lbnQpID0+ICh7XG4gICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5yQnVzaF8ubG9hZChleHRlbnRzLCBzZWdtZW50c0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfW2ZlYXR1cmVfdWlkXSA9IGxpc3RlbihcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGZWF0dXJlc18oKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICAgIGxldCBmZWF0dXJlcztcbiAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc187XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5zb3VyY2VfLmdldEZlYXR1cmVzKCk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc25hcFRvKGV2dC5waXhlbCwgZXZ0LmNvb3JkaW5hdGUsIGV2dC5tYXApO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGV2dC5jb29yZGluYXRlID0gcmVzdWx0LnZlcnRleC5zbGljZSgwLCAyKTtcbiAgICAgIGV2dC5waXhlbCA9IHJlc3VsdC52ZXJ0ZXhQaXhlbDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZUV2ZW50KGV2dCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVBZGRfKGV2dCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBnZXRGZWF0dXJlRnJvbUV2ZW50KGV2dCk7XG4gICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVSZW1vdmVfKGV2dCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBnZXRGZWF0dXJlRnJvbUV2ZW50KGV2dCk7XG4gICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZShmZWF0dXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRmVhdHVyZUNoYW5nZV8oZXZ0KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZ0LnRhcmdldCk7XG4gICAgaWYgKHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgY29uc3QgdWlkID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgaWYgKCEodWlkIGluIHRoaXMucGVuZGluZ0ZlYXR1cmVzXykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRmVhdHVyZXNfW3VpZF0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUZlYXR1cmVfKGZlYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQoZXZ0KSB7XG4gICAgY29uc3QgZmVhdHVyZXNUb1VwZGF0ZSA9IE9iamVjdC52YWx1ZXModGhpcy5wZW5kaW5nRmVhdHVyZXNfKTtcbiAgICBpZiAoZmVhdHVyZXNUb1VwZGF0ZS5sZW5ndGgpIHtcbiAgICAgIGZlYXR1cmVzVG9VcGRhdGUuZm9yRWFjaCh0aGlzLnVwZGF0ZUZlYXR1cmVfLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5wZW5kaW5nRmVhdHVyZXNfID0ge307XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmZWF0dXJlIGZyb20gdGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMgdGhhdCB3ZSBtYXkgc25hcCB0by5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bmxpc3Rlbl0gV2hldGhlciB0byB1bmxpc3RlbiB0byB0aGUgZmVhdHVyZSBjaGFuZ2VcbiAgICogICAgIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVGZWF0dXJlKGZlYXR1cmUsIHVubGlzdGVuKSB7XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IHVubGlzdGVuICE9PSB1bmRlZmluZWQgPyB1bmxpc3RlbiA6IHRydWU7XG4gICAgY29uc3QgZmVhdHVyZV91aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5pbmRleGVkRmVhdHVyZXNFeHRlbnRzX1tmZWF0dXJlX3VpZF07XG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgY29uc3QgckJ1c2ggPSB0aGlzLnJCdXNoXztcbiAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgIHJCdXNoLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlID09PSBub2RlLmZlYXR1cmUpIHtcbiAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IG5vZGVzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgckJ1c2gucmVtb3ZlKG5vZGVzVG9SZW1vdmVbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1bnJlZ2lzdGVyKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c19bZmVhdHVyZV91aWRdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfW2ZlYXR1cmVfdWlkXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGNvbnN0IGN1cnJlbnRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSB0aGlzLmZlYXR1cmVzTGlzdGVuZXJLZXlzXztcbiAgICBjb25zdCBmZWF0dXJlcyA9IC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKFxuICAgICAgdGhpcy5nZXRGZWF0dXJlc18oKVxuICAgICk7XG5cbiAgICBpZiAoY3VycmVudE1hcCkge1xuICAgICAga2V5cy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAga2V5cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5yQnVzaF8uY2xlYXIoKTtcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5mZWF0dXJlQ2hhbmdlTGlzdGVuZXJLZXlzXykuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c18gPSB7fTtcbiAgICB9XG4gICAgc3VwZXIuc2V0TWFwKG1hcCk7XG5cbiAgICBpZiAobWFwKSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgICAga2V5cy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNfLFxuICAgICAgICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVBZGRfLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICksXG4gICAgICAgICAgbGlzdGVuKFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc18sXG4gICAgICAgICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZVJlbW92ZV8sXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgICAga2V5cy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuc291cmNlXyxcbiAgICAgICAgICAgIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQWRkXyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApLFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuc291cmNlXyxcbiAgICAgICAgICAgIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcGl4ZWxDb29yZGluYXRlIENvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQHJldHVybiB7UmVzdWx0fG51bGx9IFNuYXAgcmVzdWx0XG4gICAqL1xuICBzbmFwVG8ocGl4ZWwsIHBpeGVsQ29vcmRpbmF0ZSwgbWFwKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IG1hcC5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHByb2plY3RlZENvb3JkaW5hdGUgPSBmcm9tVXNlckNvb3JkaW5hdGUocGl4ZWxDb29yZGluYXRlLCBwcm9qZWN0aW9uKTtcblxuICAgIGNvbnN0IGJveCA9IHRvVXNlckV4dGVudChcbiAgICAgIGJ1ZmZlcihcbiAgICAgICAgYm91bmRpbmdFeHRlbnQoW3Byb2plY3RlZENvb3JkaW5hdGVdKSxcbiAgICAgICAgbWFwLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsVG9sZXJhbmNlX1xuICAgICAgKSxcbiAgICAgIHByb2plY3Rpb25cbiAgICApO1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnJCdXNoXy5nZXRJbkV4dGVudChib3gpO1xuXG4gICAgY29uc3Qgc2VnbWVudHNMZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKHNlZ21lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgY2xvc2VzdFZlcnRleDtcbiAgICBsZXQgbWluU3F1YXJlZERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICBjb25zdCBzcXVhcmVkUGl4ZWxUb2xlcmFuY2UgPSB0aGlzLnBpeGVsVG9sZXJhbmNlXyAqIHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgIGNvbnN0IGdldFJlc3VsdCA9ICgpID0+IHtcbiAgICAgIGlmIChjbG9zZXN0VmVydGV4KSB7XG4gICAgICAgIGNvbnN0IHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFZlcnRleCk7XG4gICAgICAgIGNvbnN0IHNxdWFyZWRQaXhlbERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlKHBpeGVsLCB2ZXJ0ZXhQaXhlbCk7XG4gICAgICAgIGlmIChzcXVhcmVkUGl4ZWxEaXN0YW5jZSA8PSBzcXVhcmVkUGl4ZWxUb2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVydGV4OiBjbG9zZXN0VmVydGV4LFxuICAgICAgICAgICAgdmVydGV4UGl4ZWw6IFtcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCh2ZXJ0ZXhQaXhlbFswXSksXG4gICAgICAgICAgICAgIE1hdGgucm91bmQodmVydGV4UGl4ZWxbMV0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudmVydGV4Xykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50c0xlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWdtZW50RGF0YS5mZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpICE9PSAnQ2lyY2xlJykge1xuICAgICAgICAgIHNlZ21lbnREYXRhLnNlZ21lbnQuZm9yRWFjaCgodmVydGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wVmVydGV4Q29vcmQgPSBmcm9tVXNlckNvb3JkaW5hdGUodmVydGV4LCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gc3F1YXJlZERpc3RhbmNlKHByb2plY3RlZENvb3JkaW5hdGUsIHRlbXBWZXJ0ZXhDb29yZCk7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFJlc3VsdCgpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVkZ2VfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IHZlcnRleCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNlZ21lbnREYXRhID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWdtZW50RGF0YS5mZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpID09PSAnQ2lyY2xlJykge1xuICAgICAgICAgIGxldCBjaXJjbGVHZW9tZXRyeSA9IHNlZ21lbnREYXRhLmZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBjaXJjbGVHZW9tZXRyeSA9IGNpcmNsZUdlb21ldHJ5XG4gICAgICAgICAgICAgIC5jbG9uZSgpXG4gICAgICAgICAgICAgIC50cmFuc2Zvcm0odXNlclByb2plY3Rpb24sIHByb2plY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2ZXJ0ZXggPSBjbG9zZXN0T25DaXJjbGUoXG4gICAgICAgICAgICBwcm9qZWN0ZWRDb29yZGluYXRlLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSAqLyAoY2lyY2xlR2VvbWV0cnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbc2VnbWVudFN0YXJ0LCBzZWdtZW50RW5kXSA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgICAgICAgLy8gcG9pbnRzIGhhdmUgb25seSBvbmUgY29vcmRpbmF0ZVxuICAgICAgICAgIGlmIChzZWdtZW50RW5kKSB7XG4gICAgICAgICAgICB0ZW1wU2VnbWVudFswXSA9IGZyb21Vc2VyQ29vcmRpbmF0ZShzZWdtZW50U3RhcnQsIHByb2plY3Rpb24pO1xuICAgICAgICAgICAgdGVtcFNlZ21lbnRbMV0gPSBmcm9tVXNlckNvb3JkaW5hdGUoc2VnbWVudEVuZCwgcHJvamVjdGlvbik7XG4gICAgICAgICAgICB2ZXJ0ZXggPSBjbG9zZXN0T25TZWdtZW50KHByb2plY3RlZENvb3JkaW5hdGUsIHRlbXBTZWdtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRleCkge1xuICAgICAgICAgIGNvbnN0IGRlbHRhID0gc3F1YXJlZERpc3RhbmNlKHByb2plY3RlZENvb3JkaW5hdGUsIHZlcnRleCk7XG4gICAgICAgICAgaWYgKGRlbHRhIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0VmVydGV4ID0gdG9Vc2VyQ29vcmRpbmF0ZSh2ZXJ0ZXgsIHByb2plY3Rpb24pO1xuICAgICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gZGVsdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldFJlc3VsdCgpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUZlYXR1cmVfKGZlYXR1cmUpIHtcbiAgICB0aGlzLnJlbW92ZUZlYXR1cmUoZmVhdHVyZSwgZmFsc2UpO1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj59IHNlZ21lbnRzIFNlZ21lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZWdtZW50Q2lyY2xlR2VvbWV0cnlfKHNlZ21lbnRzLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLmdldE1hcCgpLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgbGV0IGNpcmNsZUdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgY29uc3QgdXNlclByb2plY3Rpb24gPSBnZXRVc2VyUHJvamVjdGlvbigpO1xuICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgY2lyY2xlR2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgY2lyY2xlR2VvbWV0cnkuY2xvbmUoKS50cmFuc2Zvcm0odXNlclByb2plY3Rpb24sIHByb2plY3Rpb24pXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwb2x5Z29uID0gZnJvbUNpcmNsZShjaXJjbGVHZW9tZXRyeSk7XG4gICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICBwb2x5Z29uLnRyYW5zZm9ybShwcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRDb29yZGluYXRlcygpWzBdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBzZWdtZW50cyBTZWdtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VnbWVudEdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyhzZWdtZW50cywgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzZWdtZW50ZXIgPSB0aGlzLkdFT01FVFJZX1NFR01FTlRFUlNfW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXTtcbiAgICAgIGlmIChzZWdtZW50ZXIpIHtcbiAgICAgICAgc2VnbWVudGVyKHNlZ21lbnRzLCBnZW9tZXRyaWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj59IHNlZ21lbnRzIFNlZ21lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VnbWVudExpbmVTdHJpbmdHZW9tZXRyeV8oc2VnbWVudHMsIGdlb21ldHJ5KSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBzZWdtZW50cyBTZWdtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VnbWVudE11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyhzZWdtZW50cywgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBsaW5lcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpqID0gbGluZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBsaW5lc1tqXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoJy4uL2Nvb3JkaW5hdGUuanMnKS5Db29yZGluYXRlPj59IHNlZ21lbnRzIFNlZ21lbnRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VnbWVudE11bHRpUG9pbnRHZW9tZXRyeV8oc2VnbWVudHMsIGdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKS5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgc2VnbWVudHMucHVzaChbcG9pbnRdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydCgnLi4vY29vcmRpbmF0ZS5qcycpLkNvb3JkaW5hdGU+Pn0gc2VnbWVudHMgU2VnbWVudHNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlZ21lbnRNdWx0aVBvbHlnb25HZW9tZXRyeV8oc2VnbWVudHMsIGdlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9seWdvbnMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrayA9IHBvbHlnb25zLmxlbmd0aDsgayA8IGtrOyArK2spIHtcbiAgICAgIGNvbnN0IHJpbmdzID0gcG9seWdvbnNba107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSByaW5ncy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChjb29yZGluYXRlcy5zbGljZShpLCBpICsgMikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBzZWdtZW50cyBTZWdtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZWdtZW50UG9pbnRHZW9tZXRyeV8oc2VnbWVudHMsIGdlb21ldHJ5KSB7XG4gICAgc2VnbWVudHMucHVzaChbZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KCcuLi9jb29yZGluYXRlLmpzJykuQ29vcmRpbmF0ZT4+fSBzZWdtZW50cyBTZWdtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlZ21lbnRQb2x5Z29uR2VvbWV0cnlfKHNlZ21lbnRzLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJpbmdzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamogPSByaW5ncy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICBjb25zdCBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChjb29yZGluYXRlcy5zbGljZShpLCBpICsgMikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTbmFwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1RyYW5zbGF0ZVxuICovXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnLi4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7YWx3YXlzfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7ZnJvbVVzZXJDb29yZGluYXRlLCBnZXRVc2VyUHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVHJhbnNsYXRlRXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbiBzdGFydC5cbiAgICogQGV2ZW50IFRyYW5zbGF0ZUV2ZW50I3RyYW5zbGF0ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIFRSQU5TTEFURVNUQVJUOiAndHJhbnNsYXRlc3RhcnQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbi5cbiAgICogQGV2ZW50IFRyYW5zbGF0ZUV2ZW50I3RyYW5zbGF0aW5nXG4gICAqIEBhcGlcbiAgICovXG4gIFRSQU5TTEFUSU5HOiAndHJhbnNsYXRpbmcnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbiBlbmQuXG4gICAqIEBldmVudCBUcmFuc2xhdGVFdmVudCN0cmFuc2xhdGVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgVFJBTlNMQVRFRU5EOiAndHJhbnNsYXRlZW5kJyxcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX5SZW5kZXJGZWF0dXJlfSBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXJ9IGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmVhdHVyZSBtYXkgYmVcbiAqIHRyYW5zbGF0ZWQgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRmVhdHVyZSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+KTpib29sZWFufSBGaWx0ZXJGdW5jdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uYWx3YXlzfS5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxGZWF0dXJlPn0gW2ZlYXR1cmVzXSBGZWF0dXJlcyBjb250YWluZWQgaW4gdGhpcyBjb2xsZWN0aW9uIHdpbGwgYmUgYWJsZSB0byBiZSB0cmFuc2xhdGVkIHRvZ2V0aGVyLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PnxmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2VcIikuZGVmYXVsdD4pOiBib29sZWFufSBbbGF5ZXJzXSBBIGxpc3Qgb2YgbGF5ZXJzIGZyb20gd2hpY2ggZmVhdHVyZXMgc2hvdWxkIGJlXG4gKiB0cmFuc2xhdGVkLiBBbHRlcm5hdGl2ZWx5LCBhIGZpbHRlciBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQuIFRoZVxuICogZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggbGF5ZXIgaW4gdGhlIG1hcCBhbmQgc2hvdWxkIHJldHVyblxuICogYHRydWVgIGZvciBsYXllcnMgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2xhdGFibGUuIElmIHRoZSBvcHRpb24gaXNcbiAqIGFic2VudCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgY29uc2lkZXJlZCB0cmFuc2xhdGFibGUuXG4gKiBOb3QgdXNlZCBpZiBgZmVhdHVyZXNgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtGaWx0ZXJGdW5jdGlvbn0gW2ZpbHRlcl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYW5kIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyfSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgbWF5IGJlXG4gKiB0cmFuc2xhdGVkIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLiBOb3QgdXNlZCBpZiBgZmVhdHVyZXNgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuIFBpeGVscyBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGV+VHJhbnNsYXRlfSBpbnN0YW5jZXNcbiAqIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zbGF0ZUV2ZW50VHlwZX0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb248RmVhdHVyZT59IGZlYXR1cmVzIFRoZSBmZWF0dXJlcyB0cmFuc2xhdGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgZXZlbnQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHN0YXJ0Q29vcmRpbmF0ZSBUaGUgb3JpZ2luYWwgY29vcmRpbmF0ZXMgYmVmb3JlLnRyYW5zbGF0aW9uIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgZmVhdHVyZXMsIGNvb3JkaW5hdGUsIHN0YXJ0Q29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZXMgYmVpbmcgdHJhbnNsYXRlZC5cbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlPn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGRyYWcgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gY29vcmRpbmF0ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb3NpdGlvbiBiZWZvcmUgdHJhbnNsYXRpb24gc3RhcnRlZC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0Q29vcmRpbmF0ZSA9IHN0YXJ0Q29vcmRpbmF0ZTtcblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50ID0gbWFwQnJvd3NlckV2ZW50O1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZScsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8J3RyYW5zbGF0ZWVuZCd8J3RyYW5zbGF0ZXN0YXJ0J3wndHJhbnNsYXRpbmcnLCBUcmFuc2xhdGVFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJ3wndHJhbnNsYXRlZW5kJ3wndHJhbnNsYXRlc3RhcnQnfCd0cmFuc2xhdGluZycsIFJldHVybj59IFRyYW5zbGF0ZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgdHJhbnNsYXRpbmcgKG1vdmluZykgZmVhdHVyZXMuXG4gKiBJZiB5b3Ugd2FudCB0byB0cmFuc2xhdGUgbXVsdGlwbGUgZmVhdHVyZXMgaW4gYSBzaW5nbGUgYWN0aW9uIChmb3IgZXhhbXBsZSxcbiAqIHRoZSBjb2xsZWN0aW9uIHVzZWQgYnkgYSBzZWxlY3QgaW50ZXJhY3Rpb24pLCBjb25zdHJ1Y3QgdGhlIGludGVyYWN0aW9uIHdpdGhcbiAqIHRoZSBgZmVhdHVyZXNgIG9wdGlvbi5cbiAqXG4gKiBAZmlyZXMgVHJhbnNsYXRlRXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgVHJhbnNsYXRlIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcigvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucykpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtUcmFuc2xhdGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtUcmFuc2xhdGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1RyYW5zbGF0ZU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiB3ZSB0cmFuc2xhdGVkIHRvLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgcG9zaXRpb24gYmVmb3JlIHRyYW5zbGF0aW9uIHN0YXJ0ZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRDb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlPnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc18gPSBvcHRpb25zLmZlYXR1cmVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZlYXR1cmVzIDogbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+KTogYm9vbGVhbn0gKi9cbiAgICBsZXQgbGF5ZXJGaWx0ZXI7XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJzICYmICF0aGlzLmZlYXR1cmVzXykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxheWVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXllckZpbHRlciA9IG9wdGlvbnMubGF5ZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICAgIGxheWVyRmlsdGVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxheWVycy5pbmNsdWRlcyhsYXllcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyRmlsdGVyID0gVFJVRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2VcIikuZGVmYXVsdD4pOiBib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJGaWx0ZXJfID0gbGF5ZXJGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGaWx0ZXJGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcl8gPSBvcHRpb25zLmZpbHRlciAmJiAhdGhpcy5mZWF0dXJlc18gPyBvcHRpb25zLmZpbHRlciA6IFRSVUU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RGZWF0dXJlXyA9IG51bGw7XG5cbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKFxuICAgICAgSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUsXG4gICAgICB0aGlzLmhhbmRsZUFjdGl2ZUNoYW5nZWRfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgIXRoaXMuY29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmVhdHVyZV8gPSB0aGlzLmZlYXR1cmVzQXRQaXhlbF8oZXZlbnQucGl4ZWwsIGV2ZW50Lm1hcCk7XG4gICAgaWYgKCF0aGlzLmxhc3RDb29yZGluYXRlXyAmJiB0aGlzLmxhc3RGZWF0dXJlXykge1xuICAgICAgdGhpcy5zdGFydENvb3JkaW5hdGVfID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIHRoaXMubGFzdENvb3JkaW5hdGVfID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KGV2ZW50KTtcblxuICAgICAgY29uc3QgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXyB8fCBuZXcgQ29sbGVjdGlvbihbdGhpcy5sYXN0RmVhdHVyZV9dKTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgVHJhbnNsYXRlRXZlbnQoXG4gICAgICAgICAgVHJhbnNsYXRlRXZlbnRUeXBlLlRSQU5TTEFURVNUQVJULFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIGV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgICAgdGhpcy5zdGFydENvb3JkaW5hdGVfLFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMubGFzdENvb3JkaW5hdGVfKSB7XG4gICAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG51bGw7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudChldmVudCk7XG5cbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc18gfHwgbmV3IENvbGxlY3Rpb24oW3RoaXMubGFzdEZlYXR1cmVfXSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IFRyYW5zbGF0ZUV2ZW50KFxuICAgICAgICAgIFRyYW5zbGF0ZUV2ZW50VHlwZS5UUkFOU0xBVEVFTkQsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgZXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29vcmRpbmF0ZV8sXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIC8vIGNsZWFudXBcbiAgICAgIHRoaXMuc3RhcnRDb29yZGluYXRlXyA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmxhc3RDb29yZGluYXRlXykge1xuICAgICAgY29uc3QgbmV3Q29vcmRpbmF0ZSA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uID0gZXZlbnQubWFwLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKCk7XG5cbiAgICAgIGNvbnN0IG5ld1ZpZXdDb29yZGluYXRlID0gZnJvbVVzZXJDb29yZGluYXRlKG5ld0Nvb3JkaW5hdGUsIHByb2plY3Rpb24pO1xuICAgICAgY29uc3QgbGFzdFZpZXdDb29yZGluYXRlID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgICB0aGlzLmxhc3RDb29yZGluYXRlXyxcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhWCA9IG5ld1ZpZXdDb29yZGluYXRlWzBdIC0gbGFzdFZpZXdDb29yZGluYXRlWzBdO1xuICAgICAgY29uc3QgZGVsdGFZID0gbmV3Vmlld0Nvb3JkaW5hdGVbMV0gLSBsYXN0Vmlld0Nvb3JkaW5hdGVbMV07XG5cbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc18gfHwgbmV3IENvbGxlY3Rpb24oW3RoaXMubGFzdEZlYXR1cmVfXSk7XG4gICAgICBjb25zdCB1c2VyUHJvamVjdGlvbiA9IGdldFVzZXJQcm9qZWN0aW9uKCk7XG5cbiAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgY29uc3QgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgaWYgKHVzZXJQcm9qZWN0aW9uKSB7XG4gICAgICAgICAgZ2VvbS50cmFuc2Zvcm0odXNlclByb2plY3Rpb24sIHByb2plY3Rpb24pO1xuICAgICAgICAgIGdlb20udHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICBnZW9tLnRyYW5zZm9ybShwcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbS50cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sYXN0Q29vcmRpbmF0ZV8gPSBuZXdDb29yZGluYXRlO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBUcmFuc2xhdGVFdmVudChcbiAgICAgICAgICBUcmFuc2xhdGVFdmVudFR5cGUuVFJBTlNMQVRJTkcsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgbmV3Q29vcmRpbmF0ZSxcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29vcmRpbmF0ZV8sXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgbW92ZSBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlTW92ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbSA9IGV2ZW50Lm1hcC5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLy8gQ2hhbmdlIHRoZSBjdXJzb3IgdG8gZ3JhYi9ncmFiYmluZyBpZiBob3ZlcmluZyBhbnkgb2YgdGhlIGZlYXR1cmVzIG1hbmFnZWRcbiAgICAvLyBieSB0aGUgaW50ZXJhY3Rpb25cbiAgICBpZiAodGhpcy5mZWF0dXJlc0F0UGl4ZWxfKGV2ZW50LnBpeGVsLCBldmVudC5tYXApKSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sYXN0Q29vcmRpbmF0ZV8gPyAnb2wtZ3JhYicgOiAnb2wtZ3JhYmJpbmcnKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCh0aGlzLmxhc3RDb29yZGluYXRlXyA/ICdvbC1ncmFiYmluZycgOiAnb2wtZ3JhYicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ29sLWdyYWInLCAnb2wtZ3JhYmJpbmcnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgdG8gc2VlIGlmIHRoZSBnaXZlbiBjb29yZGluYXRlcyBpbnRlcnNlY3RzIGFueSBvZiBvdXIgc2VsZWN0ZWRcbiAgICogZmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsIGNvb3JkaW5hdGUgdG8gdGVzdCBmb3IgaW50ZXJzZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwIHRvIHRlc3QgdGhlIGludGVyc2VjdGlvbiBvbi5cbiAgICogQHJldHVybiB7RmVhdHVyZX0gUmV0dXJucyB0aGUgZmVhdHVyZSBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIHBpeGVsXG4gICAqIGNvb3JkaW5hdGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmVhdHVyZXNBdFBpeGVsXyhwaXhlbCwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcC5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwoXG4gICAgICBwaXhlbCxcbiAgICAgIChmZWF0dXJlLCBsYXllcikgPT4ge1xuICAgICAgICBpZiAoIShmZWF0dXJlIGluc3RhbmNlb2YgRmVhdHVyZSkgfHwgIXRoaXMuZmlsdGVyXyhmZWF0dXJlLCBsYXllcikpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzXyAmJiAhdGhpcy5mZWF0dXJlc18uZ2V0QXJyYXkoKS5pbmNsdWRlcyhmZWF0dXJlKSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcl8sXG4gICAgICAgIGhpdFRvbGVyYW5jZTogdGhpcy5oaXRUb2xlcmFuY2VfLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEhpdFRvbGVyYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUb2xlcmFuY2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRIaXRUb2xlcmFuY2UoaGl0VG9sZXJhbmNlKSB7XG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gaGl0VG9sZXJhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBjb25zdCBvbGRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHN1cGVyLnNldE1hcChtYXApO1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG9sZE1hcCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUFjdGl2ZUNoYW5nZWRfKCkge1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG9sZE1hcCBPbGQgbWFwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlU3RhdGVfKG9sZE1hcCkge1xuICAgIGxldCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKCFtYXAgfHwgIWFjdGl2ZSkge1xuICAgICAgbWFwID0gbWFwIHx8IG9sZE1hcDtcbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IG1hcC5nZXRWaWV3cG9ydCgpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ29sLWdyYWInLCAnb2wtZ3JhYmJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNsYXRlO1xuIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNy1vbmVPZi0zLTEhLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTctb25lT2YtMy0yIS4vb2wuY3NzXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMWI4Y2Y5OTNcIiwgY29udGVudCwgZmFsc2UsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTctb25lT2YtMy0xIS4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LW9uZU9mLTMtMiEuL29sLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTctb25lT2YtMy0xIS4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LW9uZU9mLTMtMiEuL29sLmNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvKipcbiAqIEBtb2R1bGUgb2wveG1sXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBXaGVuIHVzaW5nIHtAbGluayBtb2R1bGU6b2wveG1sLm1ha2VDaGlsZEFwcGVuZGVyfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC94bWwubWFrZVNpbXBsZU5vZGVGYWN0b3J5fSwgdGhlIHRvcCBgb2JqZWN0U3RhY2tgIGl0ZW0gbmVlZHNcbiAqIHRvIGhhdmUgdGhpcyBzdHJ1Y3R1cmUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBOb2RlU3RhY2tJdGVtXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFbGVtZW50LCBBcnJheTwqPik6IHZvaWR9IFBhcnNlclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEVsZW1lbnQsICosIEFycmF5PCo+KTogdm9pZH0gU2VyaWFsaXplclxuICovXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFhNTF9TQ0hFTUFfSU5TVEFOQ0VfVVJJID1cbiAgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlVVJJIE5hbWVzcGFjZSBVUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZSBRdWFsaWZpZWQgbmFtZS5cbiAqIEByZXR1cm4ge0VsZW1lbnR9IE5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKSB7XG4gIHJldHVybiBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGdyYWIgYWxsIHRleHQgY29udGVudCBvZiBjaGlsZCBub2RlcyBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtib29sZWFufSBub3JtYWxpemVXaGl0ZXNwYWNlIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlOiByZW1vdmUgYWxsIGxpbmVcbiAqIGJyZWFrcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQWxsIHRleHQgY29udGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFRleHRDb250ZW50KG5vZGUsIG5vcm1hbGl6ZVdoaXRlc3BhY2UpIHtcbiAgcmV0dXJuIGdldEFsbFRleHRDb250ZW50Xyhub2RlLCBub3JtYWxpemVXaGl0ZXNwYWNlLCBbXSkuam9pbignJyk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZ3JhYiBhbGwgdGV4dCBjb250ZW50IG9mIGNoaWxkIG5vZGVzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5vcm1hbGl6ZVdoaXRlc3BhY2UgTm9ybWFsaXplIHdoaXRlc3BhY2U6IHJlbW92ZSBhbGwgbGluZVxuICogYnJlYWtzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhY2N1bXVsYXRvciBBY2N1bXVsYXRvci5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBY2N1bXVsYXRvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFRleHRDb250ZW50Xyhub2RlLCBub3JtYWxpemVXaGl0ZXNwYWNlLCBhY2N1bXVsYXRvcikge1xuICBpZiAoXG4gICAgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLkNEQVRBX1NFQ1RJT05fTk9ERSB8fFxuICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREVcbiAgKSB7XG4gICAgaWYgKG5vcm1hbGl6ZVdoaXRlc3BhY2UpIHtcbiAgICAgIGFjY3VtdWxhdG9yLnB1c2goU3RyaW5nKG5vZGUubm9kZVZhbHVlKS5yZXBsYWNlKC8oXFxyXFxufFxccnxcXG4pL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yLnB1c2gobm9kZS5ub2RlVmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgbjtcbiAgICBmb3IgKG4gPSBub2RlLmZpcnN0Q2hpbGQ7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBnZXRBbGxUZXh0Q29udGVudF8obiwgbm9ybWFsaXplV2hpdGVzcGFjZSwgYWNjdW11bGF0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBhIGRvY3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEb2N1bWVudChvYmplY3QpIHtcbiAgcmV0dXJuICdkb2N1bWVudEVsZW1lbnQnIGluIG9iamVjdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlVVJJIE5hbWVzcGFjZSBVUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKG5vZGUsIG5hbWVzcGFjZVVSSSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIFhNTCBzdHJpbmcgdG8gYW4gWE1MIERvY3VtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHhtbCBYTUwuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gRG9jdW1lbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh4bWwpIHtcbiAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeG1sLCAnYXBwbGljYXRpb24veG1sJyk7XG59XG5cbi8qKlxuICogTWFrZSBhbiBhcnJheSBleHRlbmRlciBmdW5jdGlvbiBmb3IgZXh0ZW5kaW5nIHRoZSBhcnJheSBhdCB0aGUgdG9wIG9mIHRoZVxuICogb2JqZWN0IHN0YWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBOb2RlLCBBcnJheTwqPik6IChBcnJheTwqPnx1bmRlZmluZWQpfSB2YWx1ZVJlYWRlciBWYWx1ZSByZWFkZXIuXG4gKiBAcGFyYW0ge1R9IFt0aGlzQXJnXSBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYHZhbHVlUmVhZGVyYC5cbiAqIEByZXR1cm4ge1BhcnNlcn0gUGFyc2VyLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBcnJheUV4dGVuZGVyKHZhbHVlUmVhZGVyLCB0aGlzQXJnKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlLCBvYmplY3RTdGFjaykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVJlYWRlci5jYWxsKFxuICAgICAgICB0aGlzQXJnICE9PSB1bmRlZmluZWQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2JqZWN0U3RhY2tcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChcbiAgICAgICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICAgICApO1xuICAgICAgICBleHRlbmQoYXJyYXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogTWFrZSBhbiBhcnJheSBwdXNoZXIgZnVuY3Rpb24gZm9yIHB1c2hpbmcgdG8gdGhlIGFycmF5IGF0IHRoZSB0b3Agb2YgdGhlXG4gKiBvYmplY3Qgc3RhY2suXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIEVsZW1lbnQsIEFycmF5PCo+KTogKn0gdmFsdWVSZWFkZXIgVmFsdWUgcmVhZGVyLlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGB2YWx1ZVJlYWRlcmAuXG4gKiBAcmV0dXJuIHtQYXJzZXJ9IFBhcnNlci5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXJyYXlQdXNoZXIodmFsdWVSZWFkZXIsIHRoaXNBcmcpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5vZGUsIG9iamVjdFN0YWNrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlUmVhZGVyLmNhbGwoXG4gICAgICAgIHRoaXNBcmcgIT09IHVuZGVmaW5lZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICBub2RlLFxuICAgICAgICBvYmplY3RTdGFja1xuICAgICAgKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKFxuICAgICAgICAgIG9iamVjdFN0YWNrW29iamVjdFN0YWNrLmxlbmd0aCAtIDFdXG4gICAgICAgICk7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIG9iamVjdCBzdGFjayByZXBsYWNlciBmdW5jdGlvbiBmb3IgcmVwbGFjaW5nIHRoZSBvYmplY3QgYXQgdGhlXG4gKiB0b3Agb2YgdGhlIHN0YWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBOb2RlLCBBcnJheTwqPik6ICp9IHZhbHVlUmVhZGVyIFZhbHVlIHJlYWRlci5cbiAqIEBwYXJhbSB7VH0gW3RoaXNBcmddIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgdmFsdWVSZWFkZXJgLlxuICogQHJldHVybiB7UGFyc2VyfSBQYXJzZXIuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlcGxhY2VyKHZhbHVlUmVhZGVyLCB0aGlzQXJnKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlLCBvYmplY3RTdGFjaykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVJlYWRlci5jYWxsKFxuICAgICAgICB0aGlzQXJnICE9PSB1bmRlZmluZWQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2JqZWN0U3RhY2tcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIG9iamVjdCBwcm9wZXJ0eSBwdXNoZXIgZnVuY3Rpb24gZm9yIGFkZGluZyBhIHByb3BlcnR5IHRvIHRoZVxuICogb2JqZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBFbGVtZW50LCBBcnJheTwqPik6ICp9IHZhbHVlUmVhZGVyIFZhbHVlIHJlYWRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIFByb3BlcnR5LlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGB2YWx1ZVJlYWRlcmAuXG4gKiBAcmV0dXJuIHtQYXJzZXJ9IFBhcnNlci5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JqZWN0UHJvcGVydHlQdXNoZXIodmFsdWVSZWFkZXIsIHByb3BlcnR5LCB0aGlzQXJnKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlLCBvYmplY3RTdGFjaykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVJlYWRlci5jYWxsKFxuICAgICAgICB0aGlzQXJnICE9PSB1bmRlZmluZWQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2JqZWN0U3RhY2tcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvYmplY3QgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChcbiAgICAgICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBuYW1lID0gcHJvcGVydHkgIT09IHVuZGVmaW5lZCA/IHByb3BlcnR5IDogbm9kZS5sb2NhbE5hbWU7XG4gICAgICAgIGxldCBhcnJheTtcbiAgICAgICAgaWYgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgYXJyYXkgPSBvYmplY3RbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXkgPSBbXTtcbiAgICAgICAgICBvYmplY3RbbmFtZV0gPSBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogTWFrZSBhbiBvYmplY3QgcHJvcGVydHkgc2V0dGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBFbGVtZW50LCBBcnJheTwqPik6ICp9IHZhbHVlUmVhZGVyIFZhbHVlIHJlYWRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIFByb3BlcnR5LlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGB2YWx1ZVJlYWRlcmAuXG4gKiBAcmV0dXJuIHtQYXJzZXJ9IFBhcnNlci5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JqZWN0UHJvcGVydHlTZXR0ZXIodmFsdWVSZWFkZXIsIHByb3BlcnR5LCB0aGlzQXJnKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChub2RlLCBvYmplY3RTdGFjaykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVJlYWRlci5jYWxsKFxuICAgICAgICB0aGlzQXJnICE9PSB1bmRlZmluZWQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2JqZWN0U3RhY2tcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvYmplY3QgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChcbiAgICAgICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBuYW1lID0gcHJvcGVydHkgIT09IHVuZGVmaW5lZCA/IHByb3BlcnR5IDogbm9kZS5sb2NhbE5hbWU7XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzZXJpYWxpemVyIHRoYXQgYXBwZW5kcyBub2RlcyB3cml0dGVuIGJ5IGl0cyBgbm9kZVdyaXRlcmAgdG8gaXRzXG4gKiBkZXNpZ25hdGVkIHBhcmVudC4gVGhlIHBhcmVudCBpcyB0aGUgYG5vZGVgIG9mIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC94bWx+Tm9kZVN0YWNrSXRlbX0gYXQgdGhlIHRvcCBvZiB0aGUgYG9iamVjdFN0YWNrYC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgTm9kZSwgViwgQXJyYXk8Kj4pOiB2b2lkfSBub2RlV3JpdGVyIE5vZGUgd3JpdGVyLlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBub2RlV3JpdGVyYC5cbiAqIEByZXR1cm4ge1NlcmlhbGl6ZXJ9IFNlcmlhbGl6ZXIuXG4gKiBAdGVtcGxhdGUgVCwgVlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNoaWxkQXBwZW5kZXIobm9kZVdyaXRlciwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIHZhbHVlLCBvYmplY3RTdGFjaykge1xuICAgIG5vZGVXcml0ZXIuY2FsbChcbiAgICAgIHRoaXNBcmcgIT09IHVuZGVmaW5lZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgbm9kZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb2JqZWN0U3RhY2tcbiAgICApO1xuICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7Tm9kZVN0YWNrSXRlbX0gKi8gKFxuICAgICAgb2JqZWN0U3RhY2tbb2JqZWN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICApO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnQubm9kZTtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNlcmlhbGl6ZXIgdGhhdCBjYWxscyB0aGUgcHJvdmlkZWQgYG5vZGVXcml0ZXJgIGZyb21cbiAqIHtAbGluayBtb2R1bGU6b2wveG1sLnNlcmlhbGl6ZX0uIFRoaXMgY2FuIGJlIHVzZWQgYnkgdGhlIHBhcmVudCB3cml0ZXIgdG8gaGF2ZSB0aGVcbiAqIGBub2RlV3JpdGVyYCBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiB2YWx1ZXMgd2hlbiB0aGUgYG5vZGVXcml0ZXJgIHdhc1xuICogZGVzaWduZWQgdG8gc2VyaWFsaXplIGEgc2luZ2xlIGl0ZW0uIEFuIGV4YW1wbGUgd291bGQgYmUgYSBMaW5lU3RyaW5nXG4gKiBnZW9tZXRyeSB3cml0ZXIsIHdoaWNoIGNvdWxkIGJlIHJldXNlZCBmb3Igd3JpdGluZyBNdWx0aUxpbmVTdHJpbmdcbiAqIGdlb21ldHJpZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIEVsZW1lbnQsIFYsIEFycmF5PCo+KTogdm9pZH0gbm9kZVdyaXRlciBOb2RlIHdyaXRlci5cbiAqIEBwYXJhbSB7VH0gW3RoaXNBcmddIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgbm9kZVdyaXRlcmAuXG4gKiBAcmV0dXJuIHtTZXJpYWxpemVyfSBTZXJpYWxpemVyLlxuICogQHRlbXBsYXRlIFQsIFZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBcnJheVNlcmlhbGl6ZXIobm9kZVdyaXRlciwgdGhpc0FyZykge1xuICBsZXQgc2VyaWFsaXplcnNOUywgbm9kZUZhY3Rvcnk7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSwgdmFsdWUsIG9iamVjdFN0YWNrKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXJzTlMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplcnNOUyA9IHt9O1xuICAgICAgY29uc3Qgc2VyaWFsaXplcnMgPSB7fTtcbiAgICAgIHNlcmlhbGl6ZXJzW25vZGUubG9jYWxOYW1lXSA9IG5vZGVXcml0ZXI7XG4gICAgICBzZXJpYWxpemVyc05TW25vZGUubmFtZXNwYWNlVVJJXSA9IHNlcmlhbGl6ZXJzO1xuICAgICAgbm9kZUZhY3RvcnkgPSBtYWtlU2ltcGxlTm9kZUZhY3Rvcnkobm9kZS5sb2NhbE5hbWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUoc2VyaWFsaXplcnNOUywgbm9kZUZhY3RvcnksIHZhbHVlLCBvYmplY3RTdGFjayk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbm9kZSBmYWN0b3J5IHdoaWNoIGNhbiB1c2UgdGhlIGBrZXlzYCBwYXNzZWQgdG9cbiAqIHtAbGluayBtb2R1bGU6b2wveG1sLnNlcmlhbGl6ZX0gb3Ige0BsaW5rIG1vZHVsZTpvbC94bWwucHVzaFNlcmlhbGl6ZUFuZFBvcH0gYXMgbm9kZSBuYW1lcyxcbiAqIG9yIGEgZml4ZWQgbm9kZSBuYW1lLiBUaGUgbmFtZXNwYWNlIG9mIHRoZSBjcmVhdGVkIG5vZGVzIGNhbiBlaXRoZXIgYmUgZml4ZWQsXG4gKiBvciB0aGUgcGFyZW50IG5hbWVzcGFjZSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZpeGVkTm9kZU5hbWVdIEZpeGVkIG5vZGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGFsbFxuICogICAgIGNyZWF0ZWQgbm9kZXMuIElmIG5vdCBwcm92aWRlZCwgdGhlIDNyZCBhcmd1bWVudCB0byB0aGUgcmVzdWx0aW5nIG5vZGVcbiAqICAgICBmYWN0b3J5IG5lZWRzIHRvIGJlIHByb3ZpZGVkIGFuZCB3aWxsIGJlIHRoZSBub2RlTmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZml4ZWROYW1lc3BhY2VVUkldIEZpeGVkIG5hbWVzcGFjZSBVUkkgd2hpY2ggd2lsbCBiZSB1c2VkIGZvclxuICogICAgIGFsbCBjcmVhdGVkIG5vZGVzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIHBhcmVudCBub2RlIHdpbGxcbiAqICAgICBiZSB1c2VkLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfSBOb2RlIGZhY3RvcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2ltcGxlTm9kZUZhY3RvcnkoZml4ZWROb2RlTmFtZSwgZml4ZWROYW1lc3BhY2VVUkkpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IG9iamVjdFN0YWNrIE9iamVjdCBzdGFjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25ld05vZGVOYW1lXSBOb2RlIG5hbWUuXG4gICAgICogQHJldHVybiB7Tm9kZX0gTm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodmFsdWUsIG9iamVjdFN0YWNrLCBuZXdOb2RlTmFtZSkge1xuICAgICAgY29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7Tm9kZVN0YWNrSXRlbX0gKi8gKFxuICAgICAgICBvYmplY3RTdGFja1tvYmplY3RTdGFjay5sZW5ndGggLSAxXVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0Lm5vZGU7XG4gICAgICBsZXQgbm9kZU5hbWUgPSBmaXhlZE5vZGVOYW1lO1xuICAgICAgaWYgKG5vZGVOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZU5hbWUgPSBuZXdOb2RlTmFtZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZXNwYWNlVVJJID1cbiAgICAgICAgZml4ZWROYW1lc3BhY2VVUkkgIT09IHVuZGVmaW5lZCA/IGZpeGVkTmFtZXNwYWNlVVJJIDogbm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovIChub2RlTmFtZSkpO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBub2RlIHVzaW5nIHRoZSBwYXJlbnQncyBgbmFtZXNwYWNlVVJJYCBhbmQgdGhlXG4gKiBgbm9kZU5hbWVgIHBhc3NlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3htbC5zZXJpYWxpemV9IG9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3htbC5wdXNoU2VyaWFsaXplQW5kUG9wfSB0byB0aGUgbm9kZSBmYWN0b3J5LlxuICogQGNvbnN0XG4gKiBAdHlwZSB7ZnVuY3Rpb24oKiwgQXJyYXk8Kj4sIHN0cmluZz0pOiAoTm9kZXx1bmRlZmluZWQpfVxuICovXG5leHBvcnQgY29uc3QgT0JKRUNUX1BST1BFUlRZX05PREVfRkFDVE9SWSA9IG1ha2VTaW1wbGVOb2RlRmFjdG9yeSgpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBgdmFsdWVzYCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIG1vZHVsZTpvbC94bWwuc2VyaWFsaXplfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC94bWwucHVzaFNlcmlhbGl6ZUFuZFBvcH0sIHdoZXJlIGBvcmRlcmVkS2V5c2AgaGFzIHRvIGJlIHByb3ZpZGVkIGFzXG4gKiBga2V5YCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IG9iamVjdCBLZXktdmFsdWUgcGFpcnMgZm9yIHRoZSBzZXF1ZW5jZS4gS2V5cyBjYW5cbiAqICAgICBiZSBhIHN1YnNldCBvZiB0aGUgYG9yZGVyZWRLZXlzYC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gb3JkZXJlZEtleXMgS2V5cyBpbiB0aGUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlLlxuICogQHJldHVybiB7QXJyYXk8Kj59IFZhbHVlcyBpbiB0aGUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlLiBUaGUgcmVzdWx0aW5nIGFycmF5XG4gKiAgICAgaGFzIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgYG9yZGVyZWRLZXlzYCBhcnJheS4gVmFsdWVzIHRoYXQgYXJlIG5vdFxuICogICAgIHByZXNlbnQgaW4gYG9iamVjdGAgd2lsbCBiZSBgdW5kZWZpbmVkYCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNlcXVlbmNlKG9iamVjdCwgb3JkZXJlZEtleXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gb3JkZXJlZEtleXMubGVuZ3RoO1xuICBjb25zdCBzZXF1ZW5jZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgc2VxdWVuY2VbaV0gPSBvYmplY3Rbb3JkZXJlZEtleXNbaV1dO1xuICB9XG4gIHJldHVybiBzZXF1ZW5jZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuYW1lc3BhY2VkIHN0cnVjdHVyZSwgdXNpbmcgdGhlIHNhbWUgdmFsdWVzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCBmb3IgdmVyc2lvbmVkIHBhcnNlcnMsIHdoZW4gb25seSBhIGZld1xuICogdmFsdWVzIGFyZSB2ZXJzaW9uIHNwZWNpZmljLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBuYW1lc3BhY2VVUklzIE5hbWVzcGFjZSBVUklzLlxuICogQHBhcmFtIHtUfSBzdHJ1Y3R1cmUgU3RydWN0dXJlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBUPn0gW3N0cnVjdHVyZU5TXSBOYW1lc3BhY2VkIHN0cnVjdHVyZSB0byBhZGQgdG8uXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBUPn0gTmFtZXNwYWNlZCBzdHJ1Y3R1cmUuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVN0cnVjdHVyZU5TKG5hbWVzcGFjZVVSSXMsIHN0cnVjdHVyZSwgc3RydWN0dXJlTlMpIHtcbiAgc3RydWN0dXJlTlMgPSBzdHJ1Y3R1cmVOUyAhPT0gdW5kZWZpbmVkID8gc3RydWN0dXJlTlMgOiB7fTtcbiAgbGV0IGksIGlpO1xuICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzcGFjZVVSSXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHN0cnVjdHVyZU5TW25hbWVzcGFjZVVSSXNbaV1dID0gc3RydWN0dXJlO1xuICB9XG4gIHJldHVybiBzdHJ1Y3R1cmVOUztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIG5vZGUgdXNpbmcgdGhlIHBhcnNlcnMgYW5kIG9iamVjdCBzdGFjay5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgUGFyc2VyPj59IHBhcnNlcnNOU1xuICogICAgIFBhcnNlcnMgYnkgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBvYmplY3RTdGFjayBPYmplY3Qgc3RhY2suXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU5vZGUocGFyc2Vyc05TLCBub2RlLCBvYmplY3RTdGFjaywgdGhpc0FyZykge1xuICBsZXQgbjtcbiAgZm9yIChuID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgbjsgbiA9IG4ubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgY29uc3QgcGFyc2VycyA9IHBhcnNlcnNOU1tuLm5hbWVzcGFjZVVSSV07XG4gICAgaWYgKHBhcnNlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gcGFyc2Vyc1tuLmxvY2FsTmFtZV07XG4gICAgICBpZiAocGFyc2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VyLmNhbGwodGhpc0FyZywgbiwgb2JqZWN0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYW4gb2JqZWN0IG9uIHRvcCBvZiB0aGUgc3RhY2ssIHBhcnNlIGFuZCByZXR1cm4gdGhlIHBvcHBlZCBvYmplY3QuXG4gKiBAcGFyYW0ge1R9IG9iamVjdCBPYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIFBhcnNlcj4+fSBwYXJzZXJzTlNcbiAqICAgICBQYXJzZXJzIGJ5IG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgT2JqZWN0IHN0YWNrLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgLlxuICogQHJldHVybiB7VH0gT2JqZWN0LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2hQYXJzZUFuZFBvcChvYmplY3QsIHBhcnNlcnNOUywgbm9kZSwgb2JqZWN0U3RhY2ssIHRoaXNBcmcpIHtcbiAgb2JqZWN0U3RhY2sucHVzaChvYmplY3QpO1xuICBwYXJzZU5vZGUocGFyc2Vyc05TLCBub2RlLCBvYmplY3RTdGFjaywgdGhpc0FyZyk7XG4gIHJldHVybiAvKiogQHR5cGUge1R9ICovIChvYmplY3RTdGFjay5wb3AoKSk7XG59XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFuIGFycmF5IG9mIGB2YWx1ZXNgIGFuZCBjYWxsIGEgc2VyaWFsaXplciBmb3IgZWFjaCB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgU2VyaWFsaXplcj4+fSBzZXJpYWxpemVyc05TXG4gKiAgICAgTmFtZXNwYWNlZCBzZXJpYWxpemVycy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgKiwgQXJyYXk8Kj4sIChzdHJpbmd8dW5kZWZpbmVkKSk6IChOb2RlfHVuZGVmaW5lZCl9IG5vZGVGYWN0b3J5XG4gKiAgICAgTm9kZSBmYWN0b3J5LiBUaGUgYG5vZGVGYWN0b3J5YCBjcmVhdGVzIHRoZSBub2RlIHdob3NlIG5hbWVzcGFjZSBhbmQgbmFtZVxuICogICAgIHdpbGwgYmUgdXNlZCB0byBjaG9vc2UgYSBub2RlIHdyaXRlciBmcm9tIGBzZXJpYWxpemVyc05TYC4gVGhpc1xuICogICAgIHNlcGFyYXRpb24gYWxsb3dzIHVzIHRvIGRlY2lkZSB3aGF0IGtpbmQgb2Ygbm9kZSB0byBjcmVhdGUsIGRlcGVuZGluZyBvblxuICogICAgIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHNlcmlhbGl6ZS4gQW4gZXhhbXBsZSBmb3IgdGhpcyB3b3VsZCBiZSBkaWZmZXJlbnRcbiAqICAgICBnZW9tZXRyeSB3cml0ZXJzIGJhc2VkIG9uIHRoZSBnZW9tZXRyeSB0eXBlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzIFZhbHVlcyB0byBzZXJpYWxpemUuIEFuIGV4YW1wbGUgd291bGQgYmUgYW4gYXJyYXlcbiAqICAgICBvZiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gaW5zdGFuY2VzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2tleXNdIEtleXMgb2YgdGhlIGB2YWx1ZXNgLiBXaWxsIGJlIHBhc3NlZCB0byB0aGVcbiAqICAgICBgbm9kZUZhY3RvcnlgLiBUaGlzIGlzIHVzZWQgZm9yIHNlcmlhbGl6aW5nIG9iamVjdCBsaXRlcmFscyB3aGVyZSB0aGVcbiAqICAgICBub2RlIG5hbWUgcmVsYXRlcyB0byB0aGUgcHJvcGVydHkga2V5LiBUaGUgYXJyYXkgbGVuZ3RoIG9mIGBrZXlzYCBoYXNcbiAqICAgICB0byBtYXRjaCB0aGUgbGVuZ3RoIG9mIGB2YWx1ZXNgLiBGb3Igc2VyaWFsaXppbmcgYSBzZXF1ZW5jZSwgYGtleXNgXG4gKiAgICAgZGV0ZXJtaW5lcyB0aGUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGZvciB0aGUgbm9kZSBmYWN0b3J5IGFuZFxuICogICAgIHNlcmlhbGl6ZXJzLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShcbiAgc2VyaWFsaXplcnNOUyxcbiAgbm9kZUZhY3RvcnksXG4gIHZhbHVlcyxcbiAgb2JqZWN0U3RhY2ssXG4gIGtleXMsXG4gIHRoaXNBcmdcbikge1xuICBjb25zdCBsZW5ndGggPSAoa2V5cyAhPT0gdW5kZWZpbmVkID8ga2V5cyA6IHZhbHVlcykubGVuZ3RoO1xuICBsZXQgdmFsdWUsIG5vZGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZSA9IG5vZGVGYWN0b3J5LmNhbGwoXG4gICAgICAgIHRoaXNBcmcgIT09IHVuZGVmaW5lZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2JqZWN0U3RhY2ssXG4gICAgICAgIGtleXMgIT09IHVuZGVmaW5lZCA/IGtleXNbaV0gOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZXJzTlNbbm9kZS5uYW1lc3BhY2VVUkldW25vZGUubG9jYWxOYW1lXS5jYWxsKFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvYmplY3RTdGFja1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T30gb2JqZWN0IE9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgU2VyaWFsaXplcj4+fSBzZXJpYWxpemVyc05TXG4gKiAgICAgTmFtZXNwYWNlZCBzZXJpYWxpemVycy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgKiwgQXJyYXk8Kj4sIChzdHJpbmd8dW5kZWZpbmVkKSk6IChOb2RlfHVuZGVmaW5lZCl9IG5vZGVGYWN0b3J5XG4gKiAgICAgTm9kZSBmYWN0b3J5LiBUaGUgYG5vZGVGYWN0b3J5YCBjcmVhdGVzIHRoZSBub2RlIHdob3NlIG5hbWVzcGFjZSBhbmQgbmFtZVxuICogICAgIHdpbGwgYmUgdXNlZCB0byBjaG9vc2UgYSBub2RlIHdyaXRlciBmcm9tIGBzZXJpYWxpemVyc05TYC4gVGhpc1xuICogICAgIHNlcGFyYXRpb24gYWxsb3dzIHVzIHRvIGRlY2lkZSB3aGF0IGtpbmQgb2Ygbm9kZSB0byBjcmVhdGUsIGRlcGVuZGluZyBvblxuICogICAgIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHNlcmlhbGl6ZS4gQW4gZXhhbXBsZSBmb3IgdGhpcyB3b3VsZCBiZSBkaWZmZXJlbnRcbiAqICAgICBnZW9tZXRyeSB3cml0ZXJzIGJhc2VkIG9uIHRoZSBnZW9tZXRyeSB0eXBlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzIFZhbHVlcyB0byBzZXJpYWxpemUuIEFuIGV4YW1wbGUgd291bGQgYmUgYW4gYXJyYXlcbiAqICAgICBvZiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gaW5zdGFuY2VzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gb2JqZWN0U3RhY2sgTm9kZSBzdGFjay5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2tleXNdIEtleXMgb2YgdGhlIGB2YWx1ZXNgLiBXaWxsIGJlIHBhc3NlZCB0byB0aGVcbiAqICAgICBgbm9kZUZhY3RvcnlgLiBUaGlzIGlzIHVzZWQgZm9yIHNlcmlhbGl6aW5nIG9iamVjdCBsaXRlcmFscyB3aGVyZSB0aGVcbiAqICAgICBub2RlIG5hbWUgcmVsYXRlcyB0byB0aGUgcHJvcGVydHkga2V5LiBUaGUgYXJyYXkgbGVuZ3RoIG9mIGBrZXlzYCBoYXNcbiAqICAgICB0byBtYXRjaCB0aGUgbGVuZ3RoIG9mIGB2YWx1ZXNgLiBGb3Igc2VyaWFsaXppbmcgYSBzZXF1ZW5jZSwgYGtleXNgXG4gKiAgICAgZGV0ZXJtaW5lcyB0aGUgb3JkZXIgb2YgdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtUfSBbdGhpc0FyZ10gVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGZvciB0aGUgbm9kZSBmYWN0b3J5IGFuZFxuICogICAgIHNlcmlhbGl6ZXJzLlxuICogQHJldHVybiB7T3x1bmRlZmluZWR9IE9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBPLCBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoU2VyaWFsaXplQW5kUG9wKFxuICBvYmplY3QsXG4gIHNlcmlhbGl6ZXJzTlMsXG4gIG5vZGVGYWN0b3J5LFxuICB2YWx1ZXMsXG4gIG9iamVjdFN0YWNrLFxuICBrZXlzLFxuICB0aGlzQXJnXG4pIHtcbiAgb2JqZWN0U3RhY2sucHVzaChvYmplY3QpO1xuICBzZXJpYWxpemUoc2VyaWFsaXplcnNOUywgbm9kZUZhY3RvcnksIHZhbHVlcywgb2JqZWN0U3RhY2ssIGtleXMsIHRoaXNBcmcpO1xuICByZXR1cm4gLyoqIEB0eXBlIHtPfHVuZGVmaW5lZH0gKi8gKG9iamVjdFN0YWNrLnBvcCgpKTtcbn1cblxubGV0IHhtbFNlcmlhbGl6ZXJfID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgWE1MU2VyaWFsaXplci4gQ2FuIGJlIHVzZWQgIHRvIGluamVjdCBhIFhNTFNlcmlhbGl6ZXJcbiAqIHdoZXJlIHRoZXJlIGlzIG5vIGdsb2JhbGx5IGF2YWlsYWJsZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1hNTFNlcmlhbGl6ZXJ9IHhtbFNlcmlhbGl6ZXIgQSBYTUxTZXJpYWxpemVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJYTUxTZXJpYWxpemVyKHhtbFNlcmlhbGl6ZXIpIHtcbiAgeG1sU2VyaWFsaXplcl8gPSB4bWxTZXJpYWxpemVyO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge1hNTFNlcmlhbGl6ZXJ9IFRoZSBYTUxTZXJpYWxpemVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0WE1MU2VyaWFsaXplcigpIHtcbiAgaWYgKHhtbFNlcmlhbGl6ZXJfID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIFhNTFNlcmlhbGl6ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgeG1sU2VyaWFsaXplcl8gPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICB9XG4gIHJldHVybiB4bWxTZXJpYWxpemVyXztcbn1cblxubGV0IGRvY3VtZW50XyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIERvY3VtZW50IHRvIHVzZSB3aGVuIGNyZWF0aW5nIG5vZGVzIGZvciBYTUwgc2VyaWFsaXphdGlvbnMuIENhbiBiZSB1c2VkXG4gKiB0byBpbmplY3QgYSBEb2N1bWVudCB3aGVyZSB0aGVyZSBpcyBubyBnbG9iYWxseSBhdmFpbGFibGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgQSBEb2N1bWVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRfID0gZG9jdW1lbnQ7XG59XG5cbi8qKlxuICogR2V0IGEgZG9jdW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGNyZWF0aW5nIG5vZGVzIGZvciBYTUwgc2VyaWFsaXphdGlvbnMuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gVGhlIGRvY3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gIGlmIChkb2N1bWVudF8gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jdW1lbnRfID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoJycsICcnLCBudWxsKTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnRfO1xufVxuIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWE5YmE3ZWQ0Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNmNlODY1MTZcIiwgY29udGVudCwgZmFsc2UsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1hOWJhN2VkNCZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWE5YmE3ZWQ0Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIik7XG4gICAgIGlmKG5ld0NvbnRlbnQuX19lc01vZHVsZSkgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuZGVmYXVsdDtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiaW1wb3J0IHJlcXVlc3QgZnJvbSBcIi4vcmVxdWVzdFwiO1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IOmmlumhtSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8v546v5L+d56CBXHJcbmV4cG9ydCBjb25zdCBxdWVyeVN1cGVydmlzaW9uID0gKCkgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9ob21lL3N1cGVydmlzaW9uJyxcclxuICAgICAgICBtZXRob2Q6ICdnZXQnLFxyXG4gICAgICAgIHBhcmFtczoge31cclxuICAgIH0pXHJcbn07XHJcbi8v546v5L+d56CB5Y+Y5YyW6LaL5Yq/XHJcbmV4cG9ydCBjb25zdCBxdWVyeUhibVRyZW5kID0gKHBhcmFtcykgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9ob21lL2NoYW5naW5nX3RyZW5kcycsXHJcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcclxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgfSlcclxufTtcclxuLy/njq/kv53noIHljp/lm6DliIbmnpBcclxuZXhwb3J0IGNvbnN0IHF1ZXJ5SGJtQW5hbHlzaXMgPSAocGFyYW1zKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2hvbWUvY2F1c2VfYW5hbHlzaXMnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgIH0pXHJcbn07XHJcbi8v546v5L+d56CB5Y6f5Zug6K+m5oOFXHJcbmV4cG9ydCBjb25zdCBxdWVyeUhibUNvZGVBbmFseXNpcyA9IChwYXJhbXMpID0+e1xyXG4gICAgcmV0dXJuIHJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9oZWFsdGgvaG9tZS9wb2xsdXRpb25fZGV0YWlsJyxcclxuICAgICAgICBtZXRob2Q6ICdnZXQnLFxyXG4gICAgICAgIHBhcmFtczogcGFyYW1zXHJcbiAgICB9KVxyXG59O1xyXG4vL+W+heWuoeaguOWIl+ihqFxyXG5leHBvcnQgY29uc3QgcXVlcnlBcHByb3ZhbExpc3QgPSAocGFyYW1zKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2V4YW1pbmUvcGVuZGluZ19yZXZpZXdfbGlzdCcsXHJcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcclxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgfSlcclxufTtcclxuLy/lrqHmoLhcclxuZXhwb3J0IGNvbnN0IHN1Ym1pdERlcHRBcHByb3ZhbCA9IChwYXJhbXMpID0+e1xyXG4gICAgcmV0dXJuIHJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9oZWFsdGgvZXhhbWluZS9kZXBhcnRtZW50X2FwcHJvdmFsJyxcclxuICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICBkYXRhOiBwYXJhbXNcclxuICAgIH0pXHJcbn07XHJcbi8vIOi1i+eggeexu+Wei+S4i+aLieahhlxyXG5leHBvcnQgY29uc3QgcXVlcnlDbHVlVHlwZXMgPSAoKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2V4YW1pbmUvdHlwZV9saXN0JyxcclxuICAgICAgICBtZXRob2Q6ICdnZXQnLFxyXG4gICAgICAgIHBhcmFtczoge31cclxuICAgIH0pXHJcbn07XHJcbi8v5rGh5p+T5rqQ5YiX6KGoXHJcbmV4cG9ydCBjb25zdCBxdWVyeVdSWUxpc3QgPSAocGFyYW1zKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2hvbWUvcG9sbHV0aW9uX2xpc3QnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgIH0pXHJcbn07XHJcbi8v5Yy65Z+f5LiL5ouJ5qGGXHJcbmV4cG9ydCBjb25zdCBxdWVyeUFyZWFzID0gKCkgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9ob21lL2RpdmlzaW9uX2xpc3QnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiB7fVxyXG4gICAgfSlcclxufTtcclxuLy/ku7vliqHmpoLmi6xcclxuZXhwb3J0IGNvbnN0IGdldFRhc2tJbmZvID0gKCkgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9sYXcvdGFza19zdW1tYXJpemUnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiB7fVxyXG4gICAgfSlcclxufTtcclxuLy/po47pmanmgLvop4hcclxuZXhwb3J0IGNvbnN0IGdldEV2YWx1YXRlSW5mbyA9IChkYXRhKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2V2YWx1YXRlL3JlZ2lvbl9tYXAnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiBkYXRhXHJcbiAgICB9KVxyXG59O1xyXG4vLyDpo47pmanpl67popjnsbvlnotcclxuZXhwb3J0IGNvbnN0IGdldFJpc2tUeXBlID0gKCkgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9ldmFsdWF0ZS90b3BfaW5mbycsXHJcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcclxuICAgICAgICBwYXJhbXM6IHt9XHJcbiAgICB9KVxyXG59O1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0g6LWL56CB6KeE5YiZID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL+eOr+S/neeggeinhOWImeafpeivolxyXG5leHBvcnQgY29uc3QgcXVlcnlSdWxlTGlzdCA9IChwYXJhbXMpID0+e1xyXG4gICAgcmV0dXJuIHJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9oZWFsdGgvZXZhbHVhdGUvcnVsZV9saXN0JyxcclxuICAgICAgICBtZXRob2Q6ICdnZXQnLFxyXG4gICAgICAgIHBhcmFtczogcGFyYW1zXHJcbiAgICB9KVxyXG59O1xyXG4vL+mDqOmXqOS4i+aLieahhlxyXG5leHBvcnQgY29uc3QgcXVlcnlIYm1EZXBhcnRtZW50ID0gKCkgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2ludGVyZmFjZS9kZXB0L2RlcHRfdHJlZScsXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBwYXJhbXM6IHt9XHJcbiAgICB9KVxyXG59O1xyXG4vL+agoemqjFxyXG5leHBvcnQgY29uc3QgY2hlY2tSdWxlcyA9IChwYXJhbXMpID0+e1xyXG4gICAgcmV0dXJuIHJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogJy9oZWFsdGgvZXZhbHVhdGUvY2hlY2snLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXHJcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgIH0pXHJcbn07XHJcbi8vIOS/ruaUueinhOWImVxyXG5leHBvcnQgY29uc3QgZWRpdFJ1bGVzID0gKHBhcmFtcykgPT57XHJcbiAgICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICAgICAgdXJsOiAnL2hlYWx0aC9ldmFsdWF0ZS91cGRhdGUnLFxyXG4gICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxyXG4gICAgICAgIGRhdGE6IHBhcmFtc1xyXG4gICAgfSlcclxufTtcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0g5Zyw5Zu+ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIOWcsOWbvueCueS9jVxyXG5leHBvcnQgY29uc3QgcXVlcnlXUllNYXAgPSAocGFyYW1zKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvaGVhbHRoL2hvbWUvcG9sbHV0aW9uX21hcCcsXHJcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcclxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgfSlcclxufTtcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0g57uf6K6h5oql6KGoID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBjb25zdCBxdWVyeVN0YXRpc3RpY3MgPSAoKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6ICcvYXBwL3N0YXRpc3RpY3MvZGl2aXNpb25fcGllJyxcclxuICAgICAgICBtZXRob2Q6ICdnZXQnLFxyXG4gICAgICAgIHBhcmFtczoge31cclxuICAgIH0pXHJcbn07XHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IOWKqOaAgeivhOS7tyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL+WQhOWMuuWfn+aKleivieWNoOavlFxyXG5leHBvcnQgY29uc3QgY29tcGxhaW50UHJvcG9ydGlvbiA9IChkYXRhKSA9PntcclxuICAgIHJldHVybiByZXF1ZXN0KHtcclxuICAgICAgICB1cmw6Jy9jbHVzdGVyL2FpclF1YWxpdHkvY29tcGxhaW50UHJvcG9ydGlvbicsXHJcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcclxuICAgICAgICBwYXJhbXM6IGRhdGFcclxuICAgIH0pXHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBT0NBWUFBQUFidmYzc0FBQUFBWE5TUjBJQXJzNGM2UUFBQUVSbFdFbG1UVTBBS2dBQUFBZ0FBWWRwQUFRQUFBQUJBQUFBR2dBQUFBQUFBNkFCQUFNQUFBQUJBQUVBQUtBQ0FBUUFBQUFCQUFBQURLQURBQVFBQUFBQkFBQUFEZ0FBQUFCcHpLazlBQUFCajBsRVFWUW9GVjJTdjB0Q1VSVEg3N25xVUdKRlN4WTAxS0JEa3kyRm05QnVwQWlSSnEzOUVCdGFtOW9hQXJXMmtINFJpQTcrQlc1UlU1T0RVVFlVMVZRa3BJTS9UdWY3WGk5ZlhYajNmcy8zZk01OTUxNHVxWjlSS0Z3TnZEVmZkcGhWaEppbllUTlJuVWlWdklNVCs3RllzQVdQTUdWT2lnSHU4cVZJUDJLQkdsaWxlQWlyakJvNWFEbVZqTjdTY2JucytYcHZWNWw1VXRDT2RxaTF6ZFhJQmFqY2FXbWwxMVY1S1hVUzBaTjcxRFdqbXgvdFhSTVdndFRoVmpKNkxrbnBoaGdhSG9yQmdOVTk1Z1VZR05MS2phbjZzOTBEcXlWbDlHMGdyQUo5MUZSeXlGbkxrLy82dEZ6RmcyVW9WcWxzdnJob3hkQ3lhOHFLV2FrNlpmS2xOSFB2d0RLTmxlalZXSm5IN2I0bVNtdXZleWtyM2YvdEhlQS9HTXlZTzVMVHNSaDFuUzVYSE5kbTM4MnVrUU1ERm9kV0c0bnd2WEpSVUJKVk93aHRlSkl6R0ltTkFpUlM4Y2p6aU1NelIxcnR5ZDIzOEVIRFF3NE1odkUwVEduT2xVckZXWHY4OUNIeVR3M2ZoVUtoamozL1czQjBWdlozMnUwRFJUd3ZnUFdHR25MdDE5TC85bm9pWEVQaE40Q0prbGQ2MTlIbEFBQUFBRWxGVGtTdVFtQ0NcIiIsImltcG9ydCBcIm9sL29sLmNzc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgTWFwLFxyXG4gICAgVmlldyxcclxuICAgIE92ZXJsYXksXHJcbiAgICBGZWF0dXJlLFxyXG4gICAgc3BoZXJlLFxyXG59IGZyb20gXCJvbFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0QXJlYSxcclxuICAgIGdldERpc3RhbmNlXHJcbn0gZnJvbSAnb2wvc3BoZXJlJztcclxuaW1wb3J0IHtcclxuICAgIENsdXN0ZXIsXHJcbiAgICBPU00sXHJcbiAgICBWZWN0b3IgYXMgVmVjdG9yU291cmNlLFxyXG4gICAgWFlaLFxyXG4gICAgVGlsZUFyY0dJU1Jlc3QsXHJcbn0gZnJvbSBcIm9sL3NvdXJjZVwiO1xyXG5cclxuaW1wb3J0IFdNVFNUaWxlR3JpZCBmcm9tICdvbC90aWxlZ3JpZC9XTVRTJztcclxuaW1wb3J0IHtcclxuICAgIENpcmNsZSBhcyBnZW9tQ2lyY2xlLFxyXG4gICAgRmlsbCxcclxuICAgIFN0cm9rZSxcclxuICAgIFN0eWxlLFxyXG4gICAgVGV4dCxcclxuICAgIEljb24sXHJcbn0gZnJvbSBcIm9sL3N0eWxlXCI7XHJcbi8vIENpcmNsZSxcclxuaW1wb3J0ICogYXMgY29udHJvbCBmcm9tICdvbC9jb250cm9sJztcclxuaW1wb3J0IHtcclxuICAgIFRpbGUgYXMgVGlsZUxheWVyLFxyXG4gICAgVmVjdG9yIGFzIFZlY3RvckxheWVyXHJcbn0gZnJvbSBcIm9sL2xheWVyXCI7XHJcblxyXG5pbXBvcnQgQ2lyY2xlU3R5bGUgZnJvbSAnb2wvc3R5bGUvQ2lyY2xlJzsgLy/mnIDlpb3ljZXni6zlvJXnlKjkuI3nhLbpg73mmK9DaXJjbGXkvJrlhrLnqoFnZW9t5LiOc3R5bGVcclxuaW1wb3J0IHtcclxuICAgIFBvaW50LFxyXG4gICAgTGluZVN0cmluZyxcclxuICAgIFBvbHlnb24sXHJcbiAgICBNdWx0aVBvaW50LFxyXG4gICAgTXVsdGlMaW5lU3RyaW5nLFxyXG4gICAgTXVsdGlQb2x5Z29uLFxyXG4gICAgU2ltcGxlR2VvbWV0cnksXHJcbiAgICBDaXJjbGUsXHJcbn0gZnJvbSBcIm9sL2dlb21cIjtcclxuXHJcbmltcG9ydCB7XHJcbiAgICBjaXJjdWxhclxyXG59IGZyb20gXCJvbC9nZW9tL1BvbHlnb25cIjtcclxuXHJcbmltcG9ydCB7XHJcbiAgICBjbGljayxcclxuICAgIHBvaW50ZXJNb3ZlLFxyXG4gICAgYWx0S2V5T25seVxyXG59IGZyb20gXCJvbC9ldmVudHMvY29uZGl0aW9uXCI7XHJcbmltcG9ydCB7XHJcbiAgICBTZWxlY3QsXHJcbiAgICBEcmF3XHJcbn0gZnJvbSBcIm9sL2ludGVyYWN0aW9uXCI7XHJcbmltcG9ydCB7XHJcbiAgICB1bkJ5S2V5XHJcbn0gZnJvbSAnb2wvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7XHJcbiAgICBlYXNlT3V0XHJcbn0gZnJvbSAnb2wvZWFzaW5nJztcclxuaW1wb3J0IHtcclxuICAgIGdldFZlY3RvckNvbnRleHRcclxufSBmcm9tICdvbC9yZW5kZXInO1xyXG5pbXBvcnQge1xyXG4gICAgdHJhbnNmb3JtLFxyXG4gICAgZnJvbUxvbkxhdFxyXG59IGZyb20gJ29sL3Byb2onO1xyXG5pbXBvcnQge1xyXG4gICAgRXNyaUpTT04sXHJcbiAgICBHZW9KU09OLFxyXG4gICAgS01MXHJcbn0gZnJvbSAnb2wvZm9ybWF0JztcclxuXHJcbmltcG9ydCBXTVNUaWxlR3JpZCBmcm9tICdvbC90aWxlZ3JpZC9XTVRTJztcclxuaW1wb3J0IFRpbGVHcmlkIGZyb20gXCJvbC90aWxlZ3JpZC9UaWxlR3JpZFwiO1xyXG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tIFwib2wvcHJvalwiO1xyXG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRDb250cm9sc30gZnJvbSBcIm9sL2NvbnRyb2xcIjtcclxuY29uc3QgYXJjZ2lzTWFwU2VydmVyID1cclxuICAgIFwiaHR0cDovLzEwLjIyMS4yOS40OjgwODAvT25lTWFwU2VydmVyL3Jlc3Qvc2VydmljZXMvWF9LbVdyeURhc2pnamZ3X1Y0L01hcFNlcnZlclwiO1xyXG4vLyBjb25zdCB0b2tlbiA9ICdnZ0dWRndfQmRuZG45VlMxVjBfbXdCc3Mzd1l5dkEwUUlCVGNuY3AxLUtRbVlKaUVZbHcxYU5HOXZNbG1CWU5CJ1xyXG5jb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWFwX3Rva2VuXCIpO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1hcDogbnVsbCxcclxuICAgICAgICAgICAgbGF5ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBiYXNlTGF5ZXI6IG51bGwsIC8vIOe6v+S4iuWcsOWbvlxyXG4gICAgICAgICAgICAgICAgdmVjdG9yTGF5ZXI6IG51bGwsIC8vIOefoumHj+WcsOWbvlxyXG4gICAgICAgICAgICAgICAgcG9ydHJhaXRMYXllcjogbnVsbCwgLy8g5b2x5YOP5Zyw5Zu+XHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uTGF5ZXI6IG51bGwsIC8v5qCH5rOo5bGCXHJcbiAgICAgICAgICAgICAgICBwcm92aW5jZUxheWVyOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYm91bmRhcnlfbGF5ZXI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzdHJlZXRMYXllcjpudWxsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRMYXllcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHBvaW50TGF5ZXJHajogbnVsbCxcclxuICAgICAgICAgICAgICAgIHBvaW50TGF5ZXJaYmZ4Om51bGwsXHJcbiAgICAgICAgICAgICAgICBwb2ludExheWVyV3J5Om51bGwsXHJcbiAgICAgICAgICAgICAgICBjaXJjbGVMYXllcjpudWxsLCAvL+WRqOi+ueWIhuaekOeUu+WchlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsLFxyXG4gICAgICAgICAgICBjZW50ZXI6IFsxMDIuODUwMjgyMjk2ODc0OTgsIDI1LjE2ODAwNzIyOTg3OTMyNl0sXHJcbiAgICAgICAgICAgIHRva2VuOiBcIjQ2OWNmZDljMTMzZjMwYmFhZjNmOTRhOWNkODQ4YzQ3XCIsXHJcbiAgICAgICAgICAgIHBvaW50SW5mbzogbnVsbCxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbnM6W1xyXG4gICAgICAgICAgICAgICAgMC4wMDI3NDY1ODIwMzE4NTQ5OTcsXHJcbiAgICAgICAgICAgICAgICAwLjAwMTM3MzI5MTAxNTkyNzQ5ODUsXHJcbiAgICAgICAgICAgICAgICAwLjAwMDY4NjY0NTQ5NjA3ODM0MTUsXHJcbiAgICAgICAgICAgICAgICAwLjAwMDM0MzMyMjc1OTkyNDU3ODQ3LFxyXG4gICAgICAgICAgICAgICAgMC4wMDAxNzE2NjEzNjgwNzkyNjA5OCxcclxuICAgICAgICAgICAgICAgIDAuMDAwMDg1ODMwNjg0MDM5NjMwNDksXHJcbiAgICAgICAgICAgICAgICAwLjAwMDA0MjkxNTM0MjAxODYyNTUxLFxyXG4gICAgICAgICAgICAgICAgMC4wMDAwMjE0NTc2ODI4OTM1MzA3NTMsXHJcbiAgICAgICAgICAgICAgICAwLjAwMDAxMDcyODg0MTQ0Njc2NTM3NyxcclxuICAgICAgICAgICAgICAgIDAuMDAwMDA1MzY0NDIwNzI0NTcyNDE4LFxyXG4gICAgICAgICAgICAgICAgMC4wMDAwMDI2ODIyMTAzNjEwOTY0Nzg0LFxyXG4gICAgICAgICAgICAgICAgMC4wMDAwMDEzNDExMDUxODA1NDgyMzkyXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIG1hdHJpeElkczpbMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTJdLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXRob2RzOntcclxuICAgICAgICBpbml0TWFwKHNlcnZlcix0YXJnZXQsbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgZnVsbEV4dGVudCA9IFtcclxuICAgICAgICAgICAgICAgIHNlcnZlci5mdWxsRXh0ZW50LnhtaW4sXHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuZnVsbEV4dGVudC55bWluLFxyXG4gICAgICAgICAgICAgICAgc2VydmVyLmZ1bGxFeHRlbnQueG1heCxcclxuICAgICAgICAgICAgICAgIHNlcnZlci5mdWxsRXh0ZW50LnltYXgsXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBbc2VydmVyLnRpbGVJbmZvLm9yaWdpbi54LCBzZXJ2ZXIudGlsZUluZm8ub3JpZ2luLnldO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHV0aW9ucyA9IHNlcnZlci50aWxlSW5mby5sb2RzLm1hcCgoaXRlbSkgPT4gaXRlbS5yZXNvbHV0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIGxheWVyczogW3RoaXMuZ2V0QXJjZ2lzTGF5ZXIoZnVsbEV4dGVudCwgcmVzb2x1dGlvbnMsIG9yaWdpbildLFxyXG4gICAgICAgICAgICAgICAgLy/op4blm77vvIzov5nph4zorr7nva7lnZDmoIfns7tcclxuICAgICAgICAgICAgICAgIHZpZXc6IG5ldyBWaWV3KHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9qZWN0aW9uOiAnRVBTRzo0MzI2JyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBjZW50ZXI6IFt0aGlzLmxvY2F0aW9uWzBdLCB0aGlzLmxvY2F0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uc1s5XSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uOiBnZXRQcm9qZWN0aW9uKFwiRVBTRzo0MzI2XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogZnVsbEV4dGVudCxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgLy/mjqfliLbnu4Tku7ZcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzOiBkZWZhdWx0Q29udHJvbHMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB6b29tOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSkuZXh0ZW5kKFtdKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmdldFZpZXcoKS5zZXRDZW50ZXIoW2xvY2F0aW9uWzBdLCBsb2NhdGlvblsxXV0pO1xyXG4gICAgICAgICAgICAvLyDmoIfms6jlsYJcclxuICAgICAgICAgICAgbGV0IGFubm90YXRpb25MYXllciA9IG5ldyBUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiBuZXcgWFlaKHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGBodHRwOi8vdDEudGlhbmRpdHUuY29tL0RhdGFTZXJ2ZXI/VD1jaWFfdyZ4PXt4fSZ5PXt5fSZsPXt6fSZ0az0ke3RoaXMudG9rZW59YCxcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGFubm90YXRpb25MYXllci5zZXRWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgICAgICBhbm5vdGF0aW9uTGF5ZXIuc2V0KFwiaWRcIiwgXCJhbm5vdGF0aW9uXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5hbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XHJcblxyXG5cclxuICAgICAgICAgICAgLy/lnIblvaLojIPlm7Tlm77lsYJcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMuY2lyY2xlTGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKCksXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM0NjU0ZjcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFs1LCA1XSwgLy/omZrnur9cclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHRoaXMubGF5ZXJzLmNpcmNsZUxheWVyKTtcclxuXHJcbiAgICAgICAgICAgIC8v6KGM5pS/5Yy65YiS6L6555WM5Zu+5bGCXHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnByb3ZpbmNlTGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyTW9kZTogXCJ2ZWN0b3JcIixcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSgpLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiAwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5sYXllcnMucHJvdmluY2VMYXllcik7XHJcbiAgICAgICAgICAgIGFubm90YXRpb25MYXllci5zZXRWaXNpYmxlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy/ooYzmlL/ljLrliJLooZfpgZPlm77lsYJcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMuc3RyZWV0TGF5ZXIgPSBuZXcgVmVjdG9yTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyTW9kZTogXCJ2ZWN0b3JcIixcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSgpLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiAwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5sYXllcnMuc3RyZWV0TGF5ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy/ngrnkvY3lm77lsYJcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMucG9pbnRMYXllciA9IG5ldyBWZWN0b3JMYXllcih7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2UoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5sYXllcnMucG9pbnRMYXllcik7XHJcblxyXG4gICAgICAgICAgICAvL+axoeafk+a6kOivpuaDhVxyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5wb2ludExheWVyV3J5ID0gbmV3IFZlY3RvckxheWVyKHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih0aGlzLmxheWVycy5wb2ludExheWVyV3J5KTtcclxuXHJcbiAgICAgICAgICAgIC8v5ZGo6L655YiG5p6QXHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnBvaW50TGF5ZXJaYmZ4ID0gbmV3IFZlY3RvckxheWVyKHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih0aGlzLmxheWVycy5wb2ludExheWVyWmJmeCk7XHJcbiAgICAgICAgICAgIC8v5re75Yqg5b2T5YmN5a6a5L2N55qE54K5XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFBvaW50KGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgLy/lm77lsYLnm5HlkKzkuovku7ZcclxuICAgICAgICAgICAgdGhpcy5sYXllckV2ZW50KCk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGlzLmFkZFN0cmVldCgpO1xyXG4gICAgICAgICAgICAvL+WcsOWbvueCueWHu1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1hcC5vbignY2xpY2snLCB0aGlzLmNsaWNrSW5NYXBFdmVudCk7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIC8v5Zyw5Zu+57yp5pS+XHJcbiAgICAgICAgICAgIC8vIHRoaXMubWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5tb3VzZUluTWFwRXZlbnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QXJjZ2lzTGF5ZXIoZnVsbEV4dGVudCwgcmVzb2x1dGlvbnMsIG9yaWdpbikge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihcIkVQU0c6NDMyNlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWxlTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgc291cmNlOiBuZXcgWFlaKHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGAke2FyY2dpc01hcFNlcnZlcn0vdGlsZS97en0ve3l9L3t4fT90b2tlbj0ke3Rva2VufWAsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0aWxlR3JpZDogbmV3IFRpbGVHcmlkKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVNpemU6IDI1NixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBmdWxsRXh0ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRlZmF1bHRcIixcclxuICAgICAgICAgICAgICAgICAgICB3cmFwWDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNyb3NzT3JpZ2luOiBcImFub255bW91c1wiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v5Zu+5bGC55uR5ZCs5LqL5Lu2XHJcbiAgICAgICAgbGF5ZXJFdmVudCgpe1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrU2VsZWN0ID0gbmV3IFNlbGVjdCh7XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGNsaWNrLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBsYXllcnM6IFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVycy5wb2ludExheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzLnBvaW50TGF5ZXJaYmZ4XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrU2VsZWN0Lm9uKCdzZWxlY3QnLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gZS5zZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUgPT09IHRoaXMuc2VsZWN0ZWRCeUF0dHJGZWF0dXJlKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwUG9pbnRDbGljayhmZWF0dXJlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkSW50ZXJhY3Rpb24odGhpcy5jbGlja1NlbGVjdCk7XHJcbiAgICAgICAgICAgIC8v5Zu+5bGC56e75YWl56e75Ye65LqL5Lu2XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJNb3ZlU2VsZWN0ID0gbmV3IFNlbGVjdCh7XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHBvaW50ZXJNb3ZlLFxyXG4gICAgICAgICAgICAgICAgbGF5ZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXllcnMucG9pbnRMYXllcixcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVycy5wb2ludExheWVyWmJmeFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcG9pbnRlck1vdmVTZWxlY3Qub24oJ3NlbGVjdCcsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBlLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzRmVhdHVyZXMgPSBlLmRlc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgIHNjYWxlID0gMS4yO1xyXG4gICAgICAgICAgICAgICAgLy/mt7vliqDmloflrZfmoIfms6jku6Xlj4ppY29uXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc2V0U3R5bGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDk5OSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ldyBUZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmZWF0dXJlLmdldCgnbmFtZScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogMjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEZpbGw6IG5ldyBGaWxsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICcxNHB4IHNlcmlmJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzEsIDUsIDAsIDVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBuZXcgSWNvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB0aGlzLiR1dGlscy5nZXRQb2ludEltZyhmZWF0dXJlLmdldCgndHlwZScpLGZlYXR1cmUuZ2V0KCdsZXZlbCcpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I6IFswLjUsIDAuNV0sIC8v6ZSa54K5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6c2NhbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy/ljrvpmaTmloflrZfmoIfms6hcclxuICAgICAgICAgICAgICAgIGRlc0ZlYXR1cmVzLmZvckVhY2goZGVzRmVhdHVyZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzRmVhdHVyZS5zZXRTdHlsZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ldyBUZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBuZXcgSWNvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB0aGlzLiR1dGlscy5nZXRQb2ludEltZyhkZXNGZWF0dXJlLmdldCgndHlwZScpLGRlc0ZlYXR1cmUuZ2V0KCdsZXZlbCcpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3I6IFswLjUsIDAuNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZEludGVyYWN0aW9uKHBvaW50ZXJNb3ZlU2VsZWN0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v6I635Y+W54K55L2NXHJcbiAgICAgICAgZ2V0UG9pbnRzKGRhdGEsdHlwZSl7XHJcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMucG9pbnRMYXllci5nZXRTb3VyY2UoKS5jbGVhcigpO1xyXG4gICAgICAgICAgICBwb2ludHMgPSBkYXRhO1xyXG4gICAgICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludC5qZCA9PT0gXCItXCIgJiYgcG9pbnQud2QgPT09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuamQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LndkID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvaW50LnR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/liqDovb3ngrnkvY1cclxuICAgICAgICBhZGRQb2ludChhdHRyaWJ1dGVzKXtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgRmVhdHVyZSh7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogbmV3IFBvaW50KFthdHRyaWJ1dGVzLmpkLCBhdHRyaWJ1dGVzLndkXSksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50XCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAxLjI7XHJcbiAgICAgICAgICAgIGlmKGF0dHJpYnV0ZXMudHlwZSA9PT0gJ+eOr+S/neeggScpe1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5sZXZlbCA9IGF0dHJpYnV0ZXMucXJfY29kZV9jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludC5zZXRTdHlsZShcclxuICAgICAgICAgICAgICAgIG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IG5ldyBJY29uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB0aGlzLiR1dGlscy5nZXRQb2ludEltZyhhdHRyaWJ1dGVzLnR5cGUsYXR0cmlidXRlcy5sZXZlbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcjogWzAuNSwgMC41XSwgLy/plJrngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTEsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwb2ludC5zZXRQcm9wZXJ0aWVzKGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICAvL+iuvue9rueCueS9jWlk77yM6L+Z5qC35Y+v5Lul55Soc291cmNlLmdldEZlYXR1cmVCeUlkIOaJvuWIsFxyXG4gICAgICAgICAgICBwb2ludC5zZXRJZChhdHRyaWJ1dGVzLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMucG9pbnRMYXllci5nZXRTb3VyY2UoKS5hZGRGZWF0dXJlKHBvaW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEN1cnJlbnRQb2ludChhdHRyaWJ1dGVzKXtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgRmVhdHVyZSh7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogbmV3IFBvaW50KFthdHRyaWJ1dGVzLmpkLCBhdHRyaWJ1dGVzLndkXSksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50XCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAxLjI7XHJcbiAgICAgICAgICAgIHBvaW50LnNldFN0eWxlKFxyXG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogbmV3IEljb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IHRoaXMuJHV0aWxzLmdldFBvaW50SW1nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcjogWzAuNSwgMC41XSwgLy/plJrngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTEsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwb2ludC5zZXRQcm9wZXJ0aWVzKGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5wb2ludExheWVyLmdldFNvdXJjZSgpLmFkZEZlYXR1cmUocG9pbnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/ngrnlh7vlnLDlm77kuIrnmoTngrlcclxuICAgICAgICBtYXBQb2ludENsaWNrKGZlYXR1cmUpe1xyXG4gICAgICAgICAgICB0aGlzLiRzdG9yZS5zdGF0ZS5wb2ludE5hbWUgPSBmZWF0dXJlLnZhbHVlc18ud3J5bWM7XHJcbiAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBmZWF0dXJlLmdldFByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgaWYoYXR0cmlidXRlcy5qZCAhPT0gXCJcIil7XHJcbiAgICAgICAgICAgICAgICAvL+mrmOS6ruWKqOeUu1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdoTGlnaHQoZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAvL+iuvue9rua4hemZpOS4iuS4gOS4queCue+8iOazqOaEj+mhuuW6j++8iVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdEJ5QXR0cmlidXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQnlBdHRyRmVhdHVyZSA9IGZlYXR1cmU7XHJcbiAgICAgICAgICAgICAgICAvL+WcsOWbvuS4reW/g+enu+WKqFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvID0gYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgIGxldCBjZW50ZXIgPSBbdGhpcy5pbmZvLmpkLCB0aGlzLmluZm8ud2RdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYW5Ub0Nvb3JkaW5hdGUoY2VudGVyLCAxMyk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbWVzc2FnZShcIuivpeermeeCueaaguaXoOe7j+e6rOW6pu+8gVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/pq5jkuq7ngrnkvY1cclxuICAgICAgICBoaWdoTGlnaHQoY2xpY2tlZEZlYXR1cmUpe1xyXG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IDIwMDA7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBsZXQgaGlnaExpZ2h0ZWRGZWF0dXJlO1xyXG4gICAgICAgICAgICAvL+eCueWHu+S6i+S7tuS8oOWFpeeCueWHu+eahGZlYXR1cmXvvIzpppblhYjkuI7kuIrkuIDkuKrngrnlr7nmr5TvvIzlpoLmnpzmmK/lkIzkuIDkuKrngrnvvIzliJnkuI3miafooYxcclxuICAgICAgICAgICAgaWYgKGNsaWNrZWRGZWF0dXJlID09PSB0aGlzLnNlbGVjdGVkQnlBdHRyRmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGNsaWNrZWRGZWF0dXJlLmdldFByb3BlcnRpZXMoKS5hY3RpdmVUeXBlID09PSAn5rGh5p+T5rqQ6K+m5oOFJyl7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcktleSA9IHRoaXMubGF5ZXJzLnBvaW50TGF5ZXJXcnkub24oXCJwb3N0cmVuZGVyXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLnNlbGVjdGVkQnlBdHRyRmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOW9k+WJjeayoeacieeCuemAieeahOeCueS9je+8jOWImeWPlua2iOS6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bkJ5S2V5KGxpc3RlbmVyS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOeCuemAieS6huWFtuS7lueCueS9je+8jOWImeWPlua2iOS6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdoTGlnaHRlZEZlYXR1cmUgJiYgaGlnaExpZ2h0ZWRGZWF0dXJlICE9PSBmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuQnlLZXkobGlzdGVuZXJLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGlnaExpZ2h0ZWRGZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hMaWdodGVkRmVhdHVyZSA9IGZlYXR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3R5bGXnlJ/miJBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3JDb250ZXh0ID0gZ2V0VmVjdG9yQ29udGV4dChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVTdGF0ZSA9IGV2ZW50LmZyYW1lU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsYXNoR2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYXNoR2VvbS5mbGF0Q29vcmRpbmF0ZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXNoR2VvbS5mbGF0Q29vcmRpbmF0ZXNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXNoR2VvbS5mbGF0Q29vcmRpbmF0ZXNbMV0gLSAwLjAwMDA5LFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IGZyYW1lU3RhdGUudGltZSAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsYXBzZWRSYXRpbyA9IGVsYXBzZWQgLyBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAvLyByYWRpdXMgd2lsbCBiZSA1IGF0IHN0YXJ0IGFuZCAzMCBhdCBlbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gZWFzZU91dChlbGFwc2VkUmF0aW8pICogMjU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IGVhc2VPdXQoMSAtIGVsYXBzZWRSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBuZXcgU3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogbmV3IGdlb21DaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMzUsIDIyMCwgNDMsIFwiICsgb3BhY2l0eSArIFwiKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLjI1ICsgb3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMzUgLDIyMCAsNDMsIFwiICsgb3BhY2l0eSAvIDMgKyBcIilcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JDb250ZXh0LnNldFN0eWxlKHN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3JDb250ZXh0LmRyYXdHZW9tZXRyeShmbGFzaEdlb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v6K6+572u6YeN5aSN6L+Q6KGMXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyS2V5ID0gdGhpcy5sYXllcnMucG9pbnRMYXllci5vbihcInBvc3RyZW5kZXJcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuc2VsZWN0ZWRCeUF0dHJGZWF0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5b2T5YmN5rKh5pyJ54K56YCJ55qE54K55L2N77yM5YiZ5Y+W5raI5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuQnlLZXkobGlzdGVuZXJLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c54K56YCJ5LqG5YW25LuW54K55L2N77yM5YiZ5Y+W5raI5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hMaWdodGVkRmVhdHVyZSAmJiBoaWdoTGlnaHRlZEZlYXR1cmUgIT09IGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5CeUtleShsaXN0ZW5lcktleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoaWdoTGlnaHRlZEZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaExpZ2h0ZWRGZWF0dXJlID0gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdHlsZeeUn+aIkFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlY3RvckNvbnRleHQgPSBnZXRWZWN0b3JDb250ZXh0KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZVN0YXRlID0gZXZlbnQuZnJhbWVTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmxhc2hHZW9tID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhc2hHZW9tLmZsYXRDb29yZGluYXRlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhc2hHZW9tLmZsYXRDb29yZGluYXRlc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhc2hHZW9tLmZsYXRDb29yZGluYXRlc1sxXSAtIDAuMDAwMDksXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gZnJhbWVTdGF0ZS50aW1lIC0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZFJhdGlvID0gZWxhcHNlZCAvIGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJhZGl1cyB3aWxsIGJlIDUgYXQgc3RhcnQgYW5kIDMwIGF0IGVuZC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBlYXNlT3V0KGVsYXBzZWRSYXRpbykgKiAyNTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gZWFzZU91dCgxIC0gZWxhcHNlZFJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBuZXcgZ2VvbUNpcmNsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgzNSwgMjIwLCA0MywgXCIgKyBvcGFjaXR5ICsgXCIpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAuMjUgKyBvcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgzNSAsMjIwICw0MywgXCIgKyBvcGFjaXR5IC8gMyArIFwiKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlY3RvckNvbnRleHQuc2V0U3R5bGUoc3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlY3RvckNvbnRleHQuZHJhd0dlb21ldHJ5KGZsYXNoR2VvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/orr7nva7ph43lpI3ov5DooYxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCA+IGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmoLnmja7nu4/nuqzluqbnlLvlnIZcclxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRBcnIg57uP57qs5bqmXHJcbiAgICAgICAgICogQHBhcmFtIGNpcmNsZVJhZGl1cyDljYrlvoRcclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgICBkcmF3Q2lyY2xlKHBvaW50QXJyLCBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMuY2lyY2xlTGF5ZXIuZ2V0U291cmNlKCkuY2xlYXIoKTtcclxuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IGNpcmNsZVJhZGl1cyAqIDEwMDA7XHJcbiAgICAgICAgICAgIGxldCBjaXJjbGUgPSBjaXJjdWxhcihwb2ludEFyciwgcmFkaXVzKTtcclxuICAgICAgICAgICAgbGV0IGNpcmNsZUZlYXR1cmUgPSBuZXcgRmVhdHVyZSh7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogY2lyY2xlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sYXllcnMuY2lyY2xlTGF5ZXIuZ2V0U291cmNlKCkuYWRkRmVhdHVyZShjaXJjbGVGZWF0dXJlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v5Zyw5Zu+56e75Yqo77yM57yp5pS+XHJcbiAgICAgICAgcGFuVG9Db29yZGluYXRlKGNvb3JkaW5hdGUsIHpvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0VmlldygpLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgY2VudGVyOiBjb29yZGluYXRlLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuICAgICAgICAgICAgICAgIHpvb206IHpvb20sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy/muIXpmaTngrlcclxuICAgICAgICBjbGVhclNlbGVjdEJ5QXR0cmlidXRlKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEJ5QXR0ckZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRCeUF0dHJGZWF0dXJlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsaWNrU2VsZWN0LmdldEZlYXR1cmVzKCkuY2xlYXIoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8v5a6a5L2N54K5XHJcbiAgICAgICAgZmluZEZlYXR1cmVCeUlkKGlkKXtcclxuICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSB0aGlzLmxheWVycy5wb2ludExheWVyLmdldFNvdXJjZSgpLmdldEZlYXR1cmVCeUlkKGlkKTtcclxuICAgICAgICAgICAgaWYoZmVhdHVyZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRtZXNzYWdlKFwi5pqC5peg5a+55bqU54K55L2N77yBXCIpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwUG9pbnRDbGljayhmZWF0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTliYTdlZDQmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9YTliYTdlZDQmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJhOWJhN2VkNFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkQ6XFxcXGhlbGlwaW5nV29ya1xcXFxBUFBcXFxca21FbnZQb3J0YWJsZVxcXFx3ZWJhcHBPU1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCdhOWJhN2VkNCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCdhOWJhN2VkNCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCdhOWJhN2VkNCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWE5YmE3ZWQ0JnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJ2E5YmE3ZWQ0Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvdmlld3MvZW52aXJvbm1lbnRDb2RlL21hcE1uZy9pbmRleC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1hOWJhN2VkNCZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOlxcXCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcXFwiLFxcXCJjYWNoZUlkZW50aWZpZXJcXFwiOlxcXCI0YmFlMDQ4Mi12dWUtbG9hZGVyLXRlbXBsYXRlXFxcIn0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hOWJhN2VkNCZzY29wZWQ9dHJ1ZSZcIiJdLCJzb3VyY2VSb290IjoiIn0=