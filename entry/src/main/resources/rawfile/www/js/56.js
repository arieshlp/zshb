(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[56],{

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/calendar/calendarYear.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ "./node_modules/core-js/modules/es.object.to-string.js");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue_cal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-cal */ "./node_modules/vue-cal/dist/vuecal.common.js");
/* harmony import */ var vue_cal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue_cal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue_cal_dist_vuecal_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-cal/dist/vuecal.css */ "./node_modules/vue-cal/dist/vuecal.css");
/* harmony import */ var vue_cal_dist_vuecal_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vue_cal_dist_vuecal_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils_airUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/airUtils.js */ "./src/utils/airUtils.js");
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! dayjs */ "./node_modules/dayjs/dayjs.min.js");
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_5__);


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
  name: "calendarYear",
  components: {
    VueCal: vue_cal__WEBPACK_IMPORTED_MODULE_2___default.a
  },
  props: {
    array: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    startDate: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    factor: {
      type: String
    }
  },
  data: function data() {
    return {};
  },
  methods: {
    getData: function getData(cell) {
      var _this = this;

      var dayData = {};
      this.array.forEach(function (item) {
        if (item.dateTime === cell.formattedDate) {
          dayData = {
            date: cell.content,
            aqi: item[_this.factor],
            primary: item.pollutant
          };
        }
      });
      return dayData;
    },
    getCalendarBg: function getCalendarBg(cell) {
      var color = Object(_utils_airUtils_js__WEBPACK_IMPORTED_MODULE_4__["getCalenderBgColor"])(this.factor, this.getData(cell).aqi);
      return color;
    }
  }
});

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.number.constructor.js */ "./node_modules/core-js/modules/es.number.constructor.js");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.slice.js */ "./node_modules/core-js/modules/es.array.slice.js");
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.concat.js */ "./node_modules/core-js/modules/es.array.concat.js");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _api_air_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/api/air.js */ "./src/api/air.js");
/* harmony import */ var _components_calendar_calendarYear_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/calendar/calendarYear.vue */ "./src/components/calendar/calendarYear.vue");
/* harmony import */ var _api_air_quality__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/api/air_quality */ "./src/api/air_quality.js");



//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
  name: "index",
  components: {
    calendarYear: _components_calendar_calendarYear_vue__WEBPACK_IMPORTED_MODULE_4__["default"]
  },
  data: function data() {
    return {
      yearData: [],
      year: '',
      siteName: '',
      siteId: '',
      factor: '',
      currentDate: new Date(),
      showPickerYear: false,
      yearSelect: null,
      yearColumns: [],
      xzqh: '',
      queryFlag: null
    };
  },
  mounted: function mounted() {
    this.siteId = this.$route.query.siteId;
    this.factor = this.$route.query.factor;
    this.xzqh = this.$route.query.xzqh;
    this.queryFlag = Number(this.$route.query.queryFlag); // this.year = "2023";

    this.year = new Date().getFullYear();
    this.getYears();
    this.getYearData();
  },
  methods: {
    //年数据
    getYears: function getYears() {
      // 获取默认显示的时间
      var nowTime = new Date();
      var year = nowTime.getFullYear();
      var month = nowTime.getMonth();
      var day = nowTime.getDate(); // 循环数组 填写最小时间和最大时间范围

      for (var i = 2010; i < 2099; i++) {
        this.yearColumns.push(i);
      } // 格式化时间并截取


      var years = this.formatDate(new Date(year, month, day));
      var Year = years.slice(0, 4); // 将截取的年份赋值给绑定值 用于点击弹出日期窗口后显示当前的时间

      this.yearSelect = this.yearColumns.indexOf(Number(Year));
    },
    //日期格式
    formatDate: function formatDate(date) {
      return "".concat(date.getFullYear(), "-").concat(date.getMonth() + 1, "-").concat(date.getDate());
    },
    onConfirmYear: function onConfirmYear(value) {
      this.showPickerYear = false;
      this.year = value;
      this.getYearData();
    },
    getYearData: function getYearData() {
      var _this = this;

      var info = {
        siteId: this.siteId,
        year: this.year,
        divisionName: this.xzqh,
        aqi: this.queryFlag === 0 ? '' : 'iaqi'
      };
      Object(_api_air_quality__WEBPACK_IMPORTED_MODULE_5__["airYearCalendar"])(info).then(function (res) {
        _this.yearData = res.data;
      }); // getAllYearCalender({
      // 	type: 1,
      // 	id: '',
      // 	yzName: 'AQI',
      // 	year: '2023'
      // }).then(res => {
      // 	this.yearData = res;
      // })
    }
  }
});

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "cal-wrapper" },
    [
      _c("div", { staticClass: "cal-title" }, [
        _vm._v(_vm._s(_vm.dayjs(_vm.startDate).format("YYYY-MM"))),
      ]),
      _c("vue-cal", {
        attrs: {
          locale: "zh-cn",
          "selected-date": _vm.dayjs(_vm.startDate).format("YYYY-MM" + "-01"),
          "hide-view-selector": "",
          hideTitleBar: "",
          "default-view": "month",
        },
        scopedSlots: _vm._u([
          {
            key: "cell-content",
            fn: function (ref) {
              var cell = ref.cell
              var view = ref.view
              var events = ref.events
              var goNarrower = ref.goNarrower
              return [
                _c(
                  "div",
                  {
                    staticClass: "calendar-cell",
                    style: _vm.getCalendarBg(cell),
                  },
                  [
                    _c("span", { staticClass: "day" }, [
                      _vm._v(_vm._s(cell.startDate.getDate())),
                    ]),
                  ]
                ),
              ]
            },
          },
        ]),
      }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true&":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true& ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "air-calendar-page" },
    [
      _c("van-nav-bar", {
        attrs: {
          title: "日历详情",
          "left-arrow": "",
          fixed: "",
          "z-index": "10",
        },
        on: {
          "click-left": function ($event) {
            return _vm.$router.go(-1)
          },
        },
      }),
      _c(
        "div",
        {
          staticClass: "search-content",
          staticStyle: { "margin-top": "54px" },
        },
        [
          _c(
            "div",
            {
              staticClass: "search-item fs",
              on: {
                click: function ($event) {
                  _vm.showPickerYear = true
                },
              },
            },
            [
              _vm._v(" " + _vm._s(_vm.year) + " "),
              _c("van-icon", { attrs: { name: "arrow-down" } }),
            ],
            1
          ),
        ]
      ),
      _c(
        "van-popup",
        {
          attrs: { position: "bottom" },
          model: {
            value: _vm.showPickerYear,
            callback: function ($$v) {
              _vm.showPickerYear = $$v
            },
            expression: "showPickerYear",
          },
        },
        [
          _c("van-picker", {
            attrs: {
              "show-toolbar": "",
              columns: _vm.yearColumns,
              title: "选择年",
              "default-index": _vm.yearSelect,
            },
            on: {
              confirm: _vm.onConfirmYear,
              cancel: function ($event) {
                _vm.showPickerYear = false
              },
            },
          }),
        ],
        1
      ),
      _c(
        "div",
        {
          staticStyle: {
            "margin-top": "10px",
            height: "calc(100vh - 106px)",
            overflow: "hidden auto",
          },
        },
        _vm._l(_vm.yearData, function (item, index) {
          return _c("calendarYear", {
            key: index,
            attrs: {
              array: item,
              startDate: new Date(_vm.year, index, 1),
              factor: "AQI",
            },
          })
        }),
        1
      ),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var DOMTokenListPrototype = __webpack_require__(/*! ../internals/dom-token-list-prototype */ "./node_modules/core-js/internals/dom-token-list-prototype.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/vue-cal/dist/vuecal.css":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--7-oneOf-3-1!./node_modules/postcss-loader/src??ref--7-oneOf-3-2!./node_modules/vue-cal/dist/vuecal.css ***!
  \**********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".vuecal__weekdays-headings{border-bottom:1px solid #ddd;margin-bottom:-1px}.vuecal--view-with-time .vuecal__weekdays-headings,.vuecal--week-numbers .vuecal__weekdays-headings{padding-left:3em}.vuecal--view-with-time.vuecal--twelve-hour .vuecal__weekdays-headings{font-size:.9em;padding-left:4em}.vuecal--overflow-x.vuecal--view-with-time .vuecal__weekdays-headings{padding-left:0}.vuecal__heading{width:100%;height:2.8em;font-weight:400;justify-content:center;text-align:center;align-items:center;position:relative;overflow:hidden}.vuecal__heading>.vuecal__flex{width:100%;height:100%;align-items:normal!important}.vuecal--sticky-split-labels .vuecal__heading{height:3.4em}.vuecal--day-view .vuecal__heading,.vuecal--month-view .vuecal__heading,.vuecal--week-view .vuecal__heading{width:14.2857%}.vuecal--hide-weekends.vuecal--day-view .vuecal__heading,.vuecal--hide-weekends.vuecal--month-view .vuecal__heading,.vuecal--hide-weekends.vuecal--week-view .vuecal__heading,.vuecal--years-view .vuecal__heading{width:20%}.vuecal--year-view .vuecal__heading{width:33.33%}.vuecal__heading .weekday-label{flex-shrink:0;display:flex;justify-content:center;align-items:center}.vuecal--small .vuecal__heading .small,.vuecal--xsmall .vuecal__heading .xsmall{display:block}.vuecal--small .vuecal__heading .full,.vuecal--small .vuecal__heading .xsmall,.vuecal--xsmall .vuecal__heading .full,.vuecal--xsmall .vuecal__heading .small,.vuecal__heading .small,.vuecal__heading .xsmall{display:none}.vuecal .vuecal__split-days-headers{align-items:center}@media screen and (max-width:550px){.vuecal__heading{line-height:1.2}.vuecal--small .vuecal__heading .small,.vuecal--xsmall .vuecal__heading .xsmall,.vuecal__heading .small{display:block}.vuecal--small .vuecal__heading .full,.vuecal--small .vuecal__heading .xsmall,.vuecal--xsmall .vuecal__heading .full,.vuecal--xsmall .vuecal__heading .small,.vuecal__heading .full,.vuecal__heading .xsmall{display:none}.vuecal--overflow-x .vuecal__heading .full,.vuecal--small.vuecal--overflow-x .vuecal__heading .small,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .xsmall{display:block}.vuecal--overflow-x .vuecal__heading .small,.vuecal--overflow-x .vuecal__heading .xsmall,.vuecal--small.vuecal--overflow-x .vuecal__heading .full,.vuecal--small.vuecal--overflow-x .vuecal__heading .xsmall,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .full,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .small{display:none}}@media screen and (max-width:450px){.vuecal--small .vuecal__heading .xsmall,.vuecal--xsmall .vuecal__heading .xsmall,.vuecal__heading .xsmall{display:block}.vuecal--small .vuecal__heading .full,.vuecal--small .vuecal__heading .small,.vuecal--xsmall .vuecal__heading .full,.vuecal--xsmall .vuecal__heading .small,.vuecal__heading .full,.vuecal__heading .small{display:none}.vuecal--small.vuecal--overflow-x .vuecal__heading .small,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .xsmall{display:block}.vuecal--small.vuecal--overflow-x .vuecal__heading .full,.vuecal--small.vuecal--overflow-x .vuecal__heading .xsmall,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .full,.vuecal--xsmall.vuecal--overflow-x .vuecal__heading .small{display:none}}.vuecal__header button{outline:none;font-family:inherit}.vuecal__menu{padding:0;margin:0;list-style-type:none;justify-content:center;background-color:rgba(0,0,0,.02)}.vuecal__view-btn{background:none;border:none;padding:.3em 1em;height:2.2em;font-size:1.3em;border-bottom:0 solid currentColor;cursor:pointer;color:inherit;box-sizing:border-box;transition:.2s}.vuecal__view-btn--active{border-bottom-width:2px;background:hsla(0,0%,100%,.15)}.vuecal__title-bar{background-color:rgba(0,0,0,.1);display:flex;align-items:center;text-align:center;justify-content:space-between;font-size:1.4em;line-height:1.3;min-height:2em}.vuecal--xsmall .vuecal__title-bar{font-size:1.3em}.vuecal__title{position:relative;justify-content:center}.vuecal__title button{cursor:pointer;background:none;border:none}.vuecal__title button.slide-fade--left-leave-active,.vuecal__title button.slide-fade--right-leave-active{width:100%}.vuecal__today-btn{position:relative;align-items:center;display:flex;font-size:.8em;background:none;border:none}.vuecal__today-btn span.default{font-size:.8em;padding:3px 6px;text-transform:uppercase;cursor:pointer}.vuecal__arrow{cursor:pointer;position:relative;z-index:1;background:none;border:none;white-space:nowrap}.vuecal__arrow--prev{margin-left:.6em}.vuecal__arrow--next{margin-right:.6em}.vuecal__arrow i.angle{display:inline-block;border:solid currentColor;border-width:0 2px 2px 0;padding:.25em;transform:rotate(-45deg)}.vuecal__arrow--prev i.angle{border-width:2px 0 0 2px}.vuecal__arrow--highlighted,.vuecal__today-btn--highlighted,.vuecal__view-btn--highlighted{position:relative;background-color:rgba(0,0,0,.04)}.vuecal__arrow--highlighted *,.vuecal__today-btn--highlighted *,.vuecal__view-btn--highlighted *{pointer-events:none}.vuecal__arrow--highlighted:after,.vuecal__arrow--highlighted:before,.vuecal__today-btn--highlighted:after,.vuecal__today-btn--highlighted:before,.vuecal__view-btn--highlighted:after,.vuecal__view-btn--highlighted:before{content:\"\";background-color:inherit;-webkit-animation:sonar .8s ease-out infinite;animation:sonar .8s ease-out infinite;position:absolute;top:50%;left:50%;pointer-events:none}.vuecal__arrow--highlighted:before,.vuecal__today-btn--highlighted:before,.vuecal__view-btn--highlighted:before{width:3em;height:3em;border-radius:3em;margin-top:-1.5em;margin-left:-1.5em}.vuecal__arrow--highlighted:after,.vuecal__today-btn--highlighted:after,.vuecal__view-btn--highlighted:after{-webkit-animation-duration:1.5s;animation-duration:1.5s;-webkit-animation-delay:.1s;animation-delay:.1s;width:2.6em;height:2.6em;border-radius:2.6em;margin-top:-1.3em;margin-left:-1.3em}@-webkit-keyframes sonar{0%,20%{opacity:1}to{transform:scale(2.5);opacity:0}}@keyframes sonar{0%,20%{opacity:1}to{transform:scale(2.5);opacity:0}}@media screen and (max-width:450px){.vuecal__title{font-size:.9em}.vuecal__view-btn{padding-left:.6em;padding-right:.6em}}@media screen and (max-width:350px){.vuecal__view-btn{font-size:1.1em}}.vuecal__event{color:#666;background-color:hsla(0,0%,97.3%,.8);position:relative;box-sizing:border-box;left:0;width:100%;z-index:1;transition:box-shadow .3s,left .3s,width .3s;overflow:hidden}.vuecal:not(.vuecal--dragging-event) .vuecal__event:hover{z-index:2}.vuecal__cell .vuecal__event *{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}.vuecal--view-with-time .vuecal__event:not(.vuecal__event--all-day){position:absolute}.vuecal--view-with-time .vuecal__bg .vuecal__event--all-day{position:absolute;top:0;bottom:0;z-index:0;opacity:.6;width:auto;right:0}.vuecal--view-with-time .vuecal__all-day .vuecal__event--all-day{position:relative;left:0}.vuecal__event--background{z-index:0}.vuecal__event--focus,.vuecal__event:focus{box-shadow:1px 1px 6px rgba(0,0,0,.2);z-index:3;outline:none}.vuecal__event.vuecal__event--dragging{opacity:.7}.vuecal__event.vuecal__event--static{opacity:0}@-moz-document url-prefix(){.vuecal__event.vuecal__event--dragging{opacity:1}}.vuecal__event-resize-handle{position:absolute;bottom:0;left:0;right:0;height:1em;background-color:hsla(0,0%,100%,.3);opacity:0;transform:translateY(110%);transition:.3s;cursor:ns-resize}.vuecal__event--focus .vuecal__event-resize-handle,.vuecal__event:focus .vuecal__event-resize-handle,.vuecal__event:hover .vuecal__event-resize-handle{opacity:1;transform:translateY(0)}.vuecal__event--dragging .vuecal__event-resize-handle{display:none}.vuecal__event-delete{position:absolute;top:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;height:1.4em;line-height:1.4em;background-color:rgba(221,51,51,.85);color:#fff;z-index:0;cursor:pointer;transform:translateY(-110%);transition:.3s}.vuecal--full-height-delete .vuecal__event-delete{height:auto;bottom:0}.vuecal--full-height-delete .vuecal__event-delete:before{content:\"\";width:1.7em;height:1.8em;display:block;background-image:url('data:image/svg+xml;utf8,<svg width=\"512\" height=\"512\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"m256 33c-124 0-224 100-224 224 0 124 100 224 224 224 124 0 224-100 224-224 0-124-100-224-224-224z m108 300c2 1 3 3 3 5 0 2-1 4-3 6l-21 21c-2 2-4 3-6 3-2 0-4-1-5-3l-76-75-75 76c-2 1-4 2-6 2-2 0-4-1-6-2l-21-22c-2-2-2-4-2-6 0-2 0-4 2-5l76-76-76-75c-3-3-3-9 0-12l21-21c2-2 4-3 6-3 2 0 4 1 5 3l76 74 76-74c1-2 3-3 5-3 3 0 5 1 6 3l22 21c3 3 3 9 0 12l-76 75z\" transform=\"scale(0.046875 0.046875)\" fill=\"%23fff\" opacity=\"0.9\"/></svg>')}.vuecal__event--deletable .vuecal__event-delete{transform:translateY(0);z-index:1}.vuecal__event--deletable.vuecal__event--dragging .vuecal__event-delete{opacity:0;transition:none}.vuecal--month-view .vuecal__event-title{font-size:.85em}.vuecal--short-events .vuecal__event-title{text-align:left;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding:0 3px}.vuecal__event-content,.vuecal__event-title{-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}.vuecal__event-title--edit{border-bottom:1px solid transparent;text-align:center;transition:.3s;color:inherit;background-image:url('data:image/svg+xml;utf8,<svg width=\"512\" height=\"512\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"m163 440l-91-91 251-250 90 90z m309-352l-48-48c-12-11-32-11-45 2l-45 45 91 91 45-45c13-13 13-33 2-45z m-408 275l-32 117 117-32z\" fill=\"%23000\" opacity=\"0.4\"/></svg>');background-repeat:no-repeat;background-position:120% .15em;background-size:.4em;outline:none;width:100%}.vuecal__event-title--edit:focus,.vuecal__event-title--edit:hover{border-color:rgba(0,0,0,.4);background-position:99% .15em;background-size:1.2em}.vuecal__cell{position:relative;width:100%;display:flex;justify-content:center;align-items:center;text-align:center;transition:background-color .15s ease-in-out}.vuecal__cells.month-view .vuecal__cell,.vuecal__cells.week-view .vuecal__cell{width:14.2857%}.vuecal--hide-weekends .vuecal__cells.month-view .vuecal__cell,.vuecal--hide-weekends .vuecal__cells.week-view .vuecal__cell,.vuecal__cells.years-view .vuecal__cell{width:20%}.vuecal__cells.year-view .vuecal__cell{width:33.33%}.vuecal__cells.day-view .vuecal__cell{flex:1}.vuecal--overflow-x.vuecal--day-view .vuecal__cell{width:auto}.vuecal--click-to-navigate .vuecal__cell:not(.vuecal__cell--disabled){cursor:pointer}.vuecal--day-view.vuecal--no-time .vuecal__cell,.vuecal--view-with-time .vuecal__cell,.vuecal--week-view.vuecal--no-time .vuecal__cell{display:block}.vuecal__cell.vuecal__cell--has-splits{flex-direction:row;display:flex}.vuecal__cell:before{content:\"\";position:absolute;z-index:0;top:0;left:0;right:-1px;bottom:-1px;border:1px solid #ddd}.vuecal--overflow-x.vuecal--day-view .vuecal__cell:before{bottom:0}.vuecal__cell--current,.vuecal__cell--today{background-color:rgba(240,240,255,.4);z-index:1}.vuecal__cell--selected{background-color:rgba(235,255,245,.4);z-index:2}.vuecal--day-view .vuecal__cell--selected{background:none}.vuecal__cell--out-of-scope{color:#ccc}.vuecal__cell--disabled{color:#ccc;cursor:not-allowed}.vuecal__cell--highlighted:not(.vuecal__cell--has-splits),.vuecal__cell-split.vuecal__cell-split--highlighted{background-color:rgba(0,0,0,.04);transition-duration:5ms}.vuecal__cell-content{position:relative;width:100%;height:100%;outline:none}.vuecal--month-view .vuecal__cell-content,.vuecal--year-view .vuecal__cell-content,.vuecal--years-view .vuecal__cell-content{justify-content:center}.vuecal__cell-split{display:flex;flex-grow:1;flex-direction:column;height:100%;position:relative;transition:background-color .15s ease-in-out}.vuecal__cell-events{width:100%}.vuecal__cell-events-count{left:50%;top:65%;transform:translateX(-50%);min-width:12px;height:12px;line-height:12px;padding:0 3px;background:#999;color:#fff;border-radius:12px;font-size:10px}.vuecal__cell-events-count,.vuecal__cell .vuecal__special-hours{position:absolute;box-sizing:border-box}.vuecal__cell .vuecal__special-hours{left:0;right:0}.vuecal--overflow-x.vuecal--week-view .vuecal__cell,.vuecal__cell-split{overflow:hidden}.vuecal__no-event{padding-top:1em;color:#aaa;justify-self:flex-start;margin-bottom:auto}.vuecal__all-day .vuecal__no-event{display:none}.vuecal__now-line{position:absolute;left:0;width:100%;height:0;color:red;border-top:1px solid currentColor;opacity:.6;z-index:1}.vuecal__now-line:before{content:\"\";position:absolute;top:-6px;left:0;border:5px solid transparent;border-left-color:currentColor}.vuecal{height:100%;box-shadow:inset 0 0 0 1px rgba(0,0,0,.08)}.vuecal *{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.vuecal .clickable{cursor:pointer}.vuecal--resizing-event{cursor:ns-resize}.vuecal--dragging-event{cursor:move;cursor:-webkit-grabbing;cursor:grabbing}.vuecal .dragging-helper{position:absolute;width:60px;height:40px;background:rgba(138,190,230,.8);border:1px solid #61a9e0;z-index:10}.vuecal--xsmall{font-size:.9em}.vuecal__flex{display:flex;flex-direction:row}.vuecal__flex[column]{flex-direction:column}.vuecal__flex[column],.vuecal__flex[grow]{flex:1 1 auto}.vuecal__flex[grow]{width:100%}.vuecal__flex[wrap]{flex-wrap:wrap}.vuecal__split-days-headers.slide-fade--right-leave-active{display:none}.vuecal--week-numbers.vuecal--month-view .vuecal__split-days-headers{margin-left:3em}.vuecal--day-view:not(.vuecal--overflow-x) .vuecal__split-days-headers{margin-left:3em;height:2.2em}.vuecal--day-view.vuecal--twelve-hour:not(.vuecal--overflow-x) .vuecal__split-days-headers{margin-left:4em}.vuecal__split-days-headers .day-split-header{display:flex;flex-grow:1;justify-content:center}.vuecal__split-days-headers .vuecal--day-view.vuecal--overflow-x.vuecal--sticky-split-labels .day-split-header{height:1.5em}.vuecal__body{position:relative;overflow:hidden}.vuecal__all-day{min-height:1.7em;margin-bottom:-1px;flex-shrink:0}.vuecal__all-day>span{width:3em;box-sizing:border-box;color:#999;padding-right:2px;display:flex;flex-shrink:0;align-items:center;justify-content:flex-end;border-bottom:1px solid #ddd;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}.vuecal__all-day>span span{font-size:.85em;text-align:right;line-height:1.1}.vuecal--twelve-hour .vuecal__all-day>span{width:4em}.vuecal__bg{overflow:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;min-height:60px;position:relative;width:100%;margin-bottom:1px}.vuecal--no-time .vuecal__bg{display:flex;flex:1 1 auto;overflow:visible}.vuecal__week-numbers{width:3em;flex-shrink:0!important}.vuecal__week-numbers .vuecal__week-number-cell{opacity:.4;font-size:.9em;align-items:center;justify-items:center;justify-content:center}.vuecal__time-column{width:3em;height:100%;flex-shrink:0}.vuecal--twelve-hour .vuecal__time-column{width:4em;font-size:.9em}.vuecal--overflow-x.vuecal--week-view .vuecal__time-column{margin-top:2.8em;box-shadow:0 1px 1px rgba(0,0,0,.3)}.vuecal--overflow-x.vuecal--week-view.vuecal--sticky-split-labels .vuecal__time-column{margin-top:3.4em}.vuecal--overflow-x.vuecal--day-view.vuecal--sticky-split-labels .vuecal__time-column{margin-top:1.5em}.vuecal__time-column .vuecal__time-cell{color:#999;text-align:right;padding-right:2px;font-size:.9em}.vuecal__time-column .vuecal__time-cell .line:before{content:\"\";position:absolute;left:0;right:0;border-top:1px solid #eee}.vuecal__cells{margin:0 1px 1px 0}.vuecal--overflow-x.vuecal--day-view .vuecal__cells{margin:0}.vuecal--events-on-month-view.vuecal--short-events .vuecal__cells{width:99.9%}.vuecal--overflow-x.vuecal--day-view .vuecal__cells,.vuecal--overflow-x.vuecal--week-view .vuecal__cells{flex-wrap:nowrap;overflow:auto}.slide-fade--left-enter-active,.slide-fade--left-leave-active,.slide-fade--right-enter-active,.slide-fade--right-leave-active{transition:.25s ease-out}.slide-fade--left-enter,.slide-fade--right-leave-to{transform:translateX(-15px);opacity:0}.slide-fade--left-leave-to,.slide-fade--right-enter{transform:translateX(15px);opacity:0}.slide-fade--left-leave-active,.slide-fade--right-leave-active{position:absolute!important;height:100%}.vuecal__title-bar .slide-fade--left-leave-active,.vuecal__title-bar .slide-fade--right-leave-active{left:0;right:0;height:auto}.vuecal__heading .slide-fade--left-leave-active,.vuecal__heading .slide-fade--right-leave-active{display:flex;align-items:center}.vuecal--green-theme .vuecal__cell-events-count,.vuecal--green-theme .vuecal__menu{background-color:#42b983;color:#fff}.vuecal--green-theme .vuecal__title-bar{background-color:#e4f5ef}.vuecal--green-theme .vuecal__cell--current,.vuecal--green-theme .vuecal__cell--today{background-color:rgba(240,240,255,.4)}.vuecal--green-theme:not(.vuecal--day-view) .vuecal__cell--selected{background-color:rgba(235,255,245,.4)}.vuecal--green-theme .vuecal__cell--selected:before{border-color:rgba(66,185,131,.5)}.vuecal--green-theme .vuecal__cell--highlighted:not(.vuecal__cell--has-splits),.vuecal--green-theme .vuecal__cell-split--highlighted{background-color:rgba(195,255,225,.5)}.vuecal--green-theme .vuecal__arrow--highlighted,.vuecal--green-theme .vuecal__today-btn--highlighted,.vuecal--green-theme .vuecal__view-btn--highlighted{background-color:rgba(136,236,191,.25)}.vuecal--blue-theme .vuecal__cell-events-count,.vuecal--blue-theme .vuecal__menu{background-color:rgba(66,163,185,.8);color:#fff}.vuecal--blue-theme .vuecal__title-bar{background-color:rgba(0,165,188,.3)}.vuecal--blue-theme .vuecal__cell--current,.vuecal--blue-theme .vuecal__cell--today{background-color:rgba(240,240,255,.4)}.vuecal--blue-theme:not(.vuecal--day-view) .vuecal__cell--selected{background-color:rgba(235,253,255,.4)}.vuecal--blue-theme .vuecal__cell--selected:before{border-color:rgba(115,191,204,.5)}.vuecal--blue-theme .vuecal__cell--highlighted:not(.vuecal__cell--has-splits),.vuecal--blue-theme .vuecal__cell-split--highlighted{background-color:rgba(0,165,188,.06)}.vuecal--blue-theme .vuecal__arrow--highlighted,.vuecal--blue-theme .vuecal__today-btn--highlighted,.vuecal--blue-theme .vuecal__view-btn--highlighted{background-color:rgba(66,163,185,.2)}.vuecal--rounded-theme .vuecal__weekdays-headings{border:none}.vuecal--rounded-theme .vuecal__cell,.vuecal--rounded-theme:not(.vuecal--day-view) .vuecal__cell:before{background:none;border:none}.vuecal--rounded-theme .vuecal__cell.out-of-scope{opacity:.4}.vuecal--rounded-theme .vuecal__cell-content{width:30px;height:30px;flex-grow:0;border:1px solid transparent;border-radius:30px;color:#333}.vuecal--rounded-theme.vuecal--day-view .vuecal__cell-content{width:auto;background:none}.vuecal--rounded-theme.vuecal--year-view .vuecal__cell{width:33.33%}.vuecal--rounded-theme.vuecal--year-view .vuecal__cell-content{width:85px}.vuecal--rounded-theme.vuecal--years-view .vuecal__cell-content{width:52px}.vuecal--rounded-theme .vuecal__cell{background-color:transparent!important}.vuecal--rounded-theme.vuecal--green-theme:not(.vuecal--day-view) .vuecal__cell-content{background-color:#f1faf7}.vuecal--rounded-theme.vuecal--green-theme:not(.vuecal--day-view) .vuecal__cell--today .vuecal__cell-content{background-color:#42b983;color:#fff}.vuecal--rounded-theme.vuecal--green-theme .vuecal--day-view .vuecal__cell--today:before{background-color:rgba(66,185,131,.05)}.vuecal--rounded-theme.vuecal--green-theme:not(.vuecal--day-view) .vuecal__cell--selected .vuecal__cell-content{border-color:#42b983}.vuecal--rounded-theme.vuecal--green-theme .vuecal__cell--highlighted:not(.vuecal__cell--has-splits),.vuecal--rounded-theme.vuecal--green-theme .vuecal__cell-split--highlighted{background-color:rgba(195,255,225,.5)}.vuecal--rounded-theme.vuecal--blue-theme:not(.vuecal--day-view) .vuecal__cell-content{background-color:rgba(100,182,255,.2)}.vuecal--rounded-theme.vuecal--blue-theme:not(.vuecal--day-view) .vuecal__cell--today .vuecal__cell-content{background-color:#8fb7e4;color:#fff}.vuecal--rounded-theme.vuecal--blue-theme .vuecal--day-view .vuecal__cell--today:before{background-color:rgba(143,183,228,.1)}.vuecal--rounded-theme.vuecal--blue-theme:not(.vuecal--day-view) .vuecal__cell--selected .vuecal__cell-content{border-color:#61a9e0}.vuecal--rounded-theme.vuecal--blue-theme .vuecal__cell--highlighted:not(.vuecal__cell--has-splits),.vuecal--rounded-theme.vuecal--blue-theme .vuecal__cell-split--highlighted{background-color:rgba(0,165,188,.06)}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".vuecal__cell:before {\n  border: 0;\n}\n.vuecal__flex {\n  background-color: #fff;\n}\n.vuecal {\n  margin: 5px 0;\n  padding: 5px 8px;\n  background-color: #fff;\n  border-radius: 10px;\n}\n.cal-wrapper {\n  margin: 2px 5px;\n  display: inline-block;\n  width: calc(48vw - 4px);\n  pointer-events: none;\n}\n.cal-wrapper .cal-title {\n  padding: 5px 0;\n  font-size: 12px;\n  color: #121236;\n  font-weight: bold;\n  text-align: center;\n}\n.cal-wrapper .vuecal {\n  box-shadow: none;\n}\n.cal-wrapper .vuecal__title-bar {\n  background-color: transparent;\n  font-size: 16px;\n  font-weight: bold;\n}\n.cal-wrapper .vuecal__heading {\n  display: none;\n}\n.cal-wrapper .calendar-cell {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-around;\n  border-radius: 4px;\n  background: rgba(0, 0, 0, 0.1);\n  color: rgba(0, 0, 0, 0.2);\n  border: 2px solid #fff;\n}\n.cal-wrapper .calendar-cell .day {\n  font-size: 12px;\n  scale: 0.8;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, ".search-content[data-v-2964f21b] {\n  display: flex;\n  align-items: center;\n  margin: 54px 10px 5px;\n  padding-top: 10px;\n  color: rgba(18, 18, 54, 0.5);\n  font-size: 12px;\n}\n.search-content .search-item[data-v-2964f21b] {\n  width: 100%;\n  padding: 6px;\n  background: #fff;\n  border-radius: 6px;\n  color: rgba(0, 0, 0, 0.8);\n  margin-right: 5px;\n}\n.air-calendar-page[data-v-2964f21b] {\n  width: 100%;\n  height: 100vh;\n  background-color: #fafafa;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/vue-cal/dist/vuecal.common.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-cal/dist/vuecal.common.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		37: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "vuecal.common." + ({"0":"i18n/ar","1":"i18n/bg","2":"i18n/bn","3":"i18n/bs","4":"i18n/ca","5":"i18n/cs","6":"i18n/da","7":"i18n/de","8":"i18n/el","9":"i18n/es","10":"i18n/fa","11":"i18n/fr","12":"i18n/he","13":"i18n/hr","14":"i18n/hu","15":"i18n/id","16":"i18n/is","17":"i18n/it","18":"i18n/ja","19":"i18n/ka","20":"i18n/ko","21":"i18n/lt","22":"i18n/nl","23":"i18n/no","24":"i18n/pl","25":"i18n/pt-br","26":"i18n/ro","27":"i18n/ru","28":"i18n/sk","29":"i18n/sl","30":"i18n/sr","31":"i18n/sv","32":"i18n/tr","33":"i18n/uk","34":"i18n/vi","35":"i18n/zh-cn","36":"i18n/zh-hk"}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = (typeof self !== 'undefined' ? self : this)["webpackJsonpvuecal"] = (typeof self !== 'undefined' ? self : this)["webpackJsonpvuecal"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00aa":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "057f":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyNames = __webpack_require__("241c").f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var has = __webpack_require__("5135");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "1148":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var isRegExp = __webpack_require__("44e7");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);


/***/ }),

/***/ "13d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $reduce = __webpack_require__("d58f").left;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "1516":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "159b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var forEach = __webpack_require__("17c2");
var createNonEnumerableProperty = __webpack_require__("9112");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "1790":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./ar": [
		"bd5b",
		0
	],
	"./ar.json": [
		"bd5b",
		0
	],
	"./bg": [
		"3e48",
		1
	],
	"./bg.json": [
		"3e48",
		1
	],
	"./bn": [
		"e160",
		2
	],
	"./bn.json": [
		"e160",
		2
	],
	"./bs": [
		"53fe",
		3
	],
	"./bs.json": [
		"53fe",
		3
	],
	"./ca": [
		"36ee",
		4
	],
	"./ca.json": [
		"36ee",
		4
	],
	"./cs": [
		"e3ad",
		5
	],
	"./cs.json": [
		"e3ad",
		5
	],
	"./da": [
		"e5bc",
		6
	],
	"./da.json": [
		"e5bc",
		6
	],
	"./de": [
		"8d7d",
		7
	],
	"./de.json": [
		"8d7d",
		7
	],
	"./el": [
		"9e70",
		8
	],
	"./el.json": [
		"9e70",
		8
	],
	"./en": [
		"7213"
	],
	"./en.json": [
		"7213"
	],
	"./es": [
		"e240",
		9
	],
	"./es.json": [
		"e240",
		9
	],
	"./fa": [
		"d53b",
		10
	],
	"./fa.json": [
		"d53b",
		10
	],
	"./fr": [
		"0699",
		11
	],
	"./fr.json": [
		"0699",
		11
	],
	"./he": [
		"616e",
		12
	],
	"./he.json": [
		"616e",
		12
	],
	"./hr": [
		"7cd4",
		13
	],
	"./hr.json": [
		"7cd4",
		13
	],
	"./hu": [
		"e131",
		14
	],
	"./hu.json": [
		"e131",
		14
	],
	"./id": [
		"2147",
		15
	],
	"./id.json": [
		"2147",
		15
	],
	"./is": [
		"503f",
		16
	],
	"./is.json": [
		"503f",
		16
	],
	"./it": [
		"eed7",
		17
	],
	"./it.json": [
		"eed7",
		17
	],
	"./ja": [
		"39f7",
		18
	],
	"./ja.json": [
		"39f7",
		18
	],
	"./ka": [
		"acbd",
		19
	],
	"./ka.json": [
		"acbd",
		19
	],
	"./ko": [
		"50dc",
		20
	],
	"./ko.json": [
		"50dc",
		20
	],
	"./lt": [
		"8ed2",
		21
	],
	"./lt.json": [
		"8ed2",
		21
	],
	"./nl": [
		"b258",
		22
	],
	"./nl.json": [
		"b258",
		22
	],
	"./no": [
		"f1ef",
		23
	],
	"./no.json": [
		"f1ef",
		23
	],
	"./pl": [
		"6079",
		24
	],
	"./pl.json": [
		"6079",
		24
	],
	"./pt-br": [
		"89f4",
		25
	],
	"./pt-br.json": [
		"89f4",
		25
	],
	"./ro": [
		"abf5",
		26
	],
	"./ro.json": [
		"abf5",
		26
	],
	"./ru": [
		"a65a",
		27
	],
	"./ru.json": [
		"a65a",
		27
	],
	"./sk": [
		"a39e",
		28
	],
	"./sk.json": [
		"a39e",
		28
	],
	"./sl": [
		"c9a5",
		29
	],
	"./sl.json": [
		"c9a5",
		29
	],
	"./sr": [
		"7981",
		30
	],
	"./sr.json": [
		"7981",
		30
	],
	"./sv": [
		"2a6b",
		31
	],
	"./sv.json": [
		"2a6b",
		31
	],
	"./tr": [
		"278e",
		32
	],
	"./tr.json": [
		"278e",
		32
	],
	"./uk": [
		"7405",
		33
	],
	"./uk.json": [
		"7405",
		33
	],
	"./vi": [
		"c5f8",
		34
	],
	"./vi.json": [
		"c5f8",
		34
	],
	"./zh-cn": [
		"88b4",
		35
	],
	"./zh-cn.json": [
		"88b4",
		35
	],
	"./zh-hk": [
		"cb46",
		36
	],
	"./zh-hk.json": [
		"cb46",
		36
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(function() {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {
		return __webpack_require__.t(id, 3);
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = "1790";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "17c2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__("b727").forEach;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),

/***/ "19aa":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "1a4e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c0b":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1cdc":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "1d80":
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "2029":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_weekdays_headings_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("725e");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_weekdays_headings_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_weekdays_headings_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_weekdays_headings_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "2266":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var bind = __webpack_require__("0366");
var getIteratorMethod = __webpack_require__("35a1");
var callWithSafeIterationClosing = __webpack_require__("9bdd");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};


/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var setGlobal = __webpack_require__("ce4e");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "2532":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "25f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__("6eeb");
var anObject = __webpack_require__("825a");
var fails = __webpack_require__("d039");
var flags = __webpack_require__("ad6d");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "2626":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var definePropertyModule = __webpack_require__("9bf2");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "2cf4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");
var bind = __webpack_require__("0366");
var html = __webpack_require__("1be4");
var createElement = __webpack_require__("cc12");
var IS_IOS = __webpack_require__("1cdc");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "342f":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "38c4":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "38cf":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var repeat = __webpack_require__("1148");

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
$({ target: 'String', proto: true }, {
  repeat: repeat
});


/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "3ca3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "4160":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var forEach = __webpack_require__("17c2");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "428f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global;


/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "44d2":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var create = __webpack_require__("7c73");
var definePropertyModule = __webpack_require__("9bf2");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "44de":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "45fc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $some = __webpack_require__("b727").some;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('some');
var USES_TO_LENGTH = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aFunction = __webpack_require__("1c0b");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "4930":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toLength = __webpack_require__("50c4");
var toAbsoluteIndex = __webpack_require__("23cb");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4de4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $filter = __webpack_require__("b727").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__("0366");
var toObject = __webpack_require__("7b0b");
var callWithSafeIterationClosing = __webpack_require__("9bdd");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var getIteratorMethod = __webpack_require__("35a1");

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "4fad":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var $entries = __webpack_require__("6f53").entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "5135":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "5319":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.4',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");
var whitespaces = __webpack_require__("5899");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "5a34":
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__("44e7");

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "6062":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "60da":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var objectKeys = __webpack_require__("df75");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;


/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "6566":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__("9bf2").f;
var create = __webpack_require__("7c73");
var redefineAll = __webpack_require__("e2cc");
var bind = __webpack_require__("0366");
var anInstance = __webpack_require__("19aa");
var iterate = __webpack_require__("2266");
var defineIterator = __webpack_require__("7dd0");
var setSpecies = __webpack_require__("2626");
var DESCRIPTORS = __webpack_require__("83ab");
var fastKey = __webpack_require__("f183").fastKey;
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var objectHas = __webpack_require__("5135");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6d61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var InternalMetadataModule = __webpack_require__("f183");
var iterate = __webpack_require__("2266");
var anInstance = __webpack_require__("19aa");
var isObject = __webpack_require__("861d");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var setToStringTag = __webpack_require__("d44e");
var inheritIfRequired = __webpack_require__("7156");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "6eeb":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var setGlobal = __webpack_require__("ce4e");
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "6f53":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var objectKeys = __webpack_require__("df75");
var toIndexedObject = __webpack_require__("fc6a");
var propertyIsEnumerable = __webpack_require__("d1e7").f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7213":
/***/ (function(module) {

module.exports = JSON.parse("{\"weekDays\":[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"],\"months\":[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"years\":\"Years\",\"year\":\"Year\",\"month\":\"Month\",\"week\":\"Week\",\"day\":\"Day\",\"today\":\"Today\",\"noEvent\":\"No Event\",\"allDay\":\"All day\",\"deleteEvent\":\"Delete\",\"createEvent\":\"Create an event\",\"dateFormat\":\"dddd MMMM D{S}, YYYY\"}");

/***/ }),

/***/ "725e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "746f":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var has = __webpack_require__("5135");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var defineProperties = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "7db0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $find = __webpack_require__("b727").find;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "7dd0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createIteratorConstructor = __webpack_require__("9ed3");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");
var Iterators = __webpack_require__("3f8c");
var IteratorsCore = __webpack_require__("ae93");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "7f9a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var inspectSource = __webpack_require__("8925");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "81d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__("c04e");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "857a":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ "861d":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("c6cd");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");

/***/ }),

/***/ "90e3":
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "99af":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var arraySpeciesCreate = __webpack_require__("65f0");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "9bdd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var anObject = __webpack_require__("825a");
var toPrimitive = __webpack_require__("c04e");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9ed3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var setToStringTag = __webpack_require__("d44e");
var Iterators = __webpack_require__("3f8c");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__("d039");

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "9ff5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_event_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1516");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_event_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_event_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_event_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "a15b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IndexedObject = __webpack_require__("44ad");
var toIndexedObject = __webpack_require__("fc6a");
var arrayMethodIsStrict = __webpack_require__("a640");

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "a434":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toAbsoluteIndex = __webpack_require__("23cb");
var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");
var toObject = __webpack_require__("7b0b");
var arraySpeciesCreate = __webpack_require__("65f0");
var createProperty = __webpack_require__("8418");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "a4d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var createPropertyDescriptor = __webpack_require__("5c6c");
var nativeObjectCreate = __webpack_require__("7c73");
var objectKeys = __webpack_require__("df75");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternal = __webpack_require__("057f");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var shared = __webpack_require__("5692");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");
var uid = __webpack_require__("90e3");
var wellKnownSymbol = __webpack_require__("b622");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineWellKnownSymbol = __webpack_require__("746f");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");
var $forEach = __webpack_require__("b727").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "a630":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var from = __webpack_require__("4df4");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "a640":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "a691":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var has = __webpack_require__("5135");
var classof = __webpack_require__("c6b6");
var inheritIfRequired = __webpack_require__("7156");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var create = __webpack_require__("7c73");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "ab13":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "ae40":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};


/***/ }),

/***/ "ae93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__("e163");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "af03":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b575":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var classof = __webpack_require__("c6b6");
var macrotask = __webpack_require__("2cf4").set;
var IS_IOS = __webpack_require__("1cdc");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var has = __webpack_require__("5135");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b64b":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var nativeKeys = __webpack_require__("df75");
var fails = __webpack_require__("d039");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};


/***/ }),

/***/ "bb2f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c6b6":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setGlobal = __webpack_require__("ce4e");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c740":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $findIndex = __webpack_require__("b727").findIndex;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c96a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.small` method
// https://tc39.github.io/ecma262/#sec-string.prototype.small
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('small') }, {
  small: function small() {
    return createHTML(this, 'small', '', '');
  }
});


/***/ }),

/***/ "c975":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $indexOf = __webpack_require__("4d64").indexOf;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "caad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $includes = __webpack_require__("4d64").includes;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "cb29":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fill = __webpack_require__("81d5");
var addToUnscopables = __webpack_require__("44d2");

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "cca6":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var assign = __webpack_require__("60da");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "cdf9":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var newPromiseCapability = __webpack_require__("f069");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "ce4e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "d011":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_cell_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("38c4");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_cell_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_cell_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_cell_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var global = __webpack_require__("da84");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "d28b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("746f");

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var redefine = __webpack_require__("6eeb");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d58f":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");
var toLength = __webpack_require__("50c4");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var redefine = __webpack_require__("6eeb");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var regexpExec = __webpack_require__("9263");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "da8a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_header_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1a4e");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_header_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_header_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_header_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "dbb4":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var ownKeys = __webpack_require__("56ef");
var toIndexedObject = __webpack_require__("fc6a");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var createProperty = __webpack_require__("8418");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "ddb0":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var ArrayIteratorMethods = __webpack_require__("e260");
var createNonEnumerableProperty = __webpack_require__("9112");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var has = __webpack_require__("5135");
var isObject = __webpack_require__("861d");
var defineProperty = __webpack_require__("9bf2").f;
var copyConstructorProperties = __webpack_require__("e893");

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "e163":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toObject = __webpack_require__("7b0b");
var sharedKey = __webpack_require__("f772");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "e177":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "e260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var addToUnscopables = __webpack_require__("44d2");
var Iterators = __webpack_require__("3f8c");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "e2cc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("6eeb");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "e439":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
var DESCRIPTORS = __webpack_require__("83ab");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "e667":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "e6cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var NativePromise = __webpack_require__("fea9");
var redefine = __webpack_require__("6eeb");
var redefineAll = __webpack_require__("e2cc");
var setToStringTag = __webpack_require__("d44e");
var setSpecies = __webpack_require__("2626");
var isObject = __webpack_require__("861d");
var aFunction = __webpack_require__("1c0b");
var anInstance = __webpack_require__("19aa");
var classof = __webpack_require__("c6b6");
var inspectSource = __webpack_require__("8925");
var iterate = __webpack_require__("2266");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var speciesConstructor = __webpack_require__("4840");
var task = __webpack_require__("2cf4").set;
var microtask = __webpack_require__("b575");
var promiseResolve = __webpack_require__("cdf9");
var hostReportErrors = __webpack_require__("44de");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var InternalStateModule = __webpack_require__("69f3");
var isForced = __webpack_require__("94ca");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "f069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("1c0b");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "f183":
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__("d012");
var isObject = __webpack_require__("861d");
var has = __webpack_require__("5135");
var defineProperty = __webpack_require__("9bf2").f;
var uid = __webpack_require__("90e3");
var FREEZING = __webpack_require__("bb2f");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "f6fd":
/***/ (function(module, exports) {

// document.currentScript polyfill by Adam Miller

// MIT license

(function(document){
  var currentScript = "currentScript",
      scripts = document.getElementsByTagName('script'); // Live NodeList collection

  // If browser needs currentScript polyfill, add get currentScript() to the document object
  if (!(currentScript in document)) {
    Object.defineProperty(document, currentScript, {
      get: function(){

        // IE 6-10 supports script readyState
        // IE 10+ support stack trace
        try { throw new Error(); }
        catch (err) {

          // Find the second match for the "at" string to get file src url from stack.
          // Specifically works with the format of stack traces in IE.
          var i, res = ((/.*at [^\(]*\((.*):.+:.+\)$/ig).exec(err.stack) || [false])[1];

          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag
          for(i in scripts){
            if(scripts[i].src == res || scripts[i].readyState == "interactive"){
              return scripts[i];
            }
          }

          // If no match, return null
          return null;
        }
      }
    });
  }
})(document);


/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  if (true) {
    __webpack_require__("f6fd")
  }

  var setPublicPath_i
  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"487f8217-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/index.vue?vue&type=template&id=0efd3937&lang=pug&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"vuecal",staticClass:"vuecal__flex vuecal",class:_vm.cssClasses,attrs:{"column":"","lang":_vm.locale}},[_c('vuecal-header',{attrs:{"options":_vm.$props,"view-props":{ views: _vm.views, view: _vm.view, weekDaysInHeader: _vm.weekDaysInHeader },"week-days":_vm.weekDays,"day-splits":_vm.daySplits,"switch-to-narrower-view":_vm.switchToNarrowerView},scopedSlots:_vm._u([{key:"arrow-prev",fn:function(){return [_vm._t("arrow-prev",[_vm._v(" "),_c('i',{staticClass:"angle"}),_vm._v(" ")])]},proxy:true},{key:"arrow-next",fn:function(){return [_vm._t("arrow-next",[_vm._v(" "),_c('i',{staticClass:"angle"}),_vm._v(" ")])]},proxy:true},{key:"today-button",fn:function(){return [_vm._t("today-button",[_c('span',{staticClass:"default"},[_vm._v(_vm._s(_vm.texts.today))])])]},proxy:true},{key:"title",fn:function(){return [_vm._t("title",[_vm._v(_vm._s(_vm.viewTitle))],{"title":_vm.viewTitle,"view":_vm.view})]},proxy:true},{key:"weekday-heading",fn:function(ref){
var heading = ref.heading;
var view = ref.view;
return [_vm._t("weekday-heading",null,{"heading":heading,"view":view})]}}],null,true)}),(!_vm.hideBody)?_c('div',{staticClass:"vuecal__flex vuecal__body",attrs:{"grow":""}},[_c('transition',{attrs:{"name":("slide-fade--" + _vm.transitionDirection),"appear":_vm.transitions}},[_c('div',{key:_vm.transitions ? _vm.view.id : false,staticClass:"vuecal__flex",staticStyle:{"min-width":"100%"},attrs:{"column":""}},[(_vm.showAllDayEvents && _vm.hasTimeColumn)?_c('div',{staticClass:"vuecal__flex vuecal__all-day"},[_c('span',{staticStyle:{"width":"3em"}},[_c('span',[_vm._v(_vm._s(_vm.texts.allDay))])]),_c('div',{staticClass:"vuecal__flex vuecal__cells",class:((_vm.view.id) + "-view"),attrs:{"grow":"","wrap":(!_vm.minCellWidth && !_vm.minSplitWidth) || _vm.view.id !== 'week',"column":!!_vm.minCellWidth || !!_vm.minSplitWidth}},_vm._l((_vm.viewCells),function(cell,i){return _c('vuecal-cell',{key:i,attrs:{"options":_vm.$props,"data":cell,"all-day":true,"min-timestamp":_vm.minTimestamp,"max-timestamp":_vm.maxTimestamp,"cell-splits":_vm.hasSplits && _vm.daySplits || []},scopedSlots:_vm._u([{key:"event",fn:function(ref){
var event = ref.event;
var view = ref.view;
return [_vm._t("event",[(_vm.editableEvents && event.title)?_c('div',{staticClass:"vuecal__event-title vuecal__event-title--edit",attrs:{"contenteditable":""},domProps:{"innerHTML":_vm._s(event.title)},on:{"blur":function($event){return _vm.onEventTitleBlur($event, event)}}}):(event.title)?_c('div',{staticClass:"vuecal__event-title",domProps:{"innerHTML":_vm._s(event.title)}}):_vm._e(),(event.content && _vm.showAllDayEvents !== 'short' && !_vm.isShortMonthView)?_c('div',{staticClass:"vuecal__event-content",domProps:{"innerHTML":_vm._s(event.content)}}):_vm._e()],{"view":view,"event":event})]}}],null,true)},[_vm._t("no-event",null,{"slot":"no-event"})],2)}),1)]):_vm._e(),_c('div',{staticClass:"vuecal__bg",class:{ vuecal__flex: !_vm.hasTimeColumn },attrs:{"column":""}},[_c('div',{staticClass:"vuecal__flex",attrs:{"row":"","grow":""}},[(_vm.hasTimeColumn)?_c('div',{staticClass:"vuecal__time-column"},_vm._l((_vm.timeCells),function(cell,i){return _c('div',{key:i,staticClass:"vuecal__time-cell",style:(("height: " + _vm.timeCellHeight + "px"))},[_vm._t("time-cell",[_c('span',{staticClass:"line"}),_c('span',{staticClass:"label"},[_vm._v(_vm._s(cell.label))])],{"hours":cell.hours,"minutes":cell.minutes})],2)}),0):_vm._e(),(_vm.showWeekNumbers && _vm.view.id === 'month')?_c('div',{staticClass:"vuecal__flex vuecal__week-numbers",attrs:{"column":""}},_vm._l((6),function(i){return _c('div',{key:i,staticClass:"vuecal__flex vuecal__week-number-cell",attrs:{"grow":""}},[_vm._t("week-number-cell",[_vm._v(_vm._s(_vm.getWeekNumber(i - 1)))],{"week":_vm.getWeekNumber(i - 1)})],2)}),0):_vm._e(),_c('div',{staticClass:"vuecal__flex vuecal__cells",class:((_vm.view.id) + "-view"),attrs:{"grow":"","wrap":(!_vm.minCellWidth && !_vm.minSplitWidth) || _vm.view.id !== 'week',"column":!!_vm.minCellWidth || !!_vm.minSplitWidth}},[((_vm.minCellWidth || (_vm.hasSplits && _vm.minSplitWidth)) && _vm.view.id === 'week')?_c('weekdays-headings',{style:(_vm.contentMinWidth ? ("min-width: " + _vm.contentMinWidth + "px") : ''),attrs:{"vuecal":this,"transition-direction":_vm.transitionDirection,"view":_vm.view,"week-days":_vm.weekDays,"switch-to-narrower-view":_vm.switchToNarrowerView},scopedSlots:_vm._u([{key:"weekday-heading",fn:function(ref){
var heading = ref.heading;
var view = ref.view;
return [_vm._t("weekday-heading",null,{"heading":heading,"view":view})]}}],null,true)}):(_vm.hasSplits && _vm.stickySplitLabels && _vm.minSplitWidth)?_c('div',{staticClass:"vuecal__flex vuecal__split-days-headers",style:(_vm.contentMinWidth ? ("min-width: " + _vm.contentMinWidth + "px") : '')},_vm._l((_vm.daySplits),function(split,i){return _c('div',{key:i,staticClass:"day-split-header",class:split.class || false},[_vm._v(_vm._s(split.label))])}),0):_vm._e(),_c('div',{ref:"cells",staticClass:"vuecal__flex",style:(_vm.contentMinWidth ? ("min-width: " + _vm.contentMinWidth + "px") : ''),attrs:{"grow":"","wrap":(!_vm.minCellWidth && !_vm.minSplitWidth) || _vm.view.id !== 'week'}},_vm._l((_vm.viewCells),function(cell,i){return _c('vuecal-cell',{key:i,attrs:{"options":_vm.$props,"data":cell,"cell-width":_vm.hideWeekdays.length && ['month', 'week'].includes(_vm.view.id) && _vm.cellWidth,"min-timestamp":_vm.minTimestamp,"max-timestamp":_vm.maxTimestamp,"cell-splits":_vm.hasSplits && _vm.daySplits || []},scopedSlots:_vm._u([{key:"cell-content",fn:function(ref){
var events = ref.events;
var split = ref.split;
var selectCell = ref.selectCell;
return [_vm._t("cell-content",[(split && !_vm.stickySplitLabels)?_c('div',{staticClass:"split-label",domProps:{"innerHTML":_vm._s(split.label)}}):_vm._e(),(cell.content)?_c('div',{staticClass:"vuecal__cell-date",domProps:{"innerHTML":_vm._s(cell.content)}}):_vm._e(),(((_vm.view.id === 'month' && !_vm.eventsOnMonthView) || (['years', 'year'].includes(_vm.view.id) && _vm.eventsCountOnYearView)) && events.length)?_c('div',{staticClass:"vuecal__cell-events-count"},[_vm._t("events-count",[_vm._v(_vm._s(events.length))],{"view":_vm.view,"events":events})],2):_vm._e(),(!events.length && ['week', 'day'].includes(_vm.view.id))?_c('div',{staticClass:"vuecal__no-event"},[_vm._t("no-event",[_vm._v(_vm._s(_vm.texts.noEvent))])],2):_vm._e()],{"cell":cell,"view":_vm.view,"goNarrower":selectCell,"events":events})]}},{key:"event",fn:function(ref){
var event = ref.event;
var view = ref.view;
return [_vm._t("event",[(_vm.editableEvents && event.title)?_c('div',{staticClass:"vuecal__event-title vuecal__event-title--edit",attrs:{"contenteditable":""},domProps:{"innerHTML":_vm._s(event.title)},on:{"blur":function($event){return _vm.onEventTitleBlur($event, event)}}}):(event.title)?_c('div',{staticClass:"vuecal__event-title",domProps:{"innerHTML":_vm._s(event.title)}}):_vm._e(),(_vm.time && !event.allDay && (event.startTimeMinutes || event.endTimeMinutes) && !(view === 'month' && (event.allDay || _vm.showAllDayEvents === 'short')) && !_vm.isShortMonthView)?_c('div',{staticClass:"vuecal__event-time"},[_vm._v(_vm._s(_vm.formatTime(event.startTimeMinutes))),(event.endTimeMinutes)?_c('span',[_vm._v(" - "+_vm._s(_vm.formatTime(event.endTimeMinutes)))]):_vm._e(),(event.daysCount > 1 && (event.segments[cell.formattedDate] || {}).isFirstDay)?_c('small',{staticClass:"days-to-end"},[_vm._v(" +"+_vm._s(event.daysCount - 1)+_vm._s((_vm.texts.day[0] || '').toLowerCase()))]):_vm._e()]):_vm._e(),(event.content && !(view === 'month' && event.allDay && _vm.showAllDayEvents === 'short') && !_vm.isShortMonthView)?_c('div',{staticClass:"vuecal__event-content",domProps:{"innerHTML":_vm._s(event.content)}}):_vm._e()],{"view":view,"event":event})]}}],null,true)},[_vm._t("default")],2)}),1)],1)])])])])],1):_vm._e()],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/vue-cal/index.vue?vue&type=template&id=0efd3937&lang=pug&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __webpack_require__("cb29");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.for-each.js
var es_array_for_each = __webpack_require__("4160");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
var es_array_index_of = __webpack_require__("c975");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.some.js
var es_array_some = __webpack_require__("45fc");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.repeat.js
var es_string_repeat = __webpack_require__("38cf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.small.js
var es_string_small = __webpack_require__("c96a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js







function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js








function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js



function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js









function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __webpack_require__("e439");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var es_object_get_own_property_descriptors = __webpack_require__("dbb4");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js









function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// CONCATENATED MODULE: ./src/components/vue-cal/date-utils.js






// Cache Today's date (to a maximum) for better isToday() performances. Formatted without leading 0.
// We still need to update Today's date when Today changes without page refresh.
var date_utils_now, todayDate, todayF;

var todayFormatted = function todayFormatted() {
  if (todayDate !== new Date().getDate()) {
    date_utils_now = new Date();
    todayDate = date_utils_now.getDate();
    todayF = "".concat(date_utils_now.getFullYear(), "-").concat(date_utils_now.getMonth(), "-").concat(date_utils_now.getDate());
  }

  return todayF;
};

var initDatePrototypes = function initDatePrototypes() {
  Date.texts = {
    weekDays: Array(7).fill(''),
    months: Array(12).fill('')
  }; // eslint-disable-next-line

  Date.prototype.addDays = function (days) {
    var date = new Date(this.valueOf());
    date.setDate(date.getDate() + days);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.subtractDays = function (days) {
    var date = new Date(this.valueOf());
    date.setDate(date.getDate() - days);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.addHours = function (hours) {
    var date = new Date(this.valueOf());
    date.setHours(date.getHours() + hours);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.subtractHours = function (hours) {
    var date = new Date(this.valueOf());
    date.setHours(date.getHours() - hours);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.addMinutes = function (minutes) {
    var date = new Date(this.valueOf());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.subtractMinutes = function (minutes) {
    var date = new Date(this.valueOf());
    date.setMinutes(date.getMinutes() - minutes);
    return date;
  }; // eslint-disable-next-line


  Date.prototype.getWeek = function () {
    var d = new Date(Date.UTC(this.getFullYear(), this.getMonth(), this.getDate()));
    var dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
  }; // eslint-disable-next-line


  Date.prototype.isToday = function () {
    return "".concat(this.getFullYear(), "-").concat(this.getMonth(), "-").concat(this.getDate()) === todayFormatted();
  }; // eslint-disable-next-line


  Date.prototype.isLeapYear = function () {
    var year = this.getFullYear();
    return !(year % 400) || year % 100 && !(year % 4);
  }; // eslint-disable-next-line


  Date.prototype.format = function () {
    var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'YYYY-MM-DD';
    return date_utils_formatDate(this, format, Date.texts);
  }; // eslint-disable-next-line


  Date.prototype.formatTime = function () {
    var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HH:mm';
    return date_utils_formatTime(this.getHours() * 60 + this.getMinutes(), format, Date.texts);
  };
}; // Add prototypes ASAP.


if (Date && !Date.prototype.addDays) initDatePrototypes();
var date_utils_updateDateTexts = function updateDateTexts(texts) {
  Date.texts = texts;
}; // Returns today if it's FirstDayOfWeek (Monday or Sunday) or previous FirstDayOfWeek otherwise.

var getPreviousFirstDayOfWeek = function getPreviousFirstDayOfWeek() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var weekStartsOnSunday = arguments.length > 1 ? arguments[1] : undefined;
  var prevFirstDayOfWeek = date && new Date(date.valueOf()) || new Date();
  var dayModifier = weekStartsOnSunday ? 7 : 6;
  prevFirstDayOfWeek.setDate(prevFirstDayOfWeek.getDate() - (prevFirstDayOfWeek.getDay() + dayModifier) % 7);
  return prevFirstDayOfWeek;
};

var nth = function nth(d) {
  if (d > 3 && d < 21) return 'th';

  switch (d % 10) {
    case 1:
      return 'st';

    case 2:
      return 'nd';

    case 3:
      return 'rd';

    default:
      return 'th';
  }
};

var dateObject = {};

var hydrateDateObject = function hydrateDateObject(date, texts) {
  if (dateObject.D) return dateObject;
  var YYYY = date.getFullYear();
  var M = date.getMonth() + 1;
  var D = date.getDate();
  var day = date.getDay(); // Day of the week.

  var dayNumber = (day - 1 + 7) % 7; // Day of the week. 0 to 6 with 6 = Sunday.
  // Some of this props are functions, to only calculate on demand.

  dateObject = {
    // Year.
    YYYY: YYYY,
    // 2019.
    YY: function YY() {
      return YYYY.toString().substring(2);
    },
    // 19.
    // Month.
    M: M,
    // 1 to 12.
    MM: function MM() {
      return (M < 10 ? '0' : '') + M;
    },
    // 01 to 12.
    MMM: function MMM() {
      return texts.months[M - 1].substring(0, 3);
    },
    // Jan to Dec.
    MMMM: function MMMM() {
      return texts.months[M - 1];
    },
    // January to December.
    MMMMG: function MMMMG() {
      return (texts.monthsGenitive || texts.months)[M - 1];
    },
    // January to December in genitive form (Greek...)
    // Day.
    D: D,
    // 1 to 31.
    DD: function DD() {
      return (D < 10 ? '0' : '') + D;
    },
    // 01 to 31.
    S: function S() {
      return nth(D);
    },
    // st, nd, rd, th.
    // Day of the week.
    d: dayNumber + 1,
    // 1 to 7 with 7 = Sunday.
    dd: function dd() {
      return texts.weekDays[dayNumber][0];
    },
    // M to S.
    ddd: function ddd() {
      return texts.weekDays[dayNumber].substr(0, 3);
    },
    // Mon to Sun.
    dddd: function dddd() {
      return texts.weekDays[dayNumber];
    } // Monday to Sunday.

  };
  return dateObject;
};

var timeObject = {};

var hydrateTimeObject = function hydrateTimeObject(date, texts) {
  if (timeObject.am) return timeObject;
  var H, m;

  if (date instanceof Date) {
    H = date.getHours();
    m = date.getMinutes();
  } else {
    H = Math.floor(date / 60);
    m = Math.floor(date % 60);
  }

  var h = H % 12 ? H % 12 : 12;
  var am = (texts || {
    am: 'am',
    pm: 'pm'
  })[H === 24 || H < 12 ? 'am' : 'pm'];
  timeObject = {
    H: H,
    h: h,
    HH: (H < 10 ? '0' : '') + H,
    hh: (h < 10 ? '0' : '') + h,
    am: am,
    AM: am.toUpperCase(),
    m: m,
    mm: (m < 10 ? '0' : '') + m
  };
  return timeObject;
}; // Time in minutes.


var date_utils_formatTime = function formatTime(time) {
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'HH:mm';
  var texts = arguments.length > 2 ? arguments[2] : undefined;
  timeObject = {}; // Reinit the time object on each function call.

  var timeObj = hydrateTimeObject(time, texts);
  return format.replace(/(\{[a-zA-Z]+\}|[a-zA-Z]+)/g, function (m, contents) {
    var result = timeObj[contents.replace(/\{|\}/g, '')];
    return result !== undefined ? result : contents;
  });
};
/**
 * Formats a date/time to the given format and returns the formatted string.
 *
 * @param {Date} date a JavaScript Date object to format.
 * @param {String} format the wanted format.
 * @param {Object} texts the vue-cal localized texts object.
 * @return {String} the formatted string.
 */

var date_utils_formatDate = function formatDate(date) {
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'YYYY-MM-DD';
  var texts = arguments.length > 2 ? arguments[2] : undefined;
  if (!format) format = 'YYYY-MM-DD'; // Allows passing null for default format.

  if (format === 'YYYY-MM-DD') return formatDateLite(date); // Reinit the date and time object on each function call.

  dateObject = {};
  timeObject = {}; // Each keyword is a function to load the dateObject or timeObject on demand: no wasted resource.

  var dateObj = {
    YYYY: function YYYY() {
      return hydrateDateObject(date, texts).YYYY;
    },
    YY: function YY() {
      return hydrateDateObject(date, texts).YY();
    },
    M: function M() {
      return hydrateDateObject(date, texts).M;
    },
    MM: function MM() {
      return hydrateDateObject(date, texts).MM();
    },
    MMM: function MMM() {
      return hydrateDateObject(date, texts).MMM();
    },
    MMMM: function MMMM() {
      return hydrateDateObject(date, texts).MMMM();
    },
    MMMMG: function MMMMG() {
      return hydrateDateObject(date, texts).MMMMG();
    },
    D: function D() {
      return hydrateDateObject(date, texts).D;
    },
    DD: function DD() {
      return hydrateDateObject(date, texts).DD();
    },
    S: function S() {
      return hydrateDateObject(date, texts).S();
    },
    d: function d() {
      return hydrateDateObject(date, texts).d;
    },
    dd: function dd() {
      return hydrateDateObject(date, texts).dd();
    },
    ddd: function ddd() {
      return hydrateDateObject(date, texts).ddd();
    },
    dddd: function dddd() {
      return hydrateDateObject(date, texts).dddd();
    },
    HH: function HH() {
      return hydrateTimeObject(date, texts).HH;
    },
    H: function H() {
      return hydrateTimeObject(date, texts).H;
    },
    hh: function hh() {
      return hydrateTimeObject(date, texts).hh;
    },
    h: function h() {
      return hydrateTimeObject(date, texts).h;
    },
    am: function am() {
      return hydrateTimeObject(date, texts).am;
    },
    AM: function AM() {
      return hydrateTimeObject(date, texts).AM;
    },
    mm: function mm() {
      return hydrateTimeObject(date, texts).mm;
    },
    m: function m() {
      return hydrateTimeObject(date, texts).m;
    }
  };
  return format.replace(/(\{[a-zA-Z]+\}|[a-zA-Z]+)/g, function (m, contents) {
    var result = dateObj[contents.replace(/\{|\}/g, '')];
    return result !== undefined ? result() : contents;
  });
}; // More performant function to convert a Date to `YYYY-MM-DD` formatted string only.

var formatDateLite = function formatDateLite(date) {
  var m = date.getMonth() + 1;
  var d = date.getDate();
  return "".concat(date.getFullYear(), "-").concat(m < 10 ? '0' : '').concat(m, "-").concat(d < 10 ? '0' : '').concat(d);
};
/**
 * Converts a string to a Javascript Date object. If a Date object is passed, return it as is.
 *
 * @param {String | Date} date the string to convert to Date.
 * @return {Date} the equivalent Javascript Date object.
 */

var stringToDate = function stringToDate(date) {
  if (date instanceof Date) return date; // Regexp way is less performant: https://jsperf.com/string-to-date-regexp-vs-new-date
  // const [, y, m, d, h = 0, min = 0] = date.match(/(\d{4})-(\d{2})-(\d{2})(?: (\d{2}):(\d{2}))?/)
  // return new Date(y, parseInt(m) - 1, d, h, min)

  return new Date(date.replace(/-/g, '/')); // replace '-' with '/' for Safari.
};
/**
 * Count the number of days this date range spans onto.
 * E.g. countDays(2019-11-02 18:00, 2019-11-03 02:00) = 2
 *
 * @param {String | Date} start the start date
 * @param {String | Date} end the end date
 * @return {Integer} The number of days this date range involves
 */

var countDays = function countDays(start, end) {
  // replace '-' with '/' for Safari.
  if (typeof start === 'string') start = start.replace(/-/g, '/');
  if (typeof end === 'string') end = end.replace(/-/g, '/'); // Set start & end at midnight then compare the delta. Don't modify the original dates.

  start = new Date(start).setHours(0, 0, 0, 0); // Set end at midnight plus 1 sec, so Math.ceil will round it up to a full day.

  end = new Date(end).setHours(0, 0, 1, 0); // Remove the potential daylight saving delta.

  var timezoneDiffMs = (new Date(end).getTimezoneOffset() - new Date(start).getTimezoneOffset()) * 60 * 1000;
  return Math.ceil((end - start - timezoneDiffMs) / (24 * 3600 * 1000));
};
/**
 * Take 2 dates and check if within the same time step (useful in overlapping events).
 *
 * @return {Boolean} `true` if their time is included in the same time step,
 *                   this means these 2 dates are very close.
 */

var datesInSameTimeStep = function datesInSameTimeStep(date1, date2, timeStep) {
  return Math.abs(date1.getTime() - date2.getTime()) <= timeStep * 60 * 1000;
};
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__("c740");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.js
var es_set = __webpack_require__("6062");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./src/components/vue-cal/event-utils.js






















var defaultEventDuration = 2; // In hours.

var minutesInADay = 24 * 60; // Don't do the maths every time.
// This is an approximation, it will not work with DLS time.
// const approxDayMilliseconds = minutesInADay * 60 * 1000
// This is an approximate minimum we can get in a year. Purposely stay bellow 365 but close.
// const minYearMilliseconds = 364 * approxDayMilliseconds // Don't do the maths every time.

var eventDefaults = {
  _eid: null,
  start: '',
  // Externally given formatted date & time.
  startDate: '',
  // Date object.
  startTimeMinutes: 0,
  end: '',
  // Externally given formatted date & time.
  endDate: '',
  // Date object.
  endTimeMinutes: 0,
  title: '',
  content: '',
  background: false,
  allDay: false,
  segments: null,
  repeat: null,
  daysCount: 1,
  deletable: true,
  deleting: false,
  resizable: true,
  resizing: false,
  draggable: true,
  dragging: false,
  draggingStatic: false,
  // Controls the CSS class of the static clone while dragging.
  focused: false,
  top: 0,
  height: 0,
  classes: []
};
/**
 * Create an event at the given date and time, and allow overriding
 * event attributes through the eventOptions object.
 *
 * @param {Date | String} dateTime The date and time of the new event start.
 * @param {Object} eventOptions some options to override the `eventDefaults` - optional.
 * @param {Object} vuecal the vuecal main component, to access needed methods, props, etc.
 */

var event_utils_createAnEvent = function createAnEvent(dateTime, eventOptions, vuecal) {
  if (typeof dateTime === 'string') dateTime = stringToDate(dateTime);
  if (!(dateTime instanceof Date)) return false;
  var hours = dateTime.getHours();
  var minutes = dateTime.getMinutes();
  var startTimeMinutes = hours * 60 + minutes;
  var hoursEnd = hours + defaultEventDuration;
  var endTimeMinutes = startTimeMinutes + 120;
  var formattedHours = (hours < 10 ? '0' : '') + hours;
  var formattedHoursEnd = (hoursEnd < 10 ? '0' : '') + hoursEnd;
  var formattedMinutes = (minutes < 10 ? '0' : '') + minutes;
  var start = formatDateLite(dateTime) + (vuecal.time ? " ".concat(formattedHours, ":").concat(formattedMinutes) : '');
  var end = formatDateLite(dateTime) + (vuecal.time ? " ".concat(formattedHoursEnd, ":").concat(formattedMinutes) : '');

  var event = _objectSpread2({}, eventDefaults, {
    _eid: "".concat(vuecal._uid, "_").concat(vuecal.eventIdIncrement++),
    start: start,
    startDate: dateTime,
    startTimeMinutes: startTimeMinutes,
    end: end,
    endDate: stringToDate(end),
    endTimeMinutes: endTimeMinutes,
    segments: null
  }, eventOptions); // If the onEventCreate() function is given as a parameter to vue-cal:
  // 1. give it access to the created event & the deleteAnEvent() function.
  // 2. Prevent creation of the event if this function returns false.


  if (typeof vuecal.onEventCreate === 'function') {
    if (!vuecal.onEventCreate(event, function () {
      return deleteAnEvent(event, vuecal);
    })) return;
  } // Check if event is a multiple day event and update days count.


  if (event.start.substr(0, 10) !== event.end.substr(0, 10)) {
    event.daysCount = countDays(event.startDate, event.endDate);
  } // Add event to the mutableEvents array.


  vuecal.mutableEvents.push(event); // Add the new event to the current view.
  // The event may have been edited on the fly to become a multiple-day event,
  // the method addEventsToView makes sure the segments are created.

  vuecal.addEventsToView([event]);
  vuecal.emitWithEvent('event-create', event);
  vuecal.emitWithEvent('event-change', event);
  return event;
};
/**
 * Add an event segment (= day) to a multiple-day event.
 *
 * @param {Object} e the multiple-day event to add segment in.
 */

var event_utils_addEventSegment = function addEventSegment(e) {
  if (!e.segments) {
    external_commonjs_vue_commonjs2_vue_root_Vue_default.a.set(e, 'segments', {});
    e.segments[e.start.substr(0, 10)] = {
      startDate: e.startDate,
      start: e.start.substr(0, 10),
      startTimeMinutes: e.startTimeMinutes,
      endTimeMinutes: minutesInADay,
      isFirstDay: true,
      isLastDay: false,
      height: 0,
      top: 0
    };
  } // Modify the last segment - which is no more the last one.


  var previousSegment = e.segments[formatDateLite(e.endDate)]; // previousSegment might not exist when dragging too fast, prevent errors.

  if (previousSegment) {
    previousSegment.isLastDay = false;
    previousSegment.endTimeMinutes = minutesInADay;
  } else {} // @todo: when moving fast might lose the previousSegment.
  // Trying to update it would then result in an error, but do nothing would create a visual bug.
  // Create the new last segment.


  var startDate = e.endDate.addDays(1);
  var endDate = new Date(startDate);
  var formattedDate = formatDateLite(startDate);
  startDate.setHours(0, 0, 0, 0);
  e.segments[formattedDate] = {
    startDate: startDate,
    start: formattedDate,
    startTimeMinutes: 0,
    endTimeMinutes: e.endTimeMinutes,
    isFirstDay: false,
    isLastDay: true,
    height: 0,
    top: 0
  };
  e.daysCount = Object.keys(e.segments).length;
  e.endDate = endDate;
  e.end = "".concat(formattedDate, " ").concat(date_utils_formatTime(e.endTimeMinutes));
  return formattedDate;
};
/**
 * Remove an event segment (= day) from a multiple-day event.
 *
 * @param {Object} e the multiple-day event to remove segments from.
 */

var event_utils_removeEventSegment = function removeEventSegment(e) {
  var segmentsCount = Object.keys(e.segments).length;
  if (segmentsCount <= 1) return e.end.substr(0, 10); // Remove the last segment.

  delete e.segments[e.end.substr(0, 10)];
  segmentsCount--;
  var endDate = e.endDate.subtractDays(1);
  var formattedDate = formatDateLite(endDate);
  var previousSegment = e.segments[formattedDate]; // If no more segments, reset the segments attribute to null.

  if (!segmentsCount) e.segments = null; // previousSegment might not exist when dragging too fast, prevent errors.
  else if (previousSegment) {
      // Modify the new last segment.
      previousSegment.isLastDay = true;
      previousSegment.endTimeMinutes = e.endTimeMinutes;
    } else {// @todo: when moving fast might lose the previousSegment.
      // Trying to update it would then result in an error, but do nothing would create a visual bug.
    }
  e.daysCount = segmentsCount || 1;
  e.endDate = endDate;
  e.end = "".concat(formattedDate, " ").concat(date_utils_formatTime(e.endTimeMinutes));
  return formattedDate;
};
/**
 * Create 1 segment per day of the given event, but only within the current view.
 * (It won't create segments for all the days in view that are not in the event!)
 *
 * An event segment is a piece of event per day that contains more day-specific data.
 *
 * @param {Object} e the multiple-day event to create segments for.
 * @param {Date} viewStartDate the starting date of the view.
 * @param {Date} viewEndDate the ending date of the view.
 * @param {Object} vuecal the vuecal main component, to access needed methods, props, etc.
 */

var event_utils_createEventSegments = function createEventSegments(e, viewStartDate, viewEndDate) {
  var viewStartTimestamp = viewStartDate.getTime();
  var viewEndTimestamp = viewEndDate.getTime();
  var eventStart = e.startDate.getTime();
  var eventEnd = e.endDate.getTime();
  var repeatedEventStartFound = false;
  var timestamp, end, eventStartAtMidnight; // @todo: I don't think we still need that:
  // Removing 1 sec when ending at 00:00, so that we don't create a segment for nothing on last day.

  if (!e.endDate.getHours() && !e.endDate.getMinutes()) eventEnd -= 1000;
  external_commonjs_vue_commonjs2_vue_root_Vue_default.a.set(e, 'segments', {}); // The goal is to create 1 segment per day in the event, but only within the current view.

  if (!e.repeat) {
    // Simple case first.
    timestamp = Math.max(viewStartTimestamp, eventStart);
    end = Math.min(viewEndTimestamp, eventEnd);
  } else {
    // Start at the beginning of the range, and end at soonest between `repeat.until` if any or range end.
    // This range will most likely be too large (e.g. whole week) and we need to narrow it
    // down in the while loop bellow.
    // We must not create unused segments, it would break the render or result in weird behaviors.
    timestamp = viewStartTimestamp;
    end = Math.min(viewEndTimestamp, e.repeat.until ? stringToDate(e.repeat.until).getTime() : viewEndTimestamp);
  }

  while (timestamp <= end) {
    var createSegment = false; // Be careful not to simply add 24 hours!
    // In case of DLS, that would cause the event to never end and browser to hang.
    // So use `addDays(1)` instead.

    var nextMidnight = new Date(timestamp).addDays(1).setHours(0, 0, 0, 0);
    var isFirstDay = void 0,
        isLastDay = void 0,
        startDate = void 0,
        formattedDate = void 0;

    if (e.repeat) {
      var tmpDate = new Date(timestamp);
      var tmpDateFormatted = formatDateLite(tmpDate); // If the current day in loop is a known date of the repeated event (in `e.occurrences`),
      // then we found the first day of the event repetition, now update the `eventStart` and
      // the end of the loop at current day + event days count.

      if (repeatedEventStartFound || e.occurrences && e.occurrences[tmpDateFormatted]) {
        if (!repeatedEventStartFound) {
          eventStart = e.occurrences[tmpDateFormatted].start;
          eventStartAtMidnight = new Date(eventStart).setHours(0, 0, 0, 0);
          eventEnd = e.occurrences[tmpDateFormatted].end;
        }

        repeatedEventStartFound = true;
        createSegment = true;
      }

      isFirstDay = timestamp === eventStartAtMidnight;
      isLastDay = tmpDateFormatted === formatDateLite(new Date(eventEnd));
      startDate = isFirstDay ? new Date(eventStart) : new Date(timestamp);
      formattedDate = formatDateLite(startDate); // We want to find any potential other repetition of event in same range.

      if (isLastDay) repeatedEventStartFound = false;
    } else {
      createSegment = true;
      isFirstDay = timestamp === eventStart;
      isLastDay = end === eventEnd && nextMidnight > end;
      startDate = isFirstDay ? e.startDate : new Date(timestamp);
      formattedDate = isFirstDay ? e.start.substr(0, 10) : formatDateLite(startDate);
    }

    if (createSegment) {
      e.segments[formattedDate] = {
        startDate: startDate,
        start: formattedDate,
        startTimeMinutes: isFirstDay ? e.startTimeMinutes : 0,
        endTimeMinutes: isLastDay ? e.endTimeMinutes : minutesInADay,
        isFirstDay: isFirstDay,
        isLastDay: isLastDay,
        height: 0,
        top: 0
      };
    }

    timestamp = nextMidnight;
  }

  return e;
};
/**
 * Delete an event.
 *
 * @param {Object} event the calendar event to delete.
 * @param {Object} vuecal the vuecal main component, to access needed methods, props, etc.
 */

var deleteAnEvent = function deleteAnEvent(event, vuecal) {
  vuecal.emitWithEvent('event-delete', event); // Delete the event globally.

  vuecal.mutableEvents = vuecal.mutableEvents.filter(function (e) {
    return e._eid !== event._eid;
  }); // Delete the event from the current view.
  // checkCellOverlappingEvents() will be re-run automatically from the cell computed events.

  vuecal.view.events = vuecal.view.events.filter(function (e) {
    return e._eid !== event._eid;
  });
}; // EVENT OVERLAPS.
// ===================================================================
// Only for the current view, recreated on view change.

var comparisonArray, event_utils_cellOverlaps; // Will recalculate all the overlaps of the current cell OR split.
// cellEvents will contain only the current split events if in a split.

var event_utils_checkCellOverlappingEvents = function checkCellOverlappingEvents(cellEvents, options) {
  comparisonArray = cellEvents.slice(0);
  event_utils_cellOverlaps = {}; // Can't filter background events before calling this function otherwise
  // when an event is changed to background it would not update its previous overlaps.

  cellEvents.forEach(function (e) {
    // For performance, never compare the current event in the next loops.
    // The array is smaller and smaller as we loop.
    comparisonArray.shift();
    if (!event_utils_cellOverlaps[e._eid]) external_commonjs_vue_commonjs2_vue_root_Vue_default.a.set(event_utils_cellOverlaps, e._eid, {
      overlaps: [],
      start: e.start,
      position: 0
    });
    event_utils_cellOverlaps[e._eid].position = 0;
    comparisonArray.forEach(function (e2) {
      if (!event_utils_cellOverlaps[e2._eid]) external_commonjs_vue_commonjs2_vue_root_Vue_default.a.set(event_utils_cellOverlaps, e2._eid, {
        overlaps: [],
        start: e2.start,
        position: 0
      });
      var eventIsInRange = eventInRange(e2, e.startDate, e.endDate);
      var eventsInSameTimeStep = options.overlapsPerTimeStep ? datesInSameTimeStep(e.startDate, e2.startDate, options.timeStep) : 1; // Add to the overlaps array if overlapping.

      if (!e.background && !e.allDay && !e2.background && !e2.allDay && eventIsInRange && eventsInSameTimeStep) {
        event_utils_cellOverlaps[e._eid].overlaps.push(e2._eid);

        event_utils_cellOverlaps[e._eid].overlaps = _toConsumableArray(new Set(event_utils_cellOverlaps[e._eid].overlaps)); // Dedupe, most performant way.

        event_utils_cellOverlaps[e2._eid].overlaps.push(e._eid);

        event_utils_cellOverlaps[e2._eid].overlaps = _toConsumableArray(new Set(event_utils_cellOverlaps[e2._eid].overlaps)); // Dedupe, most performant way.

        event_utils_cellOverlaps[e2._eid].position++;
      } // Remove from the overlaps array if not overlapping or if 1 of the 2 events is background or all-day long.
      else {
          var pos1, pos2;
          if ((pos1 = (event_utils_cellOverlaps[e._eid] || {
            overlaps: []
          }).overlaps.indexOf(e2._eid)) > -1) event_utils_cellOverlaps[e._eid].overlaps.splice(pos1, 1);
          if ((pos2 = (event_utils_cellOverlaps[e2._eid] || {
            overlaps: []
          }).overlaps.indexOf(e._eid)) > -1) event_utils_cellOverlaps[e2._eid].overlaps.splice(pos2, 1);
          event_utils_cellOverlaps[e2._eid].position--;
        }
    });
  }); // Overlaps streak is the longest horizontal set of simultaneous events.
  // This is determining the width of events in a streak.
  // e.g. 3 overlapping events [1, 2, 3]; 1 overlaps 2 & 3; 2 & 3 don't overlap;
  //      => streak = 2; each width = 50% not 33%.

  var longestStreak = 0;

  var _loop = function _loop(id) {
    var item = event_utils_cellOverlaps[id]; // Calculate the position of each event in current streak (determines the CSS left property).

    var overlapsRow = item.overlaps.map(function (id2) {
      return {
        id: id2,
        start: event_utils_cellOverlaps[id2].start
      };
    });
    overlapsRow.push({
      id: id,
      start: item.start
    });
    overlapsRow.sort(function (a, b) {
      return a.start < b.start ? -1 : a.start > b.start ? 1 : a.id > b.id ? -1 : 1;
    });
    item.position = overlapsRow.findIndex(function (e) {
      return e.id === id;
    });
    longestStreak = Math.max(event_utils_getOverlapsStreak(item, event_utils_cellOverlaps), longestStreak);
  };

  for (var id in event_utils_cellOverlaps) {
    _loop(id);
  }

  return [event_utils_cellOverlaps, longestStreak];
};
/**
 * Overlaps streak is the longest horizontal set of simultaneous events.
 * This is determining the width of each events in this streak.
 * E.g. 3 overlapping events [1, 2, 3]; 1 overlaps 2 & 3; 2 & 3 don't overlap;
 *      => streak = 2; each width = 50% not 33%.
 *
 * @param {Object} event The current event we are checking among all the events of the current cell.
 * @param {Object} cellOverlaps An indexed array of all the events overlaps for the current cell.
 * @return {Number} The number of simultaneous event for this event.
 */

var event_utils_getOverlapsStreak = function getOverlapsStreak(event) {
  var cellOverlaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var streak = event.overlaps.length + 1;
  var removeFromStreak = [];
  event.overlaps.forEach(function (id) {
    if (!removeFromStreak.includes(id)) {
      var overlapsWithoutSelf = event.overlaps.filter(function (id2) {
        return id2 !== id;
      });
      overlapsWithoutSelf.forEach(function (id3) {
        if (!cellOverlaps[id3].overlaps.includes(id)) removeFromStreak.push(id3);
      });
    }
  });
  removeFromStreak = _toConsumableArray(new Set(removeFromStreak)); // Dedupe, most performant way.

  streak -= removeFromStreak.length;
  return streak;
};
/**
 * Update the event top and height CSS properties of each event as long as vuecal.time is true.
 *
 * @param {Object} event The event to update position (top & height) of.
 * @param {Object} vuecal the vuecal main component, to access needed methods, props, etc.
 */

var updateEventPosition = function updateEventPosition(event, vuecal) {
  var startTimeMinutes = event.startTimeMinutes,
      endTimeMinutes = event.endTimeMinutes; // if (event.dragging) {
  //   event.top = event.dragging.y
  //   event.left = event.dragging.x
  //   return
  // }
  // Top of event.

  var minutesFromTop = startTimeMinutes - vuecal.timeFrom;
  var top = Math.round(minutesFromTop * vuecal.timeCellHeight / vuecal.timeStep); // Bottom of event.

  minutesFromTop = Math.min(endTimeMinutes, vuecal.timeTo) - vuecal.timeFrom;
  var bottom = Math.round(minutesFromTop * vuecal.timeCellHeight / vuecal.timeStep);
  event.top = Math.max(top, 0);
  event.height = Math.max(bottom - event.top, 5); // Min height is 5px.
};
/**
 * Tells whether an event is in a given date range, even partially.
 *
 * @param {Object} event The event to test.
 * @param {Date} start The start of range date object.
 * @param {Date} end The end of range date object.
 * @return {Boolean} true if in range, even partially.
 */

var eventInRange = function eventInRange(event, start, end) {
  // Check if all-day or timeless event (if date but no time there won't be a `:` in event.start).
  if (event.allDay || event.start.indexOf(':') === -1) {
    // Get the date and discard the time if any, then check it's within the date range.
    var eventStart = new Date(event.startDate).setHours(0, 0, 0, 0);
    return eventStart >= new Date(start).setHours(0, 0, 0, 0) && eventStart <= new Date(end).setHours(0, 0, 0, 0);
  }

  var startTimestamp = event.startDate.getTime();
  var endTimestamp = event.endDate.getTime();
  return startTimestamp < end.getTime() && endTimestamp > start.getTime();
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"487f8217-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/header.vue?vue&type=template&id=11733953&lang=pug&
var headervue_type_template_id_11733953_lang_pug_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vuecal__header"},[(!_vm.options.hideViewSelector)?_c('div',{staticClass:"vuecal__flex vuecal__menu",attrs:{"role":"tablist","aria-label":"Calendar views navigation"}},_vm._l((_vm.viewProps.views),function(v,id){return (v.enabled)?_c('button',{staticClass:"vuecal__view-btn",class:{ 'vuecal__view-btn--active': _vm.viewProps.view.id === id, 'vuecal__view-btn--highlighted': _vm.highlightedControl === id },attrs:{"aria-label":((v.label) + " view")},on:{"dragenter":function($event){_vm.options.editableEvents && _vm.viewSelectorDragEnter($event, id, _vm.$parent, _vm.$data)},"dragleave":function($event){_vm.options.editableEvents && _vm.viewSelectorDragLeave($event, id, _vm.$parent, _vm.$data)},"click":function($event){return _vm.$parent.switchView(id, null, true)}}},[_vm._v(_vm._s(v.label))]):_vm._e()}),0):_vm._e(),(!_vm.options.hideTitleBar)?_c('div',{staticClass:"vuecal__title-bar"},[_c('button',{staticClass:"vuecal__arrow vuecal__arrow--prev",class:{ 'vuecal__arrow--highlighted': _vm.highlightedControl === 'previous' },attrs:{"aria-label":("Previous " + (_vm.viewProps.view.id))},on:{"click":_vm.previous,"dragenter":function($event){_vm.options.editableEvents && _vm.viewSelectorDragEnter($event, 'previous', _vm.$parent, _vm.$data)},"dragleave":function($event){_vm.options.editableEvents && _vm.viewSelectorDragLeave($event, 'previous', _vm.$parent, _vm.$data)}}},[_vm._t("arrow-prev")],2),_c('div',{staticClass:"vuecal__flex vuecal__title",attrs:{"grow":""}},[_c(_vm.options.transitions ? 'transition' : 'div',{tag:"component",attrs:{"name":("slide-fade--" + _vm.transitionDirection)}},[_c(!!_vm.broaderView ? 'button' : 'span',{key:("" + (_vm.viewProps.view.id) + (_vm.viewProps.view.startDate.toString())),tag:"component",attrs:{"aria-label":!!_vm.broaderView ? ("Go to " + _vm.broaderView + " view") : false},on:{"click":_vm.switchToBroaderView}},[_vm._t("title")],2)],1)],1),(_vm.options.todayButton)?_c('button',{staticClass:"vuecal__today-btn",class:{ 'vuecal__today-btn--highlighted': _vm.highlightedControl === 'today' },attrs:{"aria-label":"Today"},on:{"click":_vm.goToToday,"dragenter":function($event){_vm.options.editableEvents && _vm.viewSelectorDragEnter($event, 'today', _vm.$parent, _vm.$data)},"dragleave":function($event){_vm.options.editableEvents && _vm.viewSelectorDragLeave($event, 'today', _vm.$parent, _vm.$data)}}},[_vm._t("today-button")],2):_vm._e(),_c('button',{staticClass:"vuecal__arrow vuecal__arrow--next",class:{ 'vuecal__arrow--highlighted': _vm.highlightedControl === 'next' },attrs:{"aria-label":("Next " + (_vm.viewProps.view.id))},on:{"click":_vm.next,"dragenter":function($event){_vm.options.editableEvents && _vm.viewSelectorDragEnter($event, 'next', _vm.$parent, _vm.$data)},"dragleave":function($event){_vm.options.editableEvents && _vm.viewSelectorDragLeave($event, 'next', _vm.$parent, _vm.$data)}}},[_vm._t("arrow-next")],2)]):_vm._e(),(_vm.viewProps.weekDaysInHeader)?_c('weekdays-headings',{attrs:{"vuecal":_vm.$parent,"view":_vm.viewProps.view,"week-days":_vm.weekDays,"transition-direction":_vm.transitionDirection,"switch-to-narrower-view":_vm.switchToNarrowerView},scopedSlots:_vm._u([{key:"weekday-heading",fn:function(ref){
var heading = ref.heading;
var view = ref.view;
return [_vm._t("weekday-heading",null,{"heading":heading,"view":view})]}}],null,true)}):_vm._e(),_c('transition',{attrs:{"name":("slide-fade--" + _vm.transitionDirection)}},[(_vm.viewProps.view.id === 'day' && _vm.$parent.hasSplits && _vm.options.stickySplitLabels && !_vm.options.minSplitWidth)?_c('div',{staticClass:"vuecal__flex vuecal__split-days-headers"},_vm._l((_vm.daySplits),function(split,i){return _c('div',{key:i,staticClass:"day-split-header",class:split.class || false},[_vm._v(_vm._s(split.label))])}),0):_vm._e()])],1)}
var headervue_type_template_id_11733953_lang_pug_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/vue-cal/header.vue?vue&type=template&id=11733953&lang=pug&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"487f8217-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/weekdays-headings.vue?vue&type=template&id=9a0c19d0&lang=pug&
var weekdays_headingsvue_type_template_id_9a0c19d0_lang_pug_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vuecal__flex vuecal__weekdays-headings"},_vm._l((_vm.headings),function(heading,i){return (!heading.hide)?_c('div',{key:i,staticClass:"vuecal__flex vuecal__heading",class:{ today: heading.today, clickable: _vm.cellHeadingsClickable },style:(_vm.weekdayCellStyles),on:{"click":function($event){_vm.view.id === 'week' && _vm.selectCell(heading.date, $event)},"dblclick":function($event){_vm.view.id === 'week' && _vm.vuecal.dblclickToNavigate && _vm.switchToNarrowerView()}}},[_c('transition',{attrs:{"name":("slide-fade--" + _vm.transitionDirection),"appear":_vm.vuecal.transitions}},[_c('div',{key:_vm.vuecal.transitions ? (i + "-" + (heading.dayOfMonth)) : false,staticClass:"vuecal__flex",attrs:{"column":""}},[_c('div',{staticClass:"vuecal__flex weekday-label",attrs:{"grow":""}},[_vm._t("weekday-heading",[_c('span',{staticClass:"full"},[_vm._v(_vm._s(heading.full))]),_c('span',{staticClass:"small"},[_vm._v(_vm._s(heading.small))]),_c('span',{staticClass:"xsmall"},[_vm._v(_vm._s(heading.xsmall))]),(heading.dayOfMonth)?_c('span',[_vm._v(" "+_vm._s(heading.dayOfMonth))]):_vm._e()],{"heading":_vm.cleanupHeading(heading),"view":_vm.view})],2),(_vm.vuecal.hasSplits && _vm.vuecal.stickySplitLabels)?_c('div',{staticClass:"vuecal__flex vuecal__split-days-headers",attrs:{"grow":""}},_vm._l((_vm.vuecal.daySplits),function(split,i){return _c('div',{key:i,staticClass:"day-split-header",class:split.class || false},[_vm._v(_vm._s(split.label))])}),0):_vm._e()])])],1):_vm._e()}),0)}
var weekdays_headingsvue_type_template_id_9a0c19d0_lang_pug_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/vue-cal/weekdays-headings.vue?vue&type=template&id=9a0c19d0&lang=pug&

// CONCATENATED MODULE: ./src/components/vue-cal/cell-utils.js
/**
 * Select a cell and go to narrower view on double click or single click according to vuecal option.
 *
 * @param {Boolean} force Force switching to narrower view.
 * @param {Object} vuecal The vuecal instance.
 * @param {Date} date The selected cell date at the exact time where it was clicked (through cursor coords).
 * @param {Integer} split The selected cell split if any.
 */
var cell_utils_selectCell = function selectCell() {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var vuecal = arguments.length > 1 ? arguments[1] : undefined;
  var date = arguments.length > 2 ? arguments[2] : undefined;
  var split = arguments.length > 3 ? arguments[3] : undefined;
  // Cell-click event returns a date and time at cursor position.
  vuecal.$emit('cell-click', split ? {
    date: date,
    split: split
  } : date); // Switch to narrower view.

  if (vuecal.clickToNavigate || force) vuecal.switchToNarrowerView(); // Handle double click manually for touch devices.
  else if (vuecal.dblclickToNavigate && 'ontouchstart' in window) {
      vuecal.domEvents.dblTapACell.taps++;
      setTimeout(function () {
        return vuecal.domEvents.dblTapACell.taps = 0;
      }, vuecal.domEvents.dblTapACell.timeout);

      if (vuecal.domEvents.dblTapACell.taps >= 2) {
        vuecal.domEvents.dblTapACell.taps = 0;
        vuecal.switchToNarrowerView();
        vuecal.$emit('cell-dblclick', split ? {
          date: date,
          split: split
        } : date);
      }
    }
};
/**
 * Select a cell and go to narrower view on enter.
 *
 * @param {Boolean} force Force switching to narrower view.
 * @param {Object} vuecal The vuecal instance.
 * @param {Date} date The selected cell date at the exact time where it was clicked (through cursor coords).
 * @param {Integer} split The selected cell split if any.
 */

var keyPressEnterCell = function keyPressEnterCell(vuecal, date, split) {
  // Cell-key-press-enter event returns a date and time at cursor position.
  vuecal.$emit('cell-keypress-enter', split ? {
    date: date,
    split: split
  } : date); // Switch to narrower view.

  vuecal.switchToNarrowerView();
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/weekdays-headings.vue?vue&type=script&lang=js&




//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var weekdays_headingsvue_type_script_lang_js_ = ({
  props: {
    vuecal: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    view: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    transitionDirection: {
      type: String,
      default: 'right'
    },
    weekDays: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    switchToNarrowerView: {
      type: Function,
      default: function _default() {}
    }
  },
  methods: {
    selectCell: function selectCell(date, DOMEvent) {
      date = new Date(date);
      date.setMinutes(this.vuecal.minutesAtCursor(DOMEvent).minutes);

      cell_utils_selectCell(false, this.vuecal, date, DOMEvent);
    },
    cleanupHeading: function cleanupHeading(heading) {
      return _objectSpread2({
        label: heading.full,
        date: heading.date
      }, heading.today ? {
        today: heading.today
      } : {});
    }
  },
  computed: {
    headings: function headings() {
      var _this = this;

      if (!['month', 'week'].includes(this.view.id)) return [];
      var todayFound = false;
      var headings = this.weekDays.map(function (cell, i) {
        var date = _this.view.startDate.addDays(i);

        return _objectSpread2({
          hide: cell.hide,
          full: cell.label,
          // If defined in i18n file, weekDaysShort overrides default truncation of
          // week days when does not fit on screen or with small/xsmall options.
          small: cell.short || cell.label.substr(0, 3),
          xsmall: cell.short || cell.label.substr(0, 1)
        }, _this.view.id === 'week' ? {
          dayOfMonth: date.getDate(),
          date: date,
          today: !todayFound && date.isToday() && !todayFound++
        } : {});
      });
      return headings;
    },
    cellWidth: function cellWidth() {
      return 100 / (7 - this.weekDays.reduce(function (total, day) {
        return total + day.hide;
      }, 0));
    },
    weekdayCellStyles: function weekdayCellStyles() {
      return _objectSpread2({}, this.vuecal.hideWeekdays.length ? {
        width: "".concat(this.cellWidth, "%")
      } : {});
    },
    cellHeadingsClickable: function cellHeadingsClickable() {
      return this.view.id === 'week' && (this.vuecal.clickToNavigate || this.vuecal.dblclickToNavigate);
    }
  }
});
// CONCATENATED MODULE: ./src/components/vue-cal/weekdays-headings.vue?vue&type=script&lang=js&
 /* harmony default export */ var vue_cal_weekdays_headingsvue_type_script_lang_js_ = (weekdays_headingsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/vue-cal/weekdays-headings.vue?vue&type=style&index=0&lang=scss&
var weekdays_headingsvue_type_style_index_0_lang_scss_ = __webpack_require__("2029");

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/vue-cal/weekdays-headings.vue






/* normalize component */

var component = normalizeComponent(
  vue_cal_weekdays_headingsvue_type_script_lang_js_,
  weekdays_headingsvue_type_template_id_9a0c19d0_lang_pug_render,
  weekdays_headingsvue_type_template_id_9a0c19d0_lang_pug_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var weekdays_headings = (component.exports);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.entries.js
var es_object_entries = __webpack_require__("4fad");

// CONCATENATED MODULE: ./src/components/vue-cal/drag-and-drop.js









// @todo:
// OK - emit the `event-drop` & `event-change` events on event drop
// OK - handle drag and drop and splits / highlight splits separately
// OK - add split in emitted event
// OK - check that event.draggable = false prevents dragging
// OK - check edge and IE
// OK - also go to narrower view from month view
// OK - Fix drag image not visible on Safari
// OK - Support drag over today button
// OK - drop an event that would start before last midnight
// OK - Prevent dragging background events
// OK - Allow dragging timeless events
// OK - Fix event deletion
// OK - Only trigger view change if it changed
// OK - Add option to snap to time on event drop
// OK - add javadoc
//    - modularize this file?
var holdOverTimeout = 800; // How long we should hold over an element before it reacts.

var changeViewTimeout = null;
var pressPrevOrNextInterval = null;
var viewBeforeDrag = {
  id: null,
  date: null
}; // To go back if cancelling.

var viewChanged = false;
var cancelViewChange = true;
var dragOverCell = {
  el: null,
  cell: null,
  timeout: null
};
/**
 * On event drag start, only possible if editableEvent is true.
 * /!\ This is using the native HTML5 drag & drop, not supported on touch devices.
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} event The event being dragged.
 * @param {Object} vuecal The instance of Vue Cal component.
 */

var eventDragStart = function eventDragStart(e, event, vuecal) {
  // Cancel the drag if event has draggable set to false and trying to drag a text selection.
  if (e.target.nodeType === 3) return e.preventDefault();
  e.dataTransfer.setData('text', '...'); // Without this the drag will not happen in Firefox.

  e.dataTransfer.dropEffect = 'move';
  var _vuecal$domEvents = vuecal.domEvents,
      clickHoldAnEvent = _vuecal$domEvents.clickHoldAnEvent,
      dragAnEvent = _vuecal$domEvents.dragAnEvent; // Cancel any delete on dragStart (if held for too long). Don't drag an event with a visible delete button.

  setTimeout(function () {
    clickHoldAnEvent._eid = null;
    clearTimeout(clickHoldAnEvent.timeoutId);
    event.deleting = false;
  }, 0);
  dragAnEvent._eid = event._eid;
  event.dragging = true; // Controls the CSS class of the static event that remains while a copy is being dragged.
  // Thanks to this class, the event being dragged can have a different style.

  setTimeout(function () {
    return event.draggingStatic = true;
  }, 0);
  viewChanged = false;
  viewBeforeDrag = {
    id: vuecal.view.id,
    date: vuecal.view.startDate
  };

  var _vuecal$minutesAtCurs = vuecal.minutesAtCursor(e),
      minutes = _vuecal$minutesAtCurs.minutes; // When click and drag an event the cursor can be anywhere in the event,
  // when later dropping the event, we need to subtract the cursor position in the event.


  dragAnEvent.cursorGrabAt = minutes - event.startTimeMinutes;
  cancelViewChange = true; // Re-init the cancel view: should cancel unless a cell received the event.
};
/**
 * On event drag end, when releasing the event.
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} event The event being dragged.
 * @param {Object} vuecal The instance of Vue Cal component.
 */

var eventDragEnd = function eventDragEnd(e, event, vuecal) {
  var dragAnEvent = vuecal.domEvents.dragAnEvent;
  dragAnEvent._eid = null;
  event.dragging = false;
  event.draggingStatic = false; // When dropping the event, cancel view change if no cell received the event (in cellDragDrop).

  if (viewChanged && cancelViewChange && viewBeforeDrag.id) vuecal.switchView(viewBeforeDrag.id, viewBeforeDrag.date, true);
};
/**
 * On cell/split enter with a dragging event.
 * Highlight the cell, and if on `years`, `year`, `month` view,
 * set a timer to go deeper on drag hold over this cell.
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} cell The cell component's $data.
 * @param {Date} cellDate The hovered cell starting date.
 * @param {Object} vuecal The instance of Vue Cal component.
 */

var cellDragEnter = function cellDragEnter(e, cell, cellDate, vuecal) {
  var target = e.currentTarget; // Cancel dragEnter event if hovering a child.

  if (e.currentTarget.contains(e.relatedTarget)) return;
  if (target === dragOverCell.el || !target.className.includes('vuecal__cell-content')) return false; // Un-highlight the previous cell.

  if (dragOverCell.el) dragOverCell.cell.highlighted = false;
  dragOverCell = {
    el: target,
    cell: cell,
    timeout: clearTimeout(dragOverCell.timeout)
  };
  cell.highlighted = true; // On `years`, `year` & `month` views, go to narrower view on drag and hold.

  if (['years', 'year', 'month'].includes(vuecal.view.id)) {
    dragOverCell.timeout = setTimeout(function () {
      return vuecal.switchToNarrowerView(cellDate);
    }, 2000);
  }
};
/**
 * On cell/split drag over, highlight the cell being hovered,
 * Useful when starting to drag event on the same cell/split it's in.
 * Warning: This is fired repeatedly as long as you stay over this cell/split.
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} cell The cell component's $data.
 * @param {Date} cellDate The hovered cell starting date.
 * @param {Object} vuecal The instance of Vue Cal component.
 * @param {Number|String} split The optional split being hovered if any.
 */

var cellDragOver = function cellDragOver(e, cell, cellDate, vuecal, split) {
  e.preventDefault();
  cell.highlighted = true;
  if (split || split === 0) cell.highlightedSplit = split;
};
/**
 * When event drag leaves a cell/split.
 * Remove the cell/split highlighted state.
 * Warning: cell dragleave event happens AFTER another cell dragenter!
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} cell The cell component's $data.
 * @param {Date} cellDate The hovered cell starting date.
 * @param {Object} vuecal The instance of Vue Cal component.
 */

var cellDragLeave = function cellDragLeave(e, cell, cellDate, vuecal) {
  e.preventDefault();
  if (e.currentTarget.contains(e.relatedTarget)) return;
  cell.highlightedSplit = false; // Only cancel the timer if leaving the current cell to no other one.
  // If leaving this cell to enter another, a cancel is done in cellDragEnter,
  // and a new timer is started.

  if (dragOverCell.cell === cell) {
    clearTimeout(dragOverCell.timeout);
    cell.highlighted = false;
    dragOverCell = {
      el: null,
      cell: null,
      timeout: null
    };
  }
};
/**
 * On successful event drop into a cell/split.
 * Change the event start and end time and remove the event dragging state
 * and cell/split highlighted state.
 *
 * @param {Object} e The associated DOM event.
 * @param {Object} cell The cell component's $data.
 * @param {Date} cellDate The hovered cell starting date.
 * @param {Object} vuecal The instance of Vue Cal component.
 * @param {Number|String} split The optional split being dropped into, if any.
 */

var drag_and_drop_cellDragDrop = function cellDragDrop(e, cell, cellDate, vuecal, split) {
  // Needed to prevent navigation to the text set in dataTransfer from eventDragStart().
  e.preventDefault();
  var view = vuecal.view,
      dragAnEvent = vuecal.domEvents.dragAnEvent,
      mutableEvents = vuecal.mutableEvents,
      minutesAtCursor = vuecal.minutesAtCursor,
      snapToTime = vuecal.snapToTime; // Find the dragged event from its _eid in the view or mutableEvents array.

  var event = view.events.find(function (e) {
    return e._eid === dragAnEvent._eid;
  });
  var eventInView = !!event;
  if (!event) event = mutableEvents.find(function (e) {
    return e._eid === dragAnEvent._eid;
  }) || {}; // Modify the event start and end date.

  var _event = event,
      oldDate = _event.startDate,
      oldSplit = _event.split;
  var eventDuration = event.endTimeMinutes - event.startTimeMinutes; // Force the start of the event at previous midnight minimum.

  var startTimeMinutes = Math.max(minutesAtCursor(e).minutes - dragAnEvent.cursorGrabAt, 0); // On drop, snap to time every X minutes if the option is on.

  if (snapToTime) {
    var plusHalfSnapTime = startTimeMinutes + snapToTime / 2;
    startTimeMinutes = plusHalfSnapTime - plusHalfSnapTime % snapToTime;
  }

  event.startTimeMinutes = startTimeMinutes;
  event.startDate = new Date(new Date(cellDate).setMinutes(startTimeMinutes));
  event.start = "".concat(event.startDate.format(), " ").concat(event.startDate.formatTime()); // Force the end of the event at next midnight maximum.

  event.endTimeMinutes = Math.min(startTimeMinutes + eventDuration, 24 * 60);
  event.endDate = new Date(new Date(cellDate).setMinutes(event.endTimeMinutes));
  event.end = "".concat(event.endDate.format(), " ").concat(event.endDate.formatTime());
  event.dragging = false;
  if (split || split === 0) event.split = split;
  if (!eventInView) vuecal.addEventsToView([event]);
  cell.highlighted = false;
  cell.highlightedSplit = null;
  cancelViewChange = false;

  var params = _objectSpread2({
    event: vuecal.cleanupEvent(event),
    oldDate: oldDate,
    newDate: event.startDate
  }, (split || split === 0) && {
    oldSplit: oldSplit,
    newSplit: split
  });

  vuecal.$emit('event-drop', params);
  vuecal.$emit('event-change', params.event);
};
/**
 * On drag enter on a view button or on today, prev & next buttons.
 * Sets a highlighted state on the hovered button, and go to requested view.
 *
 * @param {Object} e The associated DOM event.
 * @param {String} id The id of the header element being hovered. One of:
 *                    previous, next, today, years, year, month, week, day.
 * @param {Object} vuecal The instance of Vue Cal component.
 * @param {Object} headerData The header component's $data.
 */

var drag_and_drop_viewSelectorDragEnter = function viewSelectorDragEnter(e, id, vuecal, headerData) {
  if (e.currentTarget.contains(e.relatedTarget)) return;
  headerData.highlightedControl = id;
  clearTimeout(changeViewTimeout);
  changeViewTimeout = setTimeout(function () {
    if (['previous', 'next'].includes(id)) {
      vuecal[id](); // Keep pressing on previous or next button until user goes away.

      clearInterval(pressPrevOrNextInterval);
      pressPrevOrNextInterval = setInterval(vuecal[id], holdOverTimeout);
    } else if (id === 'today') {
      clearInterval(pressPrevOrNextInterval);
      var viewId;

      if (vuecal.view.id.includes('year')) {
        viewId = Object.entries(vuecal.views).find(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              vid = _ref2[0],
              obj = _ref2[1];

          return obj.enabled && !vid.includes('year');
        })[0];
      }

      vuecal.switchView(viewId || vuecal.view.id, new Date(new Date().setHours(0, 0, 0, 0)), true);
    } else vuecal.switchView(id, null, true);

    viewChanged = true;
  }, holdOverTimeout);
};
/**
 * On drag leave on a view button or on today, prev & next buttons.
 * Removes the highlighted state on the hovered button, and cancel the timer to
 * go to the requested view.
 *
 * @param {Object} e The associated DOM event.
 * @param {String} id The id of the header element being hovered. One of:
 *                    previous, next, today, years, year, month, week, day.
 * @param {Object} vuecal The instance of Vue Cal component.
 * @param {Object} headerData The header component's $data.
 */

var viewSelectorDragLeave = function viewSelectorDragLeave(e, id, vuecal, headerData) {
  if (e.currentTarget.contains(e.relatedTarget)) return; // Only cancel the timer if leaving the current nav button to no other one.
  // If leaving this nav button to enter another, a cancel is done in viewSelectorDragEnter,
  // and a new timer is started.

  if (headerData.highlightedControl === id) {
    headerData.highlightedControl = null;
    if (changeViewTimeout) changeViewTimeout = clearTimeout(changeViewTimeout);
    if (pressPrevOrNextInterval) pressPrevOrNextInterval = clearInterval(pressPrevOrNextInterval);
  }
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/header.vue?vue&type=script&lang=js&




//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var headervue_type_script_lang_js_ = ({
  components: {
    WeekdaysHeadings: weekdays_headings
  },
  props: {
    // Vuecal main component options (props).
    options: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    daySplits: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    viewProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    weekDays: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    switchToNarrowerView: {
      type: Function,
      default: function _default() {}
    }
  },
  data: function data() {
    return {
      highlightedControl: null
    };
  },
  methods: {
    previous: function previous() {
      this.$parent.previousNext(false);
    },
    next: function next() {
      this.$parent.previousNext();
    },
    goToToday: function goToToday() {
      // Last midnight.
      this.$parent.updateSelectedDate(new Date(new Date().setHours(0, 0, 0, 0)));
    },
    switchToBroaderView: function switchToBroaderView() {
      this.transitionDirection = 'left';
      if (this.broaderView) this.$parent.switchView(this.broaderView);
    },
    viewSelectorDragEnter: drag_and_drop_viewSelectorDragEnter,
    viewSelectorDragLeave: viewSelectorDragLeave
  },
  computed: {
    transitionDirection: {
      get: function get() {
        return this.$parent.transitionDirection;
      },
      set: function set(direction) {
        this.$parent.transitionDirection = direction;
      }
    },
    broaderView: function broaderView() {
      var _this = this;

      var views = Object.keys(this.viewProps.views);
      views = views.slice(0, views.indexOf(this.viewProps.view.id));
      views.reverse();
      return views.find(function (v) {
        return _this.viewProps.views[v].enabled;
      });
    }
  }
});
// CONCATENATED MODULE: ./src/components/vue-cal/header.vue?vue&type=script&lang=js&
 /* harmony default export */ var vue_cal_headervue_type_script_lang_js_ = (headervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/vue-cal/header.vue?vue&type=style&index=0&lang=scss&
var headervue_type_style_index_0_lang_scss_ = __webpack_require__("da8a");

// CONCATENATED MODULE: ./src/components/vue-cal/header.vue






/* normalize component */

var header_component = normalizeComponent(
  vue_cal_headervue_type_script_lang_js_,
  headervue_type_template_id_11733953_lang_pug_render,
  headervue_type_template_id_11733953_lang_pug_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var header = (header_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"487f8217-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/cell.vue?vue&type=template&id=7475f2f0&lang=pug&
var cellvue_type_template_id_7475f2f0_lang_pug_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition-group',{staticClass:"vuecal__cell",class:_vm.cssClasses,style:(_vm.cellStyles),attrs:{"name":("slide-fade--" + _vm.transitionDirection),"tag":"div","appear":_vm.options.transitions}},[_vm._l(((_vm.splits.length ? _vm.splits : 1)),function(split,i){return _c('div',{key:_vm.options.transitions ? (_vm.view + "-" + (_vm.data.content) + "-" + i) : i,staticClass:"vuecal__flex vuecal__cell-content",class:_vm.splits.length && ("vuecal__cell-split " + (split.class) + (_vm.highlightedSplit === split.id ? ' vuecal__cell-split--highlighted' : '')),attrs:{"data-split":_vm.splits.length ? split.id : false,"column":"","tabindex":"0","aria-label":_vm.data.content},on:{"focus":function($event){return _vm.onCellFocus($event)},"keypress":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.onCellkeyPressEnter($event)},"touchstart":function($event){!_vm.isDisabled && _vm.onCellTouchStart($event, _vm.splits.length ? split.id : null)},"mousedown":function($event){!_vm.isDisabled && _vm.onCellMouseDown($event, _vm.splits.length ? split.id : null)},"click":function($event){!_vm.isDisabled && _vm.selectCell($event)},"dblclick":function($event){!_vm.isDisabled && _vm.onCellDblClick($event)},"contextmenu":function($event){!_vm.isDisabled && _vm.options.cellContextmenu && _vm.onCellContextMenu($event)},"dragenter":function($event){!_vm.isDisabled && _vm.options.editableEvents && _vm.cellDragEnter($event, _vm.$data, _vm.data.startDate, _vm.$parent)},"dragover":function($event){!_vm.isDisabled && _vm.options.editableEvents && _vm.cellDragOver($event, _vm.$data, _vm.data.startDate, _vm.$parent, _vm.splits.length ? split.id : null)},"dragleave":function($event){!_vm.isDisabled && _vm.options.editableEvents && _vm.cellDragLeave($event, _vm.$data, _vm.data.startDate, _vm.$parent)},"drop":function($event){!_vm.isDisabled && _vm.options.editableEvents && _vm.cellDragDrop($event, _vm.$data, _vm.data.startDate, _vm.$parent, _vm.splits.length ? split.id : null)}}},[(_vm.isWeekOrDayView && !_vm.allDay && _vm.specialHours.from !== null)?_c('div',{staticClass:"vuecal__special-hours",class:("vuecal__special-hours--day" + (_vm.specialHours.day) + " " + (_vm.specialHours.class)),style:(("height: " + (_vm.specialHours.height) + "px;top: " + (_vm.specialHours.top) + "px"))}):_vm._e(),_vm._t("cell-content",null,{"events":_vm.events,"selectCell":function ($event) { return _vm.selectCell($event, true); },"split":_vm.splits.length ? split : false}),(_vm.eventsCount && (_vm.isWeekOrDayView || (_vm.view === 'month' && _vm.options.eventsOnMonthView)))?_c('div',{staticClass:"vuecal__cell-events"},_vm._l(((_vm.splits.length ? split.events : _vm.events)),function(event,j){return _c('event',{key:j,attrs:{"vuecal":_vm.$parent,"cell-formatted-date":_vm.data.formattedDate,"event":event,"all-day":_vm.allDay,"cell-events":_vm.splits.length ? split.events : _vm.events,"overlaps":((_vm.splits.length ? split.overlaps[event._eid] : _vm.cellOverlaps[event._eid]) || []).overlaps,"event-position":((_vm.splits.length ? split.overlaps[event._eid] : _vm.cellOverlaps[event._eid]) || []).position,"overlaps-streak":_vm.splits.length ? split.overlapsStreak : _vm.cellOverlapsStreak},scopedSlots:_vm._u([{key:"event",fn:function(ref){
var event = ref.event;
var view = ref.view;
return [_vm._t("event",null,{"view":view,"event":event})]}}],null,true)})}),1):_vm._e()],2)}),(_vm.timelineVisible)?_c('div',{key:_vm.options.transitions ? (_vm.view + "-now-line") : 'now-line',staticClass:"vuecal__now-line",style:(("top: " + _vm.todaysTimePosition + "px")),attrs:{"title":_vm.$parent.formatTime(_vm.nowInMinutes)}}):_vm._e()],2)}
var cellvue_type_template_id_7475f2f0_lang_pug_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/vue-cal/cell.vue?vue&type=template&id=7475f2f0&lang=pug&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"487f8217-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/event.vue?vue&type=template&id=19e4fa59&lang=pug&
var eventvue_type_template_id_19e4fa59_lang_pug_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vuecal__event",class:_vm.eventClasses,style:(_vm.eventStyles),attrs:{"tabindex":"0","draggable":_vm.vuecal.editableEvents && _vm.event.draggable && !_vm.event.background},on:{"focus":_vm.focusEvent,"keypress":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.stopPropagation();return _vm.onClick($event)},"mouseenter":_vm.onMouseEnter,"mouseleave":_vm.onMouseLeave,"touchstart":function($event){$event.stopPropagation();return _vm.onTouchStart($event)},"mousedown":function($event){_vm.onMouseDown($event) /* Don't stop mousedown propagation & trigger cell mousedown */},"click":_vm.onClick,"dblclick":_vm.onDblClick,"dragstart":function($event){_vm.vuecal.editableEvents && _vm.event.draggable && !_vm.event.background && _vm.onDragStart($event)},"dragend":function($event){_vm.vuecal.editableEvents && _vm.event.draggable && !_vm.event.background && _vm.onDragEnd($event)}}},[(_vm.vuecal.editableEvents && _vm.event.deletable)?_c('div',{staticClass:"vuecal__event-delete",on:{"click":function($event){$event.stopPropagation();return _vm.deleteEvent($event)},"touchstart":function($event){$event.stopPropagation();return _vm.touchDeleteEvent($event)}}},[_vm._v(_vm._s(_vm.vuecal.texts.deleteEvent))]):_vm._e(),_vm._t("event",null,{"event":_vm.event,"view":_vm.vuecal.view.id}),(_vm.resizable)?_c('div',{staticClass:"vuecal__event-resize-handle",attrs:{"contenteditable":"false"},on:{"mousedown":function($event){$event.stopPropagation();$event.preventDefault();return _vm.onDragHandleMouseDown($event)},"touchstart":function($event){$event.stopPropagation();$event.preventDefault();return _vm.onDragHandleMouseDown($event)}}}):_vm._e()],2)}
var eventvue_type_template_id_19e4fa59_lang_pug_staticRenderFns = []


// CONCATENATED MODULE: ./src/components/vue-cal/event.vue?vue&type=template&id=19e4fa59&lang=pug&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/event.vue?vue&type=script&lang=js&







//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var eventvue_type_script_lang_js_ = ({
  props: {
    cellFormattedDate: {
      type: String,
      default: ''
    },
    vuecal: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    event: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    cellEvents: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    overlaps: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    eventPosition: {
      type: Number,
      default: 0
    },
    overlapsStreak: {
      type: Number,
      default: 0
    },
    allDay: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    // On an event.
    onMouseDown: function onMouseDown(e) {
      var _this = this;

      var touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Prevent a double mouse down on touch devices.
      if ('ontouchstart' in window && !touch) return false;
      var _this$domEvents = this.domEvents,
          clickHoldAnEvent = _this$domEvents.clickHoldAnEvent,
          focusAnEvent = _this$domEvents.focusAnEvent,
          resizeAnEvent = _this$domEvents.resizeAnEvent,
          dragAnEvent = _this$domEvents.dragAnEvent; // If the delete button is already out and event is on focus then delete event.

      if (focusAnEvent._eid === this.event._eid && clickHoldAnEvent._eid === this.event._eid) {
        return true;
      } // Focus the clicked event.


      this.focusEvent();
      clickHoldAnEvent._eid = null; // Reinit click hold on each click.
      // Show event delete button.

      if (this.vuecal.editableEvents) {
        clickHoldAnEvent.timeoutId = setTimeout(function () {
          if (!resizeAnEvent._eid && !dragAnEvent._eid) {
            clickHoldAnEvent._eid = _this.event._eid;
            _this.event.deleting = true;
          }
        }, clickHoldAnEvent.timeout);
      }
    },
    onMouseEnter: function onMouseEnter(e) {
      e.preventDefault();
      this.vuecal.emitWithEvent('event-mouse-enter', this.event);
    },
    onMouseLeave: function onMouseLeave(e) {
      e.preventDefault();
      this.vuecal.emitWithEvent('event-mouse-leave', this.event);
    },
    onTouchStart: function onTouchStart(e) {
      this.onMouseDown(e, true);
    },
    onClick: function onClick(e) {
      if (typeof this.vuecal.onEventClick === 'function') return this.vuecal.onEventClick(this.event, e);
    },
    onDblClick: function onDblClick(e) {
      if (typeof this.vuecal.onEventDblclick === 'function') return this.vuecal.onEventDblclick(this.event, e);
    },
    onDragStart: function onDragStart(e) {
      eventDragStart(e, this.event, this.vuecal);
    },
    onDragEnd: function onDragEnd(e) {
      eventDragEnd(e, this.event, this.vuecal);
    },
    onDragHandleMouseDown: function onDragHandleMouseDown() {
      this.domEvents.dragAnEvent._eid = null;
      this.domEvents.resizeAnEvent = Object.assign(this.domEvents.resizeAnEvent, {
        _eid: this.event._eid,
        start: (this.segment || this.event).start,
        split: this.event.split || null,
        segment: !!this.segment && this.segment.start,
        originalEndTimeMinutes: this.event.endTimeMinutes
      });
      this.event.resizing = true;
    },
    deleteEvent: function deleteEvent() {
      var touch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      // Prevent a double mouse down on touch devices.
      if ('ontouchstart' in window && !touch) return false;
      deleteAnEvent(this.event, this.vuecal);
    },
    touchDeleteEvent: function touchDeleteEvent(event) {
      this.deleteEvent(true);
    },
    cancelDeleteEvent: function cancelDeleteEvent() {
      this.event.deleting = false;
    },
    focusEvent: function focusEvent() {
      var focusAnEvent = this.domEvents.focusAnEvent;
      var onFocus = focusAnEvent._eid;
      if (onFocus === this.event._eid) return;
      this.vuecal.emitWithEvent('event-focus', this.event); // Unfocus previous event if any.

      if (onFocus && onFocus !== this.event._eid) {
        var event = this.vuecal.view.events.find(function (e) {
          return e._eid === focusAnEvent._eid;
        });
        if (event) event.focused = false;
      } // Cancel delete on previous event if any.


      this.vuecal.cancelDelete();
      focusAnEvent._eid = this.event._eid;
      this.event.focused = true;
    }
  },
  computed: {
    // Don't rely on global variables otherwise whenever it would change all the events would be redrawn.
    eventStyles: function eventStyles() {
      if (this.event.allDay || !this.vuecal.time || !this.event.endTimeMinutes || this.vuecal.view.id === 'month' || this.allDay) return {};
      var width = 100 / Math.min(this.overlaps.length + 1, this.overlapsStreak);
      var left = 100 / (this.overlaps.length + 1) * this.eventPosition;

      if (this.vuecal.minEventWidth && width < this.vuecal.minEventWidth) {
        width = this.vuecal.minEventWidth;
        left = (100 - this.vuecal.minEventWidth) / this.overlaps.length * this.eventPosition;
      }

      return {
        top: "".concat((this.segment || this.event).top, "px"),
        height: "".concat((this.segment || this.event).height, "px"),
        width: "".concat(width, "%"),
        left: this.event.left && "".concat(this.event.left, "px") || "".concat(left, "%")
      };
    },
    // Don't rely on global variables otherwise whenever it would change all the events would be redrawn.
    eventClasses: function eventClasses() {
      var _ref2;

      var _ref = this.segment || {},
          isFirstDay = _ref.isFirstDay,
          isLastDay = _ref.isLastDay;

      return _ref2 = {}, _defineProperty(_ref2, this.event.classes.join(' '), true), _defineProperty(_ref2, 'vuecal__event--focus', this.event.focused), _defineProperty(_ref2, 'vuecal__event--resizing', this.event.resizing), _defineProperty(_ref2, 'vuecal__event--background', this.event.background), _defineProperty(_ref2, 'vuecal__event--deletable', this.event.deleting), _defineProperty(_ref2, 'vuecal__event--all-day', this.event.allDay), _defineProperty(_ref2, 'vuecal__event--dragging', !this.event.draggingStatic && this.event.dragging), _defineProperty(_ref2, 'vuecal__event--static', this.event.dragging && this.event.draggingStatic), _defineProperty(_ref2, 'vuecal__event--multiple-days', !!this.segment), _defineProperty(_ref2, 'event-start', this.segment && isFirstDay && !isLastDay), _defineProperty(_ref2, 'event-middle', this.segment && !isFirstDay && !isLastDay), _defineProperty(_ref2, 'event-end', this.segment && isLastDay && !isFirstDay), _ref2;
    },
    // When multiple-day events, a segment is a portion of event spanning on 1 day.
    segment: function segment() {
      return this.event.segments && this.event.segments[this.cellFormattedDate] || null;
    },
    resizable: function resizable() {
      return this.vuecal.editableEvents && this.event.resizable && this.vuecal.time && this.event.endTimeMinutes && !this.allDay && (!this.segment || this.segment && this.segment.isLastDay) && this.vuecal.view.id !== 'month';
    },
    domEvents: {
      get: function get() {
        return this.vuecal.domEvents;
      },
      set: function set(object) {
        this.vuecal.domEvents = object;
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/vue-cal/event.vue?vue&type=script&lang=js&
 /* harmony default export */ var vue_cal_eventvue_type_script_lang_js_ = (eventvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/vue-cal/event.vue?vue&type=style&index=0&lang=scss&
var eventvue_type_style_index_0_lang_scss_ = __webpack_require__("9ff5");

// CONCATENATED MODULE: ./src/components/vue-cal/event.vue






/* normalize component */

var event_component = normalizeComponent(
  vue_cal_eventvue_type_script_lang_js_,
  eventvue_type_template_id_19e4fa59_lang_pug_render,
  eventvue_type_template_id_19e4fa59_lang_pug_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var vue_cal_event = (event_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/cell.vue?vue&type=script&lang=js&














//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var cellvue_type_script_lang_js_ = ({
  components: {
    Event: vue_cal_event
  },
  props: {
    // Vue-cal main component options (props).
    options: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    data: {
      type: Object,
      required: true
    },
    cellSplits: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    minTimestamp: {
      type: [Number, null],
      default: null
    },
    maxTimestamp: {
      type: [Number, null],
      default: null
    },
    cellWidth: {
      type: [Number, Boolean],
      default: false
    },
    allDay: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      cellOverlaps: {},
      cellOverlapsStreak: 1,
      // Largest amount of simultaneous events in cell.
      // On mouse down, save the time at cursor so it can be reused on cell focus event
      // where there is no cursor coords.
      timeAtCursor: null,
      highlighted: false,
      // On event drag over.
      highlightedSplit: null
    };
  },
  methods: {
    getSplitAtCursor: function getSplitAtCursor(DOMEvent) {
      var split = DOMEvent.target.classList.contains('vuecal__cell-split') && DOMEvent.target || this.$parent.findAncestor(DOMEvent.target, 'vuecal__cell-split');
      return split && split.attributes['data-split'].value || null;
    },
    checkCellOverlappingEvents: function checkCellOverlappingEvents() {
      // If splits, checkCellOverlappingEvents() is called from within computed splits.
      if (this.options.time && this.eventsCount && !this.splits.length) {
        if (this.eventsCount === 1) {
          this.cellOverlaps = [];
          this.cellOverlapsStreak = 1;
        } // If only 1 event remains re-init the overlaps.
        else {
            var _checkCellOverlapping = event_utils_checkCellOverlappingEvents(this.events, this.options);

            var _checkCellOverlapping2 = _slicedToArray(_checkCellOverlapping, 2);

            this.cellOverlaps = _checkCellOverlapping2[0];
            this.cellOverlapsStreak = _checkCellOverlapping2[1];
          }
      }
    },
    isDOMElementAnEvent: function isDOMElementAnEvent(el) {
      return this.$parent.isDOMElementAnEvent(el);
    },
    selectCell: function selectCell(DOMEvent) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!this.isSelected) this.onCellFocus(DOMEvent); // If splitting days, also return the clicked split on cell click when emitting event.

      var split = this.splits.length ? this.getSplitAtCursor(DOMEvent) : null;

      cell_utils_selectCell(force, this.$parent, this.timeAtCursor, split);

      this.timeAtCursor = null;
    },
    onCellkeyPressEnter: function onCellkeyPressEnter(DOMEvent) {
      if (!this.isSelected) this.onCellFocus(DOMEvent); // If splitting days, also return the clicked split on cell keypress when emitting event.

      var split = this.splits.length ? this.getSplitAtCursor(DOMEvent) : null;
      keyPressEnterCell(this.$parent, this.timeAtCursor, split);
      this.timeAtCursor = null;
    },

    /**
     * On cell focus, from tab key or from click, emit the cell-focus event with
     * the date of the cell start when focusing from tab or the date & time at cursor
     * if click/touch.
     */
    onCellFocus: function onCellFocus(DOMEvent) {
      if (!this.isSelected) {
        this.isSelected = this.data.startDate; // If splitting days, also return the clicked split on cell focus when emitting event.

        var split = this.splits.length ? this.getSplitAtCursor(DOMEvent) : null; // Cell-focus event returns the cell start date (at midnight) if triggered from tab key,
        // or cursor coords time if clicked.

        var date = this.timeAtCursor || this.data.startDate;
        this.$parent.$emit('cell-focus', split ? {
          date: date,
          split: split
        } : date);
      }
    },
    onCellMouseDown: function onCellMouseDown(DOMEvent) {
      var _this = this;

      var split = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var touch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // Prevent a double mouse down on touch devices.
      if ('ontouchstart' in window && !touch) return false;
      var _this$domEvents = this.domEvents,
          clickHoldACell = _this$domEvents.clickHoldACell,
          focusAnEvent = _this$domEvents.focusAnEvent; // Reinit the click trigger on each mousedown.
      // In some cases we explicitly set this flag to prevent the click event to trigger,
      // and cancel event creation.

      this.domEvents.cancelClickEventCreation = false;
      this.timeAtCursor = new Date(this.data.startDate);
      this.timeAtCursor.setMinutes(this.$parent.minutesAtCursor(DOMEvent).minutes);
      var mouseDownOnEvent = this.isDOMElementAnEvent(DOMEvent.target); // Unfocus an event if any is focused and clicking on cell outside of an event.

      if (!mouseDownOnEvent && focusAnEvent._eid) {
        (this.$parent.view.events.find(function (e) {
          return e._eid === focusAnEvent._eid;
        }) || {}).focused = false;
      } // If the cellClickHold option is true and not mousedown on an event, click & hold to create an event.


      if (this.options.editableEvents && this.options.cellClickHold && !mouseDownOnEvent && ['month', 'week', 'day'].includes(this.view)) {
        clickHoldACell.cellId = "".concat(this.$parent._uid, "_").concat(this.data.formattedDate);
        clickHoldACell.split = split;
        clickHoldACell.timeoutId = setTimeout(function () {
          if (clickHoldACell.cellId && !_this.domEvents.cancelClickEventCreation) {
            _this.$parent.createEvent(_this.timeAtCursor, clickHoldACell.split ? {
              split: clickHoldACell.split
            } : {});
          }
        }, clickHoldACell.timeout);
      }
    },
    onCellTouchStart: function onCellTouchStart(DOMEvent) {
      var split = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // If not mousedown on an event.
      this.onCellMouseDown(DOMEvent, split, true);
    },
    onCellDblClick: function onCellDblClick(DOMEvent) {
      var date = new Date(this.data.startDate);
      date.setMinutes(this.$parent.minutesAtCursor(DOMEvent).minutes); // If splitting days, also return the clicked split on cell dblclick when emitting event.

      var split = this.splits.length ? this.getSplitAtCursor(DOMEvent) : null;
      this.$parent.$emit('cell-dblclick', split ? {
        date: date,
        split: split
      } : date);
      if (this.options.dblclickToNavigate) this.$parent.switchToNarrowerView();
    },
    onCellContextMenu: function onCellContextMenu(DOMEvent) {
      DOMEvent.stopPropagation();
      DOMEvent.preventDefault();
      var date = new Date(this.data.startDate);

      var _this$$parent$minutes = this.$parent.minutesAtCursor(DOMEvent),
          cursorCoords = _this$$parent$minutes.cursorCoords,
          minutes = _this$$parent$minutes.minutes;

      date.setMinutes(minutes); // If splitting days, also return the clicked split on cell contextmenu when emitting event.

      var split = this.splits.length ? this.getSplitAtCursor(DOMEvent) : null;
      this.$parent.$emit('cell-contextmenu', _objectSpread2({
        date: date
      }, cursorCoords, {}, split || {}));
    },
    cellDragOver: cellDragOver,
    cellDragEnter: cellDragEnter,
    cellDragLeave: cellDragLeave,
    cellDragDrop: drag_and_drop_cellDragDrop
  },
  computed: {
    nowInMinutes: function nowInMinutes() {
      return this.$parent.now.getHours() * 60 + this.$parent.now.getMinutes();
    },
    isBeforeMinDate: function isBeforeMinDate() {
      return this.minTimestamp !== null && this.minTimestamp > this.data.endDate.getTime();
    },
    isAfterMaxDate: function isAfterMaxDate() {
      return this.maxTimestamp && this.maxTimestamp < this.data.startDate.getTime();
    },
    // Is the current cell disabled or not.
    isDisabled: function isDisabled() {
      return this.isBeforeMinDate || this.isAfterMaxDate;
    },
    // Is the current cell selected or not.
    isSelected: {
      get: function get() {
        var selected = false;
        var selectedDate = this.$parent.view.selectedDate;

        if (this.view === 'years') {
          selected = selectedDate.getFullYear() === this.data.startDate.getFullYear();
        } else if (this.view === 'year') {
          selected = selectedDate.getFullYear() === this.data.startDate.getFullYear() && selectedDate.getMonth() === this.data.startDate.getMonth();
        } else selected = selectedDate.getTime() === this.data.startDate.getTime();

        return selected;
      },
      set: function set(date) {
        this.$parent.view.selectedDate = date;
      }
    },
    domEvents: {
      get: function get() {
        return this.$parent.domEvents;
      },
      set: function set(object) {
        this.$parent.domEvents = object;
      }
    },
    texts: function texts() {
      return this.$parent.texts;
    },
    view: function view() {
      return this.$parent.view.id;
    },
    // Cache result for performance.
    isWeekOrDayView: function isWeekOrDayView() {
      return ['week', 'day'].includes(this.view);
    },
    transitionDirection: function transitionDirection() {
      return this.$parent.transitionDirection;
    },
    specialHours: function specialHours() {
      var _this$data$specialHou = this.data.specialHours,
          from = _this$data$specialHou.from,
          to = _this$data$specialHou.to;
      from = Math.max(from, this.options.timeFrom);
      to = Math.min(to, this.options.timeTo);
      return _objectSpread2({}, this.data.specialHours, {
        height: (to - from) * this.timeScale,
        top: (from - this.options.timeFrom) * this.timeScale
      });
    },
    events: function events() {
      var _this2 = this;

      var _this$data = this.data,
          cellStart = _this$data.startDate,
          cellEnd = _this$data.endDate;
      var events = []; // Calculate events on month/week/day views or years/year if eventsCountOnYearView.

      if (!(['years', 'year'].includes(this.view) && !this.options.eventsCountOnYearView)) {
        // Means that when $parent.view.events changes all the cells will be looking up new value. :/
        // Also clone array to prevent modifying original.
        events = this.$parent.view.events.slice(0);

        if (this.view === 'month') {
          var _events;

          (_events = events).push.apply(_events, _toConsumableArray(this.$parent.view.outOfScopeEvents));
        } // Only keep events in cell time range.


        events = events.filter(function (e) {
          return eventInRange(e, cellStart, cellEnd);
        });
        if (this.options.showAllDayEvents && this.view !== 'month') events = events.filter(function (e) {
          return !!e.allDay === _this2.allDay;
        }); // From events in view, filter the ones that are out of `time-from`-`time-to` range in this cell.

        if (this.options.time && this.isWeekOrDayView && !this.allDay) {
          var _this$options = this.options,
              timeFrom = _this$options.timeFrom,
              timeTo = _this$options.timeTo;
          events = events.filter(function (e) {
            var segment = e.daysCount > 1 && e.segments[_this2.data.formattedDate] || {};
            var singleDayInRange = e.daysCount === 1 && e.startTimeMinutes < timeTo && e.endTimeMinutes > timeFrom;
            var multipleDayInRange = e.daysCount > 1 && segment.startTimeMinutes < timeTo && segment.endTimeMinutes > timeFrom;
            var recurrMultDayInRange = false; // e.daysCount > 1 && e.repeat && recurringEventInRange(e, cellStart, cellEnd)

            return e.allDay || singleDayInRange || multipleDayInRange || recurrMultDayInRange;
          });
        } // Position events with time in the timeline when there is a timeline and not in allDay slot.


        if (this.options.time && this.isWeekOrDayView && !(this.options.showAllDayEvents && this.allDay)) {
          events.forEach(function (event) {
            // all-day events are positionned via css: top-0 & bottom-0.
            // So they behave as background events if not in allDay slot.
            // @todo: Do we want this or not?
            var eventToUpdate = event.segments && event.segments[_this2.data.formattedDate] || event;
            if ((event.startTimeMinutes || event.endTimeMinutes) && !event.allDay) updateEventPosition(eventToUpdate, _this2.$parent);
          }); // Sort events in chronological order.

          events.sort(function (a, b) {
            return a.start < b.start ? -1 : 1;
          });
        } // If splits, checkCellOverlappingEvents() is called from within computed splits.


        if (!this.cellSplits.length) this.$nextTick(this.checkCellOverlappingEvents);
      }

      return events;
    },
    eventsCount: function eventsCount() {
      return this.events.length;
    },
    splits: function splits() {
      var _this3 = this;

      return this.cellSplits.map(function (item, i) {
        var events = _this3.events.filter(function (e) {
          return e.split === item.id;
        });

        var _checkCellOverlapping3 = event_utils_checkCellOverlappingEvents(events.filter(function (e) {
          return !e.background && !e.allDay;
        }), _this3.options),
            _checkCellOverlapping4 = _slicedToArray(_checkCellOverlapping3, 2),
            overlaps = _checkCellOverlapping4[0],
            streak = _checkCellOverlapping4[1];

        return _objectSpread2({}, item, {
          overlaps: overlaps,
          overlapsStreak: streak,
          events: events
        });
      });
    },
    cssClasses: function cssClasses() {
      return {
        'vuecal__cell--current': this.data.current,
        // E.g. Current year in years view.
        'vuecal__cell--today': this.data.today,
        'vuecal__cell--out-of-scope': this.data.outOfScope,
        'vuecal__cell--before-min': this.isDisabled && this.isBeforeMinDate,
        'vuecal__cell--after-max': this.isDisabled && this.isAfterMaxDate,
        'vuecal__cell--disabled': this.isDisabled,
        'vuecal__cell--selected': this.isSelected,
        'vuecal__cell--highlighted': this.highlighted,
        'vuecal__cell--has-splits': this.splits.length,
        'vuecal__cell--has-events': this.eventsCount
      };
    },
    cellStyles: function cellStyles() {
      return _objectSpread2({}, this.cellWidth ? {
        width: "".concat(this.cellWidth, "%")
      } : {});
    },
    timelineVisible: function timelineVisible() {
      if (!this.data.today || !this.options.time || this.allDay || !this.isWeekOrDayView) return;
      return this.$parent.now.getHours() * 60 + this.$parent.now.getMinutes() <= this.options.timeTo;
    },
    todaysTimePosition: function todaysTimePosition() {
      // Skip the Maths if not relevant.
      if (!this.data.today || !this.options.time) return;
      var startTimeMinutes = this.$parent.now.getHours() * 60 + this.$parent.now.getMinutes();
      var minutesFromTop = startTimeMinutes - this.options.timeFrom;
      return Math.round(minutesFromTop * this.timeScale);
    },
    timeScale: function timeScale() {
      return this.options.timeCellHeight / this.options.timeStep;
    }
  }
});
// CONCATENATED MODULE: ./src/components/vue-cal/cell.vue?vue&type=script&lang=js&
 /* harmony default export */ var vue_cal_cellvue_type_script_lang_js_ = (cellvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/components/vue-cal/cell.vue?vue&type=style&index=0&lang=scss&
var cellvue_type_style_index_0_lang_scss_ = __webpack_require__("d011");

// CONCATENATED MODULE: ./src/components/vue-cal/cell.vue






/* normalize component */

var cell_component = normalizeComponent(
  vue_cal_cellvue_type_script_lang_js_,
  cellvue_type_template_id_7475f2f0_lang_pug_render,
  cellvue_type_template_id_7475f2f0_lang_pug_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var vue_cal_cell = (cell_component.exports);
// EXTERNAL MODULE: ./src/components/vue-cal/styles.scss
var styles = __webpack_require__("00aa");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-cal/index.vue?vue&type=script&lang=js&



























//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//






var vue_calvue_type_script_lang_js_minutesInADay = 24 * 60; // Don't do the maths every time.

var textsDefaults = {
  weekDays: Array(7).fill(''),
  weekDaysShort: [],
  months: Array(12).fill(''),
  years: '',
  year: '',
  month: '',
  week: '',
  day: '',
  today: '',
  noEvent: '',
  allDay: '',
  deleteEvent: '',
  createEvent: '',
  dateFormat: 'dddd MMMM D, YYYY',
  am: 'am',
  pm: 'pm'
};
/* harmony default export */ var vue_calvue_type_script_lang_js_ = ({
  name: 'vue-cal',
  components: {
    'vuecal-cell': vue_cal_cell,
    'vuecal-header': header,
    WeekdaysHeadings: weekdays_headings
  },
  props: {
    cellClickHold: {
      type: Boolean,
      default: true
    },
    cellContextmenu: {
      type: Boolean,
      default: false
    },
    clickToNavigate: {
      type: Boolean,
      default: false
    },
    dblclickToNavigate: {
      type: Boolean,
      default: true
    },
    defaultView: {
      type: String,
      default: 'week'
    },
    disableViews: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    editableEvents: {
      type: Boolean,
      default: false
    },
    events: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    eventsCountOnYearView: {
      type: Boolean,
      default: false
    },
    eventsOnMonthView: {
      type: [Boolean, String],
      default: false
    },
    hideBody: {
      type: Boolean,
      default: false
    },
    hideTitleBar: {
      type: Boolean,
      default: false
    },
    hideViewSelector: {
      type: Boolean,
      default: false
    },
    hideWeekdays: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    hideWeekends: {
      type: Boolean,
      default: false
    },
    locale: {
      type: String,
      default: 'en'
    },
    maxDate: {
      type: [String, Date],
      default: ''
    },
    minCellWidth: {
      type: Number,
      default: 0
    },
    minDate: {
      type: [String, Date],
      default: ''
    },
    minEventWidth: {
      type: Number,
      default: 0
    },
    minSplitWidth: {
      type: Number,
      default: 0
    },
    onEventClick: {
      type: [Function, null],
      default: null
    },
    onEventCreate: {
      type: [Function, null],
      default: null
    },
    onEventDblclick: {
      type: [Function, null],
      default: null
    },
    overlapsPerTimeStep: {
      type: Boolean,
      default: false
    },
    resizeX: {
      type: Boolean,
      default: false
    },
    selectedDate: {
      type: [String, Date],
      default: ''
    },
    showAllDayEvents: {
      type: [Boolean, String],
      default: false
    },
    showWeekNumbers: {
      type: [Boolean, String],
      default: false
    },
    snapToTime: {
      type: Number,
      default: 0
    },
    small: {
      type: Boolean,
      default: false
    },
    specialHours: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    splitDays: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    startWeekOnSunday: {
      type: Boolean,
      default: false
    },
    stickySplitLabels: {
      type: Boolean,
      default: false
    },
    time: {
      type: Boolean,
      default: true
    },
    timeCellHeight: {
      type: Number,
      default: 40
    },
    // In pixels.
    timeFormat: {
      type: String,
      default: ''
    },
    timeFrom: {
      type: Number,
      default: 0
    },
    // In minutes.
    timeStep: {
      type: Number,
      default: 60
    },
    // In minutes.
    timeTo: {
      type: Number,
      default: vue_calvue_type_script_lang_js_minutesInADay
    },
    // In minutes.
    todayButton: {
      type: Boolean,
      default: false
    },
    transitions: {
      type: Boolean,
      default: true
    },
    twelveHour: {
      type: Boolean,
      default: false
    },
    watchRealTime: {
      type: Boolean,
      default: false
    },
    // Expensive, so only trigger on demand.
    xsmall: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      // Make texts reactive before a locale is loaded.
      texts: _objectSpread2({}, textsDefaults),
      ready: false,
      // Is vue-cal ready.
      // At any time this object will be filled with current view, visible events and selected date.
      view: {
        id: '',
        title: '',
        startDate: null,
        endDate: null,
        firstCellDate: null,
        lastCellDate: null,
        selectedDate: null,
        // All the events are stored in the mutableEvents array, but subset of visible ones are passed
        // Into the current view for fast lookup and manipulation.
        events: []
      },
      eventIdIncrement: 1,
      // Internal unique id.
      // Preset at now date on load, but updated every minute if watchRealTime,
      // or updated at least on each cells rerender, in order to keep Today's date accurate.
      now: new Date(),
      // Useful when watchRealTime = true, 2 timeouts: 1 to snap to round minutes, then 1 every minute.
      timeTickerIds: [null, null],
      // All the possible events/cells interractions:
      // e.g. focus, click, click & hold, resize, drag & drop (coming).
      domEvents: {
        resizeAnEvent: {
          _eid: null,
          // Only one at a time.
          start: null,
          split: null,
          segment: null,
          originalEndTimeMinutes: 0,
          endTimeMinutes: 0,
          startCell: null,
          endCell: null
        },
        dragAnEvent: {
          _eid: null,
          // Only one at a time.
          cursorGrabAt: 0 // The cursor position (in minutes) in the event.

        },
        focusAnEvent: {
          _eid: null // Only one at a time.

        },
        clickHoldAnEvent: {
          _eid: null,
          // Only one at a time.
          timeout: 1200,
          // Hold for 1.2s to delete an event.
          timeoutId: null
        },
        dblTapACell: {
          taps: 0,
          timeout: 500 // Allowed latency between first and second click.

        },
        clickHoldACell: {
          cellId: null,
          split: null,
          timeout: 1200,
          // Hold for 1.2s to create an event.
          timeoutId: null
        },
        // A single click can trigger event creation if the user decides so.
        // But prevent this to happen on click & hold, on event click and on resize event.
        cancelClickEventCreation: false
      },
      // The events source of truth.
      // An array of mutable events updated each time given external events array changes.
      mutableEvents: [],
      // Transition when switching view. left when going toward the past, right when going toward future.
      transitionDirection: 'right'
    };
  },
  methods: {
    /**
     * Only import locale on demand to keep a small library weight.
     *
     * @param {String} locale the language user whishes to have on vue-cal
     */
    loadLocale: function loadLocale(locale) {
      var _this = this;

      if (this.locale === 'en') this.texts = Object.assign({}, textsDefaults, __webpack_require__("7213"));else {
        __webpack_require__("1790")("./".concat(locale)).then(function (response) {
          _this.texts = Object.assign({}, textsDefaults, response.default);

          date_utils_updateDateTexts(_this.texts);
        });
      }
    },

    /**
     * On click/dblclick of a cell go to a narrower view if available.
     * E.g. Click on month cell takes you to week view if not hidden, otherwise on day view if not hidden.
     *
     * @param {String | Date} date A starting date for the view, if none, fallbacks to the selected date,
     *                             If also empty fallbacks to the current view start date.
     */
    switchToNarrowerView: function switchToNarrowerView() {
      var _this2 = this;

      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.transitionDirection = 'right';
      var views = Object.keys(this.views);
      views = views.slice(views.indexOf(this.view.id) + 1);
      var view = views.find(function (v) {
        return _this2.views[v].enabled;
      });
      if (view) this.switchView(view, date);
    },

    /**
     * Switches to the specified view on view selector click, or programmatically form external call (via $refs).
     * If a date is given, it will be selected and if the view does not contain it, it will go to that date.
     *
     * @param {String} view the view to go to. Among `years`, `year`, `month`, `week`, `day`.
     * @param {String | Date} date A starting date for the view, if none, fallbacks to the selected date,
     *                             If also empty fallbacks to the current view start date.
     * @param {Boolean} fromViewSelector to know if the caller is the built-in view selector.
     */
    switchView: function switchView(view) {
      var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var fromViewSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (this.transitions && fromViewSelector) {
        var views = Object.keys(this.views);
        this.transitionDirection = views.indexOf(this.view.id) > views.indexOf(view) ? 'left' : 'right';
      }

      this.view.events = [];
      this.view.id = view;
      this.view.firstCellDate = null; // For month view, if filling cells before 1st of month.

      this.view.lastCellDate = null; // For month view, if filling cells after current month.

      if (!date) {
        date = this.view.selectedDate || this.view.startDate;
        if (view === 'week') date = getPreviousFirstDayOfWeek(date, this.startWeekOnSunday);
      }

      switch (view) {
        case 'years':
          {
            // Always fill first cell with a multiple of 25 years, E.g. year 2000, or 2025.
            this.view.startDate = new Date(Math.floor(date.getFullYear() / 25) * 25 || 2000, 0, 1);
            this.view.endDate = new Date(this.view.startDate.getFullYear() + 25, 0, 1);
            this.view.endDate.setSeconds(-1); // End at 23:59:59.

            break;
          }

        case 'year':
          {
            this.view.startDate = new Date(date.getFullYear(), 0, 1);
            this.view.endDate = new Date(date.getFullYear() + 1, 0, 1);
            this.view.endDate.setSeconds(-1); // End at 23:59:59.

            break;
          }

        case 'month':
          {
            this.view.startDate = new Date(date.getFullYear(), date.getMonth(), 1);
            this.view.endDate = new Date(date.getFullYear(), date.getMonth() + 1, 1);
            this.view.endDate.setSeconds(-1); // End at 23:59:59.
            // If the first day of the month is not a FirstDayOfWeek (Monday or Sunday), prepend missing days to the days array.

            var startDate = new Date(this.view.startDate);

            if (startDate.getDay() !== (this.startWeekOnSunday ? 0 : 1)) {
              startDate = getPreviousFirstDayOfWeek(startDate, this.startWeekOnSunday);
            } // Used in viewCells computed array & returned in emitted events.


            this.view.firstCellDate = startDate;
            this.view.lastCellDate = startDate.addDays(41);
            this.view.lastCellDate.setHours(23, 59, 59, 0);

            if (this.hideWeekends) {
              // Remove first weekend from firstCellDate if hide-weekends.
              if ([0, 6].includes(this.view.firstCellDate.getDay())) {
                var daysToAdd = this.view.firstCellDate.getDay() === 6 && !this.startWeekOnSunday ? 2 : 1;
                this.view.firstCellDate = this.view.firstCellDate.addDays(daysToAdd);
              } // Remove first weekend from startDate if hide-weekends.


              if ([0, 6].includes(this.view.startDate.getDay())) {
                var _daysToAdd = this.view.startDate.getDay() === 6 ? 2 : 1;

                this.view.startDate = this.view.startDate.addDays(_daysToAdd);
              } // Remove last weekend from lastCellDate if hide-weekends.


              if ([0, 6].includes(this.view.lastCellDate.getDay())) {
                var daysToSubtract = this.view.lastCellDate.getDay() === 0 && !this.startWeekOnSunday ? 2 : 1;
                this.view.lastCellDate = this.view.lastCellDate.subtractDays(daysToSubtract);
              } // Remove last weekend from endDate if hide-weekends.


              if ([0, 6].includes(this.view.endDate.getDay())) {
                var _daysToSubtract = this.view.endDate.getDay() === 0 ? 2 : 1;

                this.view.endDate = this.view.endDate.subtractDays(_daysToSubtract);
              }
            }

            break;
          }

        case 'week':
          {
            var weekDaysCount = this.hideWeekends ? 5 : 7;
            this.view.startDate = this.hideWeekends && this.startWeekOnSunday ? date.addDays(1) : date;
            this.view.startDate.setHours(0, 0, 0, 0);
            this.view.endDate = date.addDays(weekDaysCount);
            this.view.endDate.setSeconds(-1); // End at 23:59:59.

            break;
          }

        case 'day':
          {
            this.view.startDate = date;
            this.view.startDate.setHours(0, 0, 0, 0);
            this.view.endDate = new Date(date);
            this.view.endDate.setHours(23, 59, 59, 0); // End at 23:59:59.

            break;
          }
      }

      this.addEventsToView();

      if (this.ready) {
        var _startDate = this.view.startDate;

        var params = _objectSpread2({
          view: view,
          startDate: _startDate,
          endDate: this.view.endDate
        }, this.view.id === 'month' ? {
          firstCellDate: this.view.firstCellDate,
          lastCellDate: this.view.lastCellDate,
          outOfScopeEvents: this.view.outOfScopeEvents.map(this.cleanupEvent)
        } : {}, {
          events: this.view.events.map(this.cleanupEvent)
        }, this.view.id === 'week' ? {
          week: this.startWeekOnSunday ? _startDate.addDays(1).getWeek() : _startDate.getWeek()
        } : {});

        this.$emit('view-change', params);
      }
    },

    /**
     * Shorthand function for external call (via $refs).
     */
    previous: function previous() {
      this.previousNext(false);
    },

    /**
     * Shorthand function for external call (via $refs).
     */
    next: function next() {
      this.previousNext();
    },

    /**
     * On click on previous or next arrow, update the calendar visible date range.
     *
     * @param {Boolean} next
     */
    previousNext: function previousNext() {
      var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.transitionDirection = next ? 'right' : 'left';
      var modifier = next ? 1 : -1;
      var firstCellDate = null;
      var _this$view = this.view,
          startDate = _this$view.startDate,
          viewId = _this$view.id;

      switch (viewId) {
        case 'years':
          firstCellDate = new Date(startDate.getFullYear() + 25 * modifier, 0, 1);
          break;

        case 'year':
          firstCellDate = new Date(startDate.getFullYear() + 1 * modifier, 1, 1);
          break;

        case 'month':
          firstCellDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1 * modifier, 1);
          break;

        case 'week':
          firstCellDate = getPreviousFirstDayOfWeek(startDate, this.startWeekOnSunday)[next ? 'addDays' : 'subtractDays'](7);
          break;

        case 'day':
          firstCellDate = startDate[next ? 'addDays' : 'subtractDays'](1);
          break;
      }

      if (firstCellDate) this.switchView(viewId, firstCellDate);
    },

    /**
     * Add events (subset from mutableEvents) to the current view (in `this.view.events`).
     * This is done for performance, so that all the cells have a quick lookup of only what's needed.
     *
     * @param {Array} events
     */
    addEventsToView: function addEventsToView() {
      var _this$view$events,
          _this3 = this;

      var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var _this$view2 = this.view,
          id = _this$view2.id,
          startDate = _this$view2.startDate,
          endDate = _this$view2.endDate,
          firstCellDate = _this$view2.firstCellDate,
          lastCellDate = _this$view2.lastCellDate; // Clear the current view if not explicitely giving an array of events to add.

      if (!events.length) this.view.events = []; // @todo: remove the code that explicitely updates this.mutableEvents (e.g on event resize).
      // as we are already mutating the event from mutableEvents.

      events = events.length ? events : _toConsumableArray(this.mutableEvents); // In no event or if on years/year view and eventsCountOnYearView is false
      // then don't add events to view.

      if (!events || ['years', 'year'].includes(id) && !this.eventsCountOnYearView) return; // First remove the events that are not in view.
      // Keep the unfiltered array of events for outOfScopeEvents bellow.

      var filteredEvents = events.filter(function (e) {
        return eventInRange(e, startDate, endDate);
      }); // For each multiple-day event and only if needed, create its segments (= days) for rendering in the view.
      // If we don't display the event on month view (eventsOnMonthView = false) then don't create segments.

      if (['month', 'week', 'day'].includes(id) && !(id === 'month' && !this.eventsOnMonthView)) {
        filteredEvents = filteredEvents.map(function (e) {
          return e.daysCount > 1 ? event_utils_createEventSegments(e, firstCellDate || startDate, lastCellDate || endDate) : e;
        });
      }

      (_this$view$events = this.view.events).push.apply(_this$view$events, _toConsumableArray(filteredEvents));

      if (id === 'month') {
        // Save out of scope events into the view object separated from the array of in-scope events.
        this.view.outOfScopeEvents = [];
        events.forEach(function (e) {
          if (eventInRange(e, firstCellDate, startDate) || eventInRange(e, endDate, lastCellDate)) {
            // Only add events to the view.outOfScopeEvents array if not already in view.events
            // (multiple-day events case).
            if (!_this3.view.events.some(function (e2) {
              return e2._eid === e._eid;
            })) _this3.view.outOfScopeEvents.push(e);
          }
        });
      }
    },

    /**
     * find a DOM ancestor of a given DOM node `el` matching given class name.
     *
     * @param {Object} el a DOM node to find ancestor from.
     * @param {String} Class the CSS class name of the ancestor.
     * @return {Object} The matched DOM node or null if no match.
     */
    findAncestor: function findAncestor(el, Class) {
      while ((el = el.parentElement) && !el.classList.contains(Class)) {}

      return el;
    },

    /**
     * Tells whether a clicked DOM node is or is within a calendar event.
     *
     * @param {Object} el a DOM node to check if event.
     * @return {Boolean} true if the given DOM node is - or is in - an event.
     */
    isDOMElementAnEvent: function isDOMElementAnEvent(el) {
      return el.classList.contains('vuecal__event') || this.findAncestor(el, 'vuecal__event');
    },

    /**
     * Capture mousemove anywhere in the page.
     * If resizing an event was started earlier, this will update event end.
     * If resizing was not started, this method is calculation is avoided with a premature return.
     * Notes: Event resizing is started in cell component (onMouseDown) but place onMouseMove & onMouseUp
     *        handlers in the single-instance parent for performance.
     *
     * @param {Object} e the native DOM event object.
     */
    onMouseMove: function onMouseMove(e) {
      var _this$domEvents = this.domEvents,
          resizeAnEvent = _this$domEvents.resizeAnEvent,
          dragAnEvent = _this$domEvents.dragAnEvent;
      if (resizeAnEvent._eid === null && dragAnEvent._eid === null) return;
      e.preventDefault();

      if (resizeAnEvent._eid) {
        var event = this.view.events.find(function (e) {
          return e._eid === resizeAnEvent._eid;
        }) || {
          segments: {}
        };

        var _this$minutesAtCursor = this.minutesAtCursor(e),
            minutes = _this$minutesAtCursor.minutes,
            cursorCoords = _this$minutesAtCursor.cursorCoords;

        var segment = event.segments && event.segments[resizeAnEvent.segment]; // Don't allow time above 24 hours.

        event.endTimeMinutes = resizeAnEvent.endTimeMinutes = Math.min(minutes, vue_calvue_type_script_lang_js_minutesInADay); // Prevent reducing event duration to less than 1 min so it does not disappear.

        event.endTimeMinutes = resizeAnEvent.endTimeMinutes = Math.max(event.endTimeMinutes, this.timeFrom + 1, (segment || event).startTimeMinutes + 1); // On resize, snap to time every X minutes if the option is on.

        if (this.snapToTime) {
          var plusHalfSnapTime = event.endTimeMinutes + this.snapToTime / 2;
          event.endTimeMinutes = plusHalfSnapTime - plusHalfSnapTime % this.snapToTime;
        }

        if (segment) segment.endTimeMinutes = event.endTimeMinutes;
        event.endDate.setHours(0, event.endTimeMinutes, event.endTimeMinutes === vue_calvue_type_script_lang_js_minutesInADay ? -1 : 0, // Remove 1 second if time is 24:00.
        0);
        event.end = formatDateLite(event.endDate) + ' ' + date_utils_formatTime(event.endTimeMinutes); // Resize events horizontally if resize-x is enabled (add/remove segments).

        if (this.resizeX && this.view.id === 'week') {
          event.daysCount = countDays(event.startDate, event.endDate);
          var cells = this.$refs.cells;
          var cellWidth = cells.offsetWidth / cells.childElementCount;
          var endCell = Math.floor(cursorCoords.x / cellWidth);

          if (!resizeAnEvent.startCell) {
            resizeAnEvent.startCell = endCell - (event.daysCount - 1);
          }

          if (resizeAnEvent.endCell !== endCell) {
            resizeAnEvent.endCell = endCell;
            var endDate = event.startDate.addDays(endCell - resizeAnEvent.startCell);
            var newDaysCount = countDays(event.startDate, endDate);

            if (newDaysCount !== event.daysCount) {
              // Check that all segments are up to date.
              var lastSegmentFormattedDate = null;
              if (newDaysCount > event.daysCount) lastSegmentFormattedDate = event_utils_addEventSegment(event);else lastSegmentFormattedDate = event_utils_removeEventSegment(event);
              resizeAnEvent.segment = lastSegmentFormattedDate;
              event.endTimeMinutes += 0.001; // Force updating the current event.
            }
          }
        }
      }
    },

    /**
     * Capture mouseup anywhere in the page, not only on a cell or event.
     * Then end up any resize, drag & drop, click & hold or event or cell.
     * Notes: Mouseup can never cancel a click with preventDefault or stopPropagation,
     *        But it always happens before the click event.
     *
     * @param {Object} e the native DOM event object.
     */
    onMouseUp: function onMouseUp(e) {
      var _this$domEvents2 = this.domEvents,
          resizeAnEvent = _this$domEvents2.resizeAnEvent,
          clickHoldAnEvent = _this$domEvents2.clickHoldAnEvent,
          clickHoldACell = _this$domEvents2.clickHoldACell; // On event resize end, emit event if duration has changed.

      if (resizeAnEvent._eid) {
        this.domEvents.cancelClickEventCreation = true;
        var event = this.view.events.find(function (e) {
          return e._eid === resizeAnEvent._eid;
        });

        if (event && event.endTimeMinutes !== resizeAnEvent.originalEndTimeMinutes) {
          // Store modified event back in mutable events.
          var mutableEvent = this.mutableEvents.find(function (e) {
            return e._eid === resizeAnEvent._eid;
          });
          mutableEvent.endTimeMinutes = event.endTimeMinutes;
          mutableEvent.end = event.end;
          mutableEvent.endDate = event.endDate;
          this.emitWithEvent('event-duration-change', event);
          this.emitWithEvent('event-change', event);
        }

        if (event) event.resizing = false;
        resizeAnEvent._eid = null;
        resizeAnEvent.start = null;
        resizeAnEvent.split = null;
        resizeAnEvent.segment = null;
        resizeAnEvent.originalEndTimeMinutes = null;
        resizeAnEvent.endTimeMinutes = null;
        resizeAnEvent.startCell = null;
        resizeAnEvent.endCell = null;
      }

      if (this.isDOMElementAnEvent(e.target)) this.domEvents.cancelClickEventCreation = true; // If not mouse up on an event, unfocus any event except if just dragged.
      else if (!resizeAnEvent._eid) this.unfocusEvent(); // Prevent showing delete button if click and hold was not long enough.
      // Click & hold timeout is initiated in onMouseDown() in event component.

      if (clickHoldAnEvent.timeoutId && !clickHoldAnEvent._eid) {
        clearTimeout(clickHoldAnEvent.timeoutId);
        clickHoldAnEvent.timeoutId = null;
      } // Prevent creating an event if click and hold was not long enough.


      if (clickHoldACell.timeoutId) {
        clearTimeout(clickHoldACell.timeoutId);
        clickHoldACell.timeoutId = null;
      }
    },

    /**
     * Capture `escape` keypress when delete button is visible, and cancel deletion.
     *
     * @param {Object} e the native DOM event object.
     */
    onKeyUp: function onKeyUp(e) {
      if (e.keyCode === 27) this.cancelDelete(); // Escape key.
    },

    /**
     * Unfocus an event (e.g. when clicking outside of focused event).
     */
    unfocusEvent: function unfocusEvent() {
      var _this$domEvents3 = this.domEvents,
          focusAnEvent = _this$domEvents3.focusAnEvent,
          clickHoldAnEvent = _this$domEvents3.clickHoldAnEvent;
      var event = this.view.events.find(function (e) {
        return e._eid === (focusAnEvent._eid || clickHoldAnEvent._eid);
      });
      focusAnEvent._eid = null; // Cancel event focus.

      clickHoldAnEvent._eid = null; // Hide delete button.

      if (event) {
        event.focused = false;
        event.deleting = false;
      }
    },

    /**
     * Cancel an event deletion (e.g. when clicking outside of visible delete button).
     */
    cancelDelete: function cancelDelete() {
      var clickHoldAnEvent = this.domEvents.clickHoldAnEvent;

      if (clickHoldAnEvent._eid) {
        var event = this.view.events.find(function (e) {
          return e._eid === clickHoldAnEvent._eid;
        });
        if (event) event.deleting = false;
        clickHoldAnEvent._eid = null;
        clickHoldAnEvent.timeoutId = null;
      }
    },

    /**
     * After editing an event title (if `this.editable`), save the new string into the event object
     * and emit event to the outside world.
     *
     * @param {Object} e the native DOM event object.
     * @param {Object} event the vue-cal event object.
     */
    onEventTitleBlur: function onEventTitleBlur(e, event) {
      // If no change cancel action.
      if (event.title === e.target.innerHTML) return;
      event.title = e.target.innerHTML;
      this.emitWithEvent('event-title-change', event);
      this.emitWithEvent('event-change', event);
    },

    /**
     * The `mutableEvents` array of events is the source of truth.
     * It is first populated from the `events` prop and every time the `events` prop changes.
     * When the user updates an event through interractions, the event gets updated here.
     * Notes: mutableEvents couldn't be a computed variable based on this.events, because we add
     *        items to the array. (Cannot mutate props)
     */
    updateMutableEvents: function updateMutableEvents() {
      var _this4 = this;

      this.mutableEvents = []; // For each event of the `events` prop, prepare the event for vue-cal:
      // Populate missing keys: start, startDate, startTimeMinutes, end, endDate, endTimeMinutes, daysCount.
      // Lots of these variables may look redundant but are here for performance as a cached result of calculation. :)

      this.events.forEach(function (event) {
        // `event.start` accepts a formatted string - `event.startDate` accepts a Date object.
        var startDate, startDateF, startTime, hoursStart, minutesStart;

        if (event.start) {
          var _event$start$split, _event$start$split2, _event$start$split2$, _startTime$split, _startTime$split2;

          // eslint-disable-next-line
          !(_event$start$split = event.start.split(' '), _event$start$split2 = _slicedToArray(_event$start$split, 2), startDateF = _event$start$split2[0], _event$start$split2$ = _event$start$split2[1], startTime = _event$start$split2$ === void 0 ? '' : _event$start$split2$, _event$start$split); // eslint-disable-next-line

          !(_startTime$split = startTime.split(':'), _startTime$split2 = _slicedToArray(_startTime$split, 2), hoursStart = _startTime$split2[0], minutesStart = _startTime$split2[1], _startTime$split);
          startDate = stringToDate(event.start);
        } else if (event.startDate && event.startDate instanceof Date) {
          startDateF = formatDateLite(event.startDate);
          hoursStart = event.startDate.getHours();
          minutesStart = event.startDate.getMinutes();
          startDate = event.startDate;
        }

        var startTimeMinutes = parseInt(hoursStart) * 60 + parseInt(minutesStart);

        var start = event.start || startDateF + ' ' + date_utils_formatTime(startTimeMinutes); // `event.end` accepts a formatted string - `event.endDate` accepts a Date object.


        var endDate, endDateF, endTime, hoursEnd, minutesEnd;

        if (event.end) {
          var _event$end$split, _event$end$split2, _event$end$split2$, _endTime$split, _endTime$split2;

          // eslint-disable-next-line
          !(_event$end$split = event.end.split(' '), _event$end$split2 = _slicedToArray(_event$end$split, 2), endDateF = _event$end$split2[0], _event$end$split2$ = _event$end$split2[1], endTime = _event$end$split2$ === void 0 ? '' : _event$end$split2$, _event$end$split); // eslint-disable-next-line

          !(_endTime$split = endTime.split(':'), _endTime$split2 = _slicedToArray(_endTime$split, 2), hoursEnd = _endTime$split2[0], minutesEnd = _endTime$split2[1], _endTime$split);
          endDate = stringToDate(event.end);
        } else if (event.endDate && event.endDate instanceof Date) {
          endDateF = formatDateLite(event.endDate);
          hoursEnd = event.endDate.getHours();
          minutesEnd = event.endDate.getMinutes();
          endDate = event.endDate;
        }

        var endTimeMinutes = parseInt(hoursEnd) * 60 + parseInt(minutesEnd);

        var end = event.end || endDateF + ' ' + date_utils_formatTime(endTimeMinutes); // Correct the common practice to end at 00:00 or 24:00 to count a full day.


        if (!endTimeMinutes || endTimeMinutes === vue_calvue_type_script_lang_js_minutesInADay) {
          endDate.setSeconds(-1); // End at 23:59:59.

          endDateF = formatDateLite(endDate);
          endTimeMinutes = vue_calvue_type_script_lang_js_minutesInADay;
        }

        var multipleDays = startDateF !== endDateF;
        event = Object.assign(_objectSpread2({}, eventDefaults, {
          // Keep the event ids scoped to this calendar instance.
          _eid: "".concat(_this4._uid, "_").concat(_this4.eventIdIncrement++),
          segments: multipleDays ? {} : null,
          start: start,
          startDate: startDate,
          startTimeMinutes: startTimeMinutes,
          end: end,
          endDate: endDate,
          endTimeMinutes: endTimeMinutes,
          daysCount: multipleDays ? countDays(startDate, endDate) : 1,
          classes: (event.class || '').split(' ')
        }), event);

        _this4.mutableEvents.push(event);
      });
    },

    /**
     * Get the coordinates of the mouse cursor from the cells wrapper referential (`ref="cells"`).
     *
     * @todo Cache bounding box & update it on resize.
     * @param {Object} e the native DOM event object.
     * @return {Object} containing { x: {Number}, y: {Number} }
     */
    getPosition: function getPosition(e) {
      var rect = this.$refs.cells.getBoundingClientRect();

      var _ref = 'ontouchstart' in window && e.touches ? e.touches[0] : e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;

      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    },

    /**
     * Get the number of minutes from the top to the mouse cursor.
     *
     * @param {Object} e the native DOM event object.
     * @return {Object} containing { minutes: {Number}, cursorCoords: { x: {Number}, y: {Number} } }
     */
    minutesAtCursor: function minutesAtCursor(e) {
      var minutes = 0;
      var cursorCoords = {};
      if (typeof e === 'number') minutes = e;else if (_typeof(e) === 'object') {
        cursorCoords = this.getPosition(e);
        minutes = Math.round(cursorCoords.y * this.timeStep / parseInt(this.timeCellHeight) + this.timeFrom);
      }
      return {
        minutes: minutes,
        cursorCoords: cursorCoords
      };
    },

    /**
     * Creates a new event in vue-cal memory (in the mutableEvents array) starting at the given date & time.
     * Proxy method to allow call from cell click & hold or external call (via $refs).
     * Notes: Event duration is by default 2 hours. You can override the event end through eventOptions.
     *
     * @param {String | Date} dateTime date & time at which the event will start.
     * @param {Object} eventOptions an object of options to override the event creation defaults.
     *                              (can be any key allowed in an event object)
     * @return {Object} the created event.
     */
    createEvent: function createEvent(dateTime) {
      var eventOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return event_utils_createAnEvent(dateTime, eventOptions, this);
    },

    /**
     * Remove all the vue-cal private vars from the event (before returning it through $emit()).
     *
     * @param {Object} event the event object to cleanup.
     */
    cleanupEvent: function cleanupEvent(event) {
      event = _objectSpread2({}, event); // Delete vue-cal specific props instead of returning a set of props so user
      // can place whatever they want inside an event and see it returned.

      var discardProps = ['height', 'top', 'classes', 'segments', 'deletable', 'deleting', 'resizable', 'resizing', 'draggable', 'dragging', 'draggingStatic', 'focused'];
      discardProps.forEach(function (prop) {
        if (prop in event) delete event[prop];
      });
      if (!event.repeat) delete event.repeat; // If empty we don't need it.

      return event;
    },

    /**
     * Emits an event (custom DOM event) to the outside world.
     * This event has an event name and a clean calendar event as a parameter.
     *
     * @param {String} eventName the name of the custom emitted event (e.g. `event-focus`).
     * @param {Object} event the event to return to the outside world.
     */
    emitWithEvent: function emitWithEvent(eventName, event) {
      this.$emit(eventName, this.cleanupEvent(event));
    },

    /**
     * Update the selected date:
     * - on created, from given selectedDate prop
     * - on click/dblClick of another cell
     * - from external call (via $refs)
     * - when the given selectedDate prop changes.
     * If date is not in the view, the view will change to show it.
     *
     * @param {String | Date} date The date to select.
     */
    updateSelectedDate: function updateSelectedDate(date) {
      if (date && typeof date === 'string') date = stringToDate(date);else date = new Date(date); // Clone to keep original untouched.

      if (date && date instanceof Date) {
        var selectedDate = this.view.selectedDate;
        if (selectedDate) this.transitionDirection = selectedDate.getTime() > date.getTime() ? 'left' : 'right'; // Select the day at midnight in order to allow fetching events on whole day.
        // Setting milliseconds to 0 is critical as well for timestamp comparison.

        date.setHours(0, 0, 0, 0);
        if (!selectedDate || selectedDate.getTime() !== date.getTime()) this.view.selectedDate = date;
        this.switchView(this.view.id);
      }
    },

    /**
     * Formats a date and returns the formatted string.
     * Shorthand function, to avoid passing the localized texts everywhere.
     *
     * @param {String | Date} date the date to format - can contain the time info or not.
     * @param {String} format the wanted format.
     * @return {String} the formatted date.
     */
    formatDate: function formatDate(date) {
      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'YYYY-MM-DD';
      return date_utils_formatDate(date, format, this.texts);
    },

    /**
     * Formats a time and returns the formatted string.
     * Shorthand function, to avoid passing the common format.
     *
     * @param {Number} time the time to format in minutes.
     * @param {String} format the wanted format.
     * @return {String} the formatted time.
     */
    formatTime: function formatTime(time, format) {
      return date_utils_formatTime(time, format || this.timeFormat || (this.twelveHour ? 'h:mm{am}' : 'HH:mm'), this.texts);
    },

    /**
     * Double checks the week number is correct. Read bellow to understand!
     * this is a wrapper around the `getWeek()` function for performance:
     * As this is called multiple times from the template and cannot be in computed since there is
     * a parameter, this wrapper function avoids the `getWeek()` function call 5 times out of 6
     * using the computed `firstCellDateWeekNumber`.
     *
     * Reason why:
     * Getting the week number is not that straightforward as there might be a 53rd week in the year.
     * Whenever the year starts on a Thursday or any leap year starting on a Wednesday, this week will be 53.
     *
     * @param {Number} weekFromFirstCell Number from 0 to 6.
     */
    getWeekNumber: function getWeekNumber(weekFromFirstCell) {
      var firstCellWeekNumber = this.firstCellDateWeekNumber;
      var currentWeekNumber = firstCellWeekNumber + weekFromFirstCell;
      var modifier = this.startWeekOnSunday ? 1 : 0;

      if (currentWeekNumber > 52) {
        return this.view.firstCellDate.addDays(7 * weekFromFirstCell + modifier).getWeek();
      } else return currentWeekNumber;
    },

    /**
     * Only if watchRealTime is true.
     * Pull the current time from user machine every minute to keep vue-cal accurate even when idle.
     * This will redraw the now line every minute and ensure that Today's date is always accurate.
     */
    timeTick: function timeTick() {
      // Updating `now` will re-trigger the computed `todaysTimePosition` in cell.vue.
      this.now = new Date();
      this.timeTickerIds[1] = setTimeout(this.timeTick, 60 * 1000); // Every minute.
    },

    /**
     * Callable from outside of Vue Cal.
     */
    updateDateTexts: function updateDateTexts() {
      date_utils_updateDateTexts(this.texts);
    },

    /**
     * On Windows devices, the .vuecal__bg's vertical scrollbar takes space and pushes the content.
     * This function will also push the all-day bar to have it properly aligned.
     * The calculated style will be placed in the docment head in a style tag so it's only done once
     * (the scrollbar width never changes).
     * Ref. https://github.com/antoniandre/vue-cal/issues/221
     */
    alignAllDayBar: function alignAllDayBar() {
      // If already done from another instance, exit.
      if (document.getElementById('align-all-day-bar')) return;
      var bg = this.$refs.vuecal.getElementsByClassName('vuecal__bg')[0];
      var scrollbarWidth = bg.offsetWidth - bg.children[0].offsetWidth; // Only add a style tag once and if a scrollbar width is detected.

      if (scrollbarWidth) {
        var style = document.createElement('style');
        style.id = 'align-all-day-bar';
        style.type = 'text/css';
        style.innerHTML = ".vuecal__all-day {padding-right: ".concat(scrollbarWidth, "px}");
        document.head.appendChild(style);
      }
    }
  },
  created: function created() {
    this.loadLocale(this.locale);

    date_utils_updateDateTexts(this.texts); // Init the array of events, then keep listening for changes in watcher.


    this.updateMutableEvents(this.events);
    this.view.id = this.defaultView;
    if (this.selectedDate) this.updateSelectedDate(this.selectedDate);else {
      this.view.selectedDate = new Date();
      this.switchView(this.defaultView);
    } // Timers are expensive, this should only trigger on demand.

    if (this.time && this.watchRealTime) {
      // Snap the time ticker on sharp minutes (when seconds = 0), so that we can set
      // the time ticker interval to 60 seconds and spare some function calls.
      this.timeTickerIds[0] = setTimeout(this.timeTick, (60 - this.now.getSeconds()) * 1000);
    }
  },
  mounted: function mounted() {
    var hasTouch = 'ontouchstart' in window;

    if (this.editableEvents) {
      window.addEventListener(hasTouch ? 'touchmove' : 'mousemove', this.onMouseMove, {
        passive: false
      });
      window.addEventListener(hasTouch ? 'touchend' : 'mouseup', this.onMouseUp);
      window.addEventListener('keyup', this.onKeyUp);
    } // Disable context menu on touch devices on the whole vue-cal instance.


    if (hasTouch) {
      this.$refs.vuecal.oncontextmenu = function (e) {
        e.preventDefault();
        e.stopPropagation();
      };
    } // https://github.com/antoniandre/vue-cal/issues/221


    if (this.showAllDayEvents) this.alignAllDayBar(); // Emit the `ready` event with useful parameters.

    var startDate = this.view.startDate;

    var params = _objectSpread2({
      view: this.view.id,
      startDate: startDate,
      endDate: this.view.endDate
    }, this.view.id === 'month' ? {
      firstCellDate: this.view.firstCellDate,
      lastCellDate: this.view.lastCellDate
    } : {}, {
      events: this.view.events.map(this.cleanupEvent)
    }, this.view.id === 'week' ? {
      week: this.startWeekOnSunday ? startDate.addDays(1).getWeek() : startDate.getWeek()
    } : {});

    this.$emit('ready', params);
    this.ready = true;
  },
  beforeDestroy: function beforeDestroy() {
    var hasTouch = 'ontouchstart' in window;
    window.removeEventListener(hasTouch ? 'touchmove' : 'mousemove', this.onMouseMove, {
      passive: false
    });
    window.removeEventListener(hasTouch ? 'touchend' : 'mouseup', this.onMouseUp);
    window.removeEventListener('keyup', this.onKeyUp); // Don't keep the ticking running if unused.

    if (this.timeTickerIds[0]) clearTimeout(this.timeTickerIds[0]);
    if (this.timeTickerIds[1]) clearTimeout(this.timeTickerIds[1]);
    this.timeTickerIds = [null, null];
  },
  computed: {
    views: function views() {
      return {
        years: {
          label: this.texts.years,
          enabled: !this.disableViews.includes('years')
        },
        year: {
          label: this.texts.year,
          enabled: !this.disableViews.includes('year')
        },
        month: {
          label: this.texts.month,
          enabled: !this.disableViews.includes('month')
        },
        week: {
          label: this.texts.week,
          enabled: !this.disableViews.includes('week')
        },
        day: {
          label: this.texts.day,
          enabled: !this.disableViews.includes('day')
        }
      };
    },
    hasTimeColumn: function hasTimeColumn() {
      return this.time && ['week', 'day'].includes(this.view.id);
    },
    isShortMonthView: function isShortMonthView() {
      return this.view.id === 'month' && this.eventsOnMonthView === 'short';
    },
    firstCellDateWeekNumber: function firstCellDateWeekNumber() {
      var date = this.view.firstCellDate;
      return this.startWeekOnSunday ? date.addDays(1).getWeek() : date.getWeek();
    },
    // For week & day views.
    timeCells: function timeCells() {
      var timeCells = [];

      for (var i = this.timeFrom, max = this.timeTo; i < max; i += this.timeStep) {
        timeCells.push({
          hours: Math.floor(i / 60),
          minutes: i % 60,
          label: this.formatTime(i),
          value: i
        });
      }

      return timeCells;
    },
    // Filter out the day splits that are hidden.
    daySplits: function daySplits() {
      return (this.splitDays.filter(function (item) {
        return !item.hide;
      }) || []).map(function (item, i) {
        return _objectSpread2({}, item, {
          id: item.id || i + 1
        });
      }) // Make sure there's always an id.
      ;
    },
    // Whether the current view has days splits.
    hasSplits: function hasSplits() {
      return this.daySplits.length && ['week', 'day'].includes(this.view.id);
    },
    contentMinWidth: function contentMinWidth() {
      var minWidth = null;
      if (this.hasSplits && this.minSplitWidth) minWidth = this.visibleDaysCount * this.minSplitWidth * this.daySplits.length;else if (this.minCellWidth && this.view.id === 'week') minWidth = this.visibleDaysCount * this.minCellWidth;
      return minWidth;
    },
    minTimestamp: function minTimestamp() {
      var date = null;
      if (this.minDate && typeof this.minDate === 'string') date = stringToDate(this.minDate);else if (this.minDate && this.minDate instanceof Date) date = this.minDate;
      return date ? date.getTime() : null;
    },
    maxTimestamp: function maxTimestamp() {
      var date = null;
      if (this.maxDate && typeof this.maxDate === 'string') date = stringToDate(this.maxDate);else if (this.maxDate && this.minDate instanceof Date) date = this.maxDate;
      return date ? date.getTime() : null;
    },
    weekDays: function weekDays() {
      var _this5 = this;

      var _this$texts = this.texts,
          weekDays = _this$texts.weekDays,
          _this$texts$weekDaysS = _this$texts.weekDaysShort,
          weekDaysShort = _this$texts$weekDaysS === void 0 ? [] : _this$texts$weekDaysS; // Do not modify original for next instances.

      weekDays = weekDays.slice(0).map(function (day, i) {
        return _objectSpread2({
          label: day
        }, weekDaysShort.length ? {
          short: weekDaysShort[i]
        } : {}, {
          hide: _this5.hideWeekends && i >= 5 || _this5.hideWeekdays.length && _this5.hideWeekdays.includes(i + 1)
        });
      });
      if (this.startWeekOnSunday) weekDays.unshift(weekDays.pop());
      return weekDays;
    },
    weekDaysInHeader: function weekDaysInHeader() {
      return this.view.id === 'month' || this.view.id === 'week' && !this.minCellWidth && !this.minSplitWidth;
    },
    months: function months() {
      return this.texts.months.map(function (month) {
        return {
          label: month
        };
      });
    },
    // Prepare the special hours object once for all at root level and not in cell.
    specialDayHours: function specialDayHours() {
      var _this6 = this;

      return Array(7).fill('').map(function (cell, i) {
        var _ref2 = _this6.specialHours[i + 1] || {},
            from = _ref2.from,
            to = _ref2.to,
            Class = _ref2.class;

        return {
          day: i + 1,
          from: ![null, undefined].includes(from) ? from * 1 : null,
          to: ![null, undefined].includes(to) ? to * 1 : null,
          class: Class || ''
        };
      });
    },
    viewTitle: function viewTitle() {
      var title = '';
      var date = this.view.startDate;
      var year = date.getFullYear();
      var month = date.getMonth();

      switch (this.view.id) {
        case 'years':
          {
            title = this.texts.years;
            break;
          }

        case 'year':
          {
            title = year;
            break;
          }

        case 'month':
          {
            title = "".concat(this.months[month].label, " ").concat(year);
            break;
          }

        case 'week':
          {
            var lastDayOfWeek = this.view.endDate; // Might be another day than Sunday, if hiding days.

            var y1 = date.getFullYear();
            var m1 = this.texts.months[date.getMonth()];
            if (this.xsmall) m1 = m1.substring(0, 3);
            var formattedMonthYear = "".concat(m1, " ").concat(y1); // If week is not ending in the same month it started in.

            if (lastDayOfWeek.getMonth() !== date.getMonth()) {
              var y2 = lastDayOfWeek.getFullYear();
              var m2 = this.texts.months[lastDayOfWeek.getMonth()];
              if (this.xsmall) m2 = m2.substring(0, 3);
              if (y1 === y2) formattedMonthYear = "".concat(m1, " - ").concat(m2, " ").concat(y1);else {
                if (this.small) formattedMonthYear = "".concat(m1.substring(0, 3), " ").concat(y1, " - ").concat(m2.substring(0, 3), " ").concat(y2);else formattedMonthYear = "".concat(m1, " ").concat(y1, " - ").concat(m2, " ").concat(y2);
              }
            }

            title = "".concat(this.texts.week, " ").concat(this.startWeekOnSunday ? date.addDays(1).getWeek() : date.getWeek(), " (").concat(formattedMonthYear, ")");
            break;
          }

        case 'day':
          {
            title = this.formatDate(date, this.texts.dateFormat);
            break;
          }
      }

      return title;
    },
    viewCells: function viewCells() {
      var _this7 = this;

      var cells = [];
      var fromYear = null;
      var todayFound = false; // If watchRealTime = true, a time ticker will keep updating this.now every minute.
      // If watchRealTime = false - and by default - update this.now value each time we rerender the cells
      // so we keep Today's date always accurate at a minimum cost and maximum performance.
      // eslint-disable-next-line

      if (!this.watchRealTime) this.now = new Date();
      var now = this.now;

      switch (this.view.id) {
        case 'years':
          {
            fromYear = this.view.startDate.getFullYear();
            cells = Array.apply(null, Array(25)).map(function (cell, i) {
              var startDate = new Date(fromYear + i, 0, 1);
              var endDate = new Date(fromYear + i + 1, 0, 1);
              endDate.setSeconds(-1); // End at 23:59:59.

              return {
                startDate: startDate,
                formattedDate: formatDateLite(startDate),
                endDate: endDate,
                content: fromYear + i,
                current: fromYear + i === now.getFullYear()
              };
            });
            break;
          }

        case 'year':
          {
            fromYear = this.view.startDate.getFullYear();
            cells = Array.apply(null, Array(12)).map(function (cell, i) {
              var startDate = new Date(fromYear, i, 1);
              var endDate = new Date(fromYear, i + 1, 1);
              endDate.setSeconds(-1); // End at 23:59:59.

              return {
                startDate: startDate,
                formattedDate: formatDateLite(startDate),
                endDate: endDate,
                content: _this7.xsmall ? _this7.months[i].label.substr(0, 3) : _this7.months[i].label,
                current: i === now.getMonth() && fromYear === now.getFullYear()
              };
            });
            break;
          }

        case 'month':
          {
            var month = this.view.startDate.getMonth();
            var firstCellDate = new Date(this.view.firstCellDate);
            todayFound = false; // Create 42 cells (6 rows x 7 days) and populate them with days.

            cells = Array.apply(null, Array(42)).map(function (cell, i) {
              var startDate = firstCellDate.addDays(i);
              var endDate = new Date(startDate);
              endDate.setHours(23, 59, 59, 0); // End at 23:59:59.
              // To increase performance skip checking isToday if today already found.

              var isToday = !todayFound && startDate.isToday() && !todayFound++;
              return {
                startDate: startDate,
                formattedDate: formatDateLite(startDate),
                endDate: endDate,
                content: startDate.getDate(),
                today: isToday,
                outOfScope: startDate.getMonth() !== month
              };
            });

            if (this.hideWeekends || this.hideWeekdays.length) {
              cells = cells.filter(function (cell) {
                var day = cell.startDate.getDay();
                if (!day) day = 7; // Put Sunday at position 7 instead of 0.

                return !(_this7.hideWeekends && day >= 6 || _this7.hideWeekdays.length && _this7.hideWeekdays.includes(day));
              });
            }

            break;
          }

        case 'week':
          {
            todayFound = false;
            var firstDayOfWeek = this.view.startDate;
            var weekDays = this.weekDays;
            cells = weekDays.map(function (cell, i) {
              var startDate = firstDayOfWeek.addDays(i);
              var endDate = new Date(startDate);
              endDate.setHours(23, 59, 59, 0); // End at 23:59:59.

              var dayOfWeek = (startDate.getDay() - 1 + 7) % 7; // Day of the week from 0 to 6 with 6 = Sunday.

              return {
                startDate: startDate,
                formattedDate: formatDateLite(startDate),
                endDate: endDate,
                // To increase performance skip checking isToday if today already found.
                today: !todayFound && startDate.isToday() && !todayFound++,
                specialHours: _this7.specialDayHours[dayOfWeek]
              };
            }).filter(function (cell, i) {
              return !weekDays[i].hide;
            });
            break;
          }

        case 'day':
          {
            var startDate = this.view.startDate;
            var endDate = new Date(this.view.startDate);
            endDate.setHours(23, 59, 59, 0); // End at 23:59:59.

            var dayOfWeek = (startDate.getDay() - 1 + 7) % 7; // Day of the week from 0 to 6 with 6 = Sunday.

            cells = [{
              startDate: startDate,
              formattedDate: formatDateLite(startDate),
              endDate: endDate,
              today: startDate.isToday(),
              specialHours: this.specialDayHours[dayOfWeek]
            }];
            break;
          }
      }

      return cells;
    },
    // Only when hiding weekdays on month and week views.
    visibleDaysCount: function visibleDaysCount() {
      if (this.view.id === 'day') return 1;
      return 7 - this.weekDays.reduce(function (total, day) {
        return total + day.hide;
      }, 0);
    },
    cellWidth: function cellWidth() {
      return 100 / this.visibleDaysCount;
    },
    cssClasses: function cssClasses() {
      var _ref3;

      return _ref3 = {}, _defineProperty(_ref3, "vuecal--".concat(this.view.id, "-view"), true), _defineProperty(_ref3, "vuecal--".concat(this.locale), this.locale), _defineProperty(_ref3, 'vuecal--no-time', !this.time), _defineProperty(_ref3, 'vuecal--view-with-time', this.hasTimeColumn), _defineProperty(_ref3, 'vuecal--week-numbers', this.showWeekNumbers && this.view.id === 'month'), _defineProperty(_ref3, 'vuecal--twelve-hour', this.twelveHour), _defineProperty(_ref3, 'vuecal--click-to-navigate', this.clickToNavigate), _defineProperty(_ref3, 'vuecal--hide-weekends', this.hideWeekends), _defineProperty(_ref3, 'vuecal--split-days', this.hasSplits), _defineProperty(_ref3, 'vuecal--sticky-split-labels', this.hasSplits && this.stickySplitLabels), _defineProperty(_ref3, 'vuecal--overflow-x', this.minCellWidth && this.view.id === 'week' || this.hasSplits && this.minSplitWidth), _defineProperty(_ref3, 'vuecal--small', this.small), _defineProperty(_ref3, 'vuecal--xsmall', this.xsmall), _defineProperty(_ref3, 'vuecal--resizing-event', this.domEvents.resizeAnEvent.endTimeMinutes), _defineProperty(_ref3, 'vuecal--dragging-event', this.domEvents.dragAnEvent._eid), _defineProperty(_ref3, 'vuecal--events-on-month-view', this.eventsOnMonthView), _defineProperty(_ref3, 'vuecal--short-events', this.view.id === 'month' && this.eventsOnMonthView === 'short'), _ref3;
    }
  },
  watch: {
    events: {
      // To be able to detect an event attribute change, it has to be first initialized with a value.
      handler: function handler(events, oldEvents) {
        this.updateMutableEvents(events);
        this.addEventsToView();
      },
      deep: true
    },
    locale: function locale(_locale) {
      this.loadLocale(_locale);
    },
    selectedDate: function selectedDate(date) {
      this.updateSelectedDate(date);
    }
  }
});
// CONCATENATED MODULE: ./src/components/vue-cal/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_vue_calvue_type_script_lang_js_ = (vue_calvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./src/components/vue-cal/index.vue





/* normalize component */

var vue_cal_component = normalizeComponent(
  components_vue_calvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var vue_cal = (vue_cal_component.exports);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (vue_cal);



/***/ }),

/***/ "fb6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");
var toIndexedObject = __webpack_require__("fc6a");
var createProperty = __webpack_require__("8418");
var wellKnownSymbol = __webpack_require__("b622");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__("4930");

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "fea9":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global.Promise;


/***/ })

/******/ })["default"];

/***/ }),

/***/ "./node_modules/vue-cal/dist/vuecal.css":
/*!**********************************************!*\
  !*** ./node_modules/vue-cal/dist/vuecal.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js??ref--7-oneOf-3-1!../../postcss-loader/src??ref--7-oneOf-3-2!./vuecal.css */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/src/index.js?!./node_modules/vue-cal/dist/vuecal.css");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("1f4afb3e", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--9-oneOf-1-0!./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss& ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib??vue-loader-options!./calendarYear.vue?vue&type=style&index=0&lang=scss& */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("6661b682", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--9-oneOf-1-0!./node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--9-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("0df7abee", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./src/api/air.js":
/*!************************!*\
  !*** ./src/api/air.js ***!
  \************************/
/*! exports provided: getAllYearCalender, queryAirCalender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllYearCalender", function() { return getAllYearCalender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAirCalender", function() { return queryAirCalender; });
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./src/api/request.js");

/**
 * 获取全年日历数据
 */

function getAllYearCalender(_ref) {
  var type = _ref.type,
      id = _ref.id,
      yzName = _ref.yzName,
      year = _ref.year;
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: 'http://116.52.6.118:18899/KQZLYZW/home/getYearRL',
    method: 'GET',
    params: {
      type: type,
      id: id,
      yzName: yzName || 'AQI',
      year: year
    }
  });
}
/**
 * 空气日历
 */

function queryAirCalender(_ref2) {
  var id = _ref2.id,
      time = _ref2.time,
      yzName = _ref2.yzName;
  return Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])({
    url: 'http://116.52.6.118:18899/KQZLYZW/home/getKQRL',
    method: 'GET',
    params: {
      id: id,
      time: time,
      yzName: yzName
    }
  });
}

/***/ }),

/***/ "./src/components/calendar/calendarYear.vue":
/*!**************************************************!*\
  !*** ./src/components/calendar/calendarYear.vue ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calendarYear.vue?vue&type=template&id=04b409ec& */ "./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec&");
/* harmony import */ var _calendarYear_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calendarYear.vue?vue&type=script&lang=js& */ "./src/components/calendar/calendarYear.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calendarYear.vue?vue&type=style&index=0&lang=scss& */ "./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _calendarYear_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__["render"],
  _calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/calendar/calendarYear.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/components/calendar/calendarYear.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./src/components/calendar/calendarYear.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/babel-loader/lib!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib??vue-loader-options!./calendarYear.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&":
/*!************************************************************************************!*\
  !*** ./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss& ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader??ref--9-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib??vue-loader-options!./calendarYear.vue?vue&type=style&index=0&lang=scss& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=style&index=0&lang=scss&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),

/***/ "./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec&":
/*!*********************************************************************************!*\
  !*** ./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec& ***!
  \*********************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib??vue-loader-options!./calendarYear.vue?vue&type=template&id=04b409ec& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/calendar/calendarYear.vue?vue&type=template&id=04b409ec&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_calendarYear_vue_vue_type_template_id_04b409ec___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/views/airHomePage/airCalendarDetail/index.vue":
/*!***********************************************************!*\
  !*** ./src/views/airHomePage/airCalendarDetail/index.vue ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=2964f21b&scoped=true& */ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true&");
/* harmony import */ var _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js& */ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& */ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "2964f21b",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/views/airHomePage/airCalendarDetail/index.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js&":
/*!************************************************************************************!*\
  !*** ./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js& ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../../node_modules/babel-loader/lib!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_13_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&":
/*!*********************************************************************************************************************!*\
  !*** ./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-style-loader??ref--9-oneOf-1-0!../../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/src??ref--9-oneOf-1-2!../../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=style&index=0&id=2964f21b&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_9_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_9_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_9_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_9_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_2964f21b_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),

/***/ "./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true&":
/*!******************************************************************************************************!*\
  !*** ./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true& ***!
  \******************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"4bae0482-vue-loader-template"}!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../../node_modules/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=2964f21b&scoped=true& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"4bae0482-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/views/airHomePage/airCalendarDetail/index.vue?vue&type=template&id=2964f21b&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_cache_loader_dist_cjs_js_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_4bae0482_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2964f21b_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvY2FsZW5kYXIvY2FsZW5kYXJZZWFyLnZ1ZSIsIndlYnBhY2s6Ly8vc3JjL3ZpZXdzL2FpckhvbWVQYWdlL2FpckNhbGVuZGFyRGV0YWlsL2luZGV4LnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jYWxlbmRhci9jYWxlbmRhclllYXIudnVlPzBhMDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2FpckhvbWVQYWdlL2FpckNhbGVuZGFyRGV0YWlsL2luZGV4LnZ1ZT9hYWFiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1jYWwvZGlzdC92dWVjYWwuY3NzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NhbGVuZGFyL2NhbGVuZGFyWWVhci52dWU/NWIxMiIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWlySG9tZVBhZ2UvYWlyQ2FsZW5kYXJEZXRhaWwvaW5kZXgudnVlP2Y1MGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1jYWwvZGlzdC92dWVjYWwuY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtY2FsL2Rpc3QvdnVlY2FsLmNzcz8zNDU4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NhbGVuZGFyL2NhbGVuZGFyWWVhci52dWU/YWM0MyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWlySG9tZVBhZ2UvYWlyQ2FsZW5kYXJEZXRhaWwvaW5kZXgudnVlPzk2NWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9haXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2FsZW5kYXIvY2FsZW5kYXJZZWFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9jYWxlbmRhci9jYWxlbmRhclllYXIudnVlPzRhYWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvY2FsZW5kYXIvY2FsZW5kYXJZZWFyLnZ1ZT85NzE2Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2NhbGVuZGFyL2NhbGVuZGFyWWVhci52dWU/ODhiZiIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWlySG9tZVBhZ2UvYWlyQ2FsZW5kYXJEZXRhaWwvaW5kZXgudnVlIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9haXJIb21lUGFnZS9haXJDYWxlbmRhckRldGFpbC9pbmRleC52dWU/MzRlOCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYWlySG9tZVBhZ2UvYWlyQ2FsZW5kYXJEZXRhaWwvaW5kZXgudnVlP2VjZDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2FpckhvbWVQYWdlL2FpckNhbGVuZGFyRGV0YWlsL2luZGV4LnZ1ZT9lNDI2Il0sIm5hbWVzIjpbImdldEFsbFllYXJDYWxlbmRlciIsInR5cGUiLCJpZCIsInl6TmFtZSIsInllYXIiLCJyZXF1ZXN0IiwidXJsIiwibWV0aG9kIiwicGFyYW1zIiwicXVlcnlBaXJDYWxlbmRlciIsInRpbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0Esc0JBREE7QUFFQTtBQUFBO0FBQUEsR0FGQTtBQUdBO0FBQ0E7QUFDQSxpQkFEQTtBQUVBO0FBQUE7QUFBQTtBQUZBLEtB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQyxLQUFLO0FBQ0w7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQztBQUNuQztBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFVBQVU7QUFDVixDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDhEQUE4RDtBQUNqRTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQixvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEc7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7O0FBRWI7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTyxLQUFLO0FBQ1osS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3RztBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJmaWxlIjoianMvNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XHJcblx0PGRpdiBjbGFzcz1cImNhbC13cmFwcGVyXCI+XHJcblx0XHQ8ZGl2IGNsYXNzPVwiY2FsLXRpdGxlXCI+e3tkYXlqcyhzdGFydERhdGUpLmZvcm1hdCgnWVlZWS1NTScpfX08L2Rpdj5cclxuXHRcdDx2dWUtY2FsXHJcblx0XHRcdFx0bG9jYWxlPVwiemgtY25cIlxyXG5cdFx0XHRcdDpzZWxlY3RlZC1kYXRlPVwiZGF5anMoc3RhcnREYXRlKS5mb3JtYXQoJ1lZWVktTU0nKyctMDEnKVwiXHJcblx0XHRcdFx0aGlkZS12aWV3LXNlbGVjdG9yXHJcblx0XHRcdFx0aGlkZVRpdGxlQmFyXHJcblx0XHRcdFx0ZGVmYXVsdC12aWV3PVwibW9udGhcIj5cclxuXHRcdFx0PHRlbXBsYXRlIHYtc2xvdDpjZWxsLWNvbnRlbnQ9XCJ7IGNlbGwsIHZpZXcsIGV2ZW50cywgZ29OYXJyb3dlciB9XCI+XHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImNhbGVuZGFyLWNlbGxcIiA6c3R5bGU9XCJnZXRDYWxlbmRhckJnKGNlbGwpXCI+XHJcblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImRheVwiPnt7IGNlbGwuc3RhcnREYXRlLmdldERhdGUoKSB9fTwvc3Bhbj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC90ZW1wbGF0ZT5cclxuXHRcdDwvdnVlLWNhbD5cclxuXHQ8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFZ1ZUNhbCBmcm9tICd2dWUtY2FsJ1xyXG5cdGltcG9ydCAndnVlLWNhbC9kaXN0L3Z1ZWNhbC5jc3MnXHJcblx0aW1wb3J0IHtnZXRDYWxlbmRlckJnQ29sb3J9IGZyb20gJ0AvdXRpbHMvYWlyVXRpbHMuanMnXHJcblx0aW1wb3J0IGRheWpzIGZyb20gJ2RheWpzJ1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRuYW1lOiBcImNhbGVuZGFyWWVhclwiLFxyXG5cdFx0Y29tcG9uZW50czoge1Z1ZUNhbH0sXHJcblx0XHRwcm9wczoge1xyXG5cdFx0XHRhcnJheToge1xyXG5cdFx0XHRcdHR5cGU6IEFycmF5LFxyXG5cdFx0XHRcdGRlZmF1bHQ6ICgpID0+IFtdXHJcblx0XHRcdH0sXHJcblx0XHRcdHN0YXJ0RGF0ZToge1xyXG5cdFx0XHRcdHR5cGU6IERhdGUsXHJcblx0XHRcdFx0ZGVmYXVsdDogKCkgPT4gbmV3IERhdGUoKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmYWN0b3I6IHtcclxuXHRcdFx0XHR0eXBlOiBTdHJpbmdcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7fVxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0Z2V0RGF0YShjZWxsKSB7XHJcblx0XHRcdFx0bGV0IGRheURhdGEgPSB7fTtcclxuXHRcdFx0XHR0aGlzLmFycmF5LmZvckVhY2goKGl0ZW0pID0+IHtcclxuXHRcdFx0XHRcdGlmIChpdGVtLmRhdGVUaW1lID09PSBjZWxsLmZvcm1hdHRlZERhdGUpIHtcclxuXHRcdFx0XHRcdFx0ZGF5RGF0YSA9IHtcclxuXHRcdFx0XHRcdFx0XHRkYXRlOiBjZWxsLmNvbnRlbnQsXHJcblx0XHRcdFx0XHRcdFx0YXFpOiBpdGVtW3RoaXMuZmFjdG9yXSxcclxuXHRcdFx0XHRcdFx0XHRwcmltYXJ5OiBpdGVtLnBvbGx1dGFudFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuIGRheURhdGFcclxuXHRcdFx0fSxcclxuXHRcdFx0Z2V0Q2FsZW5kYXJCZyhjZWxsKSB7XHJcblx0XHRcdFx0bGV0IGNvbG9yID0gZ2V0Q2FsZW5kZXJCZ0NvbG9yKHRoaXMuZmFjdG9yLCB0aGlzLmdldERhdGEoY2VsbCkuYXFpKTtcclxuXHRcdFx0XHRyZXR1cm4gY29sb3JcclxuXHRcdFx0fSxcclxuXHRcdH1cclxuXHR9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XHJcblxyXG5cdC52dWVjYWxfX2NlbGw6YmVmb3JlIHtcclxuXHRcdGJvcmRlcjogMDtcclxuXHR9XHJcblxyXG5cdC52dWVjYWxfX2ZsZXgge1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuXHR9XHJcblxyXG5cdC52dWVjYWwge1xyXG5cdFx0bWFyZ2luOiA1cHggMDtcclxuXHRcdHBhZGRpbmc6IDVweCA4cHg7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMTBweDtcclxuXHR9XHJcblxyXG5cdC5jYWwtd3JhcHBlciB7XHJcblx0XHRtYXJnaW46IDJweCA1cHg7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0XHR3aWR0aDogY2FsYyg0OHZ3IC0gNHB4KTtcclxuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG5cclxuXHRcdC5jYWwtdGl0bGUge1xyXG5cdFx0XHRwYWRkaW5nOiA1cHggMDtcclxuXHRcdFx0Zm9udC1zaXplOiAxMnB4O1xyXG5cdFx0XHRjb2xvcjogIzEyMTIzNjtcclxuXHRcdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XHJcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHQudnVlY2FsIHtcclxuXHRcdFx0Ym94LXNoYWRvdzogbm9uZTtcclxuXHRcdH1cclxuXHJcblx0XHQudnVlY2FsX190aXRsZS1iYXIge1xyXG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuXHRcdFx0Zm9udC1zaXplOiAxNnB4O1xyXG5cdFx0XHRmb250LXdlaWdodDogYm9sZDtcclxuXHRcdH1cclxuXHJcblx0XHQudnVlY2FsX19oZWFkaW5nIHtcclxuXHRcdFx0ZGlzcGxheTogbm9uZTtcclxuXHRcdH1cclxuXHJcblx0XHQuY2FsZW5kYXItY2VsbCB7XHJcblx0XHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xyXG5cdFx0XHRib3JkZXItcmFkaXVzOiA0cHg7XHJcblx0XHRcdGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4xKTtcclxuXHRcdFx0Y29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcclxuXHRcdFx0Ym9yZGVyOiAycHggc29saWQgI2ZmZjtcclxuXHJcblx0XHRcdC5kYXkge1xyXG5cdFx0XHRcdGZvbnQtc2l6ZTogMTJweDtcclxuXHRcdFx0XHRzY2FsZTogMC44O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCI8dGVtcGxhdGU+XG5cdDxkaXYgY2xhc3M9XCJhaXItY2FsZW5kYXItcGFnZVwiPlxuXHRcdDx2YW4tbmF2LWJhclxuXHRcdFx0XHR0aXRsZT1cIuaXpeWOhuivpuaDhVwiXG5cdFx0XHRcdGxlZnQtYXJyb3dcblx0XHRcdFx0Zml4ZWRcblx0XHRcdFx0ei1pbmRleD1cIjEwXCJcblx0XHRcdFx0QGNsaWNrLWxlZnQ9XCIkcm91dGVyLmdvKC0xKVwiXG5cdFx0Lz5cblx0XHQ8ZGl2IGNsYXNzPVwic2VhcmNoLWNvbnRlbnRcIiBzdHlsZT1cIm1hcmdpbi10b3A6IDU0cHhcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJzZWFyY2gtaXRlbSBmc1wiIEBjbGljaz1cInNob3dQaWNrZXJZZWFyPSB0cnVlXCI+XG5cdFx0XHRcdHt7eWVhcn19XG5cdFx0XHRcdDx2YW4taWNvbiBuYW1lPVwiYXJyb3ctZG93blwiIC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8dmFuLXBvcHVwIHYtbW9kZWw9XCJzaG93UGlja2VyWWVhclwiIHBvc2l0aW9uPVwiYm90dG9tXCI+XG5cdFx0XHQ8dmFuLXBpY2tlclxuXHRcdFx0ICAgICAgICBzaG93LXRvb2xiYXIgOmNvbHVtbnM9XCJ5ZWFyQ29sdW1uc1wiXG5cdFx0XHQgICAgICAgIHRpdGxlPVwi6YCJ5oup5bm0XCIgOmRlZmF1bHQtaW5kZXg9XCJ5ZWFyU2VsZWN0XCJcblx0XHRcdCAgICAgICAgQGNvbmZpcm09XCJvbkNvbmZpcm1ZZWFyXCJcblx0XHRcdCAgICAgICAgQGNhbmNlbD1cInNob3dQaWNrZXJZZWFyPWZhbHNlXCJcblx0XHRcdC8+XG5cdFx0PC92YW4tcG9wdXA+XG5cdFx0PGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7aGVpZ2h0OiBjYWxjKDEwMHZoIC0gMTA2cHgpO292ZXJmbG93OiBoaWRkZW4gYXV0bztcIj5cblx0XHRcdDxjYWxlbmRhclllYXIgdi1mb3I9XCIoaXRlbSwgaW5kZXgpIGluIHllYXJEYXRhXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0OmtleT1cImluZGV4XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0OmFycmF5PVwiaXRlbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDpzdGFydERhdGU9XCJuZXcgRGF0ZSh5ZWFyLCBpbmRleCwgMSlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ6ZmFjdG9yPVwiJ0FRSSdcIi8+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblx0aW1wb3J0IHtnZXRBbGxZZWFyQ2FsZW5kZXJ9IGZyb20gJ0AvYXBpL2Fpci5qcyc7XG5cdGltcG9ydCBjYWxlbmRhclllYXIgZnJvbSBcIkAvY29tcG9uZW50cy9jYWxlbmRhci9jYWxlbmRhclllYXIudnVlXCI7XG5pbXBvcnQge1xuXHRcdFx0YWlyWWVhckNhbGVuZGFyLGdldEFpclNpdGVcblx0XHR9IGZyb20gJ0AvYXBpL2Fpcl9xdWFsaXR5Jztcblx0ZXhwb3J0IGRlZmF1bHQge1xuXHRcdG5hbWU6IFwiaW5kZXhcIixcblx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRjYWxlbmRhclllYXJcblx0XHR9LFxuXHRcdGRhdGEoKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR5ZWFyRGF0YTogW10sXG5cdFx0XHRcdHllYXI6ICcnLFxuXHRcdFx0XHRzaXRlTmFtZTogJycsXG5cdFx0XHRcdHNpdGVJZDonJyxcblx0XHRcdFx0ZmFjdG9yOicnLFxuXHRcdFx0XHRjdXJyZW50RGF0ZTogbmV3IERhdGUoKSxcblx0XHRcdFx0c2hvd1BpY2tlclllYXI6IGZhbHNlLFxuXHRcdFx0XHR5ZWFyU2VsZWN0Om51bGwsXG5cdFx0XHRcdHllYXJDb2x1bW5zOltdLFxuXHRcdFx0XHR4enFoOicnLFxuXHRcdFx0XHRxdWVyeUZsYWc6IG51bGwsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtb3VudGVkKCkge1xuXHRcdFx0dGhpcy5zaXRlSWQgPSB0aGlzLiRyb3V0ZS5xdWVyeS5zaXRlSWQ7XG5cdFx0XHR0aGlzLmZhY3RvciA9IHRoaXMuJHJvdXRlLnF1ZXJ5LmZhY3Rvcjtcblx0XHRcdHRoaXMueHpxaCA9IHRoaXMuJHJvdXRlLnF1ZXJ5Lnh6cWg7XG5cdFx0XHR0aGlzLnF1ZXJ5RmxhZyA9IE51bWJlcih0aGlzLiRyb3V0ZS5xdWVyeS5xdWVyeUZsYWcpO1xuXHRcdFx0Ly8gdGhpcy55ZWFyID0gXCIyMDIzXCI7XG5cdFx0XHR0aGlzLnllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHR0aGlzLmdldFllYXJzKCk7XG5cdFx0XHR0aGlzLmdldFllYXJEYXRhKCk7XG5cdFx0fSxcblx0XHRtZXRob2RzOiB7XG5cdFx0XHQvL+W5tOaVsOaNrlxuXHRcdFx0IGdldFllYXJzKCkge1xuXHRcdFx0XHRcdC8vIOiOt+WPlum7mOiupOaYvuekuueahOaXtumXtFxuXHRcdFx0XHRcdHZhciBub3dUaW1lID0gbmV3IERhdGUoKTtcblx0XHRcdFx0bGV0IHllYXIgPSBub3dUaW1lLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGxldCBtb250aCA9IG5vd1RpbWUuZ2V0TW9udGgoKTtcblx0XHRcdFx0bGV0IGRheSA9IG5vd1RpbWUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHQvLyDlvqrnjq/mlbDnu4Qg5aGr5YaZ5pyA5bCP5pe26Ze05ZKM5pyA5aSn5pe26Ze06IyD5Zu0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAyMDEwOyBpIDwgMjA5OTsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnllYXJDb2x1bW5zLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8g5qC85byP5YyW5pe26Ze05bm25oiq5Y+WXG5cdFx0XHRcdHZhciB5ZWFycyA9IHRoaXMuZm9ybWF0RGF0ZSggbmV3IERhdGUoeWVhciwgbW9udGggLGRheSkpO1xuXHRcdFx0XHR2YXIgWWVhciA9IHllYXJzLnNsaWNlKDAsNCk7XG5cdFx0XHRcdC8vIOWwhuaIquWPlueahOW5tOS7vei1i+WAvOe7mee7keWumuWAvCDnlKjkuo7ngrnlh7vlvLnlh7rml6XmnJ/nqpflj6PlkI7mmL7npLrlvZPliY3nmoTml7bpl7Rcblx0XHRcdFx0dGhpcy55ZWFyU2VsZWN0ID0gdGhpcy55ZWFyQ29sdW1ucy5pbmRleE9mKE51bWJlcihZZWFyKSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly/ml6XmnJ/moLzlvI9cblx0XHRcdGZvcm1hdERhdGUoZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0ke2RhdGUuZ2V0TW9udGgoKSsxfS0ke2RhdGUuZ2V0RGF0ZSgpfWA7XG5cdFx0XHR9LFxuXHRcdFx0b25Db25maXJtWWVhcih2YWx1ZSl7XG5cdFx0XHRcdHRoaXMuc2hvd1BpY2tlclllYXIgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy55ZWFyID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuZ2V0WWVhckRhdGEoKVxuXHRcdFx0fSxcblx0XHRcdGdldFllYXJEYXRhKCkge1xuXHRcdFx0XHRsZXQgaW5mbyA9IHtcblx0XHRcdFx0XHRzaXRlSWQ6dGhpcy5zaXRlSWQsXG5cdFx0XHRcdFx0eWVhcjp0aGlzLnllYXIsXG5cdFx0XHRcdFx0ZGl2aXNpb25OYW1lOnRoaXMueHpxaCxcblx0XHRcdFx0XHRhcWk6IHRoaXMucXVlcnlGbGFnID09PSAwPyAnJzonaWFxaScsXG5cdFx0XHRcdH1cblx0XHRcdFx0YWlyWWVhckNhbGVuZGFyKGluZm8pLnRoZW4ocmVzPT57XG5cdFx0XHRcdFx0dGhpcy55ZWFyRGF0YSA9IHJlcy5kYXRhO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQvLyBnZXRBbGxZZWFyQ2FsZW5kZXIoe1xuXHRcdFx0XHQvLyBcdHR5cGU6IDEsXG5cdFx0XHRcdC8vIFx0aWQ6ICcnLFxuXHRcdFx0XHQvLyBcdHl6TmFtZTogJ0FRSScsXG5cdFx0XHRcdC8vIFx0eWVhcjogJzIwMjMnXG5cdFx0XHRcdC8vIH0pLnRoZW4ocmVzID0+IHtcblx0XHRcdFx0Ly8gXHR0aGlzLnllYXJEYXRhID0gcmVzO1xuXHRcdFx0XHQvLyB9KVxuXHRcdFx0fSxcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInNjc3NcIiBzY29wZWQ+XG5cdC5zZWFyY2gtY29udGVudCB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdG1hcmdpbjogNTRweCAxMHB4IDVweDtcblx0XHQgICAgcGFkZGluZy10b3A6IDEwcHg7XG5cdFx0Y29sb3I6IHJnYmEoMTgsIDE4LCA1NCwgMC41KTtcblx0XHRmb250LXNpemU6IDEycHg7XG5cblx0XHQuc2VhcmNoLWl0ZW0ge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRwYWRkaW5nOiA2cHg7XG5cdFx0XHRiYWNrZ3JvdW5kOiAjZmZmO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogNnB4O1xuXHRcdFx0Y29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHRcdG1hcmdpbi1yaWdodDogNXB4O1xuXHRcdH1cblx0fVxuXHQuYWlyLWNhbGVuZGFyLXBhZ2Uge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwdmg7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYTtcblx0XHQvLyBvdmVyZmxvdzogYXV0bztcblx0fVxuPC9zdHlsZT5cbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJjYWwtd3JhcHBlclwiIH0sXG4gICAgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjYWwtdGl0bGVcIiB9LCBbXG4gICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLmRheWpzKF92bS5zdGFydERhdGUpLmZvcm1hdChcIllZWVktTU1cIikpKSxcbiAgICAgIF0pLFxuICAgICAgX2MoXCJ2dWUtY2FsXCIsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBsb2NhbGU6IFwiemgtY25cIixcbiAgICAgICAgICBcInNlbGVjdGVkLWRhdGVcIjogX3ZtLmRheWpzKF92bS5zdGFydERhdGUpLmZvcm1hdChcIllZWVktTU1cIiArIFwiLTAxXCIpLFxuICAgICAgICAgIFwiaGlkZS12aWV3LXNlbGVjdG9yXCI6IFwiXCIsXG4gICAgICAgICAgaGlkZVRpdGxlQmFyOiBcIlwiLFxuICAgICAgICAgIFwiZGVmYXVsdC12aWV3XCI6IFwibW9udGhcIixcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVkU2xvdHM6IF92bS5fdShbXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNlbGwtY29udGVudFwiLFxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSByZWYuY2VsbFxuICAgICAgICAgICAgICB2YXIgdmlldyA9IHJlZi52aWV3XG4gICAgICAgICAgICAgIHZhciBldmVudHMgPSByZWYuZXZlbnRzXG4gICAgICAgICAgICAgIHZhciBnb05hcnJvd2VyID0gcmVmLmdvTmFycm93ZXJcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNhbGVuZGFyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF92bS5nZXRDYWxlbmRhckJnKGNlbGwpLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZGF5XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoY2VsbC5zdGFydERhdGUuZ2V0RGF0ZSgpKSksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSksXG4gICAgICB9KSxcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJhaXItY2FsZW5kYXItcGFnZVwiIH0sXG4gICAgW1xuICAgICAgX2MoXCJ2YW4tbmF2LWJhclwiLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgdGl0bGU6IFwi5pel5Y6G6K+m5oOFXCIsXG4gICAgICAgICAgXCJsZWZ0LWFycm93XCI6IFwiXCIsXG4gICAgICAgICAgZml4ZWQ6IFwiXCIsXG4gICAgICAgICAgXCJ6LWluZGV4XCI6IFwiMTBcIixcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcImNsaWNrLWxlZnRcIjogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF92bS4kcm91dGVyLmdvKC0xKVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwic2VhcmNoLWNvbnRlbnRcIixcbiAgICAgICAgICBzdGF0aWNTdHlsZTogeyBcIm1hcmdpbi10b3BcIjogXCI1NHB4XCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwic2VhcmNoLWl0ZW0gZnNcIixcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLnNob3dQaWNrZXJZZWFyID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIgKyBfdm0uX3MoX3ZtLnllYXIpICsgXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInZhbi1pY29uXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJhcnJvdy1kb3duXCIgfSB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKSxcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF9jKFxuICAgICAgICBcInZhbi1wb3B1cFwiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHsgcG9zaXRpb246IFwiYm90dG9tXCIgfSxcbiAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgdmFsdWU6IF92bS5zaG93UGlja2VyWWVhcixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoJCR2KSB7XG4gICAgICAgICAgICAgIF92bS5zaG93UGlja2VyWWVhciA9ICQkdlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwic2hvd1BpY2tlclllYXJcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJ2YW4tcGlja2VyXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIFwic2hvdy10b29sYmFyXCI6IFwiXCIsXG4gICAgICAgICAgICAgIGNvbHVtbnM6IF92bS55ZWFyQ29sdW1ucyxcbiAgICAgICAgICAgICAgdGl0bGU6IFwi6YCJ5oup5bm0XCIsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdC1pbmRleFwiOiBfdm0ueWVhclNlbGVjdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjb25maXJtOiBfdm0ub25Db25maXJtWWVhcixcbiAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3ZtLnNob3dQaWNrZXJZZWFyID0gZmFsc2VcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIxMHB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYygxMDB2aCAtIDEwNnB4KVwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBfdm0uX2woX3ZtLnllYXJEYXRhLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXCJjYWxlbmRhclllYXJcIiwge1xuICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGFycmF5OiBpdGVtLFxuICAgICAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKF92bS55ZWFyLCBpbmRleCwgMSksXG4gICAgICAgICAgICAgIGZhY3RvcjogXCJBUUlcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCIndXNlIHN0cmljdCc7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdmb3JFYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5tb2R1bGUuZXhwb3J0cyA9ICFTVFJJQ1RfTUVUSE9EID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1mb3JlYWNoIC0tIHNhZmVcbn0gOiBbXS5mb3JFYWNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgJFR5cGVFcnJvcignTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2VzLW5vdC1leGNlZWQtc2FmZS1pbnRlZ2VyJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbicpO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG4vLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdjb25jYXQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBhcml0eTogMSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoRSk7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihuICsgbGVuKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKG4gKyAxKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBET01Ub2tlbkxpc3RQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLXRva2VuLWxpc3QtcHJvdG90eXBlJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxudmFyIGhhbmRsZVByb3RvdHlwZSA9IGZ1bmN0aW9uIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgZm9yRWFjaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcbiAgfVxufTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIHtcbiAgICBoYW5kbGVQcm90b3R5cGUoZ2xvYmFsVGhpc1tDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbFRoaXNbQ09MTEVDVElPTl9OQU1FXS5wcm90b3R5cGUpO1xuICB9XG59XG5cbmhhbmRsZVByb3RvdHlwZShET01Ub2tlbkxpc3RQcm90b3R5cGUpO1xuIiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnZ1ZWNhbF9fd2Vla2RheXMtaGVhZGluZ3N7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2RkZDttYXJnaW4tYm90dG9tOi0xcHh9LnZ1ZWNhbC0tdmlldy13aXRoLXRpbWUgLnZ1ZWNhbF9fd2Vla2RheXMtaGVhZGluZ3MsLnZ1ZWNhbC0td2Vlay1udW1iZXJzIC52dWVjYWxfX3dlZWtkYXlzLWhlYWRpbmdze3BhZGRpbmctbGVmdDozZW19LnZ1ZWNhbC0tdmlldy13aXRoLXRpbWUudnVlY2FsLS10d2VsdmUtaG91ciAudnVlY2FsX193ZWVrZGF5cy1oZWFkaW5nc3tmb250LXNpemU6LjllbTtwYWRkaW5nLWxlZnQ6NGVtfS52dWVjYWwtLW92ZXJmbG93LXgudnVlY2FsLS12aWV3LXdpdGgtdGltZSAudnVlY2FsX193ZWVrZGF5cy1oZWFkaW5nc3twYWRkaW5nLWxlZnQ6MH0udnVlY2FsX19oZWFkaW5ne3dpZHRoOjEwMCU7aGVpZ2h0OjIuOGVtO2ZvbnQtd2VpZ2h0OjQwMDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3RleHQtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LnZ1ZWNhbF9faGVhZGluZz4udnVlY2FsX19mbGV4e3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YWxpZ24taXRlbXM6bm9ybWFsIWltcG9ydGFudH0udnVlY2FsLS1zdGlja3ktc3BsaXQtbGFiZWxzIC52dWVjYWxfX2hlYWRpbmd7aGVpZ2h0OjMuNGVtfS52dWVjYWwtLWRheS12aWV3IC52dWVjYWxfX2hlYWRpbmcsLnZ1ZWNhbC0tbW9udGgtdmlldyAudnVlY2FsX19oZWFkaW5nLC52dWVjYWwtLXdlZWstdmlldyAudnVlY2FsX19oZWFkaW5ne3dpZHRoOjE0LjI4NTclfS52dWVjYWwtLWhpZGUtd2Vla2VuZHMudnVlY2FsLS1kYXktdmlldyAudnVlY2FsX19oZWFkaW5nLC52dWVjYWwtLWhpZGUtd2Vla2VuZHMudnVlY2FsLS1tb250aC12aWV3IC52dWVjYWxfX2hlYWRpbmcsLnZ1ZWNhbC0taGlkZS13ZWVrZW5kcy52dWVjYWwtLXdlZWstdmlldyAudnVlY2FsX19oZWFkaW5nLC52dWVjYWwtLXllYXJzLXZpZXcgLnZ1ZWNhbF9faGVhZGluZ3t3aWR0aDoyMCV9LnZ1ZWNhbC0teWVhci12aWV3IC52dWVjYWxfX2hlYWRpbmd7d2lkdGg6MzMuMzMlfS52dWVjYWxfX2hlYWRpbmcgLndlZWtkYXktbGFiZWx7ZmxleC1zaHJpbms6MDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LnZ1ZWNhbC0tc21hbGwgLnZ1ZWNhbF9faGVhZGluZyAuc21hbGwsLnZ1ZWNhbC0teHNtYWxsIC52dWVjYWxfX2hlYWRpbmcgLnhzbWFsbHtkaXNwbGF5OmJsb2NrfS52dWVjYWwtLXNtYWxsIC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbC0tc21hbGwgLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxsLC52dWVjYWwtLXhzbWFsbCAudnVlY2FsX19oZWFkaW5nIC5mdWxsLC52dWVjYWwtLXhzbWFsbCAudnVlY2FsX19oZWFkaW5nIC5zbWFsbCwudnVlY2FsX19oZWFkaW5nIC5zbWFsbCwudnVlY2FsX19oZWFkaW5nIC54c21hbGx7ZGlzcGxheTpub25lfS52dWVjYWwgLnZ1ZWNhbF9fc3BsaXQtZGF5cy1oZWFkZXJze2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjU1MHB4KXsudnVlY2FsX19oZWFkaW5ne2xpbmUtaGVpZ2h0OjEuMn0udnVlY2FsLS1zbWFsbCAudnVlY2FsX19oZWFkaW5nIC5zbWFsbCwudnVlY2FsLS14c21hbGwgLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxsLC52dWVjYWxfX2hlYWRpbmcgLnNtYWxse2Rpc3BsYXk6YmxvY2t9LnZ1ZWNhbC0tc21hbGwgLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsLS1zbWFsbCAudnVlY2FsX19oZWFkaW5nIC54c21hbGwsLnZ1ZWNhbC0teHNtYWxsIC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbC0teHNtYWxsIC52dWVjYWxfX2hlYWRpbmcgLnNtYWxsLC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxse2Rpc3BsYXk6bm9uZX0udnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbC0tc21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLnNtYWxsLC52dWVjYWwtLXhzbWFsbC52dWVjYWwtLW92ZXJmbG93LXggLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxse2Rpc3BsYXk6YmxvY2t9LnZ1ZWNhbC0tb3ZlcmZsb3cteCAudnVlY2FsX19oZWFkaW5nIC5zbWFsbCwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLnhzbWFsbCwudnVlY2FsLS1zbWFsbC52dWVjYWwtLW92ZXJmbG93LXggLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsLS1zbWFsbC52dWVjYWwtLW92ZXJmbG93LXggLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxsLC52dWVjYWwtLXhzbWFsbC52dWVjYWwtLW92ZXJmbG93LXggLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsLS14c21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLnNtYWxse2Rpc3BsYXk6bm9uZX19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo0NTBweCl7LnZ1ZWNhbC0tc21hbGwgLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxsLC52dWVjYWwtLXhzbWFsbCAudnVlY2FsX19oZWFkaW5nIC54c21hbGwsLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxse2Rpc3BsYXk6YmxvY2t9LnZ1ZWNhbC0tc21hbGwgLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsLS1zbWFsbCAudnVlY2FsX19oZWFkaW5nIC5zbWFsbCwudnVlY2FsLS14c21hbGwgLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsLS14c21hbGwgLnZ1ZWNhbF9faGVhZGluZyAuc21hbGwsLnZ1ZWNhbF9faGVhZGluZyAuZnVsbCwudnVlY2FsX19oZWFkaW5nIC5zbWFsbHtkaXNwbGF5Om5vbmV9LnZ1ZWNhbC0tc21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLnNtYWxsLC52dWVjYWwtLXhzbWFsbC52dWVjYWwtLW92ZXJmbG93LXggLnZ1ZWNhbF9faGVhZGluZyAueHNtYWxse2Rpc3BsYXk6YmxvY2t9LnZ1ZWNhbC0tc21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbC0tc21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLnhzbWFsbCwudnVlY2FsLS14c21hbGwudnVlY2FsLS1vdmVyZmxvdy14IC52dWVjYWxfX2hlYWRpbmcgLmZ1bGwsLnZ1ZWNhbC0teHNtYWxsLnZ1ZWNhbC0tb3ZlcmZsb3cteCAudnVlY2FsX19oZWFkaW5nIC5zbWFsbHtkaXNwbGF5Om5vbmV9fS52dWVjYWxfX2hlYWRlciBidXR0b257b3V0bGluZTpub25lO2ZvbnQtZmFtaWx5OmluaGVyaXR9LnZ1ZWNhbF9fbWVudXtwYWRkaW5nOjA7bWFyZ2luOjA7bGlzdC1zdHlsZS10eXBlOm5vbmU7anVzdGlmeS1jb250ZW50OmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjAyKX0udnVlY2FsX192aWV3LWJ0bntiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7cGFkZGluZzouM2VtIDFlbTtoZWlnaHQ6Mi4yZW07Zm9udC1zaXplOjEuM2VtO2JvcmRlci1ib3R0b206MCBzb2xpZCBjdXJyZW50Q29sb3I7Y3Vyc29yOnBvaW50ZXI7Y29sb3I6aW5oZXJpdDtib3gtc2l6aW5nOmJvcmRlci1ib3g7dHJhbnNpdGlvbjouMnN9LnZ1ZWNhbF9fdmlldy1idG4tLWFjdGl2ZXtib3JkZXItYm90dG9tLXdpZHRoOjJweDtiYWNrZ3JvdW5kOmhzbGEoMCwwJSwxMDAlLC4xNSl9LnZ1ZWNhbF9fdGl0bGUtYmFye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMSk7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjtmb250LXNpemU6MS40ZW07bGluZS1oZWlnaHQ6MS4zO21pbi1oZWlnaHQ6MmVtfS52dWVjYWwtLXhzbWFsbCAudnVlY2FsX190aXRsZS1iYXJ7Zm9udC1zaXplOjEuM2VtfS52dWVjYWxfX3RpdGxle3Bvc2l0aW9uOnJlbGF0aXZlO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LnZ1ZWNhbF9fdGl0bGUgYnV0dG9ue2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZX0udnVlY2FsX190aXRsZSBidXR0b24uc2xpZGUtZmFkZS0tbGVmdC1sZWF2ZS1hY3RpdmUsLnZ1ZWNhbF9fdGl0bGUgYnV0dG9uLnNsaWRlLWZhZGUtLXJpZ2h0LWxlYXZlLWFjdGl2ZXt3aWR0aDoxMDAlfS52dWVjYWxfX3RvZGF5LWJ0bntwb3NpdGlvbjpyZWxhdGl2ZTthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2ZvbnQtc2l6ZTouOGVtO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZX0udnVlY2FsX190b2RheS1idG4gc3Bhbi5kZWZhdWx0e2ZvbnQtc2l6ZTouOGVtO3BhZGRpbmc6M3B4IDZweDt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2U7Y3Vyc29yOnBvaW50ZXJ9LnZ1ZWNhbF9fYXJyb3d7Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXB9LnZ1ZWNhbF9fYXJyb3ctLXByZXZ7bWFyZ2luLWxlZnQ6LjZlbX0udnVlY2FsX19hcnJvdy0tbmV4dHttYXJnaW4tcmlnaHQ6LjZlbX0udnVlY2FsX19hcnJvdyBpLmFuZ2xle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JvcmRlcjpzb2xpZCBjdXJyZW50Q29sb3I7Ym9yZGVyLXdpZHRoOjAgMnB4IDJweCAwO3BhZGRpbmc6LjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS52dWVjYWxfX2Fycm93LS1wcmV2IGkuYW5nbGV7Ym9yZGVyLXdpZHRoOjJweCAwIDAgMnB4fS52dWVjYWxfX2Fycm93LS1oaWdobGlnaHRlZCwudnVlY2FsX190b2RheS1idG4tLWhpZ2hsaWdodGVkLC52dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjA0KX0udnVlY2FsX19hcnJvdy0taGlnaGxpZ2h0ZWQgKiwudnVlY2FsX190b2RheS1idG4tLWhpZ2hsaWdodGVkICosLnZ1ZWNhbF9fdmlldy1idG4tLWhpZ2hsaWdodGVkICp7cG9pbnRlci1ldmVudHM6bm9uZX0udnVlY2FsX19hcnJvdy0taGlnaGxpZ2h0ZWQ6YWZ0ZXIsLnZ1ZWNhbF9fYXJyb3ctLWhpZ2hsaWdodGVkOmJlZm9yZSwudnVlY2FsX190b2RheS1idG4tLWhpZ2hsaWdodGVkOmFmdGVyLC52dWVjYWxfX3RvZGF5LWJ0bi0taGlnaGxpZ2h0ZWQ6YmVmb3JlLC52dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZDphZnRlciwudnVlY2FsX192aWV3LWJ0bi0taGlnaGxpZ2h0ZWQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7YmFja2dyb3VuZC1jb2xvcjppbmhlcml0Oy13ZWJraXQtYW5pbWF0aW9uOnNvbmFyIC44cyBlYXNlLW91dCBpbmZpbml0ZTthbmltYXRpb246c29uYXIgLjhzIGVhc2Utb3V0IGluZmluaXRlO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7cG9pbnRlci1ldmVudHM6bm9uZX0udnVlY2FsX19hcnJvdy0taGlnaGxpZ2h0ZWQ6YmVmb3JlLC52dWVjYWxfX3RvZGF5LWJ0bi0taGlnaGxpZ2h0ZWQ6YmVmb3JlLC52dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZDpiZWZvcmV7d2lkdGg6M2VtO2hlaWdodDozZW07Ym9yZGVyLXJhZGl1czozZW07bWFyZ2luLXRvcDotMS41ZW07bWFyZ2luLWxlZnQ6LTEuNWVtfS52dWVjYWxfX2Fycm93LS1oaWdobGlnaHRlZDphZnRlciwudnVlY2FsX190b2RheS1idG4tLWhpZ2hsaWdodGVkOmFmdGVyLC52dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZDphZnRlcnstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjoxLjVzO2FuaW1hdGlvbi1kdXJhdGlvbjoxLjVzOy13ZWJraXQtYW5pbWF0aW9uLWRlbGF5Oi4xczthbmltYXRpb24tZGVsYXk6LjFzO3dpZHRoOjIuNmVtO2hlaWdodDoyLjZlbTtib3JkZXItcmFkaXVzOjIuNmVtO21hcmdpbi10b3A6LTEuM2VtO21hcmdpbi1sZWZ0Oi0xLjNlbX1ALXdlYmtpdC1rZXlmcmFtZXMgc29uYXJ7MCUsMjAle29wYWNpdHk6MX10b3t0cmFuc2Zvcm06c2NhbGUoMi41KTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc29uYXJ7MCUsMjAle29wYWNpdHk6MX10b3t0cmFuc2Zvcm06c2NhbGUoMi41KTtvcGFjaXR5OjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6NDUwcHgpey52dWVjYWxfX3RpdGxle2ZvbnQtc2l6ZTouOWVtfS52dWVjYWxfX3ZpZXctYnRue3BhZGRpbmctbGVmdDouNmVtO3BhZGRpbmctcmlnaHQ6LjZlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozNTBweCl7LnZ1ZWNhbF9fdmlldy1idG57Zm9udC1zaXplOjEuMWVtfX0udnVlY2FsX19ldmVudHtjb2xvcjojNjY2O2JhY2tncm91bmQtY29sb3I6aHNsYSgwLDAlLDk3LjMlLC44KTtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7bGVmdDowO3dpZHRoOjEwMCU7ei1pbmRleDoxO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuM3MsbGVmdCAuM3Msd2lkdGggLjNzO292ZXJmbG93OmhpZGRlbn0udnVlY2FsOm5vdCgudnVlY2FsLS1kcmFnZ2luZy1ldmVudCkgLnZ1ZWNhbF9fZXZlbnQ6aG92ZXJ7ei1pbmRleDoyfS52dWVjYWxfX2NlbGwgLnZ1ZWNhbF9fZXZlbnQgKnstd2Via2l0LXVzZXItc2VsZWN0OnRleHQ7LW1vei11c2VyLXNlbGVjdDp0ZXh0Oy1tcy11c2VyLXNlbGVjdDp0ZXh0O3VzZXItc2VsZWN0OnRleHR9LnZ1ZWNhbC0tdmlldy13aXRoLXRpbWUgLnZ1ZWNhbF9fZXZlbnQ6bm90KC52dWVjYWxfX2V2ZW50LS1hbGwtZGF5KXtwb3NpdGlvbjphYnNvbHV0ZX0udnVlY2FsLS12aWV3LXdpdGgtdGltZSAudnVlY2FsX19iZyAudnVlY2FsX19ldmVudC0tYWxsLWRheXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDt6LWluZGV4OjA7b3BhY2l0eTouNjt3aWR0aDphdXRvO3JpZ2h0OjB9LnZ1ZWNhbC0tdmlldy13aXRoLXRpbWUgLnZ1ZWNhbF9fYWxsLWRheSAudnVlY2FsX19ldmVudC0tYWxsLWRheXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjB9LnZ1ZWNhbF9fZXZlbnQtLWJhY2tncm91bmR7ei1pbmRleDowfS52dWVjYWxfX2V2ZW50LS1mb2N1cywudnVlY2FsX19ldmVudDpmb2N1c3tib3gtc2hhZG93OjFweCAxcHggNnB4IHJnYmEoMCwwLDAsLjIpO3otaW5kZXg6MztvdXRsaW5lOm5vbmV9LnZ1ZWNhbF9fZXZlbnQudnVlY2FsX19ldmVudC0tZHJhZ2dpbmd7b3BhY2l0eTouN30udnVlY2FsX19ldmVudC52dWVjYWxfX2V2ZW50LS1zdGF0aWN7b3BhY2l0eTowfUAtbW96LWRvY3VtZW50IHVybC1wcmVmaXgoKXsudnVlY2FsX19ldmVudC52dWVjYWxfX2V2ZW50LS1kcmFnZ2luZ3tvcGFjaXR5OjF9fS52dWVjYWxfX2V2ZW50LXJlc2l6ZS1oYW5kbGV7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjFlbTtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSwxMDAlLC4zKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTEwJSk7dHJhbnNpdGlvbjouM3M7Y3Vyc29yOm5zLXJlc2l6ZX0udnVlY2FsX19ldmVudC0tZm9jdXMgLnZ1ZWNhbF9fZXZlbnQtcmVzaXplLWhhbmRsZSwudnVlY2FsX19ldmVudDpmb2N1cyAudnVlY2FsX19ldmVudC1yZXNpemUtaGFuZGxlLC52dWVjYWxfX2V2ZW50OmhvdmVyIC52dWVjYWxfX2V2ZW50LXJlc2l6ZS1oYW5kbGV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfS52dWVjYWxfX2V2ZW50LS1kcmFnZ2luZyAudnVlY2FsX19ldmVudC1yZXNpemUtaGFuZGxle2Rpc3BsYXk6bm9uZX0udnVlY2FsX19ldmVudC1kZWxldGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3JpZ2h0OjA7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MS40ZW07bGluZS1oZWlnaHQ6MS40ZW07YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIyMSw1MSw1MSwuODUpO2NvbG9yOiNmZmY7ei1pbmRleDowO2N1cnNvcjpwb2ludGVyO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMTAlKTt0cmFuc2l0aW9uOi4zc30udnVlY2FsLS1mdWxsLWhlaWdodC1kZWxldGUgLnZ1ZWNhbF9fZXZlbnQtZGVsZXRle2hlaWdodDphdXRvO2JvdHRvbTowfS52dWVjYWwtLWZ1bGwtaGVpZ2h0LWRlbGV0ZSAudnVlY2FsX19ldmVudC1kZWxldGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7d2lkdGg6MS43ZW07aGVpZ2h0OjEuOGVtO2Rpc3BsYXk6YmxvY2s7YmFja2dyb3VuZC1pbWFnZTp1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgd2lkdGg9XFxcIjUxMlxcXCIgaGVpZ2h0PVxcXCI1MTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA1MTIgNTEyXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIj48cGF0aCBkPVxcXCJtMjU2IDMzYy0xMjQgMC0yMjQgMTAwLTIyNCAyMjQgMCAxMjQgMTAwIDIyNCAyMjQgMjI0IDEyNCAwIDIyNC0xMDAgMjI0LTIyNCAwLTEyNC0xMDAtMjI0LTIyNC0yMjR6IG0xMDggMzAwYzIgMSAzIDMgMyA1IDAgMi0xIDQtMyA2bC0yMSAyMWMtMiAyLTQgMy02IDMtMiAwLTQtMS01LTNsLTc2LTc1LTc1IDc2Yy0yIDEtNCAyLTYgMi0yIDAtNC0xLTYtMmwtMjEtMjJjLTItMi0yLTQtMi02IDAtMiAwLTQgMi01bDc2LTc2LTc2LTc1Yy0zLTMtMy05IDAtMTJsMjEtMjFjMi0yIDQtMyA2LTMgMiAwIDQgMSA1IDNsNzYgNzQgNzYtNzRjMS0yIDMtMyA1LTMgMyAwIDUgMSA2IDNsMjIgMjFjMyAzIDMgOSAwIDEybC03NiA3NXpcXFwiIHRyYW5zZm9ybT1cXFwic2NhbGUoMC4wNDY4NzUgMC4wNDY4NzUpXFxcIiBmaWxsPVxcXCIlMjNmZmZcXFwiIG9wYWNpdHk9XFxcIjAuOVxcXCIvPjwvc3ZnPicpfS52dWVjYWxfX2V2ZW50LS1kZWxldGFibGUgLnZ1ZWNhbF9fZXZlbnQtZGVsZXRle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3otaW5kZXg6MX0udnVlY2FsX19ldmVudC0tZGVsZXRhYmxlLnZ1ZWNhbF9fZXZlbnQtLWRyYWdnaW5nIC52dWVjYWxfX2V2ZW50LWRlbGV0ZXtvcGFjaXR5OjA7dHJhbnNpdGlvbjpub25lfS52dWVjYWwtLW1vbnRoLXZpZXcgLnZ1ZWNhbF9fZXZlbnQtdGl0bGV7Zm9udC1zaXplOi44NWVtfS52dWVjYWwtLXNob3J0LWV2ZW50cyAudnVlY2FsX19ldmVudC10aXRsZXt0ZXh0LWFsaWduOmxlZnQ7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3BhZGRpbmc6MCAzcHh9LnZ1ZWNhbF9fZXZlbnQtY29udGVudCwudnVlY2FsX19ldmVudC10aXRsZXstd2Via2l0LWh5cGhlbnM6YXV0bzstbXMtaHlwaGVuczphdXRvO2h5cGhlbnM6YXV0b30udnVlY2FsX19ldmVudC10aXRsZS0tZWRpdHtib3JkZXItYm90dG9tOjFweCBzb2xpZCB0cmFuc3BhcmVudDt0ZXh0LWFsaWduOmNlbnRlcjt0cmFuc2l0aW9uOi4zcztjb2xvcjppbmhlcml0O2JhY2tncm91bmQtaW1hZ2U6dXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHdpZHRoPVxcXCI1MTJcXFwiIGhlaWdodD1cXFwiNTEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTEyIDUxMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCI+PHBhdGggZD1cXFwibTE2MyA0NDBsLTkxLTkxIDI1MS0yNTAgOTAgOTB6IG0zMDktMzUybC00OC00OGMtMTItMTEtMzItMTEtNDUgMmwtNDUgNDUgOTEgOTEgNDUtNDVjMTMtMTMgMTMtMzMgMi00NXogbS00MDggMjc1bC0zMiAxMTcgMTE3LTMyelxcXCIgZmlsbD1cXFwiJTIzMDAwXFxcIiBvcGFjaXR5PVxcXCIwLjRcXFwiLz48L3N2Zz4nKTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1wb3NpdGlvbjoxMjAlIC4xNWVtO2JhY2tncm91bmQtc2l6ZTouNGVtO291dGxpbmU6bm9uZTt3aWR0aDoxMDAlfS52dWVjYWxfX2V2ZW50LXRpdGxlLS1lZGl0OmZvY3VzLC52dWVjYWxfX2V2ZW50LXRpdGxlLS1lZGl0OmhvdmVye2JvcmRlci1jb2xvcjpyZ2JhKDAsMCwwLC40KTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjk5JSAuMTVlbTtiYWNrZ3JvdW5kLXNpemU6MS4yZW19LnZ1ZWNhbF9fY2VsbHtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlLWluLW91dH0udnVlY2FsX19jZWxscy5tb250aC12aWV3IC52dWVjYWxfX2NlbGwsLnZ1ZWNhbF9fY2VsbHMud2Vlay12aWV3IC52dWVjYWxfX2NlbGx7d2lkdGg6MTQuMjg1NyV9LnZ1ZWNhbC0taGlkZS13ZWVrZW5kcyAudnVlY2FsX19jZWxscy5tb250aC12aWV3IC52dWVjYWxfX2NlbGwsLnZ1ZWNhbC0taGlkZS13ZWVrZW5kcyAudnVlY2FsX19jZWxscy53ZWVrLXZpZXcgLnZ1ZWNhbF9fY2VsbCwudnVlY2FsX19jZWxscy55ZWFycy12aWV3IC52dWVjYWxfX2NlbGx7d2lkdGg6MjAlfS52dWVjYWxfX2NlbGxzLnllYXItdmlldyAudnVlY2FsX19jZWxse3dpZHRoOjMzLjMzJX0udnVlY2FsX19jZWxscy5kYXktdmlldyAudnVlY2FsX19jZWxse2ZsZXg6MX0udnVlY2FsLS1vdmVyZmxvdy14LnZ1ZWNhbC0tZGF5LXZpZXcgLnZ1ZWNhbF9fY2VsbHt3aWR0aDphdXRvfS52dWVjYWwtLWNsaWNrLXRvLW5hdmlnYXRlIC52dWVjYWxfX2NlbGw6bm90KC52dWVjYWxfX2NlbGwtLWRpc2FibGVkKXtjdXJzb3I6cG9pbnRlcn0udnVlY2FsLS1kYXktdmlldy52dWVjYWwtLW5vLXRpbWUgLnZ1ZWNhbF9fY2VsbCwudnVlY2FsLS12aWV3LXdpdGgtdGltZSAudnVlY2FsX19jZWxsLC52dWVjYWwtLXdlZWstdmlldy52dWVjYWwtLW5vLXRpbWUgLnZ1ZWNhbF9fY2VsbHtkaXNwbGF5OmJsb2NrfS52dWVjYWxfX2NlbGwudnVlY2FsX19jZWxsLS1oYXMtc3BsaXRze2ZsZXgtZGlyZWN0aW9uOnJvdztkaXNwbGF5OmZsZXh9LnZ1ZWNhbF9fY2VsbDpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjA7dG9wOjA7bGVmdDowO3JpZ2h0Oi0xcHg7Ym90dG9tOi0xcHg7Ym9yZGVyOjFweCBzb2xpZCAjZGRkfS52dWVjYWwtLW92ZXJmbG93LXgudnVlY2FsLS1kYXktdmlldyAudnVlY2FsX19jZWxsOmJlZm9yZXtib3R0b206MH0udnVlY2FsX19jZWxsLS1jdXJyZW50LC52dWVjYWxfX2NlbGwtLXRvZGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNDAsMjQwLDI1NSwuNCk7ei1pbmRleDoxfS52dWVjYWxfX2NlbGwtLXNlbGVjdGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzUsMjU1LDI0NSwuNCk7ei1pbmRleDoyfS52dWVjYWwtLWRheS12aWV3IC52dWVjYWxfX2NlbGwtLXNlbGVjdGVke2JhY2tncm91bmQ6bm9uZX0udnVlY2FsX19jZWxsLS1vdXQtb2Ytc2NvcGV7Y29sb3I6I2NjY30udnVlY2FsX19jZWxsLS1kaXNhYmxlZHtjb2xvcjojY2NjO2N1cnNvcjpub3QtYWxsb3dlZH0udnVlY2FsX19jZWxsLS1oaWdobGlnaHRlZDpub3QoLnZ1ZWNhbF9fY2VsbC0taGFzLXNwbGl0cyksLnZ1ZWNhbF9fY2VsbC1zcGxpdC52dWVjYWxfX2NlbGwtc3BsaXQtLWhpZ2hsaWdodGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMDQpO3RyYW5zaXRpb24tZHVyYXRpb246NW1zfS52dWVjYWxfX2NlbGwtY29udGVudHtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO291dGxpbmU6bm9uZX0udnVlY2FsLS1tb250aC12aWV3IC52dWVjYWxfX2NlbGwtY29udGVudCwudnVlY2FsLS15ZWFyLXZpZXcgLnZ1ZWNhbF9fY2VsbC1jb250ZW50LC52dWVjYWwtLXllYXJzLXZpZXcgLnZ1ZWNhbF9fY2VsbC1jb250ZW50e2p1c3RpZnktY29udGVudDpjZW50ZXJ9LnZ1ZWNhbF9fY2VsbC1zcGxpdHtkaXNwbGF5OmZsZXg7ZmxleC1ncm93OjE7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMTVzIGVhc2UtaW4tb3V0fS52dWVjYWxfX2NlbGwtZXZlbnRze3dpZHRoOjEwMCV9LnZ1ZWNhbF9fY2VsbC1ldmVudHMtY291bnR7bGVmdDo1MCU7dG9wOjY1JTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTttaW4td2lkdGg6MTJweDtoZWlnaHQ6MTJweDtsaW5lLWhlaWdodDoxMnB4O3BhZGRpbmc6MCAzcHg7YmFja2dyb3VuZDojOTk5O2NvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czoxMnB4O2ZvbnQtc2l6ZToxMHB4fS52dWVjYWxfX2NlbGwtZXZlbnRzLWNvdW50LC52dWVjYWxfX2NlbGwgLnZ1ZWNhbF9fc3BlY2lhbC1ob3Vyc3twb3NpdGlvbjphYnNvbHV0ZTtib3gtc2l6aW5nOmJvcmRlci1ib3h9LnZ1ZWNhbF9fY2VsbCAudnVlY2FsX19zcGVjaWFsLWhvdXJze2xlZnQ6MDtyaWdodDowfS52dWVjYWwtLW92ZXJmbG93LXgudnVlY2FsLS13ZWVrLXZpZXcgLnZ1ZWNhbF9fY2VsbCwudnVlY2FsX19jZWxsLXNwbGl0e292ZXJmbG93OmhpZGRlbn0udnVlY2FsX19uby1ldmVudHtwYWRkaW5nLXRvcDoxZW07Y29sb3I6I2FhYTtqdXN0aWZ5LXNlbGY6ZmxleC1zdGFydDttYXJnaW4tYm90dG9tOmF1dG99LnZ1ZWNhbF9fYWxsLWRheSAudnVlY2FsX19uby1ldmVudHtkaXNwbGF5Om5vbmV9LnZ1ZWNhbF9fbm93LWxpbmV7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjA7Y29sb3I6cmVkO2JvcmRlci10b3A6MXB4IHNvbGlkIGN1cnJlbnRDb2xvcjtvcGFjaXR5Oi42O3otaW5kZXg6MX0udnVlY2FsX19ub3ctbGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTZweDtsZWZ0OjA7Ym9yZGVyOjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdC1jb2xvcjpjdXJyZW50Q29sb3J9LnZ1ZWNhbHtoZWlnaHQ6MTAwJTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCByZ2JhKDAsMCwwLC4wOCl9LnZ1ZWNhbCAqey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0udnVlY2FsIC5jbGlja2FibGV7Y3Vyc29yOnBvaW50ZXJ9LnZ1ZWNhbC0tcmVzaXppbmctZXZlbnR7Y3Vyc29yOm5zLXJlc2l6ZX0udnVlY2FsLS1kcmFnZ2luZy1ldmVudHtjdXJzb3I6bW92ZTtjdXJzb3I6LXdlYmtpdC1ncmFiYmluZztjdXJzb3I6Z3JhYmJpbmd9LnZ1ZWNhbCAuZHJhZ2dpbmctaGVscGVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjYwcHg7aGVpZ2h0OjQwcHg7YmFja2dyb3VuZDpyZ2JhKDEzOCwxOTAsMjMwLC44KTtib3JkZXI6MXB4IHNvbGlkICM2MWE5ZTA7ei1pbmRleDoxMH0udnVlY2FsLS14c21hbGx7Zm9udC1zaXplOi45ZW19LnZ1ZWNhbF9fZmxleHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93fS52dWVjYWxfX2ZsZXhbY29sdW1uXXtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LnZ1ZWNhbF9fZmxleFtjb2x1bW5dLC52dWVjYWxfX2ZsZXhbZ3Jvd117ZmxleDoxIDEgYXV0b30udnVlY2FsX19mbGV4W2dyb3dde3dpZHRoOjEwMCV9LnZ1ZWNhbF9fZmxleFt3cmFwXXtmbGV4LXdyYXA6d3JhcH0udnVlY2FsX19zcGxpdC1kYXlzLWhlYWRlcnMuc2xpZGUtZmFkZS0tcmlnaHQtbGVhdmUtYWN0aXZle2Rpc3BsYXk6bm9uZX0udnVlY2FsLS13ZWVrLW51bWJlcnMudnVlY2FsLS1tb250aC12aWV3IC52dWVjYWxfX3NwbGl0LWRheXMtaGVhZGVyc3ttYXJnaW4tbGVmdDozZW19LnZ1ZWNhbC0tZGF5LXZpZXc6bm90KC52dWVjYWwtLW92ZXJmbG93LXgpIC52dWVjYWxfX3NwbGl0LWRheXMtaGVhZGVyc3ttYXJnaW4tbGVmdDozZW07aGVpZ2h0OjIuMmVtfS52dWVjYWwtLWRheS12aWV3LnZ1ZWNhbC0tdHdlbHZlLWhvdXI6bm90KC52dWVjYWwtLW92ZXJmbG93LXgpIC52dWVjYWxfX3NwbGl0LWRheXMtaGVhZGVyc3ttYXJnaW4tbGVmdDo0ZW19LnZ1ZWNhbF9fc3BsaXQtZGF5cy1oZWFkZXJzIC5kYXktc3BsaXQtaGVhZGVye2Rpc3BsYXk6ZmxleDtmbGV4LWdyb3c6MTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS52dWVjYWxfX3NwbGl0LWRheXMtaGVhZGVycyAudnVlY2FsLS1kYXktdmlldy52dWVjYWwtLW92ZXJmbG93LXgudnVlY2FsLS1zdGlja3ktc3BsaXQtbGFiZWxzIC5kYXktc3BsaXQtaGVhZGVye2hlaWdodDoxLjVlbX0udnVlY2FsX19ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0udnVlY2FsX19hbGwtZGF5e21pbi1oZWlnaHQ6MS43ZW07bWFyZ2luLWJvdHRvbTotMXB4O2ZsZXgtc2hyaW5rOjB9LnZ1ZWNhbF9fYWxsLWRheT5zcGFue3dpZHRoOjNlbTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6Izk5OTtwYWRkaW5nLXJpZ2h0OjJweDtkaXNwbGF5OmZsZXg7ZmxleC1zaHJpbms6MDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkZGQ7LXdlYmtpdC1oeXBoZW5zOmF1dG87LW1zLWh5cGhlbnM6YXV0bztoeXBoZW5zOmF1dG99LnZ1ZWNhbF9fYWxsLWRheT5zcGFuIHNwYW57Zm9udC1zaXplOi44NWVtO3RleHQtYWxpZ246cmlnaHQ7bGluZS1oZWlnaHQ6MS4xfS52dWVjYWwtLXR3ZWx2ZS1ob3VyIC52dWVjYWxfX2FsbC1kYXk+c3Bhbnt3aWR0aDo0ZW19LnZ1ZWNhbF9fYmd7b3ZlcmZsb3c6YXV0bztvdmVyZmxvdy14OmhpZGRlbjstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDttaW4taGVpZ2h0OjYwcHg7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjFweH0udnVlY2FsLS1uby10aW1lIC52dWVjYWxfX2Jne2Rpc3BsYXk6ZmxleDtmbGV4OjEgMSBhdXRvO292ZXJmbG93OnZpc2libGV9LnZ1ZWNhbF9fd2Vlay1udW1iZXJze3dpZHRoOjNlbTtmbGV4LXNocmluazowIWltcG9ydGFudH0udnVlY2FsX193ZWVrLW51bWJlcnMgLnZ1ZWNhbF9fd2Vlay1udW1iZXItY2VsbHtvcGFjaXR5Oi40O2ZvbnQtc2l6ZTouOWVtO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS52dWVjYWxfX3RpbWUtY29sdW1ue3dpZHRoOjNlbTtoZWlnaHQ6MTAwJTtmbGV4LXNocmluazowfS52dWVjYWwtLXR3ZWx2ZS1ob3VyIC52dWVjYWxfX3RpbWUtY29sdW1ue3dpZHRoOjRlbTtmb250LXNpemU6LjllbX0udnVlY2FsLS1vdmVyZmxvdy14LnZ1ZWNhbC0td2Vlay12aWV3IC52dWVjYWxfX3RpbWUtY29sdW1ue21hcmdpbi10b3A6Mi44ZW07Ym94LXNoYWRvdzowIDFweCAxcHggcmdiYSgwLDAsMCwuMyl9LnZ1ZWNhbC0tb3ZlcmZsb3cteC52dWVjYWwtLXdlZWstdmlldy52dWVjYWwtLXN0aWNreS1zcGxpdC1sYWJlbHMgLnZ1ZWNhbF9fdGltZS1jb2x1bW57bWFyZ2luLXRvcDozLjRlbX0udnVlY2FsLS1vdmVyZmxvdy14LnZ1ZWNhbC0tZGF5LXZpZXcudnVlY2FsLS1zdGlja3ktc3BsaXQtbGFiZWxzIC52dWVjYWxfX3RpbWUtY29sdW1ue21hcmdpbi10b3A6MS41ZW19LnZ1ZWNhbF9fdGltZS1jb2x1bW4gLnZ1ZWNhbF9fdGltZS1jZWxse2NvbG9yOiM5OTk7dGV4dC1hbGlnbjpyaWdodDtwYWRkaW5nLXJpZ2h0OjJweDtmb250LXNpemU6LjllbX0udnVlY2FsX190aW1lLWNvbHVtbiAudnVlY2FsX190aW1lLWNlbGwgLmxpbmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZX0udnVlY2FsX19jZWxsc3ttYXJnaW46MCAxcHggMXB4IDB9LnZ1ZWNhbC0tb3ZlcmZsb3cteC52dWVjYWwtLWRheS12aWV3IC52dWVjYWxfX2NlbGxze21hcmdpbjowfS52dWVjYWwtLWV2ZW50cy1vbi1tb250aC12aWV3LnZ1ZWNhbC0tc2hvcnQtZXZlbnRzIC52dWVjYWxfX2NlbGxze3dpZHRoOjk5LjklfS52dWVjYWwtLW92ZXJmbG93LXgudnVlY2FsLS1kYXktdmlldyAudnVlY2FsX19jZWxscywudnVlY2FsLS1vdmVyZmxvdy14LnZ1ZWNhbC0td2Vlay12aWV3IC52dWVjYWxfX2NlbGxze2ZsZXgtd3JhcDpub3dyYXA7b3ZlcmZsb3c6YXV0b30uc2xpZGUtZmFkZS0tbGVmdC1lbnRlci1hY3RpdmUsLnNsaWRlLWZhZGUtLWxlZnQtbGVhdmUtYWN0aXZlLC5zbGlkZS1mYWRlLS1yaWdodC1lbnRlci1hY3RpdmUsLnNsaWRlLWZhZGUtLXJpZ2h0LWxlYXZlLWFjdGl2ZXt0cmFuc2l0aW9uOi4yNXMgZWFzZS1vdXR9LnNsaWRlLWZhZGUtLWxlZnQtZW50ZXIsLnNsaWRlLWZhZGUtLXJpZ2h0LWxlYXZlLXRve3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xNXB4KTtvcGFjaXR5OjB9LnNsaWRlLWZhZGUtLWxlZnQtbGVhdmUtdG8sLnNsaWRlLWZhZGUtLXJpZ2h0LWVudGVye3RyYW5zZm9ybTp0cmFuc2xhdGVYKDE1cHgpO29wYWNpdHk6MH0uc2xpZGUtZmFkZS0tbGVmdC1sZWF2ZS1hY3RpdmUsLnNsaWRlLWZhZGUtLXJpZ2h0LWxlYXZlLWFjdGl2ZXtwb3NpdGlvbjphYnNvbHV0ZSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCV9LnZ1ZWNhbF9fdGl0bGUtYmFyIC5zbGlkZS1mYWRlLS1sZWZ0LWxlYXZlLWFjdGl2ZSwudnVlY2FsX190aXRsZS1iYXIgLnNsaWRlLWZhZGUtLXJpZ2h0LWxlYXZlLWFjdGl2ZXtsZWZ0OjA7cmlnaHQ6MDtoZWlnaHQ6YXV0b30udnVlY2FsX19oZWFkaW5nIC5zbGlkZS1mYWRlLS1sZWZ0LWxlYXZlLWFjdGl2ZSwudnVlY2FsX19oZWFkaW5nIC5zbGlkZS1mYWRlLS1yaWdodC1sZWF2ZS1hY3RpdmV7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0udnVlY2FsLS1ncmVlbi10aGVtZSAudnVlY2FsX19jZWxsLWV2ZW50cy1jb3VudCwudnVlY2FsLS1ncmVlbi10aGVtZSAudnVlY2FsX19tZW51e2JhY2tncm91bmQtY29sb3I6IzQyYjk4Mztjb2xvcjojZmZmfS52dWVjYWwtLWdyZWVuLXRoZW1lIC52dWVjYWxfX3RpdGxlLWJhcntiYWNrZ3JvdW5kLWNvbG9yOiNlNGY1ZWZ9LnZ1ZWNhbC0tZ3JlZW4tdGhlbWUgLnZ1ZWNhbF9fY2VsbC0tY3VycmVudCwudnVlY2FsLS1ncmVlbi10aGVtZSAudnVlY2FsX19jZWxsLS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjQwLDI0MCwyNTUsLjQpfS52dWVjYWwtLWdyZWVuLXRoZW1lOm5vdCgudnVlY2FsLS1kYXktdmlldykgLnZ1ZWNhbF9fY2VsbC0tc2VsZWN0ZWR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzNSwyNTUsMjQ1LC40KX0udnVlY2FsLS1ncmVlbi10aGVtZSAudnVlY2FsX19jZWxsLS1zZWxlY3RlZDpiZWZvcmV7Ym9yZGVyLWNvbG9yOnJnYmEoNjYsMTg1LDEzMSwuNSl9LnZ1ZWNhbC0tZ3JlZW4tdGhlbWUgLnZ1ZWNhbF9fY2VsbC0taGlnaGxpZ2h0ZWQ6bm90KC52dWVjYWxfX2NlbGwtLWhhcy1zcGxpdHMpLC52dWVjYWwtLWdyZWVuLXRoZW1lIC52dWVjYWxfX2NlbGwtc3BsaXQtLWhpZ2hsaWdodGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgxOTUsMjU1LDIyNSwuNSl9LnZ1ZWNhbC0tZ3JlZW4tdGhlbWUgLnZ1ZWNhbF9fYXJyb3ctLWhpZ2hsaWdodGVkLC52dWVjYWwtLWdyZWVuLXRoZW1lIC52dWVjYWxfX3RvZGF5LWJ0bi0taGlnaGxpZ2h0ZWQsLnZ1ZWNhbC0tZ3JlZW4tdGhlbWUgLnZ1ZWNhbF9fdmlldy1idG4tLWhpZ2hsaWdodGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgxMzYsMjM2LDE5MSwuMjUpfS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fY2VsbC1ldmVudHMtY291bnQsLnZ1ZWNhbC0tYmx1ZS10aGVtZSAudnVlY2FsX19tZW51e2JhY2tncm91bmQtY29sb3I6cmdiYSg2NiwxNjMsMTg1LC44KTtjb2xvcjojZmZmfS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fdGl0bGUtYmFye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDE2NSwxODgsLjMpfS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fY2VsbC0tY3VycmVudCwudnVlY2FsLS1ibHVlLXRoZW1lIC52dWVjYWxfX2NlbGwtLXRvZGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNDAsMjQwLDI1NSwuNCl9LnZ1ZWNhbC0tYmx1ZS10aGVtZTpub3QoLnZ1ZWNhbC0tZGF5LXZpZXcpIC52dWVjYWxfX2NlbGwtLXNlbGVjdGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzUsMjUzLDI1NSwuNCl9LnZ1ZWNhbC0tYmx1ZS10aGVtZSAudnVlY2FsX19jZWxsLS1zZWxlY3RlZDpiZWZvcmV7Ym9yZGVyLWNvbG9yOnJnYmEoMTE1LDE5MSwyMDQsLjUpfS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fY2VsbC0taGlnaGxpZ2h0ZWQ6bm90KC52dWVjYWxfX2NlbGwtLWhhcy1zcGxpdHMpLC52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fY2VsbC1zcGxpdC0taGlnaGxpZ2h0ZWR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMTY1LDE4OCwuMDYpfS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fYXJyb3ctLWhpZ2hsaWdodGVkLC52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fdG9kYXktYnRuLS1oaWdobGlnaHRlZCwudnVlY2FsLS1ibHVlLXRoZW1lIC52dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNjYsMTYzLDE4NSwuMil9LnZ1ZWNhbC0tcm91bmRlZC10aGVtZSAudnVlY2FsX193ZWVrZGF5cy1oZWFkaW5nc3tib3JkZXI6bm9uZX0udnVlY2FsLS1yb3VuZGVkLXRoZW1lIC52dWVjYWxfX2NlbGwsLnZ1ZWNhbC0tcm91bmRlZC10aGVtZTpub3QoLnZ1ZWNhbC0tZGF5LXZpZXcpIC52dWVjYWxfX2NlbGw6YmVmb3Jle2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZX0udnVlY2FsLS1yb3VuZGVkLXRoZW1lIC52dWVjYWxfX2NlbGwub3V0LW9mLXNjb3Ble29wYWNpdHk6LjR9LnZ1ZWNhbC0tcm91bmRlZC10aGVtZSAudnVlY2FsX19jZWxsLWNvbnRlbnR7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtmbGV4LWdyb3c6MDtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6MzBweDtjb2xvcjojMzMzfS52dWVjYWwtLXJvdW5kZWQtdGhlbWUudnVlY2FsLS1kYXktdmlldyAudnVlY2FsX19jZWxsLWNvbnRlbnR7d2lkdGg6YXV0bztiYWNrZ3JvdW5kOm5vbmV9LnZ1ZWNhbC0tcm91bmRlZC10aGVtZS52dWVjYWwtLXllYXItdmlldyAudnVlY2FsX19jZWxse3dpZHRoOjMzLjMzJX0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0teWVhci12aWV3IC52dWVjYWxfX2NlbGwtY29udGVudHt3aWR0aDo4NXB4fS52dWVjYWwtLXJvdW5kZWQtdGhlbWUudnVlY2FsLS15ZWFycy12aWV3IC52dWVjYWxfX2NlbGwtY29udGVudHt3aWR0aDo1MnB4fS52dWVjYWwtLXJvdW5kZWQtdGhlbWUgLnZ1ZWNhbF9fY2VsbHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50IWltcG9ydGFudH0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tZ3JlZW4tdGhlbWU6bm90KC52dWVjYWwtLWRheS12aWV3KSAudnVlY2FsX19jZWxsLWNvbnRlbnR7YmFja2dyb3VuZC1jb2xvcjojZjFmYWY3fS52dWVjYWwtLXJvdW5kZWQtdGhlbWUudnVlY2FsLS1ncmVlbi10aGVtZTpub3QoLnZ1ZWNhbC0tZGF5LXZpZXcpIC52dWVjYWxfX2NlbGwtLXRvZGF5IC52dWVjYWxfX2NlbGwtY29udGVudHtiYWNrZ3JvdW5kLWNvbG9yOiM0MmI5ODM7Y29sb3I6I2ZmZn0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tZ3JlZW4tdGhlbWUgLnZ1ZWNhbC0tZGF5LXZpZXcgLnZ1ZWNhbF9fY2VsbC0tdG9kYXk6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6cmdiYSg2NiwxODUsMTMxLC4wNSl9LnZ1ZWNhbC0tcm91bmRlZC10aGVtZS52dWVjYWwtLWdyZWVuLXRoZW1lOm5vdCgudnVlY2FsLS1kYXktdmlldykgLnZ1ZWNhbF9fY2VsbC0tc2VsZWN0ZWQgLnZ1ZWNhbF9fY2VsbC1jb250ZW50e2JvcmRlci1jb2xvcjojNDJiOTgzfS52dWVjYWwtLXJvdW5kZWQtdGhlbWUudnVlY2FsLS1ncmVlbi10aGVtZSAudnVlY2FsX19jZWxsLS1oaWdobGlnaHRlZDpub3QoLnZ1ZWNhbF9fY2VsbC0taGFzLXNwbGl0cyksLnZ1ZWNhbC0tcm91bmRlZC10aGVtZS52dWVjYWwtLWdyZWVuLXRoZW1lIC52dWVjYWxfX2NlbGwtc3BsaXQtLWhpZ2hsaWdodGVke2JhY2tncm91bmQtY29sb3I6cmdiYSgxOTUsMjU1LDIyNSwuNSl9LnZ1ZWNhbC0tcm91bmRlZC10aGVtZS52dWVjYWwtLWJsdWUtdGhlbWU6bm90KC52dWVjYWwtLWRheS12aWV3KSAudnVlY2FsX19jZWxsLWNvbnRlbnR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEwMCwxODIsMjU1LC4yKX0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tYmx1ZS10aGVtZTpub3QoLnZ1ZWNhbC0tZGF5LXZpZXcpIC52dWVjYWxfX2NlbGwtLXRvZGF5IC52dWVjYWxfX2NlbGwtY29udGVudHtiYWNrZ3JvdW5kLWNvbG9yOiM4ZmI3ZTQ7Y29sb3I6I2ZmZn0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tYmx1ZS10aGVtZSAudnVlY2FsLS1kYXktdmlldyAudnVlY2FsX19jZWxsLS10b2RheTpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE0MywxODMsMjI4LC4xKX0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tYmx1ZS10aGVtZTpub3QoLnZ1ZWNhbC0tZGF5LXZpZXcpIC52dWVjYWxfX2NlbGwtLXNlbGVjdGVkIC52dWVjYWxfX2NlbGwtY29udGVudHtib3JkZXItY29sb3I6IzYxYTllMH0udnVlY2FsLS1yb3VuZGVkLXRoZW1lLnZ1ZWNhbC0tYmx1ZS10aGVtZSAudnVlY2FsX19jZWxsLS1oaWdobGlnaHRlZDpub3QoLnZ1ZWNhbF9fY2VsbC0taGFzLXNwbGl0cyksLnZ1ZWNhbC0tcm91bmRlZC10aGVtZS52dWVjYWwtLWJsdWUtdGhlbWUgLnZ1ZWNhbF9fY2VsbC1zcGxpdC0taGlnaGxpZ2h0ZWR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMTY1LDE4OCwuMDYpfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnZ1ZWNhbF9fY2VsbDpiZWZvcmUge1xcbiAgYm9yZGVyOiAwO1xcbn1cXG4udnVlY2FsX19mbGV4IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcbi52dWVjYWwge1xcbiAgbWFyZ2luOiA1cHggMDtcXG4gIHBhZGRpbmc6IDVweCA4cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG59XFxuLmNhbC13cmFwcGVyIHtcXG4gIG1hcmdpbjogMnB4IDVweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiBjYWxjKDQ4dncgLSA0cHgpO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5jYWwtd3JhcHBlciAuY2FsLXRpdGxlIHtcXG4gIHBhZGRpbmc6IDVweCAwO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY29sb3I6ICMxMjEyMzY7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmNhbC13cmFwcGVyIC52dWVjYWwge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuLmNhbC13cmFwcGVyIC52dWVjYWxfX3RpdGxlLWJhciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uY2FsLXdyYXBwZXIgLnZ1ZWNhbF9faGVhZGluZyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uY2FsLXdyYXBwZXIgLmNhbGVuZGFyLWNlbGwge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgYm9yZGVyOiAycHggc29saWQgI2ZmZjtcXG59XFxuLmNhbC13cmFwcGVyIC5jYWxlbmRhci1jZWxsIC5kYXkge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgc2NhbGU6IDAuODtcXG59XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2VhcmNoLWNvbnRlbnRbZGF0YS12LTI5NjRmMjFiXSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1hcmdpbjogNTRweCAxMHB4IDVweDtcXG4gIHBhZGRpbmctdG9wOiAxMHB4O1xcbiAgY29sb3I6IHJnYmEoMTgsIDE4LCA1NCwgMC41KTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuLnNlYXJjaC1jb250ZW50IC5zZWFyY2gtaXRlbVtkYXRhLXYtMjk2NGYyMWJdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogNnB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG59XFxuLmFpci1jYWxlbmRhci1wYWdlW2RhdGEtdi0yOTY0ZjIxYl0ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYTtcXG59XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG4vKioqKioqLyBcdGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGRhdGEpIHtcbi8qKioqKiovIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuLyoqKioqKi8gXHRcdHZhciBtb3JlTW9kdWxlcyA9IGRhdGFbMV07XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcbi8qKioqKiovIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuLyoqKioqKi8gXHRcdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG4vKioqKioqLyBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4vKioqKioqLyBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbi8qKioqKiovIFx0XHRcdFx0cmVzb2x2ZXMucHVzaChpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4vKioqKioqLyBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuLyoqKioqKi8gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0aWYocGFyZW50SnNvbnBGdW5jdGlvbikgcGFyZW50SnNvbnBGdW5jdGlvbihkYXRhKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4vKioqKioqLyBcdFx0XHRyZXNvbHZlcy5zaGlmdCgpKCk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi9cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLyoqKioqKi8gXHQvLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8qKioqKiovIFx0Ly8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZENodW5rcyA9IHtcbi8qKioqKiovIFx0XHQzNzogMFxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBzY3JpcHQgcGF0aCBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBqc29ucFNjcmlwdFNyYyhjaHVua0lkKSB7XG4vKioqKioqLyBcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ucCArIFwidnVlY2FsLmNvbW1vbi5cIiArICh7XCIwXCI6XCJpMThuL2FyXCIsXCIxXCI6XCJpMThuL2JnXCIsXCIyXCI6XCJpMThuL2JuXCIsXCIzXCI6XCJpMThuL2JzXCIsXCI0XCI6XCJpMThuL2NhXCIsXCI1XCI6XCJpMThuL2NzXCIsXCI2XCI6XCJpMThuL2RhXCIsXCI3XCI6XCJpMThuL2RlXCIsXCI4XCI6XCJpMThuL2VsXCIsXCI5XCI6XCJpMThuL2VzXCIsXCIxMFwiOlwiaTE4bi9mYVwiLFwiMTFcIjpcImkxOG4vZnJcIixcIjEyXCI6XCJpMThuL2hlXCIsXCIxM1wiOlwiaTE4bi9oclwiLFwiMTRcIjpcImkxOG4vaHVcIixcIjE1XCI6XCJpMThuL2lkXCIsXCIxNlwiOlwiaTE4bi9pc1wiLFwiMTdcIjpcImkxOG4vaXRcIixcIjE4XCI6XCJpMThuL2phXCIsXCIxOVwiOlwiaTE4bi9rYVwiLFwiMjBcIjpcImkxOG4va29cIixcIjIxXCI6XCJpMThuL2x0XCIsXCIyMlwiOlwiaTE4bi9ubFwiLFwiMjNcIjpcImkxOG4vbm9cIixcIjI0XCI6XCJpMThuL3BsXCIsXCIyNVwiOlwiaTE4bi9wdC1iclwiLFwiMjZcIjpcImkxOG4vcm9cIixcIjI3XCI6XCJpMThuL3J1XCIsXCIyOFwiOlwiaTE4bi9za1wiLFwiMjlcIjpcImkxOG4vc2xcIixcIjMwXCI6XCJpMThuL3NyXCIsXCIzMVwiOlwiaTE4bi9zdlwiLFwiMzJcIjpcImkxOG4vdHJcIixcIjMzXCI6XCJpMThuL3VrXCIsXCIzNFwiOlwiaTE4bi92aVwiLFwiMzVcIjpcImkxOG4vemgtY25cIixcIjM2XCI6XCJpMThuL3poLWhrXCJ9W2NodW5rSWRdfHxjaHVua0lkKSArIFwiLmpzXCJcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vKioqKioqLyBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSBmdW5jdGlvbiByZXF1aXJlRW5zdXJlKGNodW5rSWQpIHtcbi8qKioqKiovIFx0XHR2YXIgcHJvbWlzZXMgPSBbXTtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcbi8qKioqKiovXG4vKioqKioqLyBcdFx0dmFyIGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIHsgLy8gMCBtZWFucyBcImFscmVhZHkgaW5zdGFsbGVkXCIuXG4vKioqKioqL1xuLyoqKioqKi8gXHRcdFx0Ly8gYSBQcm9taXNlIG1lYW5zIFwiY3VycmVudGx5IGxvYWRpbmdcIi5cbi8qKioqKiovIFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuLyoqKioqKi8gXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG4vKioqKioqLyBcdFx0XHR9IGVsc2Uge1xuLyoqKioqKi8gXHRcdFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG4vKioqKioqLyBcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4vKioqKioqLyBcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG4vKioqKioqLyBcdFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2UpO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHRcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuLyoqKioqKi8gXHRcdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4vKioqKioqLyBcdFx0XHRcdHZhciBvblNjcmlwdENvbXBsZXRlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHRcdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuLyoqKioqKi8gXHRcdFx0XHRzY3JpcHQudGltZW91dCA9IDEyMDtcbi8qKioqKiovIFx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdFx0c2NyaXB0LnNyYyA9IGpzb25wU2NyaXB0U3JjKGNodW5rSWQpO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHRcdFx0Ly8gY3JlYXRlIGVycm9yIGJlZm9yZSBzdGFjayB1bndvdW5kIHRvIGdldCB1c2VmdWwgc3RhY2t0cmFjZSBsYXRlclxuLyoqKioqKi8gXHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbi8qKioqKiovIFx0XHRcdFx0b25TY3JpcHRDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuLyoqKioqKi8gXHRcdFx0XHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cbi8qKioqKiovIFx0XHRcdFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuLyoqKioqKi8gXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbi8qKioqKiovIFx0XHRcdFx0XHR2YXIgY2h1bmsgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4vKioqKioqLyBcdFx0XHRcdFx0aWYoY2h1bmsgIT09IDApIHtcbi8qKioqKiovIFx0XHRcdFx0XHRcdGlmKGNodW5rKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG4vKioqKioqLyBcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG4vKioqKioqLyBcdFx0XHRcdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG4vKioqKioqLyBcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuLyoqKioqKi8gXHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuLyoqKioqKi8gXHRcdFx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcbi8qKioqKiovIFx0XHRcdFx0XHRcdFx0Y2h1bmtbMV0oZXJyb3IpO1xuLyoqKioqKi8gXHRcdFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuLyoqKioqKi8gXHRcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdFx0fTtcbi8qKioqKiovIFx0XHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4vKioqKioqLyBcdFx0XHRcdFx0b25TY3JpcHRDb21wbGV0ZSh7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSk7XG4vKioqKioqLyBcdFx0XHRcdH0sIDEyMDAwMCk7XG4vKioqKioqLyBcdFx0XHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGU7XG4vKioqKioqLyBcdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0dmFyIGpzb25wQXJyYXkgPSAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpW1wid2VicGFja0pzb25wdnVlY2FsXCJdID0gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKVtcIndlYnBhY2tKc29ucHZ1ZWNhbFwiXSB8fCBbXTtcbi8qKioqKiovIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbi8qKioqKiovIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4vKioqKioqLyBcdGpzb25wQXJyYXkgPSBqc29ucEFycmF5LnNsaWNlKCk7XG4vKioqKioqLyBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbi8qKioqKiovIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcImZiMTVcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiMDBhYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDBlZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwMzY2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWMwYlwiKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwNTdmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmM2YVwiKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MWNcIikuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwNmNmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4M2FiXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQxZTdcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjNmNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjNmFcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzA0ZVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwY2ZiXCIpO1xuXG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBjZmJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjMTJcIik7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMTQ4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE2OTFcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZDgwXCIpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBlYXRcbm1vZHVsZS5leHBvcnRzID0gJycucmVwZWF0IHx8IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG51bWJlciBvZiByZXBldGl0aW9ucycpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzdWx0ICs9IHN0cjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTI3NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3ODRcIik7XG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRlN1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDg0MFwiKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGFhNVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGM0XCIpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE0YzNcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MjYzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG5cbnZhciBhcnJheVB1c2ggPSBbXS5wdXNoO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xuXG4vLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ3gnLCAneScpIC0+IC94L3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gIVJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKFNQTElULCBuYXRpdmVTcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuICBpZiAoXG4gICAgJ2FiYmMnLnNwbGl0KC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aFxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weS5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSBhcnJheVB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW0gPyBvdXRwdXQuc2xpY2UoMCwgbGltKSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHVuZGVmaW5lZCwgMCkubGVuZ3RoKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IG5hdGl2ZVNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIGludGVybmFsU3BsaXQgPSBuYXRpdmVTcGxpdDtcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcblxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTtcblxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSwgIVNVUFBPUlRTX1kpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjEzZDVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgJHJlZHVjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNThmXCIpLmxlZnQ7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjQwXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgncmVkdWNlJyk7XG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgncmVkdWNlJywgeyAxOiAwIH0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNGMzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2YjZcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MjYzXCIpO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4cEV4ZWMuY2FsbChSLCBTKTtcbn07XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNTE2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNTliXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGE4NFwiKTtcbnZhciBET01JdGVyYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmRiY1wiKTtcbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE3YzJcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUgJiYgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoICE9PSBmb3JFYWNoKSB0cnkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGZvckVhY2gpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCA9IGZvckVhY2g7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNzkwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXAgPSB7XG5cdFwiLi9hclwiOiBbXG5cdFx0XCJiZDViXCIsXG5cdFx0MFxuXHRdLFxuXHRcIi4vYXIuanNvblwiOiBbXG5cdFx0XCJiZDViXCIsXG5cdFx0MFxuXHRdLFxuXHRcIi4vYmdcIjogW1xuXHRcdFwiM2U0OFwiLFxuXHRcdDFcblx0XSxcblx0XCIuL2JnLmpzb25cIjogW1xuXHRcdFwiM2U0OFwiLFxuXHRcdDFcblx0XSxcblx0XCIuL2JuXCI6IFtcblx0XHRcImUxNjBcIixcblx0XHQyXG5cdF0sXG5cdFwiLi9ibi5qc29uXCI6IFtcblx0XHRcImUxNjBcIixcblx0XHQyXG5cdF0sXG5cdFwiLi9ic1wiOiBbXG5cdFx0XCI1M2ZlXCIsXG5cdFx0M1xuXHRdLFxuXHRcIi4vYnMuanNvblwiOiBbXG5cdFx0XCI1M2ZlXCIsXG5cdFx0M1xuXHRdLFxuXHRcIi4vY2FcIjogW1xuXHRcdFwiMzZlZVwiLFxuXHRcdDRcblx0XSxcblx0XCIuL2NhLmpzb25cIjogW1xuXHRcdFwiMzZlZVwiLFxuXHRcdDRcblx0XSxcblx0XCIuL2NzXCI6IFtcblx0XHRcImUzYWRcIixcblx0XHQ1XG5cdF0sXG5cdFwiLi9jcy5qc29uXCI6IFtcblx0XHRcImUzYWRcIixcblx0XHQ1XG5cdF0sXG5cdFwiLi9kYVwiOiBbXG5cdFx0XCJlNWJjXCIsXG5cdFx0NlxuXHRdLFxuXHRcIi4vZGEuanNvblwiOiBbXG5cdFx0XCJlNWJjXCIsXG5cdFx0NlxuXHRdLFxuXHRcIi4vZGVcIjogW1xuXHRcdFwiOGQ3ZFwiLFxuXHRcdDdcblx0XSxcblx0XCIuL2RlLmpzb25cIjogW1xuXHRcdFwiOGQ3ZFwiLFxuXHRcdDdcblx0XSxcblx0XCIuL2VsXCI6IFtcblx0XHRcIjllNzBcIixcblx0XHQ4XG5cdF0sXG5cdFwiLi9lbC5qc29uXCI6IFtcblx0XHRcIjllNzBcIixcblx0XHQ4XG5cdF0sXG5cdFwiLi9lblwiOiBbXG5cdFx0XCI3MjEzXCJcblx0XSxcblx0XCIuL2VuLmpzb25cIjogW1xuXHRcdFwiNzIxM1wiXG5cdF0sXG5cdFwiLi9lc1wiOiBbXG5cdFx0XCJlMjQwXCIsXG5cdFx0OVxuXHRdLFxuXHRcIi4vZXMuanNvblwiOiBbXG5cdFx0XCJlMjQwXCIsXG5cdFx0OVxuXHRdLFxuXHRcIi4vZmFcIjogW1xuXHRcdFwiZDUzYlwiLFxuXHRcdDEwXG5cdF0sXG5cdFwiLi9mYS5qc29uXCI6IFtcblx0XHRcImQ1M2JcIixcblx0XHQxMFxuXHRdLFxuXHRcIi4vZnJcIjogW1xuXHRcdFwiMDY5OVwiLFxuXHRcdDExXG5cdF0sXG5cdFwiLi9mci5qc29uXCI6IFtcblx0XHRcIjA2OTlcIixcblx0XHQxMVxuXHRdLFxuXHRcIi4vaGVcIjogW1xuXHRcdFwiNjE2ZVwiLFxuXHRcdDEyXG5cdF0sXG5cdFwiLi9oZS5qc29uXCI6IFtcblx0XHRcIjYxNmVcIixcblx0XHQxMlxuXHRdLFxuXHRcIi4vaHJcIjogW1xuXHRcdFwiN2NkNFwiLFxuXHRcdDEzXG5cdF0sXG5cdFwiLi9oci5qc29uXCI6IFtcblx0XHRcIjdjZDRcIixcblx0XHQxM1xuXHRdLFxuXHRcIi4vaHVcIjogW1xuXHRcdFwiZTEzMVwiLFxuXHRcdDE0XG5cdF0sXG5cdFwiLi9odS5qc29uXCI6IFtcblx0XHRcImUxMzFcIixcblx0XHQxNFxuXHRdLFxuXHRcIi4vaWRcIjogW1xuXHRcdFwiMjE0N1wiLFxuXHRcdDE1XG5cdF0sXG5cdFwiLi9pZC5qc29uXCI6IFtcblx0XHRcIjIxNDdcIixcblx0XHQxNVxuXHRdLFxuXHRcIi4vaXNcIjogW1xuXHRcdFwiNTAzZlwiLFxuXHRcdDE2XG5cdF0sXG5cdFwiLi9pcy5qc29uXCI6IFtcblx0XHRcIjUwM2ZcIixcblx0XHQxNlxuXHRdLFxuXHRcIi4vaXRcIjogW1xuXHRcdFwiZWVkN1wiLFxuXHRcdDE3XG5cdF0sXG5cdFwiLi9pdC5qc29uXCI6IFtcblx0XHRcImVlZDdcIixcblx0XHQxN1xuXHRdLFxuXHRcIi4vamFcIjogW1xuXHRcdFwiMzlmN1wiLFxuXHRcdDE4XG5cdF0sXG5cdFwiLi9qYS5qc29uXCI6IFtcblx0XHRcIjM5ZjdcIixcblx0XHQxOFxuXHRdLFxuXHRcIi4va2FcIjogW1xuXHRcdFwiYWNiZFwiLFxuXHRcdDE5XG5cdF0sXG5cdFwiLi9rYS5qc29uXCI6IFtcblx0XHRcImFjYmRcIixcblx0XHQxOVxuXHRdLFxuXHRcIi4va29cIjogW1xuXHRcdFwiNTBkY1wiLFxuXHRcdDIwXG5cdF0sXG5cdFwiLi9rby5qc29uXCI6IFtcblx0XHRcIjUwZGNcIixcblx0XHQyMFxuXHRdLFxuXHRcIi4vbHRcIjogW1xuXHRcdFwiOGVkMlwiLFxuXHRcdDIxXG5cdF0sXG5cdFwiLi9sdC5qc29uXCI6IFtcblx0XHRcIjhlZDJcIixcblx0XHQyMVxuXHRdLFxuXHRcIi4vbmxcIjogW1xuXHRcdFwiYjI1OFwiLFxuXHRcdDIyXG5cdF0sXG5cdFwiLi9ubC5qc29uXCI6IFtcblx0XHRcImIyNThcIixcblx0XHQyMlxuXHRdLFxuXHRcIi4vbm9cIjogW1xuXHRcdFwiZjFlZlwiLFxuXHRcdDIzXG5cdF0sXG5cdFwiLi9uby5qc29uXCI6IFtcblx0XHRcImYxZWZcIixcblx0XHQyM1xuXHRdLFxuXHRcIi4vcGxcIjogW1xuXHRcdFwiNjA3OVwiLFxuXHRcdDI0XG5cdF0sXG5cdFwiLi9wbC5qc29uXCI6IFtcblx0XHRcIjYwNzlcIixcblx0XHQyNFxuXHRdLFxuXHRcIi4vcHQtYnJcIjogW1xuXHRcdFwiODlmNFwiLFxuXHRcdDI1XG5cdF0sXG5cdFwiLi9wdC1ici5qc29uXCI6IFtcblx0XHRcIjg5ZjRcIixcblx0XHQyNVxuXHRdLFxuXHRcIi4vcm9cIjogW1xuXHRcdFwiYWJmNVwiLFxuXHRcdDI2XG5cdF0sXG5cdFwiLi9yby5qc29uXCI6IFtcblx0XHRcImFiZjVcIixcblx0XHQyNlxuXHRdLFxuXHRcIi4vcnVcIjogW1xuXHRcdFwiYTY1YVwiLFxuXHRcdDI3XG5cdF0sXG5cdFwiLi9ydS5qc29uXCI6IFtcblx0XHRcImE2NWFcIixcblx0XHQyN1xuXHRdLFxuXHRcIi4vc2tcIjogW1xuXHRcdFwiYTM5ZVwiLFxuXHRcdDI4XG5cdF0sXG5cdFwiLi9zay5qc29uXCI6IFtcblx0XHRcImEzOWVcIixcblx0XHQyOFxuXHRdLFxuXHRcIi4vc2xcIjogW1xuXHRcdFwiYzlhNVwiLFxuXHRcdDI5XG5cdF0sXG5cdFwiLi9zbC5qc29uXCI6IFtcblx0XHRcImM5YTVcIixcblx0XHQyOVxuXHRdLFxuXHRcIi4vc3JcIjogW1xuXHRcdFwiNzk4MVwiLFxuXHRcdDMwXG5cdF0sXG5cdFwiLi9zci5qc29uXCI6IFtcblx0XHRcIjc5ODFcIixcblx0XHQzMFxuXHRdLFxuXHRcIi4vc3ZcIjogW1xuXHRcdFwiMmE2YlwiLFxuXHRcdDMxXG5cdF0sXG5cdFwiLi9zdi5qc29uXCI6IFtcblx0XHRcIjJhNmJcIixcblx0XHQzMVxuXHRdLFxuXHRcIi4vdHJcIjogW1xuXHRcdFwiMjc4ZVwiLFxuXHRcdDMyXG5cdF0sXG5cdFwiLi90ci5qc29uXCI6IFtcblx0XHRcIjI3OGVcIixcblx0XHQzMlxuXHRdLFxuXHRcIi4vdWtcIjogW1xuXHRcdFwiNzQwNVwiLFxuXHRcdDMzXG5cdF0sXG5cdFwiLi91ay5qc29uXCI6IFtcblx0XHRcIjc0MDVcIixcblx0XHQzM1xuXHRdLFxuXHRcIi4vdmlcIjogW1xuXHRcdFwiYzVmOFwiLFxuXHRcdDM0XG5cdF0sXG5cdFwiLi92aS5qc29uXCI6IFtcblx0XHRcImM1ZjhcIixcblx0XHQzNFxuXHRdLFxuXHRcIi4vemgtY25cIjogW1xuXHRcdFwiODhiNFwiLFxuXHRcdDM1XG5cdF0sXG5cdFwiLi96aC1jbi5qc29uXCI6IFtcblx0XHRcIjg4YjRcIixcblx0XHQzNVxuXHRdLFxuXHRcIi4vemgtaGtcIjogW1xuXHRcdFwiY2I0NlwiLFxuXHRcdDM2XG5cdF0sXG5cdFwiLi96aC1oay5qc29uXCI6IFtcblx0XHRcImNiNDZcIixcblx0XHQzNlxuXHRdXG59O1xuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHRcdHRocm93IGU7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgaWRzID0gbWFwW3JlcV0sIGlkID0gaWRzWzBdO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoaWRzLnNsaWNlKDEpLm1hcChfX3dlYnBhY2tfcmVxdWlyZV9fLmUpKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnQoaWQsIDMpO1xuXHR9KTtcbn1cbndlYnBhY2tBc3luY0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tBc3luY0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQXN5bmNDb250ZXh0LmlkID0gXCIxNzkwXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tBc3luY0NvbnRleHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjE3YzJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNzI3XCIpLmZvckVhY2g7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjQwXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZm9yRWFjaCcpO1xudmFyIFVTRVNfVE9fTEVOR1RIID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5tb2R1bGUuZXhwb3J0cyA9ICghU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEgpID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSA6IFtdLmZvckVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTlhYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFhNGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFiZTRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDA2NlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxYzBiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWM3ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxY2RjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzQyZlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAvKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxZDgwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFkZGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDAwXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjAyOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfd2Vla2RheXNfaGVhZGluZ3NfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjcyNWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX3dlZWtkYXlzX2hlYWRpbmdzX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfd2Vla2RheXNfaGVhZGluZ3NfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc193ZWVrZGF5c19oZWFkaW5nc192dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjIyNjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU5NWFcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBjNFwiKTtcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzNjZcIik7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzVhMVwiKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZGRcIik7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIGl0ZXJhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZm4sIHRoYXQsIEFTX0VOVFJJRVMsIElTX0lURVJBVE9SKSB7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChmbiwgdGhhdCwgQVNfRU5UUklFUyA/IDIgOiAxKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IEFTX0VOVFJJRVNcbiAgICAgICAgICA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pXG4gICAgICAgICAgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgcmVzdWx0ID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgYm91bmRGdW5jdGlvbiwgc3RlcC52YWx1ZSwgQVNfRU5UUklFUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG59O1xuXG5pdGVyYXRlLnN0b3AgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIHJlc3VsdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjIzY2JcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjkxXCIpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjNlN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA2Y2ZcIikuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZTRlXCIpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTg5M1wiKTtcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NGNhXCIpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjQxY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhODRcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzgzOVwiKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjUzMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBub3RBUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVhMzRcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZDgwXCIpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFiMTNcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhflN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKVxuICAgICAgLmluZGV4T2Yobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI1ZjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBmbGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZDZkXCIpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG5hdGl2ZVRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IG5hdGl2ZVRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwID0gU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgcmYgPSBSLmZsYWdzO1xuICAgIHZhciBmID0gU3RyaW5nKHJmID09PSB1bmRlZmluZWQgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlKSA/IGZsYWdzLmNhbGwoUikgOiByZik7XG4gICAgcmV0dXJuICcvJyArIHAgKyAnLycgKyBmO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNjI2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDY2XCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZjJcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmNmNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2YjZcIik7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzY2XCIpO1xudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWJlNFwiKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjMTJcIik7XG52YXIgSVNfSU9TID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjZGNcIik7XG5cbnZhciBsb2NhdGlvbiA9IGdsb2JhbC5sb2NhdGlvbjtcbnZhciBzZXQgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG52YXIgcnVuID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBydW5uZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBydW4oaWQpO1xuICB9O1xufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bihldmVudC5kYXRhKTtcbn07XG5cbnZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG4gIC8vIG9sZCBlbmdpbmVzIGhhdmUgbm90IGxvY2F0aW9uLm9yaWdpblxuICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG59O1xuXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiAgc2V0ID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2socnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhydW5uZXIoaWQpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIC8vIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjI0XG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUykge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzICYmICFmYWlscyhwb3N0KSkge1xuICAgIGRlZmVyID0gcG9zdDtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJkMDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNDJmXCIpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSArIG1hdGNoWzFdO1xufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb24gJiYgK3ZlcnNpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzQyZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDY2XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzNWExXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY1ZGZcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNmOGNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzN2U4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4M2FiXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZjJcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRmNzVcIik7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzOGM0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzOGNmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgcmVwZWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExNDhcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGVhdFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlIH0sIHtcbiAgcmVwZWF0OiByZXBlYXRcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNiYmVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNjYTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjaGFyQXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjU0N1wiKS5jaGFyQXQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWYzXCIpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdkZDBcIik7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2Y4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQxNjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxN2MyXCIpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT0gZm9yRWFjaCB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2hcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQyOGZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NGFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzZiNlwiKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NGQyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M3M1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmYyXCIpO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ0ZGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDRlN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2YjZcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ1ZmNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgJHNvbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjcyN1wiKS5zb21lO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTY0MFwiKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZTQwXCIpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ3NvbWUnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzb21lJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ4NDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjMGJcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0OTMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGQ2NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjNmFcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBjNFwiKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNjYlwiKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGRlNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciAkZmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI3MjdcIikuZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWRkZVwiKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZTQwXCIpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2ZpbHRlcicpO1xuLy8gRWRnZSAxNC0gaXNzdWVcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdmaWx0ZXInKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIHx8ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0ZGY0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzY2XCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdiMGJcIik7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmRkXCIpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOTVhXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwYzRcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODQxOFwiKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNWExXCIpO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTtcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IG5ldyBDKCk7XG4gICAgZm9yICg7IShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0ZmFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgJGVudHJpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmY1M1wiKS5lbnRyaWVzO1xuXG4vLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhPKSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKE8pO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1MGM0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTY5MVwiKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUxMzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUzMTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNzg0XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2IwYlwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGM0XCIpO1xudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjkxXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGFhNVwiKTtcbnZhciByZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE0YzNcIik7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlLCByZWFzb24pIHtcbiAgdmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gcmVhc29uLlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFO1xuICB2YXIgUkVQTEFDRV9LRUVQU18kMCA9IHJlYXNvbi5SRVBMQUNFX0tFRVBTXyQwO1xuICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogbmF0aXZlUmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgaWYgKFxuICAgICAgICAoIVJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFICYmIFJFUExBQ0VfS0VFUFNfJDApIHx8XG4gICAgICAgICh0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnc3RyaW5nJyAmJiByZXBsYWNlVmFsdWUuaW5kZXhPZihVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgfVxuICBdO1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgICB2YXIgY2FwdHVyZTtcbiAgICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTY5MlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNDMwXCIpO1xudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2Y2RcIik7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy42LjQnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1NmVmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwNjZcIik7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNDFjXCIpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NDE4XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU4OTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5tb2R1bGUuZXhwb3J0cyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1OGE4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFkODBcIik7XG52YXIgd2hpdGVzcGFjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTg5OVwiKTtcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjVhMzRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0ZTdcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1YzZjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjA2MlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbGxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmQ2MVwiKTtcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY1NjZcIik7XG5cbi8vIGBTZXRgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zZXQtb2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjYwZGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4M2FiXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkZjc1XCIpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NDE4XCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQxZTdcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2IwYlwiKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0YWRcIik7XG5cbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG5tb2R1bGUuZXhwb3J0cyA9ICFuYXRpdmVBc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgbmF0aXZlQXNzaWduKHsgYjogMSB9LCBuYXRpdmVBc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCB7IGI6IDIgfSkpLmIgIT09IDEpIHJldHVybiB0cnVlO1xuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogbmF0aXZlQXNzaWduO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY1NDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjkxXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NTY2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKS5mO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YzczXCIpO1xudmFyIHJlZGVmaW5lQWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyY2NcIik7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzY2XCIpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTlhYVwiKTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIyNjZcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2RkMFwiKTtcbnZhciBzZXRTcGVjaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI2MjZcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcbnZhciBmYXN0S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxODNcIikuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5ZjNcIik7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUykgdGhhdC5zaXplID0gMDtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgIHZhciBwcmV2aW91cywgaW5kZXg7XG4gICAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xuICAgICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIC8vIGZhc3QgY2FzZVxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07XG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT0gZW50cnkpIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZS0tO1xuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eShDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgZGVmaW5lSXRlcmF0b3IoQywgQ09OU1RSVUNUT1JfTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogZW50cnkudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICByZXR1cm4geyB2YWx1ZTogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NWYwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThiNVwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBuZXcgKEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQykobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY5ZjNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZjlhXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG52YXIgb2JqZWN0SGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY3NzJcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDEyXCIpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuICB2YXIgc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2ZDYxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk0Y2FcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmVlYlwiKTtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxODNcIik7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMjY2XCIpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTlhYVwiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjN2VcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDQ0ZVwiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3MTU2XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FLCB3cmFwcGVyLCBjb21tb24pIHtcbiAgdmFyIElTX01BUCA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignTWFwJykgIT09IC0xO1xuICB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgQ29uc3RydWN0b3IgPSBOYXRpdmVDb25zdHJ1Y3RvcjtcbiAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gTmF0aXZlUHJvdG90eXBlW0tFWV07XG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvdG90eXBlLCBLRVksXG4gICAgICBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gdW5kZWZpbmVkIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0eXBlb2YgTmF0aXZlQ29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLlJFUVVJUkVEID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihpdGVyYWJsZSk7IH0pO1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlQ29uc3RydWN0b3IoKSwgZHVtbXksIENvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHRoYXQsIElTX01BUCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBOYXRpdmVQcm90b3R5cGU7XG4gICAgICBOYXRpdmVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcblxuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgTmF0aXZlUHJvdG90eXBlLmNsZWFyKSBkZWxldGUgTmF0aXZlUHJvdG90eXBlLmNsZWFyO1xuICB9XG5cbiAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBDb25zdHJ1Y3RvciAhPSBOYXRpdmVDb25zdHJ1Y3RvciB9LCBleHBvcnRlZCk7XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZlZWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MTEyXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZTRlXCIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODkyNVwiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5ZjNcIik7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZmNTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkZjc1XCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQxZTdcIikuZjtcblxuLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sIGtleSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goVE9fRU5UUklFUyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBPYmplY3QuZW50cmllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4gIHZhbHVlczogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3MTU2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyYmJcIik7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICB0eXBlb2YgKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSA9PSAnZnVuY3Rpb24nICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzIxM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT04ucGFyc2UoXCJ7XFxcIndlZWtEYXlzXFxcIjpbXFxcIk1vbmRheVxcXCIsXFxcIlR1ZXNkYXlcXFwiLFxcXCJXZWRuZXNkYXlcXFwiLFxcXCJUaHVyc2RheVxcXCIsXFxcIkZyaWRheVxcXCIsXFxcIlNhdHVyZGF5XFxcIixcXFwiU3VuZGF5XFxcIl0sXFxcIm1vbnRoc1xcXCI6W1xcXCJKYW51YXJ5XFxcIixcXFwiRmVicnVhcnlcXFwiLFxcXCJNYXJjaFxcXCIsXFxcIkFwcmlsXFxcIixcXFwiTWF5XFxcIixcXFwiSnVuZVxcXCIsXFxcIkp1bHlcXFwiLFxcXCJBdWd1c3RcXFwiLFxcXCJTZXB0ZW1iZXJcXFwiLFxcXCJPY3RvYmVyXFxcIixcXFwiTm92ZW1iZXJcXFwiLFxcXCJEZWNlbWJlclxcXCJdLFxcXCJ5ZWFyc1xcXCI6XFxcIlllYXJzXFxcIixcXFwieWVhclxcXCI6XFxcIlllYXJcXFwiLFxcXCJtb250aFxcXCI6XFxcIk1vbnRoXFxcIixcXFwid2Vla1xcXCI6XFxcIldlZWtcXFwiLFxcXCJkYXlcXFwiOlxcXCJEYXlcXFwiLFxcXCJ0b2RheVxcXCI6XFxcIlRvZGF5XFxcIixcXFwibm9FdmVudFxcXCI6XFxcIk5vIEV2ZW50XFxcIixcXFwiYWxsRGF5XFxcIjpcXFwiQWxsIGRheVxcXCIsXFxcImRlbGV0ZUV2ZW50XFxcIjpcXFwiRGVsZXRlXFxcIixcXFwiY3JlYXRlRXZlbnRcXFwiOlxcXCJDcmVhdGUgYW4gZXZlbnRcXFwiLFxcXCJkYXRlRm9ybWF0XFxcIjpcXFwiZGRkZCBNTU1NIER7U30sIFlZWVlcXFwifVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzI1ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzQxOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc0NmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDI4ZlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1MzhcIik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc4MzlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2IwYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZDgwXCIpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3YzczXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzdlOFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ODM5XCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAxMlwiKTtcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFiZTRcIik7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjMTJcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY3NzJcIik7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBkb2N1bWVudC5kb21haW4gJiYgbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdkYjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgJGZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjcyN1wiKS5maW5kO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRkMlwiKTtcbnZhciBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZTQwXCIpO1xuXG52YXIgRklORCA9ICdmaW5kJztcbnZhciBTS0lQU19IT0xFUyA9IHRydWU7XG5cbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKEZJTkQpO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0tJUFNfSE9MRVMgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZGQwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWVkM1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMTYzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyYmJcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDQ0ZVwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNjIyXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzQzMFwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y4Y1wiKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlOTNcIik7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdmOWFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODkyNVwiKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODFkNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdiMGJcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzY2JcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBjNFwiKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4MjVhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4M2FiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NDE4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzA0ZVwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmYyXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YzZjXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjg1N2FcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcblxudmFyIHF1b3QgPSAvXCIvZztcblxuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVodG1sXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHN0cmluZykpO1xuICB2YXIgcDEgPSAnPCcgKyB0YWc7XG4gIGlmIChhdHRyaWJ1dGUgIT09ICcnKSBwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODYxZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4OTI1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmNkXCIpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGFhNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NTQ3XCIpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGJiZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ2dWVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkwZTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkxMTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWM2Y1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTI2M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHJlZ2V4cEZsYWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFkNmRcIik7XG52YXIgc3RpY2t5SGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZjdmXCIpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbnZhciBVTlNVUFBPUlRFRF9ZID0gc3RpY2t5SGVscGVycy5VTlNVUFBPUlRFRF9ZIHx8IHN0aWNreUhlbHBlcnMuQlJPS0VOX0NBUkVUO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRCB8fCBVTlNVUFBPUlRFRF9ZO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gcmVnZXhwRmxhZ3MuY2FsbChyZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoJ3knLCAnJyk7XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZignZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBTdHJpbmcoc3RyKS5zbGljZShyZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgc3RyW3JlLmxhc3RJbmRleCAtIDFdICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwoc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gbWF0Y2guaW5wdXQuc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NGNhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk5YWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU4YjVcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjBiXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwYzRcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODQxOFwiKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjVmMFwiKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFkZGVcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDAwXCIpO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xuXG4vLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBTUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdjb25jYXQnKTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSB0b0xlbmd0aChFLmxlbmd0aCk7XG4gICAgICAgIGlmIChuICsgbGVuID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliZGRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliZjJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGNmYlwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNGVcIik7XG5cbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZWQzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWU5M1wiKS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M3M1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWM2Y1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNDRlXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZjhjXCIpO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWY3ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3IsXG4vLyBzbyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUkUocywgZikge1xuICByZXR1cm4gUmVnRXhwKHMsIGYpO1xufVxuXG5leHBvcnRzLlVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG4gIHZhciByZSA9IFJFKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbmV4cG9ydHMuQlJPS0VOX0NBUkVUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NzM2ODdcbiAgdmFyIHJlID0gUkUoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWZmNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfZXZlbnRfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1MTZcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2V2ZW50X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfZXZlbnRfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19ldmVudF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImExNWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NGFkXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTY0MFwiKTtcblxudmFyIG5hdGl2ZUpvaW4gPSBbXS5qb2luO1xuXG52YXIgRVMzX1NUUklOR1MgPSBJbmRleGVkT2JqZWN0ICE9IE9iamVjdDtcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnam9pbicsICcsJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuam9pbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuam9pblxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRVMzX1NUUklOR1MgfHwgIVNUUklDVF9NRVRIT0QgfSwge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBuYXRpdmVKb2luLmNhbGwodG9JbmRleGVkT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE0MzRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzY2JcIik7XG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE2OTFcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBjNFwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjBiXCIpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NWYwXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0MThcIik7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZGRlXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc3BsaWNlJyk7XG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnc3BsaWNlJywgeyBBQ0NFU1NPUlM6IHRydWUsIDA6IDAsIDE6IDIgfSk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50IC8qICwgLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCk7XG4gICAgfVxuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xuICAgIH0gZWxzZSBpZiAoaW5zZXJ0Q291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudCAtIDE7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE0ZDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDY2XCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzQzMFwiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4M2FiXCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDkzMFwiKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmZGJmXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOGI1XCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjBiXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNGVcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjNmNcIik7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjNzNcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkZjc1XCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjQxY1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDU3ZlwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzQxOFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDZjZlwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmYyXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQxZTdcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmVlYlwiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTY5MlwiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMTJcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwZTNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTM4XCIpO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NDZmXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ0NGVcIik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWYzXCIpO1xudmFyICRmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI3MjdcIikuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9QcmltaXRpdmUoViwgdHJ1ZSk7XG4gIHZhciBlbnVtZXJhYmxlID0gbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZChkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFJU19QVVJFKSB7XG4gICAgICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcblxuJGZvckVhY2gob2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG59KTtcblxuJCh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhrZXkpO1xuICAgIGlmIChoYXMoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbChzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfSxcbiAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWSA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpO1xuICAgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gICAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9ICdbbnVsbF0nXG4gICAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgICAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG4gIH0pO1xuXG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfSlNPTl9TVFJJTkdJRlkgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgJHJlcGxhY2VyO1xuICAgICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpbmRleCkgYXJncy5wdXNoKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgICAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgICByZXR1cm4gJHN0cmluZ2lmeS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcblxuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNjMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZnJvbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZGY0XCIpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYzdlXCIpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIGZyb206IGZyb21cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE2NDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHRocm93IDE7IH0sIDEpO1xuICB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTY5MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTllM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTRjYVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzZiNlwiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3MTU2XCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNGVcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M3M1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MWNcIikuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDZjZlwiKS5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZjJcIikuZjtcbnZhciB0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4YThcIikudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyIE5hdGl2ZU51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE5hdGl2ZU51bWJlci5wcm90b3R5cGU7XG5cbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DTEFTU09GID0gY2xhc3NvZihjcmVhdGUoTnVtYmVyUHJvdG90eXBlKSkgPT0gTlVNQkVSO1xuXG4vLyBgVG9OdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IHRyaW0oaXQpO1xuICAgIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZGlnaXRzID0gaXQuc2xpY2UoMik7XG4gICAgICBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLWNvbnN0cnVjdG9yXG5pZiAoaXNGb3JjZWQoTlVNQkVSLCAhTmF0aXZlTnVtYmVyKCcgMG8xJykgfHwgIU5hdGl2ZU51bWJlcignMGIxJykgfHwgTmF0aXZlTnVtYmVyKCcrMHgxJykpKSB7XG4gIHZhciBOdW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIGR1bW15ID0gdGhpcztcbiAgICByZXR1cm4gZHVtbXkgaW5zdGFuY2VvZiBOdW1iZXJXcmFwcGVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ0xBU1NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgTnVtYmVyUHJvdG90eXBlLnZhbHVlT2YuY2FsbChkdW1teSk7IH0pIDogY2xhc3NvZihkdW1teSkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVOdW1iZXIodG9OdW1iZXIoaXQpKSwgZHVtbXksIE51bWJlcldyYXBwZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gREVTQ1JJUFRPUlMgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZU51bWJlcikgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzIwMTUgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzIwMTUgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhOYXRpdmVOdW1iZXIsIGtleSA9IGtleXNbal0pICYmICFoYXMoTnVtYmVyV3JhcHBlciwga2V5KSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkoTnVtYmVyV3JhcHBlciwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTmF0aXZlTnVtYmVyLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgTnVtYmVyV3JhcHBlci5wcm90b3R5cGUgPSBOdW1iZXJQcm90b3R5cGU7XG4gIE51bWJlclByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE51bWJlcldyYXBwZXI7XG4gIHJlZGVmaW5lKGdsb2JhbCwgTlVNQkVSLCBOdW1iZXJXcmFwcGVyKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhYjEzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICB2YXIgcmVnZXhwID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFjMWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MjYzXCIpO1xuXG4kKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xuICBleGVjOiBleGVjXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhZDZkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWU0MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY2FjaGUgPSB7fTtcblxudmFyIHRocm93ZXIgPSBmdW5jdGlvbiAoaXQpIHsgdGhyb3cgaXQ7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBvcHRpb25zKSB7XG4gIGlmIChoYXMoY2FjaGUsIE1FVEhPRF9OQU1FKSkgcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXTtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHZhciBBQ0NFU1NPUlMgPSBoYXMob3B0aW9ucywgJ0FDQ0VTU09SUycpID8gb3B0aW9ucy5BQ0NFU1NPUlMgOiBmYWxzZTtcbiAgdmFyIGFyZ3VtZW50MCA9IGhhcyhvcHRpb25zLCAwKSA/IG9wdGlvbnNbMF0gOiB0aHJvd2VyO1xuICB2YXIgYXJndW1lbnQxID0gaGFzKG9wdGlvbnMsIDEpID8gb3B0aW9uc1sxXSA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4gY2FjaGVbTUVUSE9EX05BTUVdID0gISFtZXRob2QgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoQUNDRVNTT1JTICYmICFERVNDUklQVE9SUykgcmV0dXJuIHRydWU7XG4gICAgdmFyIE8gPSB7IGxlbmd0aDogLTEgfTtcblxuICAgIGlmIChBQ0NFU1NPUlMpIGRlZmluZVByb3BlcnR5KE8sIDEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiB0aHJvd2VyIH0pO1xuICAgIGVsc2UgT1sxXSA9IDE7XG5cbiAgICBtZXRob2QuY2FsbChPLCBhcmd1bWVudDAsIGFyZ3VtZW50MSk7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhZTkzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTE2M1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM0MzBcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFmMDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG5cbi8vIGNoZWNrIHRoZSBleGlzdGVuY2Ugb2YgYSBtZXRob2QsIGxvd2VyY2FzZVxuLy8gb2YgYSB0YWcgYW5kIGVzY2FwaW5nIHF1b3RlcyBpbiBhcmd1bWVudHNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tNRVRIT0RfTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiMDQxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAwZWVcIik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNWRmXCIpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjU3NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA2Y2ZcIikuZjtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2YjZcIik7XG52YXIgbWFjcm90YXNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJjZjRcIikuc2V0O1xudmFyIElTX0lPUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxY2RjXCIpO1xuXG52YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgSVNfTk9ERSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnksIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKElTX05PREUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoTXV0YXRpb25PYnNlcnZlciAmJiAhSVNfSU9TKSB7XG4gICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB0aGVuID0gcHJvbWlzZS50aGVuO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoZW4uY2FsbChwcm9taXNlLCBmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjYyMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2OTJcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwZTNcIik7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTMwXCIpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZkYmZcIik7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIGVsc2UgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImI2NGJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjBiXCIpO1xudmFyIG5hdGl2ZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGY3NVwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNzI3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzNjZcIik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NGFkXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdiMGJcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTBjNFwiKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjVmMFwiKTtcblxudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXggfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7ICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiYjJmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzA0ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNDMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzZiNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzZjZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlNGVcIik7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNzQwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyICRmaW5kSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjcyN1wiKS5maW5kSW5kZXg7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NGQyXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBGSU5EX0lOREVYID0gJ2ZpbmRJbmRleCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aChGSU5EX0lOREVYKTtcblxuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChGSU5EX0lOREVYIGluIFtdKSBBcnJheSgxKVtGSU5EX0lOREVYXShmdW5jdGlvbiAoKSB7IFNLSVBTX0hPTEVTID0gZmFsc2U7IH0pO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZGluZGV4XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTS0lQU19IT0xFUyB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZEluZGV4KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKEZJTkRfSU5ERVgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM4YmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM5NmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgY3JlYXRlSFRNTCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NTdhXCIpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWYwM1wiKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuc21hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zbWFsbFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ3NtYWxsJykgfSwge1xuICBzbWFsbDogZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzk3NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciAkaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZDY0XCIpLmluZGV4T2Y7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjQwXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBuYXRpdmVJbmRleE9mID0gW10uaW5kZXhPZjtcblxudmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2luZGV4T2YnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdpbmRleE9mJywgeyBBQ0NFU1NPUlM6IHRydWUsIDE6IDAgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogTkVHQVRJVkVfWkVSTyB8fCAhU1RSSUNUX01FVEhPRCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gbmF0aXZlSW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYTg0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmM2YVwiKTtcbnZhciBpbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRkNjRcIikuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMTJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2FhZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciAkaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGQ2NFwiKS5pbmNsdWRlcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0ZDJcIik7XG52YXIgYXJyYXlNZXRob2RVc2VzVG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWU0MFwiKTtcblxudmFyIFVTRVNfVE9fTEVOR1RIID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ2luZGV4T2YnLCB7IEFDQ0VTU09SUzogdHJ1ZSwgMTogMCB9KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFVU0VTX1RPX0xFTkdUSCB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYjI5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MWQ1XCIpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRkMlwiKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGZpbGw6IGZpbGxcbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnZmlsbCcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNjMTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNjYTZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjBkYVwiKTtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNkZjlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMDY5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNlNGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MTEyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQwMTFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2NlbGxfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM4YzRcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2NlbGxfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19jZWxsX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfY2VsbF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQwMTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMDM5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDA2NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MjhmXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQxZTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMjhiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzQ2ZlwiKTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQyYmJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNiYmVcIik7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcbiAgICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlci5jYWxsKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQzYjdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMGVlXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZlZWJcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjA0MVwiKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ0NGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZjJcIikuZjtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkNThmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWMwYlwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjBiXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRhZFwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGM0XCIpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhhdCk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoO0lTX1JJR0hUID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4gIGxlZnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbiAgcmlnaHQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkNzg0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIG1vdmVkIHRvIGVudHJ5IHBvaW50c1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcImFjMWZcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmVlYlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNjIyXCIpO1xudmFyIHJlZ2V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTI2M1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxuLy8gSUUgPD0gMTEgcmVwbGFjZXMgJDAgd2l0aCB0aGUgd2hvbGUgbWF0Y2gsIGFzIGlmIGl0IHdhcyAkJlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAyNDY2Ni9nZXR0aW5nLWllLXRvLXJlcGxhY2UtYS1yZWdleC13aXRoLXRoZS1saXRlcmFsLXN0cmluZy0wXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnYScucmVwbGFjZSgvLi8sICckMCcpID09PSAnJDAnO1xufSkoKTtcblxudmFyIFJFUExBQ0UgPSB3ZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcbi8vIFNhZmFyaSA8PSAxMy4wLjMoPykgc3Vic3RpdHV0ZXMgbnRoIGNhcHR1cmUgd2hlcmUgbj5tIHdpdGggYW4gZW1wdHkgc3RyaW5nXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoLy4vW1JFUExBQ0VdKSB7XG4gICAgcmV0dXJuIC8uL1tSRVBMQUNFXSgnYScsICckMCcpID09PSAnJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYywgc2hhbSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICEoXG4gICAgICBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyAmJlxuICAgICAgUkVQTEFDRV9LRUVQU18kMCAmJlxuICAgICAgIVJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFXG4gICAgKSkgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9LCB7XG4gICAgICBSRVBMQUNFX0tFRVBTXyQwOiBSRVBMQUNFX0tFRVBTXyQwLFxuICAgICAgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkU6IFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFXG4gICAgfSk7XG4gICAgdmFyIHN0cmluZ01ldGhvZCA9IG1ldGhvZHNbMF07XG4gICAgdmFyIHJlZ2V4TWV0aG9kID0gbWV0aG9kc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyaW5nTWV0aG9kKTtcbiAgICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxuXG4gIGlmIChzaGFtKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwLnByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkODFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyICRtYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjcyN1wiKS5tYXA7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZGRlXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnbWFwJyk7XG4vLyBGRjQ5LSBpc3N1ZVxudmFyIFVTRVNfVE9fTEVOR1RIID0gYXJyYXlNZXRob2RVc2VzVG9MZW5ndGgoJ21hcCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfHwgIVVTRVNfVE9fTEVOR1RIIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRhODRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzhiYVwiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRhOGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2hlYWRlcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWE0ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaGVhZGVyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaGVhZGVyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaGVhZGVyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGJiNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmVmXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwNmNmXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0MThcIik7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5ID0ga2V5c1tpbmRleCsrXSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRkYjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xudmFyIERPTUl0ZXJhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmZGJjXCIpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyNjBcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRmNzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYTg0XCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc4MzlcIik7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUwMWFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzZTdcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGE4NFwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliZjJcIikuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU4OTNcIik7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlclxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIHZhciBzeW1ib2xQcm90b3R5cGUgPSBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG4gIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgbmF0aXZlID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGlzT2JqZWN0KHRoaXMpID8gdGhpcy52YWx1ZU9mKCkgOiB0aGlzO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nLmNhbGwoc3ltYm9sKTtcbiAgICAgIGlmIChoYXMoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IG5hdGl2ZSA/IHN0cmluZy5zbGljZSg3LCAtMSkgOiBzdHJpbmcucmVwbGFjZShyZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUxNjNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdiMGJcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY3NzJcIik7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxNzdcIik7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTE3N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMjYwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjNmFcIik7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NGQyXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZjhjXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlmM1wiKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZGQwXCIpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUyY2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZlZWJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImU0MzlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwNmNmXCIpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTUzOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG5cbmV4cG9ydHMuZiA9IHdlbGxLbm93blN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlNjY3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTZjZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM0MzBcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDY2XCIpO1xudmFyIE5hdGl2ZVByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmVhOVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIHJlZGVmaW5lQWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyY2NcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDQ0ZVwiKTtcbnZhciBzZXRTcGVjaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI2MjZcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWMwYlwiKTtcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE5YWFcIik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmI2XCIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODkyNVwiKTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIyNjZcIik7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFjN2VcIik7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4NDBcIik7XG52YXIgdGFzayA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyY2Y0XCIpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjU3NVwiKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZGY5XCIpO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRkZVwiKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMDY5XCIpO1xudmFyIHBlcmZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTY2N1wiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5ZjNcIik7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTRjYVwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkMDBcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3RvcikgIT09IFN0cmluZyhQcm9taXNlQ29uc3RydWN0b3IpO1xuICBpZiAoIUdMT0JBTF9DT1JFX0pTX1BST01JU0UpIHtcbiAgICAvLyBWOCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICBpZiAoVjhfVkVSU0lPTiA9PT0gNjYpIHJldHVybiB0cnVlO1xuICAgIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICBpZiAoIUlTX05PREUgJiYgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBXZSBuZWVkIFByb21pc2UjZmluYWxseSBpbiB0aGUgcHVyZSB2ZXJzaW9uIGZvciBwcmV2ZW50aW5nIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgaWYgKElTX1BVUkUgJiYgIVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGVbJ2ZpbmFsbHknXSkgcmV0dXJuIHRydWU7XG4gIC8vIFdlIGNhbid0IHVzZSBAQHNwZWNpZXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4gIC8vIGRlb3B0aW1pemF0aW9uIGFuZCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG4gIGlmIChWOF9WRVJTSU9OID49IDUxICYmIC9uYXRpdmUgY29kZS8udGVzdChQcm9taXNlQ29uc3RydWN0b3IpKSByZXR1cm4gZmFsc2U7XG4gIC8vIERldGVjdCBjb3JyZWN0bmVzcyBvZiBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG4gIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIH07XG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3IgPSB7fTtcbiAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiAgcmV0dXJuICEocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZSk7XG59KTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSlbJ2NhdGNoJ10oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gc3RhdGUucmVhY3Rpb25zO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBjaGFpbltpbmRleCsrXTtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHByb21pc2UsIHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElTX05PREUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHByb21pc2UsIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShwcm9taXNlLCBzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHByb21pc2UsIHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdCh0aGlzLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgICAgc3RhdGUucmVhY3Rpb25zLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHN0YXRlLnN0YXRlICE9IFBFTkRJTkcpIG5vdGlmeSh0aGlzLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgc3RhdGUpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICBpZiAoIUlTX1BVUkUgJiYgdHlwZW9mIE5hdGl2ZVByb21pc2UgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuXG4gICAgLy8gd3JhcCBuYXRpdmUgUHJvbWlzZSN0aGVuIGZvciBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NDBcbiAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcblxuICAgIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG4gICAgaWYgKHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJykgJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0IC8qICwgaW5pdCAqLykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4kKHsgZ2xvYmFsOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIFByb21pc2U6IFByb21pc2VDb25zdHJ1Y3RvclxufSk7XG5cbnNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UsIHRydWUpO1xuc2V0U3BlY2llcyhQUk9NSVNFKTtcblxuUHJvbWlzZVdyYXBwZXIgPSBnZXRCdWlsdEluKFBST01JU0UpO1xuXG4vLyBzdGF0aWNzXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVqZWN0XG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIGNhcGFiaWxpdHkucmVqZWN0LmNhbGwodW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuJCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRCB9LCB7XG4gIC8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG5cbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIC8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyBgUHJvbWlzZS5yYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlODkzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciBvd25LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZWZcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA2Y2ZcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZThiNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmI2XCIpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2FycmF5XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlOTVhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y4Y1wiKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjA2OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYzBiXCIpO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcblxuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmMTgzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMTJcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmYyXCIpLmY7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwZTNcIik7XG52YXIgRlJFRVpJTkcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmIyZlwiKTtcblxudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQgPSAwO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIGRlZmluZVByb3BlcnR5KGl0LCBNRVRBREFUQSwgeyB2YWx1ZToge1xuICAgIG9iamVjdElEOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG59O1xuXG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59O1xuXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpJTkcgJiYgbWV0YS5SRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBSRVFVSVJFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjVkZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAwZWVcIik7XG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmI2XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNjIyXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmNmZkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgcG9seWZpbGwgYnkgQWRhbSBNaWxsZXJcblxuLy8gTUlUIGxpY2Vuc2VcblxuKGZ1bmN0aW9uKGRvY3VtZW50KXtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBcImN1cnJlbnRTY3JpcHRcIixcbiAgICAgIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7IC8vIExpdmUgTm9kZUxpc3QgY29sbGVjdGlvblxuXG4gIC8vIElmIGJyb3dzZXIgbmVlZHMgY3VycmVudFNjcmlwdCBwb2x5ZmlsbCwgYWRkIGdldCBjdXJyZW50U2NyaXB0KCkgdG8gdGhlIGRvY3VtZW50IG9iamVjdFxuICBpZiAoIShjdXJyZW50U2NyaXB0IGluIGRvY3VtZW50KSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgY3VycmVudFNjcmlwdCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuXG4gICAgICAgIC8vIElFIDYtMTAgc3VwcG9ydHMgc2NyaXB0IHJlYWR5U3RhdGVcbiAgICAgICAgLy8gSUUgMTArIHN1cHBvcnQgc3RhY2sgdHJhY2VcbiAgICAgICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgc2Vjb25kIG1hdGNoIGZvciB0aGUgXCJhdFwiIHN0cmluZyB0byBnZXQgZmlsZSBzcmMgdXJsIGZyb20gc3RhY2suXG4gICAgICAgICAgLy8gU3BlY2lmaWNhbGx5IHdvcmtzIHdpdGggdGhlIGZvcm1hdCBvZiBzdGFjayB0cmFjZXMgaW4gSUUuXG4gICAgICAgICAgdmFyIGksIHJlcyA9ICgoLy4qYXQgW15cXChdKlxcKCguKik6Lis6LitcXCkkL2lnKS5leGVjKGVyci5zdGFjaykgfHwgW2ZhbHNlXSlbMV07XG5cbiAgICAgICAgICAvLyBGb3IgYWxsIHNjcmlwdHMgb24gdGhlIHBhZ2UsIGlmIHNyYyBtYXRjaGVzIG9yIGlmIHJlYWR5IHN0YXRlIGlzIGludGVyYWN0aXZlLCByZXR1cm4gdGhlIHNjcmlwdCB0YWdcbiAgICAgICAgICBmb3IoaSBpbiBzY3JpcHRzKXtcbiAgICAgICAgICAgIGlmKHNjcmlwdHNbaV0uc3JjID09IHJlcyB8fCBzY3JpcHRzW2ldLnJlYWR5U3RhdGUgPT0gXCJpbnRlcmFjdGl2ZVwiKXtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgbm8gbWF0Y2gsIHJldHVybiBudWxsXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSkoZG9jdW1lbnQpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImY3NzJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NjkyXCIpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MGUzXCIpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYjE1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9zZXRQdWJsaWNQYXRoLmpzXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgaW50byBsaWIvd2MgY2xpZW50IGJ1bmRsZXMuXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHJ1ZSkge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18oXCJmNmZkXCIpXG4gIH1cblxuICB2YXIgc2V0UHVibGljUGF0aF9pXG4gIGlmICgoc2V0UHVibGljUGF0aF9pID0gd2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpICYmIChzZXRQdWJsaWNQYXRoX2kgPSBzZXRQdWJsaWNQYXRoX2kuc3JjLm1hdGNoKC8oLitcXC8pW14vXStcXC5qcyhcXD8uKik/JC8pKSkge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IHNldFB1YmxpY1BhdGhfaVsxXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cblxuLy8gSW5kaWNhdGUgdG8gd2VicGFjayB0aGF0IHRoaXMgZmlsZSBjYW4gYmUgY29uY2F0ZW5hdGVkXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXRQdWJsaWNQYXRoID0gKG51bGwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI0ODdmODIxNy12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy9wdWctcGxhaW4tbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBlZmQzOTM3Jmxhbmc9cHVnJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3JlZjpcInZ1ZWNhbFwiLHN0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbFwiLGNsYXNzOl92bS5jc3NDbGFzc2VzLGF0dHJzOntcImNvbHVtblwiOlwiXCIsXCJsYW5nXCI6X3ZtLmxvY2FsZX19LFtfYygndnVlY2FsLWhlYWRlcicse2F0dHJzOntcIm9wdGlvbnNcIjpfdm0uJHByb3BzLFwidmlldy1wcm9wc1wiOnsgdmlld3M6IF92bS52aWV3cywgdmlldzogX3ZtLnZpZXcsIHdlZWtEYXlzSW5IZWFkZXI6IF92bS53ZWVrRGF5c0luSGVhZGVyIH0sXCJ3ZWVrLWRheXNcIjpfdm0ud2Vla0RheXMsXCJkYXktc3BsaXRzXCI6X3ZtLmRheVNwbGl0cyxcInN3aXRjaC10by1uYXJyb3dlci12aWV3XCI6X3ZtLnN3aXRjaFRvTmFycm93ZXJWaWV3fSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJhcnJvdy1wcmV2XCIsZm46ZnVuY3Rpb24oKXtyZXR1cm4gW192bS5fdChcImFycm93LXByZXZcIixbX3ZtLl92KFwiwqBcIiksX2MoJ2knLHtzdGF0aWNDbGFzczpcImFuZ2xlXCJ9KSxfdm0uX3YoXCLCoFwiKV0pXX0scHJveHk6dHJ1ZX0se2tleTpcImFycm93LW5leHRcIixmbjpmdW5jdGlvbigpe3JldHVybiBbX3ZtLl90KFwiYXJyb3ctbmV4dFwiLFtfdm0uX3YoXCLCoFwiKSxfYygnaScse3N0YXRpY0NsYXNzOlwiYW5nbGVcIn0pLF92bS5fdihcIsKgXCIpXSldfSxwcm94eTp0cnVlfSx7a2V5OlwidG9kYXktYnV0dG9uXCIsZm46ZnVuY3Rpb24oKXtyZXR1cm4gW192bS5fdChcInRvZGF5LWJ1dHRvblwiLFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiZGVmYXVsdFwifSxbX3ZtLl92KF92bS5fcyhfdm0udGV4dHMudG9kYXkpKV0pXSldfSxwcm94eTp0cnVlfSx7a2V5OlwidGl0bGVcIixmbjpmdW5jdGlvbigpe3JldHVybiBbX3ZtLl90KFwidGl0bGVcIixbX3ZtLl92KF92bS5fcyhfdm0udmlld1RpdGxlKSldLHtcInRpdGxlXCI6X3ZtLnZpZXdUaXRsZSxcInZpZXdcIjpfdm0udmlld30pXX0scHJveHk6dHJ1ZX0se2tleTpcIndlZWtkYXktaGVhZGluZ1wiLGZuOmZ1bmN0aW9uKHJlZil7XG52YXIgaGVhZGluZyA9IHJlZi5oZWFkaW5nO1xudmFyIHZpZXcgPSByZWYudmlldztcbnJldHVybiBbX3ZtLl90KFwid2Vla2RheS1oZWFkaW5nXCIsbnVsbCx7XCJoZWFkaW5nXCI6aGVhZGluZyxcInZpZXdcIjp2aWV3fSldfX1dLG51bGwsdHJ1ZSl9KSwoIV92bS5oaWRlQm9keSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fYm9keVwiLGF0dHJzOntcImdyb3dcIjpcIlwifX0sW19jKCd0cmFuc2l0aW9uJyx7YXR0cnM6e1wibmFtZVwiOihcInNsaWRlLWZhZGUtLVwiICsgX3ZtLnRyYW5zaXRpb25EaXJlY3Rpb24pLFwiYXBwZWFyXCI6X3ZtLnRyYW5zaXRpb25zfX0sW19jKCdkaXYnLHtrZXk6X3ZtLnRyYW5zaXRpb25zID8gX3ZtLnZpZXcuaWQgOiBmYWxzZSxzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleFwiLHN0YXRpY1N0eWxlOntcIm1pbi13aWR0aFwiOlwiMTAwJVwifSxhdHRyczp7XCJjb2x1bW5cIjpcIlwifX0sWyhfdm0uc2hvd0FsbERheUV2ZW50cyAmJiBfdm0uaGFzVGltZUNvbHVtbik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fYWxsLWRheVwifSxbX2MoJ3NwYW4nLHtzdGF0aWNTdHlsZTp7XCJ3aWR0aFwiOlwiM2VtXCJ9fSxbX2MoJ3NwYW4nLFtfdm0uX3YoX3ZtLl9zKF92bS50ZXh0cy5hbGxEYXkpKV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fY2VsbHNcIixjbGFzczooKF92bS52aWV3LmlkKSArIFwiLXZpZXdcIiksYXR0cnM6e1wiZ3Jvd1wiOlwiXCIsXCJ3cmFwXCI6KCFfdm0ubWluQ2VsbFdpZHRoICYmICFfdm0ubWluU3BsaXRXaWR0aCkgfHwgX3ZtLnZpZXcuaWQgIT09ICd3ZWVrJyxcImNvbHVtblwiOiEhX3ZtLm1pbkNlbGxXaWR0aCB8fCAhIV92bS5taW5TcGxpdFdpZHRofX0sX3ZtLl9sKChfdm0udmlld0NlbGxzKSxmdW5jdGlvbihjZWxsLGkpe3JldHVybiBfYygndnVlY2FsLWNlbGwnLHtrZXk6aSxhdHRyczp7XCJvcHRpb25zXCI6X3ZtLiRwcm9wcyxcImRhdGFcIjpjZWxsLFwiYWxsLWRheVwiOnRydWUsXCJtaW4tdGltZXN0YW1wXCI6X3ZtLm1pblRpbWVzdGFtcCxcIm1heC10aW1lc3RhbXBcIjpfdm0ubWF4VGltZXN0YW1wLFwiY2VsbC1zcGxpdHNcIjpfdm0uaGFzU3BsaXRzICYmIF92bS5kYXlTcGxpdHMgfHwgW119LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcImV2ZW50XCIsZm46ZnVuY3Rpb24ocmVmKXtcbnZhciBldmVudCA9IHJlZi5ldmVudDtcbnZhciB2aWV3ID0gcmVmLnZpZXc7XG5yZXR1cm4gW192bS5fdChcImV2ZW50XCIsWyhfdm0uZWRpdGFibGVFdmVudHMgJiYgZXZlbnQudGl0bGUpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZXZlbnQtdGl0bGUgdnVlY2FsX19ldmVudC10aXRsZS0tZWRpdFwiLGF0dHJzOntcImNvbnRlbnRlZGl0YWJsZVwiOlwiXCJ9LGRvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhldmVudC50aXRsZSl9LG9uOntcImJsdXJcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0ub25FdmVudFRpdGxlQmx1cigkZXZlbnQsIGV2ZW50KX19fSk6KGV2ZW50LnRpdGxlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2V2ZW50LXRpdGxlXCIsZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKGV2ZW50LnRpdGxlKX19KTpfdm0uX2UoKSwoZXZlbnQuY29udGVudCAmJiBfdm0uc2hvd0FsbERheUV2ZW50cyAhPT0gJ3Nob3J0JyAmJiAhX3ZtLmlzU2hvcnRNb250aFZpZXcpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZXZlbnQtY29udGVudFwiLGRvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhldmVudC5jb250ZW50KX19KTpfdm0uX2UoKV0se1widmlld1wiOnZpZXcsXCJldmVudFwiOmV2ZW50fSldfX1dLG51bGwsdHJ1ZSl9LFtfdm0uX3QoXCJuby1ldmVudFwiLG51bGwse1wic2xvdFwiOlwibm8tZXZlbnRcIn0pXSwyKX0pLDEpXSk6X3ZtLl9lKCksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19iZ1wiLGNsYXNzOnsgdnVlY2FsX19mbGV4OiAhX3ZtLmhhc1RpbWVDb2x1bW4gfSxhdHRyczp7XCJjb2x1bW5cIjpcIlwifX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleFwiLGF0dHJzOntcInJvd1wiOlwiXCIsXCJncm93XCI6XCJcIn19LFsoX3ZtLmhhc1RpbWVDb2x1bW4pP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fdGltZS1jb2x1bW5cIn0sX3ZtLl9sKChfdm0udGltZUNlbGxzKSxmdW5jdGlvbihjZWxsLGkpe3JldHVybiBfYygnZGl2Jyx7a2V5Omksc3RhdGljQ2xhc3M6XCJ2dWVjYWxfX3RpbWUtY2VsbFwiLHN0eWxlOigoXCJoZWlnaHQ6IFwiICsgX3ZtLnRpbWVDZWxsSGVpZ2h0ICsgXCJweFwiKSl9LFtfdm0uX3QoXCJ0aW1lLWNlbGxcIixbX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImxpbmVcIn0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJsYWJlbFwifSxbX3ZtLl92KF92bS5fcyhjZWxsLmxhYmVsKSldKV0se1wiaG91cnNcIjpjZWxsLmhvdXJzLFwibWludXRlc1wiOmNlbGwubWludXRlc30pXSwyKX0pLDApOl92bS5fZSgpLChfdm0uc2hvd1dlZWtOdW1iZXJzICYmIF92bS52aWV3LmlkID09PSAnbW9udGgnKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2ZsZXggdnVlY2FsX193ZWVrLW51bWJlcnNcIixhdHRyczp7XCJjb2x1bW5cIjpcIlwifX0sX3ZtLl9sKCg2KSxmdW5jdGlvbihpKXtyZXR1cm4gX2MoJ2Rpdicse2tleTppLHN0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fd2Vlay1udW1iZXItY2VsbFwiLGF0dHJzOntcImdyb3dcIjpcIlwifX0sW192bS5fdChcIndlZWstbnVtYmVyLWNlbGxcIixbX3ZtLl92KF92bS5fcyhfdm0uZ2V0V2Vla051bWJlcihpIC0gMSkpKV0se1wid2Vla1wiOl92bS5nZXRXZWVrTnVtYmVyKGkgLSAxKX0pXSwyKX0pLDApOl92bS5fZSgpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleCB2dWVjYWxfX2NlbGxzXCIsY2xhc3M6KChfdm0udmlldy5pZCkgKyBcIi12aWV3XCIpLGF0dHJzOntcImdyb3dcIjpcIlwiLFwid3JhcFwiOighX3ZtLm1pbkNlbGxXaWR0aCAmJiAhX3ZtLm1pblNwbGl0V2lkdGgpIHx8IF92bS52aWV3LmlkICE9PSAnd2VlaycsXCJjb2x1bW5cIjohIV92bS5taW5DZWxsV2lkdGggfHwgISFfdm0ubWluU3BsaXRXaWR0aH19LFsoKF92bS5taW5DZWxsV2lkdGggfHwgKF92bS5oYXNTcGxpdHMgJiYgX3ZtLm1pblNwbGl0V2lkdGgpKSAmJiBfdm0udmlldy5pZCA9PT0gJ3dlZWsnKT9fYygnd2Vla2RheXMtaGVhZGluZ3MnLHtzdHlsZTooX3ZtLmNvbnRlbnRNaW5XaWR0aCA/IChcIm1pbi13aWR0aDogXCIgKyBfdm0uY29udGVudE1pbldpZHRoICsgXCJweFwiKSA6ICcnKSxhdHRyczp7XCJ2dWVjYWxcIjp0aGlzLFwidHJhbnNpdGlvbi1kaXJlY3Rpb25cIjpfdm0udHJhbnNpdGlvbkRpcmVjdGlvbixcInZpZXdcIjpfdm0udmlldyxcIndlZWstZGF5c1wiOl92bS53ZWVrRGF5cyxcInN3aXRjaC10by1uYXJyb3dlci12aWV3XCI6X3ZtLnN3aXRjaFRvTmFycm93ZXJWaWV3fSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJ3ZWVrZGF5LWhlYWRpbmdcIixmbjpmdW5jdGlvbihyZWYpe1xudmFyIGhlYWRpbmcgPSByZWYuaGVhZGluZztcbnZhciB2aWV3ID0gcmVmLnZpZXc7XG5yZXR1cm4gW192bS5fdChcIndlZWtkYXktaGVhZGluZ1wiLG51bGwse1wiaGVhZGluZ1wiOmhlYWRpbmcsXCJ2aWV3XCI6dmlld30pXX19XSxudWxsLHRydWUpfSk6KF92bS5oYXNTcGxpdHMgJiYgX3ZtLnN0aWNreVNwbGl0TGFiZWxzICYmIF92bS5taW5TcGxpdFdpZHRoKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2ZsZXggdnVlY2FsX19zcGxpdC1kYXlzLWhlYWRlcnNcIixzdHlsZTooX3ZtLmNvbnRlbnRNaW5XaWR0aCA/IChcIm1pbi13aWR0aDogXCIgKyBfdm0uY29udGVudE1pbldpZHRoICsgXCJweFwiKSA6ICcnKX0sX3ZtLl9sKChfdm0uZGF5U3BsaXRzKSxmdW5jdGlvbihzcGxpdCxpKXtyZXR1cm4gX2MoJ2Rpdicse2tleTppLHN0YXRpY0NsYXNzOlwiZGF5LXNwbGl0LWhlYWRlclwiLGNsYXNzOnNwbGl0LmNsYXNzIHx8IGZhbHNlfSxbX3ZtLl92KF92bS5fcyhzcGxpdC5sYWJlbCkpXSl9KSwwKTpfdm0uX2UoKSxfYygnZGl2Jyx7cmVmOlwiY2VsbHNcIixzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleFwiLHN0eWxlOihfdm0uY29udGVudE1pbldpZHRoID8gKFwibWluLXdpZHRoOiBcIiArIF92bS5jb250ZW50TWluV2lkdGggKyBcInB4XCIpIDogJycpLGF0dHJzOntcImdyb3dcIjpcIlwiLFwid3JhcFwiOighX3ZtLm1pbkNlbGxXaWR0aCAmJiAhX3ZtLm1pblNwbGl0V2lkdGgpIHx8IF92bS52aWV3LmlkICE9PSAnd2Vlayd9fSxfdm0uX2woKF92bS52aWV3Q2VsbHMpLGZ1bmN0aW9uKGNlbGwsaSl7cmV0dXJuIF9jKCd2dWVjYWwtY2VsbCcse2tleTppLGF0dHJzOntcIm9wdGlvbnNcIjpfdm0uJHByb3BzLFwiZGF0YVwiOmNlbGwsXCJjZWxsLXdpZHRoXCI6X3ZtLmhpZGVXZWVrZGF5cy5sZW5ndGggJiYgWydtb250aCcsICd3ZWVrJ10uaW5jbHVkZXMoX3ZtLnZpZXcuaWQpICYmIF92bS5jZWxsV2lkdGgsXCJtaW4tdGltZXN0YW1wXCI6X3ZtLm1pblRpbWVzdGFtcCxcIm1heC10aW1lc3RhbXBcIjpfdm0ubWF4VGltZXN0YW1wLFwiY2VsbC1zcGxpdHNcIjpfdm0uaGFzU3BsaXRzICYmIF92bS5kYXlTcGxpdHMgfHwgW119LHNjb3BlZFNsb3RzOl92bS5fdShbe2tleTpcImNlbGwtY29udGVudFwiLGZuOmZ1bmN0aW9uKHJlZil7XG52YXIgZXZlbnRzID0gcmVmLmV2ZW50cztcbnZhciBzcGxpdCA9IHJlZi5zcGxpdDtcbnZhciBzZWxlY3RDZWxsID0gcmVmLnNlbGVjdENlbGw7XG5yZXR1cm4gW192bS5fdChcImNlbGwtY29udGVudFwiLFsoc3BsaXQgJiYgIV92bS5zdGlja3lTcGxpdExhYmVscyk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic3BsaXQtbGFiZWxcIixkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3Moc3BsaXQubGFiZWwpfX0pOl92bS5fZSgpLChjZWxsLmNvbnRlbnQpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fY2VsbC1kYXRlXCIsZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKGNlbGwuY29udGVudCl9fSk6X3ZtLl9lKCksKCgoX3ZtLnZpZXcuaWQgPT09ICdtb250aCcgJiYgIV92bS5ldmVudHNPbk1vbnRoVmlldykgfHwgKFsneWVhcnMnLCAneWVhciddLmluY2x1ZGVzKF92bS52aWV3LmlkKSAmJiBfdm0uZXZlbnRzQ291bnRPblllYXJWaWV3KSkgJiYgZXZlbnRzLmxlbmd0aCk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19jZWxsLWV2ZW50cy1jb3VudFwifSxbX3ZtLl90KFwiZXZlbnRzLWNvdW50XCIsW192bS5fdihfdm0uX3MoZXZlbnRzLmxlbmd0aCkpXSx7XCJ2aWV3XCI6X3ZtLnZpZXcsXCJldmVudHNcIjpldmVudHN9KV0sMik6X3ZtLl9lKCksKCFldmVudHMubGVuZ3RoICYmIFsnd2VlaycsICdkYXknXS5pbmNsdWRlcyhfdm0udmlldy5pZCkpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fbm8tZXZlbnRcIn0sW192bS5fdChcIm5vLWV2ZW50XCIsW192bS5fdihfdm0uX3MoX3ZtLnRleHRzLm5vRXZlbnQpKV0pXSwyKTpfdm0uX2UoKV0se1wiY2VsbFwiOmNlbGwsXCJ2aWV3XCI6X3ZtLnZpZXcsXCJnb05hcnJvd2VyXCI6c2VsZWN0Q2VsbCxcImV2ZW50c1wiOmV2ZW50c30pXX19LHtrZXk6XCJldmVudFwiLGZuOmZ1bmN0aW9uKHJlZil7XG52YXIgZXZlbnQgPSByZWYuZXZlbnQ7XG52YXIgdmlldyA9IHJlZi52aWV3O1xucmV0dXJuIFtfdm0uX3QoXCJldmVudFwiLFsoX3ZtLmVkaXRhYmxlRXZlbnRzICYmIGV2ZW50LnRpdGxlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2V2ZW50LXRpdGxlIHZ1ZWNhbF9fZXZlbnQtdGl0bGUtLWVkaXRcIixhdHRyczp7XCJjb250ZW50ZWRpdGFibGVcIjpcIlwifSxkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoZXZlbnQudGl0bGUpfSxvbjp7XCJibHVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLm9uRXZlbnRUaXRsZUJsdXIoJGV2ZW50LCBldmVudCl9fX0pOihldmVudC50aXRsZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19ldmVudC10aXRsZVwiLGRvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhldmVudC50aXRsZSl9fSk6X3ZtLl9lKCksKF92bS50aW1lICYmICFldmVudC5hbGxEYXkgJiYgKGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXMgfHwgZXZlbnQuZW5kVGltZU1pbnV0ZXMpICYmICEodmlldyA9PT0gJ21vbnRoJyAmJiAoZXZlbnQuYWxsRGF5IHx8IF92bS5zaG93QWxsRGF5RXZlbnRzID09PSAnc2hvcnQnKSkgJiYgIV92bS5pc1Nob3J0TW9udGhWaWV3KT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2V2ZW50LXRpbWVcIn0sW192bS5fdihfdm0uX3MoX3ZtLmZvcm1hdFRpbWUoZXZlbnQuc3RhcnRUaW1lTWludXRlcykpKSwoZXZlbnQuZW5kVGltZU1pbnV0ZXMpP19jKCdzcGFuJyxbX3ZtLl92KFwiwqAtIFwiK192bS5fcyhfdm0uZm9ybWF0VGltZShldmVudC5lbmRUaW1lTWludXRlcykpKV0pOl92bS5fZSgpLChldmVudC5kYXlzQ291bnQgPiAxICYmIChldmVudC5zZWdtZW50c1tjZWxsLmZvcm1hdHRlZERhdGVdIHx8IHt9KS5pc0ZpcnN0RGF5KT9fYygnc21hbGwnLHtzdGF0aWNDbGFzczpcImRheXMtdG8tZW5kXCJ9LFtfdm0uX3YoXCLCoCtcIitfdm0uX3MoZXZlbnQuZGF5c0NvdW50IC0gMSkrX3ZtLl9zKChfdm0udGV4dHMuZGF5WzBdIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSldKTpfdm0uX2UoKV0pOl92bS5fZSgpLChldmVudC5jb250ZW50ICYmICEodmlldyA9PT0gJ21vbnRoJyAmJiBldmVudC5hbGxEYXkgJiYgX3ZtLnNob3dBbGxEYXlFdmVudHMgPT09ICdzaG9ydCcpICYmICFfdm0uaXNTaG9ydE1vbnRoVmlldyk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19ldmVudC1jb250ZW50XCIsZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKGV2ZW50LmNvbnRlbnQpfX0pOl92bS5fZSgpXSx7XCJ2aWV3XCI6dmlldyxcImV2ZW50XCI6ZXZlbnR9KV19fV0sbnVsbCx0cnVlKX0sW192bS5fdChcImRlZmF1bHRcIildLDIpfSksMSldLDEpXSldKV0pXSldLDEpOl92bS5fZSgpXSwxKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9pbmRleC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MGVmZDM5MzcmbGFuZz1wdWcmXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1xudmFyIGVzX2FycmF5X2NvbmNhdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5OWFmXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzXG52YXIgZXNfYXJyYXlfZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjI5XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanNcbnZhciBlc19hcnJheV9maWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGRlNFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qc1xudmFyIGVzX2FycmF5X2ZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2RiMFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanNcbnZhciBlc19hcnJheV9mb3JfZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MTYwXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcy5qc1xudmFyIGVzX2FycmF5X2luY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhYWRcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzXG52YXIgZXNfYXJyYXlfaW5kZXhfb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzk3NVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzXG52YXIgZXNfYXJyYXlfbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ4MWRcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS5qc1xudmFyIGVzX2FycmF5X3JlZHVjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxM2Q1XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1xudmFyIGVzX2FycmF5X3NsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZiNmFcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWUuanNcbnZhciBlc19hcnJheV9zb21lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ZmNcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qc1xudmFyIGVzX251bWJlcl9jb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhOWUzXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzXG52YXIgZXNfb2JqZWN0X2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjY2E2XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1xudmFyIGVzX29iamVjdF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2NGJcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcbnZhciBlc19vYmplY3RfdG9fc3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzYjdcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanNcbnZhciBlc19wcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU2Y2ZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXG52YXIgZXNfcmVnZXhwX2V4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWMxZlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzXG52YXIgZXNfc3RyaW5nX2luY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI1MzJcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBlYXQuanNcbnZhciBlc19zdHJpbmdfcmVwZWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM4Y2ZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qc1xudmFyIGVzX3N0cmluZ19zcGxpdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMjc2XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc21hbGwuanNcbnZhciBlc19zdHJpbmdfc21hbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzk2YVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qc1xudmFyIHdlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTU5YlwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXG52YXIgZXNfc3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE0ZDNcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1xudmFyIGVzX3N5bWJvbF9kZXNjcmlwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMDFhXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcbnZhciBlc19zeW1ib2xfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDI4YlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMjYwXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcbnZhciBlc19zdHJpbmdfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2NhM1wiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1xudmFyIHdlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGRiMFwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXG52YXIgZXNfcmVnZXhwX3RvX3N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNWYwXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5LmpzXG5cblxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1xudmFyIGVzX2FycmF5X2Zyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTYzMFwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG52YXIgZXNfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNDM5XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1xudmFyIGVzX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRiYjRcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanNcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qc1xudmFyIGVzX3N0cmluZ19yZXBsYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUzMTlcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9kYXRlLXV0aWxzLmpzXG5cblxuXG5cblxuXG4vLyBDYWNoZSBUb2RheSdzIGRhdGUgKHRvIGEgbWF4aW11bSkgZm9yIGJldHRlciBpc1RvZGF5KCkgcGVyZm9ybWFuY2VzLiBGb3JtYXR0ZWQgd2l0aG91dCBsZWFkaW5nIDAuXG4vLyBXZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSBUb2RheSdzIGRhdGUgd2hlbiBUb2RheSBjaGFuZ2VzIHdpdGhvdXQgcGFnZSByZWZyZXNoLlxudmFyIGRhdGVfdXRpbHNfbm93LCB0b2RheURhdGUsIHRvZGF5RjtcblxudmFyIHRvZGF5Rm9ybWF0dGVkID0gZnVuY3Rpb24gdG9kYXlGb3JtYXR0ZWQoKSB7XG4gIGlmICh0b2RheURhdGUgIT09IG5ldyBEYXRlKCkuZ2V0RGF0ZSgpKSB7XG4gICAgZGF0ZV91dGlsc19ub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHRvZGF5RGF0ZSA9IGRhdGVfdXRpbHNfbm93LmdldERhdGUoKTtcbiAgICB0b2RheUYgPSBcIlwiLmNvbmNhdChkYXRlX3V0aWxzX25vdy5nZXRGdWxsWWVhcigpLCBcIi1cIikuY29uY2F0KGRhdGVfdXRpbHNfbm93LmdldE1vbnRoKCksIFwiLVwiKS5jb25jYXQoZGF0ZV91dGlsc19ub3cuZ2V0RGF0ZSgpKTtcbiAgfVxuXG4gIHJldHVybiB0b2RheUY7XG59O1xuXG52YXIgaW5pdERhdGVQcm90b3R5cGVzID0gZnVuY3Rpb24gaW5pdERhdGVQcm90b3R5cGVzKCkge1xuICBEYXRlLnRleHRzID0ge1xuICAgIHdlZWtEYXlzOiBBcnJheSg3KS5maWxsKCcnKSxcbiAgICBtb250aHM6IEFycmF5KDEyKS5maWxsKCcnKVxuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICBEYXRlLnByb3RvdHlwZS5hZGREYXlzID0gZnVuY3Rpb24gKGRheXMpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBkYXlzKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxuICBEYXRlLnByb3RvdHlwZS5zdWJ0cmFjdERheXMgPSBmdW5jdGlvbiAoZGF5cykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRheXMpO1xuICAgIHJldHVybiBkYXRlO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gIERhdGUucHJvdG90eXBlLmFkZEhvdXJzID0gZnVuY3Rpb24gKGhvdXJzKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgKyBob3Vycyk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG5cbiAgRGF0ZS5wcm90b3R5cGUuc3VidHJhY3RIb3VycyA9IGZ1bmN0aW9uIChob3Vycykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpIC0gaG91cnMpO1xuICAgIHJldHVybiBkYXRlO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gIERhdGUucHJvdG90eXBlLmFkZE1pbnV0ZXMgPSBmdW5jdGlvbiAobWludXRlcykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIG1pbnV0ZXMpO1xuICAgIHJldHVybiBkYXRlO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG4gIERhdGUucHJvdG90eXBlLnN1YnRyYWN0TWludXRlcyA9IGZ1bmN0aW9uIChtaW51dGVzKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpIC0gbWludXRlcyk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG5cbiAgRGF0ZS5wcm90b3R5cGUuZ2V0V2VlayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHRoaXMuZ2V0RnVsbFllYXIoKSwgdGhpcy5nZXRNb250aCgpLCB0aGlzLmdldERhdGUoKSkpO1xuICAgIHZhciBkYXlOdW0gPSBkLmdldFVUQ0RheSgpIHx8IDc7XG4gICAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgNCAtIGRheU51bSk7XG4gICAgdmFyIHllYXJTdGFydCA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKChkIC0geWVhclN0YXJ0KSAvIDg2NDAwMDAwICsgMSkgLyA3KTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxuICBEYXRlLnByb3RvdHlwZS5pc1RvZGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmdldEZ1bGxZZWFyKCksIFwiLVwiKS5jb25jYXQodGhpcy5nZXRNb250aCgpLCBcIi1cIikuY29uY2F0KHRoaXMuZ2V0RGF0ZSgpKSA9PT0gdG9kYXlGb3JtYXR0ZWQoKTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxuICBEYXRlLnByb3RvdHlwZS5pc0xlYXBZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB5ZWFyID0gdGhpcy5nZXRGdWxsWWVhcigpO1xuICAgIHJldHVybiAhKHllYXIgJSA0MDApIHx8IHllYXIgJSAxMDAgJiYgISh5ZWFyICUgNCk7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG5cbiAgRGF0ZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtYXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdZWVlZLU1NLUREJztcbiAgICByZXR1cm4gZGF0ZV91dGlsc19mb3JtYXREYXRlKHRoaXMsIGZvcm1hdCwgRGF0ZS50ZXh0cyk7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG5cbiAgRGF0ZS5wcm90b3R5cGUuZm9ybWF0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9ybWF0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnSEg6bW0nO1xuICAgIHJldHVybiBkYXRlX3V0aWxzX2Zvcm1hdFRpbWUodGhpcy5nZXRIb3VycygpICogNjAgKyB0aGlzLmdldE1pbnV0ZXMoKSwgZm9ybWF0LCBEYXRlLnRleHRzKTtcbiAgfTtcbn07IC8vIEFkZCBwcm90b3R5cGVzIEFTQVAuXG5cblxuaWYgKERhdGUgJiYgIURhdGUucHJvdG90eXBlLmFkZERheXMpIGluaXREYXRlUHJvdG90eXBlcygpO1xudmFyIGRhdGVfdXRpbHNfdXBkYXRlRGF0ZVRleHRzID0gZnVuY3Rpb24gdXBkYXRlRGF0ZVRleHRzKHRleHRzKSB7XG4gIERhdGUudGV4dHMgPSB0ZXh0cztcbn07IC8vIFJldHVybnMgdG9kYXkgaWYgaXQncyBGaXJzdERheU9mV2VlayAoTW9uZGF5IG9yIFN1bmRheSkgb3IgcHJldmlvdXMgRmlyc3REYXlPZldlZWsgb3RoZXJ3aXNlLlxuXG52YXIgZ2V0UHJldmlvdXNGaXJzdERheU9mV2VlayA9IGZ1bmN0aW9uIGdldFByZXZpb3VzRmlyc3REYXlPZldlZWsoKSB7XG4gIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICB2YXIgd2Vla1N0YXJ0c09uU3VuZGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBwcmV2Rmlyc3REYXlPZldlZWsgPSBkYXRlICYmIG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKSB8fCBuZXcgRGF0ZSgpO1xuICB2YXIgZGF5TW9kaWZpZXIgPSB3ZWVrU3RhcnRzT25TdW5kYXkgPyA3IDogNjtcbiAgcHJldkZpcnN0RGF5T2ZXZWVrLnNldERhdGUocHJldkZpcnN0RGF5T2ZXZWVrLmdldERhdGUoKSAtIChwcmV2Rmlyc3REYXlPZldlZWsuZ2V0RGF5KCkgKyBkYXlNb2RpZmllcikgJSA3KTtcbiAgcmV0dXJuIHByZXZGaXJzdERheU9mV2Vlaztcbn07XG5cbnZhciBudGggPSBmdW5jdGlvbiBudGgoZCkge1xuICBpZiAoZCA+IDMgJiYgZCA8IDIxKSByZXR1cm4gJ3RoJztcblxuICBzd2l0Y2ggKGQgJSAxMCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnc3QnO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICduZCc7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gJ3JkJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ3RoJztcbiAgfVxufTtcblxudmFyIGRhdGVPYmplY3QgPSB7fTtcblxudmFyIGh5ZHJhdGVEYXRlT2JqZWN0ID0gZnVuY3Rpb24gaHlkcmF0ZURhdGVPYmplY3QoZGF0ZSwgdGV4dHMpIHtcbiAgaWYgKGRhdGVPYmplY3QuRCkgcmV0dXJuIGRhdGVPYmplY3Q7XG4gIHZhciBZWVlZID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB2YXIgTSA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gIHZhciBEID0gZGF0ZS5nZXREYXRlKCk7XG4gIHZhciBkYXkgPSBkYXRlLmdldERheSgpOyAvLyBEYXkgb2YgdGhlIHdlZWsuXG5cbiAgdmFyIGRheU51bWJlciA9IChkYXkgLSAxICsgNykgJSA3OyAvLyBEYXkgb2YgdGhlIHdlZWsuIDAgdG8gNiB3aXRoIDYgPSBTdW5kYXkuXG4gIC8vIFNvbWUgb2YgdGhpcyBwcm9wcyBhcmUgZnVuY3Rpb25zLCB0byBvbmx5IGNhbGN1bGF0ZSBvbiBkZW1hbmQuXG5cbiAgZGF0ZU9iamVjdCA9IHtcbiAgICAvLyBZZWFyLlxuICAgIFlZWVk6IFlZWVksXG4gICAgLy8gMjAxOS5cbiAgICBZWTogZnVuY3Rpb24gWVkoKSB7XG4gICAgICByZXR1cm4gWVlZWS50b1N0cmluZygpLnN1YnN0cmluZygyKTtcbiAgICB9LFxuICAgIC8vIDE5LlxuICAgIC8vIE1vbnRoLlxuICAgIE06IE0sXG4gICAgLy8gMSB0byAxMi5cbiAgICBNTTogZnVuY3Rpb24gTU0oKSB7XG4gICAgICByZXR1cm4gKE0gPCAxMCA/ICcwJyA6ICcnKSArIE07XG4gICAgfSxcbiAgICAvLyAwMSB0byAxMi5cbiAgICBNTU06IGZ1bmN0aW9uIE1NTSgpIHtcbiAgICAgIHJldHVybiB0ZXh0cy5tb250aHNbTSAtIDFdLnN1YnN0cmluZygwLCAzKTtcbiAgICB9LFxuICAgIC8vIEphbiB0byBEZWMuXG4gICAgTU1NTTogZnVuY3Rpb24gTU1NTSgpIHtcbiAgICAgIHJldHVybiB0ZXh0cy5tb250aHNbTSAtIDFdO1xuICAgIH0sXG4gICAgLy8gSmFudWFyeSB0byBEZWNlbWJlci5cbiAgICBNTU1NRzogZnVuY3Rpb24gTU1NTUcoKSB7XG4gICAgICByZXR1cm4gKHRleHRzLm1vbnRoc0dlbml0aXZlIHx8IHRleHRzLm1vbnRocylbTSAtIDFdO1xuICAgIH0sXG4gICAgLy8gSmFudWFyeSB0byBEZWNlbWJlciBpbiBnZW5pdGl2ZSBmb3JtIChHcmVlay4uLilcbiAgICAvLyBEYXkuXG4gICAgRDogRCxcbiAgICAvLyAxIHRvIDMxLlxuICAgIEREOiBmdW5jdGlvbiBERCgpIHtcbiAgICAgIHJldHVybiAoRCA8IDEwID8gJzAnIDogJycpICsgRDtcbiAgICB9LFxuICAgIC8vIDAxIHRvIDMxLlxuICAgIFM6IGZ1bmN0aW9uIFMoKSB7XG4gICAgICByZXR1cm4gbnRoKEQpO1xuICAgIH0sXG4gICAgLy8gc3QsIG5kLCByZCwgdGguXG4gICAgLy8gRGF5IG9mIHRoZSB3ZWVrLlxuICAgIGQ6IGRheU51bWJlciArIDEsXG4gICAgLy8gMSB0byA3IHdpdGggNyA9IFN1bmRheS5cbiAgICBkZDogZnVuY3Rpb24gZGQoKSB7XG4gICAgICByZXR1cm4gdGV4dHMud2Vla0RheXNbZGF5TnVtYmVyXVswXTtcbiAgICB9LFxuICAgIC8vIE0gdG8gUy5cbiAgICBkZGQ6IGZ1bmN0aW9uIGRkZCgpIHtcbiAgICAgIHJldHVybiB0ZXh0cy53ZWVrRGF5c1tkYXlOdW1iZXJdLnN1YnN0cigwLCAzKTtcbiAgICB9LFxuICAgIC8vIE1vbiB0byBTdW4uXG4gICAgZGRkZDogZnVuY3Rpb24gZGRkZCgpIHtcbiAgICAgIHJldHVybiB0ZXh0cy53ZWVrRGF5c1tkYXlOdW1iZXJdO1xuICAgIH0gLy8gTW9uZGF5IHRvIFN1bmRheS5cblxuICB9O1xuICByZXR1cm4gZGF0ZU9iamVjdDtcbn07XG5cbnZhciB0aW1lT2JqZWN0ID0ge307XG5cbnZhciBoeWRyYXRlVGltZU9iamVjdCA9IGZ1bmN0aW9uIGh5ZHJhdGVUaW1lT2JqZWN0KGRhdGUsIHRleHRzKSB7XG4gIGlmICh0aW1lT2JqZWN0LmFtKSByZXR1cm4gdGltZU9iamVjdDtcbiAgdmFyIEgsIG07XG5cbiAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgSCA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICBtID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgSCA9IE1hdGguZmxvb3IoZGF0ZSAvIDYwKTtcbiAgICBtID0gTWF0aC5mbG9vcihkYXRlICUgNjApO1xuICB9XG5cbiAgdmFyIGggPSBIICUgMTIgPyBIICUgMTIgOiAxMjtcbiAgdmFyIGFtID0gKHRleHRzIHx8IHtcbiAgICBhbTogJ2FtJyxcbiAgICBwbTogJ3BtJ1xuICB9KVtIID09PSAyNCB8fCBIIDwgMTIgPyAnYW0nIDogJ3BtJ107XG4gIHRpbWVPYmplY3QgPSB7XG4gICAgSDogSCxcbiAgICBoOiBoLFxuICAgIEhIOiAoSCA8IDEwID8gJzAnIDogJycpICsgSCxcbiAgICBoaDogKGggPCAxMCA/ICcwJyA6ICcnKSArIGgsXG4gICAgYW06IGFtLFxuICAgIEFNOiBhbS50b1VwcGVyQ2FzZSgpLFxuICAgIG06IG0sXG4gICAgbW06IChtIDwgMTAgPyAnMCcgOiAnJykgKyBtXG4gIH07XG4gIHJldHVybiB0aW1lT2JqZWN0O1xufTsgLy8gVGltZSBpbiBtaW51dGVzLlxuXG5cbnZhciBkYXRlX3V0aWxzX2Zvcm1hdFRpbWUgPSBmdW5jdGlvbiBmb3JtYXRUaW1lKHRpbWUpIHtcbiAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ0hIOm1tJztcbiAgdmFyIHRleHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHRpbWVPYmplY3QgPSB7fTsgLy8gUmVpbml0IHRoZSB0aW1lIG9iamVjdCBvbiBlYWNoIGZ1bmN0aW9uIGNhbGwuXG5cbiAgdmFyIHRpbWVPYmogPSBoeWRyYXRlVGltZU9iamVjdCh0aW1lLCB0ZXh0cyk7XG4gIHJldHVybiBmb3JtYXQucmVwbGFjZSgvKFxce1thLXpBLVpdK1xcfXxbYS16QS1aXSspL2csIGZ1bmN0aW9uIChtLCBjb250ZW50cykge1xuICAgIHZhciByZXN1bHQgPSB0aW1lT2JqW2NvbnRlbnRzLnJlcGxhY2UoL1xce3xcXH0vZywgJycpXTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQgPyByZXN1bHQgOiBjb250ZW50cztcbiAgfSk7XG59O1xuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZS90aW1lIHRvIHRoZSBnaXZlbiBmb3JtYXQgYW5kIHJldHVybnMgdGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCB0byBmb3JtYXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IHRoZSB3YW50ZWQgZm9ybWF0LlxuICogQHBhcmFtIHtPYmplY3R9IHRleHRzIHRoZSB2dWUtY2FsIGxvY2FsaXplZCB0ZXh0cyBvYmplY3QuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICovXG5cbnZhciBkYXRlX3V0aWxzX2Zvcm1hdERhdGUgPSBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ1lZWVktTU0tREQnO1xuICB2YXIgdGV4dHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFmb3JtYXQpIGZvcm1hdCA9ICdZWVlZLU1NLUREJzsgLy8gQWxsb3dzIHBhc3NpbmcgbnVsbCBmb3IgZGVmYXVsdCBmb3JtYXQuXG5cbiAgaWYgKGZvcm1hdCA9PT0gJ1lZWVktTU0tREQnKSByZXR1cm4gZm9ybWF0RGF0ZUxpdGUoZGF0ZSk7IC8vIFJlaW5pdCB0aGUgZGF0ZSBhbmQgdGltZSBvYmplY3Qgb24gZWFjaCBmdW5jdGlvbiBjYWxsLlxuXG4gIGRhdGVPYmplY3QgPSB7fTtcbiAgdGltZU9iamVjdCA9IHt9OyAvLyBFYWNoIGtleXdvcmQgaXMgYSBmdW5jdGlvbiB0byBsb2FkIHRoZSBkYXRlT2JqZWN0IG9yIHRpbWVPYmplY3Qgb24gZGVtYW5kOiBubyB3YXN0ZWQgcmVzb3VyY2UuXG5cbiAgdmFyIGRhdGVPYmogPSB7XG4gICAgWVlZWTogZnVuY3Rpb24gWVlZWSgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuWVlZWTtcbiAgICB9LFxuICAgIFlZOiBmdW5jdGlvbiBZWSgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuWVkoKTtcbiAgICB9LFxuICAgIE06IGZ1bmN0aW9uIE0oKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZURhdGVPYmplY3QoZGF0ZSwgdGV4dHMpLk07XG4gICAgfSxcbiAgICBNTTogZnVuY3Rpb24gTU0oKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZURhdGVPYmplY3QoZGF0ZSwgdGV4dHMpLk1NKCk7XG4gICAgfSxcbiAgICBNTU06IGZ1bmN0aW9uIE1NTSgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuTU1NKCk7XG4gICAgfSxcbiAgICBNTU1NOiBmdW5jdGlvbiBNTU1NKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVEYXRlT2JqZWN0KGRhdGUsIHRleHRzKS5NTU1NKCk7XG4gICAgfSxcbiAgICBNTU1NRzogZnVuY3Rpb24gTU1NTUcoKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZURhdGVPYmplY3QoZGF0ZSwgdGV4dHMpLk1NTU1HKCk7XG4gICAgfSxcbiAgICBEOiBmdW5jdGlvbiBEKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVEYXRlT2JqZWN0KGRhdGUsIHRleHRzKS5EO1xuICAgIH0sXG4gICAgREQ6IGZ1bmN0aW9uIEREKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVEYXRlT2JqZWN0KGRhdGUsIHRleHRzKS5ERCgpO1xuICAgIH0sXG4gICAgUzogZnVuY3Rpb24gUygpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuUygpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZCgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuZDtcbiAgICB9LFxuICAgIGRkOiBmdW5jdGlvbiBkZCgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlRGF0ZU9iamVjdChkYXRlLCB0ZXh0cykuZGQoKTtcbiAgICB9LFxuICAgIGRkZDogZnVuY3Rpb24gZGRkKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVEYXRlT2JqZWN0KGRhdGUsIHRleHRzKS5kZGQoKTtcbiAgICB9LFxuICAgIGRkZGQ6IGZ1bmN0aW9uIGRkZGQoKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZURhdGVPYmplY3QoZGF0ZSwgdGV4dHMpLmRkZGQoKTtcbiAgICB9LFxuICAgIEhIOiBmdW5jdGlvbiBISCgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlVGltZU9iamVjdChkYXRlLCB0ZXh0cykuSEg7XG4gICAgfSxcbiAgICBIOiBmdW5jdGlvbiBIKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVUaW1lT2JqZWN0KGRhdGUsIHRleHRzKS5IO1xuICAgIH0sXG4gICAgaGg6IGZ1bmN0aW9uIGhoKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVUaW1lT2JqZWN0KGRhdGUsIHRleHRzKS5oaDtcbiAgICB9LFxuICAgIGg6IGZ1bmN0aW9uIGgoKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZVRpbWVPYmplY3QoZGF0ZSwgdGV4dHMpLmg7XG4gICAgfSxcbiAgICBhbTogZnVuY3Rpb24gYW0oKSB7XG4gICAgICByZXR1cm4gaHlkcmF0ZVRpbWVPYmplY3QoZGF0ZSwgdGV4dHMpLmFtO1xuICAgIH0sXG4gICAgQU06IGZ1bmN0aW9uIEFNKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVUaW1lT2JqZWN0KGRhdGUsIHRleHRzKS5BTTtcbiAgICB9LFxuICAgIG1tOiBmdW5jdGlvbiBtbSgpIHtcbiAgICAgIHJldHVybiBoeWRyYXRlVGltZU9iamVjdChkYXRlLCB0ZXh0cykubW07XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKCkge1xuICAgICAgcmV0dXJuIGh5ZHJhdGVUaW1lT2JqZWN0KGRhdGUsIHRleHRzKS5tO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8oXFx7W2EtekEtWl0rXFx9fFthLXpBLVpdKykvZywgZnVuY3Rpb24gKG0sIGNvbnRlbnRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGVPYmpbY29udGVudHMucmVwbGFjZSgvXFx7fFxcfS9nLCAnJyldO1xuICAgIHJldHVybiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCgpIDogY29udGVudHM7XG4gIH0pO1xufTsgLy8gTW9yZSBwZXJmb3JtYW50IGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBEYXRlIHRvIGBZWVlZLU1NLUREYCBmb3JtYXR0ZWQgc3RyaW5nIG9ubHkuXG5cbnZhciBmb3JtYXREYXRlTGl0ZSA9IGZ1bmN0aW9uIGZvcm1hdERhdGVMaXRlKGRhdGUpIHtcbiAgdmFyIG0gPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICB2YXIgZCA9IGRhdGUuZ2V0RGF0ZSgpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZGF0ZS5nZXRGdWxsWWVhcigpLCBcIi1cIikuY29uY2F0KG0gPCAxMCA/ICcwJyA6ICcnKS5jb25jYXQobSwgXCItXCIpLmNvbmNhdChkIDwgMTAgPyAnMCcgOiAnJykuY29uY2F0KGQpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0LiBJZiBhIERhdGUgb2JqZWN0IGlzIHBhc3NlZCwgcmV0dXJuIGl0IGFzIGlzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nIHwgRGF0ZX0gZGF0ZSB0aGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gRGF0ZS5cbiAqIEByZXR1cm4ge0RhdGV9IHRoZSBlcXVpdmFsZW50IEphdmFzY3JpcHQgRGF0ZSBvYmplY3QuXG4gKi9cblxudmFyIHN0cmluZ1RvRGF0ZSA9IGZ1bmN0aW9uIHN0cmluZ1RvRGF0ZShkYXRlKSB7XG4gIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIGRhdGU7IC8vIFJlZ2V4cCB3YXkgaXMgbGVzcyBwZXJmb3JtYW50OiBodHRwczovL2pzcGVyZi5jb20vc3RyaW5nLXRvLWRhdGUtcmVnZXhwLXZzLW5ldy1kYXRlXG4gIC8vIGNvbnN0IFssIHksIG0sIGQsIGggPSAwLCBtaW4gPSAwXSA9IGRhdGUubWF0Y2goLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pKD86IChcXGR7Mn0pOihcXGR7Mn0pKT8vKVxuICAvLyByZXR1cm4gbmV3IERhdGUoeSwgcGFyc2VJbnQobSkgLSAxLCBkLCBoLCBtaW4pXG5cbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUucmVwbGFjZSgvLS9nLCAnLycpKTsgLy8gcmVwbGFjZSAnLScgd2l0aCAnLycgZm9yIFNhZmFyaS5cbn07XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgZGF5cyB0aGlzIGRhdGUgcmFuZ2Ugc3BhbnMgb250by5cbiAqIEUuZy4gY291bnREYXlzKDIwMTktMTEtMDIgMTg6MDAsIDIwMTktMTEtMDMgMDI6MDApID0gMlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nIHwgRGF0ZX0gc3RhcnQgdGhlIHN0YXJ0IGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgRGF0ZX0gZW5kIHRoZSBlbmQgZGF0ZVxuICogQHJldHVybiB7SW50ZWdlcn0gVGhlIG51bWJlciBvZiBkYXlzIHRoaXMgZGF0ZSByYW5nZSBpbnZvbHZlc1xuICovXG5cbnZhciBjb3VudERheXMgPSBmdW5jdGlvbiBjb3VudERheXMoc3RhcnQsIGVuZCkge1xuICAvLyByZXBsYWNlICctJyB3aXRoICcvJyBmb3IgU2FmYXJpLlxuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC8tL2csICcvJyk7XG4gIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykgZW5kID0gZW5kLnJlcGxhY2UoLy0vZywgJy8nKTsgLy8gU2V0IHN0YXJ0ICYgZW5kIGF0IG1pZG5pZ2h0IHRoZW4gY29tcGFyZSB0aGUgZGVsdGEuIERvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWwgZGF0ZXMuXG5cbiAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7IC8vIFNldCBlbmQgYXQgbWlkbmlnaHQgcGx1cyAxIHNlYywgc28gTWF0aC5jZWlsIHdpbGwgcm91bmQgaXQgdXAgdG8gYSBmdWxsIGRheS5cblxuICBlbmQgPSBuZXcgRGF0ZShlbmQpLnNldEhvdXJzKDAsIDAsIDEsIDApOyAvLyBSZW1vdmUgdGhlIHBvdGVudGlhbCBkYXlsaWdodCBzYXZpbmcgZGVsdGEuXG5cbiAgdmFyIHRpbWV6b25lRGlmZk1zID0gKG5ldyBEYXRlKGVuZCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIG5ldyBEYXRlKHN0YXJ0KS5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDYwICogMTAwMDtcbiAgcmV0dXJuIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQgLSB0aW1lem9uZURpZmZNcykgLyAoMjQgKiAzNjAwICogMTAwMCkpO1xufTtcbi8qKlxuICogVGFrZSAyIGRhdGVzIGFuZCBjaGVjayBpZiB3aXRoaW4gdGhlIHNhbWUgdGltZSBzdGVwICh1c2VmdWwgaW4gb3ZlcmxhcHBpbmcgZXZlbnRzKS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlaXIgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGUgc2FtZSB0aW1lIHN0ZXAsXG4gKiAgICAgICAgICAgICAgICAgICB0aGlzIG1lYW5zIHRoZXNlIDIgZGF0ZXMgYXJlIHZlcnkgY2xvc2UuXG4gKi9cblxudmFyIGRhdGVzSW5TYW1lVGltZVN0ZXAgPSBmdW5jdGlvbiBkYXRlc0luU2FtZVRpbWVTdGVwKGRhdGUxLCBkYXRlMiwgdGltZVN0ZXApIHtcbiAgcmV0dXJuIE1hdGguYWJzKGRhdGUxLmdldFRpbWUoKSAtIGRhdGUyLmdldFRpbWUoKSkgPD0gdGltZVN0ZXAgKiA2MCAqIDEwMDA7XG59O1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC1pbmRleC5qc1xudmFyIGVzX2FycmF5X2ZpbmRfaW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzc0MFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzXG52YXIgZXNfYXJyYXlfc3BsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE0MzRcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qc1xudmFyIGVzX3NldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MDYyXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJ2dWVcIixcImNvbW1vbmpzMlwiOlwidnVlXCIsXCJyb290XCI6XCJWdWVcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGJiZlwiKTtcbnZhciBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZXZlbnQtdXRpbHMuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGRlZmF1bHRFdmVudER1cmF0aW9uID0gMjsgLy8gSW4gaG91cnMuXG5cbnZhciBtaW51dGVzSW5BRGF5ID0gMjQgKiA2MDsgLy8gRG9uJ3QgZG8gdGhlIG1hdGhzIGV2ZXJ5IHRpbWUuXG4vLyBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24sIGl0IHdpbGwgbm90IHdvcmsgd2l0aCBETFMgdGltZS5cbi8vIGNvbnN0IGFwcHJveERheU1pbGxpc2Vjb25kcyA9IG1pbnV0ZXNJbkFEYXkgKiA2MCAqIDEwMDBcbi8vIFRoaXMgaXMgYW4gYXBwcm94aW1hdGUgbWluaW11bSB3ZSBjYW4gZ2V0IGluIGEgeWVhci4gUHVycG9zZWx5IHN0YXkgYmVsbG93IDM2NSBidXQgY2xvc2UuXG4vLyBjb25zdCBtaW5ZZWFyTWlsbGlzZWNvbmRzID0gMzY0ICogYXBwcm94RGF5TWlsbGlzZWNvbmRzIC8vIERvbid0IGRvIHRoZSBtYXRocyBldmVyeSB0aW1lLlxuXG52YXIgZXZlbnREZWZhdWx0cyA9IHtcbiAgX2VpZDogbnVsbCxcbiAgc3RhcnQ6ICcnLFxuICAvLyBFeHRlcm5hbGx5IGdpdmVuIGZvcm1hdHRlZCBkYXRlICYgdGltZS5cbiAgc3RhcnREYXRlOiAnJyxcbiAgLy8gRGF0ZSBvYmplY3QuXG4gIHN0YXJ0VGltZU1pbnV0ZXM6IDAsXG4gIGVuZDogJycsXG4gIC8vIEV4dGVybmFsbHkgZ2l2ZW4gZm9ybWF0dGVkIGRhdGUgJiB0aW1lLlxuICBlbmREYXRlOiAnJyxcbiAgLy8gRGF0ZSBvYmplY3QuXG4gIGVuZFRpbWVNaW51dGVzOiAwLFxuICB0aXRsZTogJycsXG4gIGNvbnRlbnQ6ICcnLFxuICBiYWNrZ3JvdW5kOiBmYWxzZSxcbiAgYWxsRGF5OiBmYWxzZSxcbiAgc2VnbWVudHM6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgZGF5c0NvdW50OiAxLFxuICBkZWxldGFibGU6IHRydWUsXG4gIGRlbGV0aW5nOiBmYWxzZSxcbiAgcmVzaXphYmxlOiB0cnVlLFxuICByZXNpemluZzogZmFsc2UsXG4gIGRyYWdnYWJsZTogdHJ1ZSxcbiAgZHJhZ2dpbmc6IGZhbHNlLFxuICBkcmFnZ2luZ1N0YXRpYzogZmFsc2UsXG4gIC8vIENvbnRyb2xzIHRoZSBDU1MgY2xhc3Mgb2YgdGhlIHN0YXRpYyBjbG9uZSB3aGlsZSBkcmFnZ2luZy5cbiAgZm9jdXNlZDogZmFsc2UsXG4gIHRvcDogMCxcbiAgaGVpZ2h0OiAwLFxuICBjbGFzc2VzOiBbXVxufTtcbi8qKlxuICogQ3JlYXRlIGFuIGV2ZW50IGF0IHRoZSBnaXZlbiBkYXRlIGFuZCB0aW1lLCBhbmQgYWxsb3cgb3ZlcnJpZGluZ1xuICogZXZlbnQgYXR0cmlidXRlcyB0aHJvdWdoIHRoZSBldmVudE9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGF0ZSB8IFN0cmluZ30gZGF0ZVRpbWUgVGhlIGRhdGUgYW5kIHRpbWUgb2YgdGhlIG5ldyBldmVudCBzdGFydC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9wdGlvbnMgc29tZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBgZXZlbnREZWZhdWx0c2AgLSBvcHRpb25hbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgdGhlIHZ1ZWNhbCBtYWluIGNvbXBvbmVudCwgdG8gYWNjZXNzIG5lZWRlZCBtZXRob2RzLCBwcm9wcywgZXRjLlxuICovXG5cbnZhciBldmVudF91dGlsc19jcmVhdGVBbkV2ZW50ID0gZnVuY3Rpb24gY3JlYXRlQW5FdmVudChkYXRlVGltZSwgZXZlbnRPcHRpb25zLCB2dWVjYWwpIHtcbiAgaWYgKHR5cGVvZiBkYXRlVGltZSA9PT0gJ3N0cmluZycpIGRhdGVUaW1lID0gc3RyaW5nVG9EYXRlKGRhdGVUaW1lKTtcbiAgaWYgKCEoZGF0ZVRpbWUgaW5zdGFuY2VvZiBEYXRlKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaG91cnMgPSBkYXRlVGltZS5nZXRIb3VycygpO1xuICB2YXIgbWludXRlcyA9IGRhdGVUaW1lLmdldE1pbnV0ZXMoKTtcbiAgdmFyIHN0YXJ0VGltZU1pbnV0ZXMgPSBob3VycyAqIDYwICsgbWludXRlcztcbiAgdmFyIGhvdXJzRW5kID0gaG91cnMgKyBkZWZhdWx0RXZlbnREdXJhdGlvbjtcbiAgdmFyIGVuZFRpbWVNaW51dGVzID0gc3RhcnRUaW1lTWludXRlcyArIDEyMDtcbiAgdmFyIGZvcm1hdHRlZEhvdXJzID0gKGhvdXJzIDwgMTAgPyAnMCcgOiAnJykgKyBob3VycztcbiAgdmFyIGZvcm1hdHRlZEhvdXJzRW5kID0gKGhvdXJzRW5kIDwgMTAgPyAnMCcgOiAnJykgKyBob3Vyc0VuZDtcbiAgdmFyIGZvcm1hdHRlZE1pbnV0ZXMgPSAobWludXRlcyA8IDEwID8gJzAnIDogJycpICsgbWludXRlcztcbiAgdmFyIHN0YXJ0ID0gZm9ybWF0RGF0ZUxpdGUoZGF0ZVRpbWUpICsgKHZ1ZWNhbC50aW1lID8gXCIgXCIuY29uY2F0KGZvcm1hdHRlZEhvdXJzLCBcIjpcIikuY29uY2F0KGZvcm1hdHRlZE1pbnV0ZXMpIDogJycpO1xuICB2YXIgZW5kID0gZm9ybWF0RGF0ZUxpdGUoZGF0ZVRpbWUpICsgKHZ1ZWNhbC50aW1lID8gXCIgXCIuY29uY2F0KGZvcm1hdHRlZEhvdXJzRW5kLCBcIjpcIikuY29uY2F0KGZvcm1hdHRlZE1pbnV0ZXMpIDogJycpO1xuXG4gIHZhciBldmVudCA9IF9vYmplY3RTcHJlYWQyKHt9LCBldmVudERlZmF1bHRzLCB7XG4gICAgX2VpZDogXCJcIi5jb25jYXQodnVlY2FsLl91aWQsIFwiX1wiKS5jb25jYXQodnVlY2FsLmV2ZW50SWRJbmNyZW1lbnQrKyksXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIHN0YXJ0RGF0ZTogZGF0ZVRpbWUsXG4gICAgc3RhcnRUaW1lTWludXRlczogc3RhcnRUaW1lTWludXRlcyxcbiAgICBlbmQ6IGVuZCxcbiAgICBlbmREYXRlOiBzdHJpbmdUb0RhdGUoZW5kKSxcbiAgICBlbmRUaW1lTWludXRlczogZW5kVGltZU1pbnV0ZXMsXG4gICAgc2VnbWVudHM6IG51bGxcbiAgfSwgZXZlbnRPcHRpb25zKTsgLy8gSWYgdGhlIG9uRXZlbnRDcmVhdGUoKSBmdW5jdGlvbiBpcyBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB2dWUtY2FsOlxuICAvLyAxLiBnaXZlIGl0IGFjY2VzcyB0byB0aGUgY3JlYXRlZCBldmVudCAmIHRoZSBkZWxldGVBbkV2ZW50KCkgZnVuY3Rpb24uXG4gIC8vIDIuIFByZXZlbnQgY3JlYXRpb24gb2YgdGhlIGV2ZW50IGlmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBmYWxzZS5cblxuXG4gIGlmICh0eXBlb2YgdnVlY2FsLm9uRXZlbnRDcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIXZ1ZWNhbC5vbkV2ZW50Q3JlYXRlKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVsZXRlQW5FdmVudChldmVudCwgdnVlY2FsKTtcbiAgICB9KSkgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIGV2ZW50IGlzIGEgbXVsdGlwbGUgZGF5IGV2ZW50IGFuZCB1cGRhdGUgZGF5cyBjb3VudC5cblxuXG4gIGlmIChldmVudC5zdGFydC5zdWJzdHIoMCwgMTApICE9PSBldmVudC5lbmQuc3Vic3RyKDAsIDEwKSkge1xuICAgIGV2ZW50LmRheXNDb3VudCA9IGNvdW50RGF5cyhldmVudC5zdGFydERhdGUsIGV2ZW50LmVuZERhdGUpO1xuICB9IC8vIEFkZCBldmVudCB0byB0aGUgbXV0YWJsZUV2ZW50cyBhcnJheS5cblxuXG4gIHZ1ZWNhbC5tdXRhYmxlRXZlbnRzLnB1c2goZXZlbnQpOyAvLyBBZGQgdGhlIG5ldyBldmVudCB0byB0aGUgY3VycmVudCB2aWV3LlxuICAvLyBUaGUgZXZlbnQgbWF5IGhhdmUgYmVlbiBlZGl0ZWQgb24gdGhlIGZseSB0byBiZWNvbWUgYSBtdWx0aXBsZS1kYXkgZXZlbnQsXG4gIC8vIHRoZSBtZXRob2QgYWRkRXZlbnRzVG9WaWV3IG1ha2VzIHN1cmUgdGhlIHNlZ21lbnRzIGFyZSBjcmVhdGVkLlxuXG4gIHZ1ZWNhbC5hZGRFdmVudHNUb1ZpZXcoW2V2ZW50XSk7XG4gIHZ1ZWNhbC5lbWl0V2l0aEV2ZW50KCdldmVudC1jcmVhdGUnLCBldmVudCk7XG4gIHZ1ZWNhbC5lbWl0V2l0aEV2ZW50KCdldmVudC1jaGFuZ2UnLCBldmVudCk7XG4gIHJldHVybiBldmVudDtcbn07XG4vKipcbiAqIEFkZCBhbiBldmVudCBzZWdtZW50ICg9IGRheSkgdG8gYSBtdWx0aXBsZS1kYXkgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIG11bHRpcGxlLWRheSBldmVudCB0byBhZGQgc2VnbWVudCBpbi5cbiAqL1xuXG52YXIgZXZlbnRfdXRpbHNfYWRkRXZlbnRTZWdtZW50ID0gZnVuY3Rpb24gYWRkRXZlbnRTZWdtZW50KGUpIHtcbiAgaWYgKCFlLnNlZ21lbnRzKSB7XG4gICAgZXh0ZXJuYWxfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfcm9vdF9WdWVfZGVmYXVsdC5hLnNldChlLCAnc2VnbWVudHMnLCB7fSk7XG4gICAgZS5zZWdtZW50c1tlLnN0YXJ0LnN1YnN0cigwLCAxMCldID0ge1xuICAgICAgc3RhcnREYXRlOiBlLnN0YXJ0RGF0ZSxcbiAgICAgIHN0YXJ0OiBlLnN0YXJ0LnN1YnN0cigwLCAxMCksXG4gICAgICBzdGFydFRpbWVNaW51dGVzOiBlLnN0YXJ0VGltZU1pbnV0ZXMsXG4gICAgICBlbmRUaW1lTWludXRlczogbWludXRlc0luQURheSxcbiAgICAgIGlzRmlyc3REYXk6IHRydWUsXG4gICAgICBpc0xhc3REYXk6IGZhbHNlLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfSAvLyBNb2RpZnkgdGhlIGxhc3Qgc2VnbWVudCAtIHdoaWNoIGlzIG5vIG1vcmUgdGhlIGxhc3Qgb25lLlxuXG5cbiAgdmFyIHByZXZpb3VzU2VnbWVudCA9IGUuc2VnbWVudHNbZm9ybWF0RGF0ZUxpdGUoZS5lbmREYXRlKV07IC8vIHByZXZpb3VzU2VnbWVudCBtaWdodCBub3QgZXhpc3Qgd2hlbiBkcmFnZ2luZyB0b28gZmFzdCwgcHJldmVudCBlcnJvcnMuXG5cbiAgaWYgKHByZXZpb3VzU2VnbWVudCkge1xuICAgIHByZXZpb3VzU2VnbWVudC5pc0xhc3REYXkgPSBmYWxzZTtcbiAgICBwcmV2aW91c1NlZ21lbnQuZW5kVGltZU1pbnV0ZXMgPSBtaW51dGVzSW5BRGF5O1xuICB9IGVsc2Uge30gLy8gQHRvZG86IHdoZW4gbW92aW5nIGZhc3QgbWlnaHQgbG9zZSB0aGUgcHJldmlvdXNTZWdtZW50LlxuICAvLyBUcnlpbmcgdG8gdXBkYXRlIGl0IHdvdWxkIHRoZW4gcmVzdWx0IGluIGFuIGVycm9yLCBidXQgZG8gbm90aGluZyB3b3VsZCBjcmVhdGUgYSB2aXN1YWwgYnVnLlxuICAvLyBDcmVhdGUgdGhlIG5ldyBsYXN0IHNlZ21lbnQuXG5cblxuICB2YXIgc3RhcnREYXRlID0gZS5lbmREYXRlLmFkZERheXMoMSk7XG4gIHZhciBlbmREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgdmFyIGZvcm1hdHRlZERhdGUgPSBmb3JtYXREYXRlTGl0ZShzdGFydERhdGUpO1xuICBzdGFydERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGUuc2VnbWVudHNbZm9ybWF0dGVkRGF0ZV0gPSB7XG4gICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgc3RhcnQ6IGZvcm1hdHRlZERhdGUsXG4gICAgc3RhcnRUaW1lTWludXRlczogMCxcbiAgICBlbmRUaW1lTWludXRlczogZS5lbmRUaW1lTWludXRlcyxcbiAgICBpc0ZpcnN0RGF5OiBmYWxzZSxcbiAgICBpc0xhc3REYXk6IHRydWUsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHRvcDogMFxuICB9O1xuICBlLmRheXNDb3VudCA9IE9iamVjdC5rZXlzKGUuc2VnbWVudHMpLmxlbmd0aDtcbiAgZS5lbmREYXRlID0gZW5kRGF0ZTtcbiAgZS5lbmQgPSBcIlwiLmNvbmNhdChmb3JtYXR0ZWREYXRlLCBcIiBcIikuY29uY2F0KGRhdGVfdXRpbHNfZm9ybWF0VGltZShlLmVuZFRpbWVNaW51dGVzKSk7XG4gIHJldHVybiBmb3JtYXR0ZWREYXRlO1xufTtcbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IHNlZ21lbnQgKD0gZGF5KSBmcm9tIGEgbXVsdGlwbGUtZGF5IGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBtdWx0aXBsZS1kYXkgZXZlbnQgdG8gcmVtb3ZlIHNlZ21lbnRzIGZyb20uXG4gKi9cblxudmFyIGV2ZW50X3V0aWxzX3JlbW92ZUV2ZW50U2VnbWVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50U2VnbWVudChlKSB7XG4gIHZhciBzZWdtZW50c0NvdW50ID0gT2JqZWN0LmtleXMoZS5zZWdtZW50cykubGVuZ3RoO1xuICBpZiAoc2VnbWVudHNDb3VudCA8PSAxKSByZXR1cm4gZS5lbmQuc3Vic3RyKDAsIDEwKTsgLy8gUmVtb3ZlIHRoZSBsYXN0IHNlZ21lbnQuXG5cbiAgZGVsZXRlIGUuc2VnbWVudHNbZS5lbmQuc3Vic3RyKDAsIDEwKV07XG4gIHNlZ21lbnRzQ291bnQtLTtcbiAgdmFyIGVuZERhdGUgPSBlLmVuZERhdGUuc3VidHJhY3REYXlzKDEpO1xuICB2YXIgZm9ybWF0dGVkRGF0ZSA9IGZvcm1hdERhdGVMaXRlKGVuZERhdGUpO1xuICB2YXIgcHJldmlvdXNTZWdtZW50ID0gZS5zZWdtZW50c1tmb3JtYXR0ZWREYXRlXTsgLy8gSWYgbm8gbW9yZSBzZWdtZW50cywgcmVzZXQgdGhlIHNlZ21lbnRzIGF0dHJpYnV0ZSB0byBudWxsLlxuXG4gIGlmICghc2VnbWVudHNDb3VudCkgZS5zZWdtZW50cyA9IG51bGw7IC8vIHByZXZpb3VzU2VnbWVudCBtaWdodCBub3QgZXhpc3Qgd2hlbiBkcmFnZ2luZyB0b28gZmFzdCwgcHJldmVudCBlcnJvcnMuXG4gIGVsc2UgaWYgKHByZXZpb3VzU2VnbWVudCkge1xuICAgICAgLy8gTW9kaWZ5IHRoZSBuZXcgbGFzdCBzZWdtZW50LlxuICAgICAgcHJldmlvdXNTZWdtZW50LmlzTGFzdERheSA9IHRydWU7XG4gICAgICBwcmV2aW91c1NlZ21lbnQuZW5kVGltZU1pbnV0ZXMgPSBlLmVuZFRpbWVNaW51dGVzO1xuICAgIH0gZWxzZSB7Ly8gQHRvZG86IHdoZW4gbW92aW5nIGZhc3QgbWlnaHQgbG9zZSB0aGUgcHJldmlvdXNTZWdtZW50LlxuICAgICAgLy8gVHJ5aW5nIHRvIHVwZGF0ZSBpdCB3b3VsZCB0aGVuIHJlc3VsdCBpbiBhbiBlcnJvciwgYnV0IGRvIG5vdGhpbmcgd291bGQgY3JlYXRlIGEgdmlzdWFsIGJ1Zy5cbiAgICB9XG4gIGUuZGF5c0NvdW50ID0gc2VnbWVudHNDb3VudCB8fCAxO1xuICBlLmVuZERhdGUgPSBlbmREYXRlO1xuICBlLmVuZCA9IFwiXCIuY29uY2F0KGZvcm1hdHRlZERhdGUsIFwiIFwiKS5jb25jYXQoZGF0ZV91dGlsc19mb3JtYXRUaW1lKGUuZW5kVGltZU1pbnV0ZXMpKTtcbiAgcmV0dXJuIGZvcm1hdHRlZERhdGU7XG59O1xuLyoqXG4gKiBDcmVhdGUgMSBzZWdtZW50IHBlciBkYXkgb2YgdGhlIGdpdmVuIGV2ZW50LCBidXQgb25seSB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldy5cbiAqIChJdCB3b24ndCBjcmVhdGUgc2VnbWVudHMgZm9yIGFsbCB0aGUgZGF5cyBpbiB2aWV3IHRoYXQgYXJlIG5vdCBpbiB0aGUgZXZlbnQhKVxuICpcbiAqIEFuIGV2ZW50IHNlZ21lbnQgaXMgYSBwaWVjZSBvZiBldmVudCBwZXIgZGF5IHRoYXQgY29udGFpbnMgbW9yZSBkYXktc3BlY2lmaWMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgbXVsdGlwbGUtZGF5IGV2ZW50IHRvIGNyZWF0ZSBzZWdtZW50cyBmb3IuXG4gKiBAcGFyYW0ge0RhdGV9IHZpZXdTdGFydERhdGUgdGhlIHN0YXJ0aW5nIGRhdGUgb2YgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0RhdGV9IHZpZXdFbmREYXRlIHRoZSBlbmRpbmcgZGF0ZSBvZiB0aGUgdmlldy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgdGhlIHZ1ZWNhbCBtYWluIGNvbXBvbmVudCwgdG8gYWNjZXNzIG5lZWRlZCBtZXRob2RzLCBwcm9wcywgZXRjLlxuICovXG5cbnZhciBldmVudF91dGlsc19jcmVhdGVFdmVudFNlZ21lbnRzID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRTZWdtZW50cyhlLCB2aWV3U3RhcnREYXRlLCB2aWV3RW5kRGF0ZSkge1xuICB2YXIgdmlld1N0YXJ0VGltZXN0YW1wID0gdmlld1N0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gIHZhciB2aWV3RW5kVGltZXN0YW1wID0gdmlld0VuZERhdGUuZ2V0VGltZSgpO1xuICB2YXIgZXZlbnRTdGFydCA9IGUuc3RhcnREYXRlLmdldFRpbWUoKTtcbiAgdmFyIGV2ZW50RW5kID0gZS5lbmREYXRlLmdldFRpbWUoKTtcbiAgdmFyIHJlcGVhdGVkRXZlbnRTdGFydEZvdW5kID0gZmFsc2U7XG4gIHZhciB0aW1lc3RhbXAsIGVuZCwgZXZlbnRTdGFydEF0TWlkbmlnaHQ7IC8vIEB0b2RvOiBJIGRvbid0IHRoaW5rIHdlIHN0aWxsIG5lZWQgdGhhdDpcbiAgLy8gUmVtb3ZpbmcgMSBzZWMgd2hlbiBlbmRpbmcgYXQgMDA6MDAsIHNvIHRoYXQgd2UgZG9uJ3QgY3JlYXRlIGEgc2VnbWVudCBmb3Igbm90aGluZyBvbiBsYXN0IGRheS5cblxuICBpZiAoIWUuZW5kRGF0ZS5nZXRIb3VycygpICYmICFlLmVuZERhdGUuZ2V0TWludXRlcygpKSBldmVudEVuZCAtPSAxMDAwO1xuICBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0LmEuc2V0KGUsICdzZWdtZW50cycsIHt9KTsgLy8gVGhlIGdvYWwgaXMgdG8gY3JlYXRlIDEgc2VnbWVudCBwZXIgZGF5IGluIHRoZSBldmVudCwgYnV0IG9ubHkgd2l0aGluIHRoZSBjdXJyZW50IHZpZXcuXG5cbiAgaWYgKCFlLnJlcGVhdCkge1xuICAgIC8vIFNpbXBsZSBjYXNlIGZpcnN0LlxuICAgIHRpbWVzdGFtcCA9IE1hdGgubWF4KHZpZXdTdGFydFRpbWVzdGFtcCwgZXZlbnRTdGFydCk7XG4gICAgZW5kID0gTWF0aC5taW4odmlld0VuZFRpbWVzdGFtcCwgZXZlbnRFbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlLCBhbmQgZW5kIGF0IHNvb25lc3QgYmV0d2VlbiBgcmVwZWF0LnVudGlsYCBpZiBhbnkgb3IgcmFuZ2UgZW5kLlxuICAgIC8vIFRoaXMgcmFuZ2Ugd2lsbCBtb3N0IGxpa2VseSBiZSB0b28gbGFyZ2UgKGUuZy4gd2hvbGUgd2VlaykgYW5kIHdlIG5lZWQgdG8gbmFycm93IGl0XG4gICAgLy8gZG93biBpbiB0aGUgd2hpbGUgbG9vcCBiZWxsb3cuXG4gICAgLy8gV2UgbXVzdCBub3QgY3JlYXRlIHVudXNlZCBzZWdtZW50cywgaXQgd291bGQgYnJlYWsgdGhlIHJlbmRlciBvciByZXN1bHQgaW4gd2VpcmQgYmVoYXZpb3JzLlxuICAgIHRpbWVzdGFtcCA9IHZpZXdTdGFydFRpbWVzdGFtcDtcbiAgICBlbmQgPSBNYXRoLm1pbih2aWV3RW5kVGltZXN0YW1wLCBlLnJlcGVhdC51bnRpbCA/IHN0cmluZ1RvRGF0ZShlLnJlcGVhdC51bnRpbCkuZ2V0VGltZSgpIDogdmlld0VuZFRpbWVzdGFtcCk7XG4gIH1cblxuICB3aGlsZSAodGltZXN0YW1wIDw9IGVuZCkge1xuICAgIHZhciBjcmVhdGVTZWdtZW50ID0gZmFsc2U7IC8vIEJlIGNhcmVmdWwgbm90IHRvIHNpbXBseSBhZGQgMjQgaG91cnMhXG4gICAgLy8gSW4gY2FzZSBvZiBETFMsIHRoYXQgd291bGQgY2F1c2UgdGhlIGV2ZW50IHRvIG5ldmVyIGVuZCBhbmQgYnJvd3NlciB0byBoYW5nLlxuICAgIC8vIFNvIHVzZSBgYWRkRGF5cygxKWAgaW5zdGVhZC5cblxuICAgIHZhciBuZXh0TWlkbmlnaHQgPSBuZXcgRGF0ZSh0aW1lc3RhbXApLmFkZERheXMoMSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgdmFyIGlzRmlyc3REYXkgPSB2b2lkIDAsXG4gICAgICAgIGlzTGFzdERheSA9IHZvaWQgMCxcbiAgICAgICAgc3RhcnREYXRlID0gdm9pZCAwLFxuICAgICAgICBmb3JtYXR0ZWREYXRlID0gdm9pZCAwO1xuXG4gICAgaWYgKGUucmVwZWF0KSB7XG4gICAgICB2YXIgdG1wRGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG4gICAgICB2YXIgdG1wRGF0ZUZvcm1hdHRlZCA9IGZvcm1hdERhdGVMaXRlKHRtcERhdGUpOyAvLyBJZiB0aGUgY3VycmVudCBkYXkgaW4gbG9vcCBpcyBhIGtub3duIGRhdGUgb2YgdGhlIHJlcGVhdGVkIGV2ZW50IChpbiBgZS5vY2N1cnJlbmNlc2ApLFxuICAgICAgLy8gdGhlbiB3ZSBmb3VuZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBldmVudCByZXBldGl0aW9uLCBub3cgdXBkYXRlIHRoZSBgZXZlbnRTdGFydGAgYW5kXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBsb29wIGF0IGN1cnJlbnQgZGF5ICsgZXZlbnQgZGF5cyBjb3VudC5cblxuICAgICAgaWYgKHJlcGVhdGVkRXZlbnRTdGFydEZvdW5kIHx8IGUub2NjdXJyZW5jZXMgJiYgZS5vY2N1cnJlbmNlc1t0bXBEYXRlRm9ybWF0dGVkXSkge1xuICAgICAgICBpZiAoIXJlcGVhdGVkRXZlbnRTdGFydEZvdW5kKSB7XG4gICAgICAgICAgZXZlbnRTdGFydCA9IGUub2NjdXJyZW5jZXNbdG1wRGF0ZUZvcm1hdHRlZF0uc3RhcnQ7XG4gICAgICAgICAgZXZlbnRTdGFydEF0TWlkbmlnaHQgPSBuZXcgRGF0ZShldmVudFN0YXJ0KS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICBldmVudEVuZCA9IGUub2NjdXJyZW5jZXNbdG1wRGF0ZUZvcm1hdHRlZF0uZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwZWF0ZWRFdmVudFN0YXJ0Rm91bmQgPSB0cnVlO1xuICAgICAgICBjcmVhdGVTZWdtZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaXNGaXJzdERheSA9IHRpbWVzdGFtcCA9PT0gZXZlbnRTdGFydEF0TWlkbmlnaHQ7XG4gICAgICBpc0xhc3REYXkgPSB0bXBEYXRlRm9ybWF0dGVkID09PSBmb3JtYXREYXRlTGl0ZShuZXcgRGF0ZShldmVudEVuZCkpO1xuICAgICAgc3RhcnREYXRlID0gaXNGaXJzdERheSA/IG5ldyBEYXRlKGV2ZW50U3RhcnQpIDogbmV3IERhdGUodGltZXN0YW1wKTtcbiAgICAgIGZvcm1hdHRlZERhdGUgPSBmb3JtYXREYXRlTGl0ZShzdGFydERhdGUpOyAvLyBXZSB3YW50IHRvIGZpbmQgYW55IHBvdGVudGlhbCBvdGhlciByZXBldGl0aW9uIG9mIGV2ZW50IGluIHNhbWUgcmFuZ2UuXG5cbiAgICAgIGlmIChpc0xhc3REYXkpIHJlcGVhdGVkRXZlbnRTdGFydEZvdW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVNlZ21lbnQgPSB0cnVlO1xuICAgICAgaXNGaXJzdERheSA9IHRpbWVzdGFtcCA9PT0gZXZlbnRTdGFydDtcbiAgICAgIGlzTGFzdERheSA9IGVuZCA9PT0gZXZlbnRFbmQgJiYgbmV4dE1pZG5pZ2h0ID4gZW5kO1xuICAgICAgc3RhcnREYXRlID0gaXNGaXJzdERheSA/IGUuc3RhcnREYXRlIDogbmV3IERhdGUodGltZXN0YW1wKTtcbiAgICAgIGZvcm1hdHRlZERhdGUgPSBpc0ZpcnN0RGF5ID8gZS5zdGFydC5zdWJzdHIoMCwgMTApIDogZm9ybWF0RGF0ZUxpdGUoc3RhcnREYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY3JlYXRlU2VnbWVudCkge1xuICAgICAgZS5zZWdtZW50c1tmb3JtYXR0ZWREYXRlXSA9IHtcbiAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgICAgIHN0YXJ0OiBmb3JtYXR0ZWREYXRlLFxuICAgICAgICBzdGFydFRpbWVNaW51dGVzOiBpc0ZpcnN0RGF5ID8gZS5zdGFydFRpbWVNaW51dGVzIDogMCxcbiAgICAgICAgZW5kVGltZU1pbnV0ZXM6IGlzTGFzdERheSA/IGUuZW5kVGltZU1pbnV0ZXMgOiBtaW51dGVzSW5BRGF5LFxuICAgICAgICBpc0ZpcnN0RGF5OiBpc0ZpcnN0RGF5LFxuICAgICAgICBpc0xhc3REYXk6IGlzTGFzdERheSxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGltZXN0YW1wID0gbmV4dE1pZG5pZ2h0O1xuICB9XG5cbiAgcmV0dXJuIGU7XG59O1xuLyoqXG4gKiBEZWxldGUgYW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBjYWxlbmRhciBldmVudCB0byBkZWxldGUuXG4gKiBAcGFyYW0ge09iamVjdH0gdnVlY2FsIHRoZSB2dWVjYWwgbWFpbiBjb21wb25lbnQsIHRvIGFjY2VzcyBuZWVkZWQgbWV0aG9kcywgcHJvcHMsIGV0Yy5cbiAqL1xuXG52YXIgZGVsZXRlQW5FdmVudCA9IGZ1bmN0aW9uIGRlbGV0ZUFuRXZlbnQoZXZlbnQsIHZ1ZWNhbCkge1xuICB2dWVjYWwuZW1pdFdpdGhFdmVudCgnZXZlbnQtZGVsZXRlJywgZXZlbnQpOyAvLyBEZWxldGUgdGhlIGV2ZW50IGdsb2JhbGx5LlxuXG4gIHZ1ZWNhbC5tdXRhYmxlRXZlbnRzID0gdnVlY2FsLm11dGFibGVFdmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUuX2VpZCAhPT0gZXZlbnQuX2VpZDtcbiAgfSk7IC8vIERlbGV0ZSB0aGUgZXZlbnQgZnJvbSB0aGUgY3VycmVudCB2aWV3LlxuICAvLyBjaGVja0NlbGxPdmVybGFwcGluZ0V2ZW50cygpIHdpbGwgYmUgcmUtcnVuIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgY2VsbCBjb21wdXRlZCBldmVudHMuXG5cbiAgdnVlY2FsLnZpZXcuZXZlbnRzID0gdnVlY2FsLnZpZXcuZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLl9laWQgIT09IGV2ZW50Ll9laWQ7XG4gIH0pO1xufTsgLy8gRVZFTlQgT1ZFUkxBUFMuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPbmx5IGZvciB0aGUgY3VycmVudCB2aWV3LCByZWNyZWF0ZWQgb24gdmlldyBjaGFuZ2UuXG5cbnZhciBjb21wYXJpc29uQXJyYXksIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwczsgLy8gV2lsbCByZWNhbGN1bGF0ZSBhbGwgdGhlIG92ZXJsYXBzIG9mIHRoZSBjdXJyZW50IGNlbGwgT1Igc3BsaXQuXG4vLyBjZWxsRXZlbnRzIHdpbGwgY29udGFpbiBvbmx5IHRoZSBjdXJyZW50IHNwbGl0IGV2ZW50cyBpZiBpbiBhIHNwbGl0LlxuXG52YXIgZXZlbnRfdXRpbHNfY2hlY2tDZWxsT3ZlcmxhcHBpbmdFdmVudHMgPSBmdW5jdGlvbiBjaGVja0NlbGxPdmVybGFwcGluZ0V2ZW50cyhjZWxsRXZlbnRzLCBvcHRpb25zKSB7XG4gIGNvbXBhcmlzb25BcnJheSA9IGNlbGxFdmVudHMuc2xpY2UoMCk7XG4gIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwcyA9IHt9OyAvLyBDYW4ndCBmaWx0ZXIgYmFja2dyb3VuZCBldmVudHMgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBvdGhlcndpc2VcbiAgLy8gd2hlbiBhbiBldmVudCBpcyBjaGFuZ2VkIHRvIGJhY2tncm91bmQgaXQgd291bGQgbm90IHVwZGF0ZSBpdHMgcHJldmlvdXMgb3ZlcmxhcHMuXG5cbiAgY2VsbEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlLCBuZXZlciBjb21wYXJlIHRoZSBjdXJyZW50IGV2ZW50IGluIHRoZSBuZXh0IGxvb3BzLlxuICAgIC8vIFRoZSBhcnJheSBpcyBzbWFsbGVyIGFuZCBzbWFsbGVyIGFzIHdlIGxvb3AuXG4gICAgY29tcGFyaXNvbkFycmF5LnNoaWZ0KCk7XG4gICAgaWYgKCFldmVudF91dGlsc19jZWxsT3ZlcmxhcHNbZS5fZWlkXSkgZXh0ZXJuYWxfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfcm9vdF9WdWVfZGVmYXVsdC5hLnNldChldmVudF91dGlsc19jZWxsT3ZlcmxhcHMsIGUuX2VpZCwge1xuICAgICAgb3ZlcmxhcHM6IFtdLFxuICAgICAgc3RhcnQ6IGUuc3RhcnQsXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH0pO1xuICAgIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tlLl9laWRdLnBvc2l0aW9uID0gMDtcbiAgICBjb21wYXJpc29uQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZTIpIHtcbiAgICAgIGlmICghZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzW2UyLl9laWRdKSBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0LmEuc2V0KGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwcywgZTIuX2VpZCwge1xuICAgICAgICBvdmVybGFwczogW10sXG4gICAgICAgIHN0YXJ0OiBlMi5zdGFydCxcbiAgICAgICAgcG9zaXRpb246IDBcbiAgICAgIH0pO1xuICAgICAgdmFyIGV2ZW50SXNJblJhbmdlID0gZXZlbnRJblJhbmdlKGUyLCBlLnN0YXJ0RGF0ZSwgZS5lbmREYXRlKTtcbiAgICAgIHZhciBldmVudHNJblNhbWVUaW1lU3RlcCA9IG9wdGlvbnMub3ZlcmxhcHNQZXJUaW1lU3RlcCA/IGRhdGVzSW5TYW1lVGltZVN0ZXAoZS5zdGFydERhdGUsIGUyLnN0YXJ0RGF0ZSwgb3B0aW9ucy50aW1lU3RlcCkgOiAxOyAvLyBBZGQgdG8gdGhlIG92ZXJsYXBzIGFycmF5IGlmIG92ZXJsYXBwaW5nLlxuXG4gICAgICBpZiAoIWUuYmFja2dyb3VuZCAmJiAhZS5hbGxEYXkgJiYgIWUyLmJhY2tncm91bmQgJiYgIWUyLmFsbERheSAmJiBldmVudElzSW5SYW5nZSAmJiBldmVudHNJblNhbWVUaW1lU3RlcCkge1xuICAgICAgICBldmVudF91dGlsc19jZWxsT3ZlcmxhcHNbZS5fZWlkXS5vdmVybGFwcy5wdXNoKGUyLl9laWQpO1xuXG4gICAgICAgIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tlLl9laWRdLm92ZXJsYXBzID0gX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzW2UuX2VpZF0ub3ZlcmxhcHMpKTsgLy8gRGVkdXBlLCBtb3N0IHBlcmZvcm1hbnQgd2F5LlxuXG4gICAgICAgIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tlMi5fZWlkXS5vdmVybGFwcy5wdXNoKGUuX2VpZCk7XG5cbiAgICAgICAgZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzW2UyLl9laWRdLm92ZXJsYXBzID0gX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzW2UyLl9laWRdLm92ZXJsYXBzKSk7IC8vIERlZHVwZSwgbW9zdCBwZXJmb3JtYW50IHdheS5cblxuICAgICAgICBldmVudF91dGlsc19jZWxsT3ZlcmxhcHNbZTIuX2VpZF0ucG9zaXRpb24rKztcbiAgICAgIH0gLy8gUmVtb3ZlIGZyb20gdGhlIG92ZXJsYXBzIGFycmF5IGlmIG5vdCBvdmVybGFwcGluZyBvciBpZiAxIG9mIHRoZSAyIGV2ZW50cyBpcyBiYWNrZ3JvdW5kIG9yIGFsbC1kYXkgbG9uZy5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MxLCBwb3MyO1xuICAgICAgICAgIGlmICgocG9zMSA9IChldmVudF91dGlsc19jZWxsT3ZlcmxhcHNbZS5fZWlkXSB8fCB7XG4gICAgICAgICAgICBvdmVybGFwczogW11cbiAgICAgICAgICB9KS5vdmVybGFwcy5pbmRleE9mKGUyLl9laWQpKSA+IC0xKSBldmVudF91dGlsc19jZWxsT3ZlcmxhcHNbZS5fZWlkXS5vdmVybGFwcy5zcGxpY2UocG9zMSwgMSk7XG4gICAgICAgICAgaWYgKChwb3MyID0gKGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tlMi5fZWlkXSB8fCB7XG4gICAgICAgICAgICBvdmVybGFwczogW11cbiAgICAgICAgICB9KS5vdmVybGFwcy5pbmRleE9mKGUuX2VpZCkpID4gLTEpIGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tlMi5fZWlkXS5vdmVybGFwcy5zcGxpY2UocG9zMiwgMSk7XG4gICAgICAgICAgZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzW2UyLl9laWRdLnBvc2l0aW9uLS07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIE92ZXJsYXBzIHN0cmVhayBpcyB0aGUgbG9uZ2VzdCBob3Jpem9udGFsIHNldCBvZiBzaW11bHRhbmVvdXMgZXZlbnRzLlxuICAvLyBUaGlzIGlzIGRldGVybWluaW5nIHRoZSB3aWR0aCBvZiBldmVudHMgaW4gYSBzdHJlYWsuXG4gIC8vIGUuZy4gMyBvdmVybGFwcGluZyBldmVudHMgWzEsIDIsIDNdOyAxIG92ZXJsYXBzIDIgJiAzOyAyICYgMyBkb24ndCBvdmVybGFwO1xuICAvLyAgICAgID0+IHN0cmVhayA9IDI7IGVhY2ggd2lkdGggPSA1MCUgbm90IDMzJS5cblxuICB2YXIgbG9uZ2VzdFN0cmVhayA9IDA7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tpZF07IC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgZWFjaCBldmVudCBpbiBjdXJyZW50IHN0cmVhayAoZGV0ZXJtaW5lcyB0aGUgQ1NTIGxlZnQgcHJvcGVydHkpLlxuXG4gICAgdmFyIG92ZXJsYXBzUm93ID0gaXRlbS5vdmVybGFwcy5tYXAoZnVuY3Rpb24gKGlkMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkMixcbiAgICAgICAgc3RhcnQ6IGV2ZW50X3V0aWxzX2NlbGxPdmVybGFwc1tpZDJdLnN0YXJ0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG92ZXJsYXBzUm93LnB1c2goe1xuICAgICAgaWQ6IGlkLFxuICAgICAgc3RhcnQ6IGl0ZW0uc3RhcnRcbiAgICB9KTtcbiAgICBvdmVybGFwc1Jvdy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zdGFydCA8IGIuc3RhcnQgPyAtMSA6IGEuc3RhcnQgPiBiLnN0YXJ0ID8gMSA6IGEuaWQgPiBiLmlkID8gLTEgOiAxO1xuICAgIH0pO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvdmVybGFwc1Jvdy5maW5kSW5kZXgoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlLmlkID09PSBpZDtcbiAgICB9KTtcbiAgICBsb25nZXN0U3RyZWFrID0gTWF0aC5tYXgoZXZlbnRfdXRpbHNfZ2V0T3ZlcmxhcHNTdHJlYWsoaXRlbSwgZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzKSwgbG9uZ2VzdFN0cmVhayk7XG4gIH07XG5cbiAgZm9yICh2YXIgaWQgaW4gZXZlbnRfdXRpbHNfY2VsbE92ZXJsYXBzKSB7XG4gICAgX2xvb3AoaWQpO1xuICB9XG5cbiAgcmV0dXJuIFtldmVudF91dGlsc19jZWxsT3ZlcmxhcHMsIGxvbmdlc3RTdHJlYWtdO1xufTtcbi8qKlxuICogT3ZlcmxhcHMgc3RyZWFrIGlzIHRoZSBsb25nZXN0IGhvcml6b250YWwgc2V0IG9mIHNpbXVsdGFuZW91cyBldmVudHMuXG4gKiBUaGlzIGlzIGRldGVybWluaW5nIHRoZSB3aWR0aCBvZiBlYWNoIGV2ZW50cyBpbiB0aGlzIHN0cmVhay5cbiAqIEUuZy4gMyBvdmVybGFwcGluZyBldmVudHMgWzEsIDIsIDNdOyAxIG92ZXJsYXBzIDIgJiAzOyAyICYgMyBkb24ndCBvdmVybGFwO1xuICogICAgICA9PiBzdHJlYWsgPSAyOyBlYWNoIHdpZHRoID0gNTAlIG5vdCAzMyUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBjdXJyZW50IGV2ZW50IHdlIGFyZSBjaGVja2luZyBhbW9uZyBhbGwgdGhlIGV2ZW50cyBvZiB0aGUgY3VycmVudCBjZWxsLlxuICogQHBhcmFtIHtPYmplY3R9IGNlbGxPdmVybGFwcyBBbiBpbmRleGVkIGFycmF5IG9mIGFsbCB0aGUgZXZlbnRzIG92ZXJsYXBzIGZvciB0aGUgY3VycmVudCBjZWxsLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBldmVudCBmb3IgdGhpcyBldmVudC5cbiAqL1xuXG52YXIgZXZlbnRfdXRpbHNfZ2V0T3ZlcmxhcHNTdHJlYWsgPSBmdW5jdGlvbiBnZXRPdmVybGFwc1N0cmVhayhldmVudCkge1xuICB2YXIgY2VsbE92ZXJsYXBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHN0cmVhayA9IGV2ZW50Lm92ZXJsYXBzLmxlbmd0aCArIDE7XG4gIHZhciByZW1vdmVGcm9tU3RyZWFrID0gW107XG4gIGV2ZW50Lm92ZXJsYXBzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKCFyZW1vdmVGcm9tU3RyZWFrLmluY2x1ZGVzKGlkKSkge1xuICAgICAgdmFyIG92ZXJsYXBzV2l0aG91dFNlbGYgPSBldmVudC5vdmVybGFwcy5maWx0ZXIoZnVuY3Rpb24gKGlkMikge1xuICAgICAgICByZXR1cm4gaWQyICE9PSBpZDtcbiAgICAgIH0pO1xuICAgICAgb3ZlcmxhcHNXaXRob3V0U2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChpZDMpIHtcbiAgICAgICAgaWYgKCFjZWxsT3ZlcmxhcHNbaWQzXS5vdmVybGFwcy5pbmNsdWRlcyhpZCkpIHJlbW92ZUZyb21TdHJlYWsucHVzaChpZDMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmVtb3ZlRnJvbVN0cmVhayA9IF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KHJlbW92ZUZyb21TdHJlYWspKTsgLy8gRGVkdXBlLCBtb3N0IHBlcmZvcm1hbnQgd2F5LlxuXG4gIHN0cmVhayAtPSByZW1vdmVGcm9tU3RyZWFrLmxlbmd0aDtcbiAgcmV0dXJuIHN0cmVhaztcbn07XG4vKipcbiAqIFVwZGF0ZSB0aGUgZXZlbnQgdG9wIGFuZCBoZWlnaHQgQ1NTIHByb3BlcnRpZXMgb2YgZWFjaCBldmVudCBhcyBsb25nIGFzIHZ1ZWNhbC50aW1lIGlzIHRydWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB1cGRhdGUgcG9zaXRpb24gKHRvcCAmIGhlaWdodCkgb2YuXG4gKiBAcGFyYW0ge09iamVjdH0gdnVlY2FsIHRoZSB2dWVjYWwgbWFpbiBjb21wb25lbnQsIHRvIGFjY2VzcyBuZWVkZWQgbWV0aG9kcywgcHJvcHMsIGV0Yy5cbiAqL1xuXG52YXIgdXBkYXRlRXZlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUV2ZW50UG9zaXRpb24oZXZlbnQsIHZ1ZWNhbCkge1xuICB2YXIgc3RhcnRUaW1lTWludXRlcyA9IGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXMsXG4gICAgICBlbmRUaW1lTWludXRlcyA9IGV2ZW50LmVuZFRpbWVNaW51dGVzOyAvLyBpZiAoZXZlbnQuZHJhZ2dpbmcpIHtcbiAgLy8gICBldmVudC50b3AgPSBldmVudC5kcmFnZ2luZy55XG4gIC8vICAgZXZlbnQubGVmdCA9IGV2ZW50LmRyYWdnaW5nLnhcbiAgLy8gICByZXR1cm5cbiAgLy8gfVxuICAvLyBUb3Agb2YgZXZlbnQuXG5cbiAgdmFyIG1pbnV0ZXNGcm9tVG9wID0gc3RhcnRUaW1lTWludXRlcyAtIHZ1ZWNhbC50aW1lRnJvbTtcbiAgdmFyIHRvcCA9IE1hdGgucm91bmQobWludXRlc0Zyb21Ub3AgKiB2dWVjYWwudGltZUNlbGxIZWlnaHQgLyB2dWVjYWwudGltZVN0ZXApOyAvLyBCb3R0b20gb2YgZXZlbnQuXG5cbiAgbWludXRlc0Zyb21Ub3AgPSBNYXRoLm1pbihlbmRUaW1lTWludXRlcywgdnVlY2FsLnRpbWVUbykgLSB2dWVjYWwudGltZUZyb207XG4gIHZhciBib3R0b20gPSBNYXRoLnJvdW5kKG1pbnV0ZXNGcm9tVG9wICogdnVlY2FsLnRpbWVDZWxsSGVpZ2h0IC8gdnVlY2FsLnRpbWVTdGVwKTtcbiAgZXZlbnQudG9wID0gTWF0aC5tYXgodG9wLCAwKTtcbiAgZXZlbnQuaGVpZ2h0ID0gTWF0aC5tYXgoYm90dG9tIC0gZXZlbnQudG9wLCA1KTsgLy8gTWluIGhlaWdodCBpcyA1cHguXG59O1xuLyoqXG4gKiBUZWxscyB3aGV0aGVyIGFuIGV2ZW50IGlzIGluIGEgZ2l2ZW4gZGF0ZSByYW5nZSwgZXZlbiBwYXJ0aWFsbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB0ZXN0LlxuICogQHBhcmFtIHtEYXRlfSBzdGFydCBUaGUgc3RhcnQgb2YgcmFuZ2UgZGF0ZSBvYmplY3QuXG4gKiBAcGFyYW0ge0RhdGV9IGVuZCBUaGUgZW5kIG9mIHJhbmdlIGRhdGUgb2JqZWN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbiByYW5nZSwgZXZlbiBwYXJ0aWFsbHkuXG4gKi9cblxudmFyIGV2ZW50SW5SYW5nZSA9IGZ1bmN0aW9uIGV2ZW50SW5SYW5nZShldmVudCwgc3RhcnQsIGVuZCkge1xuICAvLyBDaGVjayBpZiBhbGwtZGF5IG9yIHRpbWVsZXNzIGV2ZW50IChpZiBkYXRlIGJ1dCBubyB0aW1lIHRoZXJlIHdvbid0IGJlIGEgYDpgIGluIGV2ZW50LnN0YXJ0KS5cbiAgaWYgKGV2ZW50LmFsbERheSB8fCBldmVudC5zdGFydC5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgLy8gR2V0IHRoZSBkYXRlIGFuZCBkaXNjYXJkIHRoZSB0aW1lIGlmIGFueSwgdGhlbiBjaGVjayBpdCdzIHdpdGhpbiB0aGUgZGF0ZSByYW5nZS5cbiAgICB2YXIgZXZlbnRTdGFydCA9IG5ldyBEYXRlKGV2ZW50LnN0YXJ0RGF0ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIGV2ZW50U3RhcnQgPj0gbmV3IERhdGUoc3RhcnQpLnNldEhvdXJzKDAsIDAsIDAsIDApICYmIGV2ZW50U3RhcnQgPD0gbmV3IERhdGUoZW5kKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfVxuXG4gIHZhciBzdGFydFRpbWVzdGFtcCA9IGV2ZW50LnN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gIHZhciBlbmRUaW1lc3RhbXAgPSBldmVudC5lbmREYXRlLmdldFRpbWUoKTtcbiAgcmV0dXJuIHN0YXJ0VGltZXN0YW1wIDwgZW5kLmdldFRpbWUoKSAmJiBlbmRUaW1lc3RhbXAgPiBzdGFydC5nZXRUaW1lKCk7XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcIixcImNhY2hlSWRlbnRpZmllclwiOlwiNDg3ZjgyMTctdnVlLWxvYWRlci10ZW1wbGF0ZVwifSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvcHVnLXBsYWluLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2hlYWRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTE3MzM5NTMmbGFuZz1wdWcmXG52YXIgaGVhZGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMTE3MzM5NTNfbGFuZ19wdWdfcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2hlYWRlclwifSxbKCFfdm0ub3B0aW9ucy5oaWRlVmlld1NlbGVjdG9yKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2ZsZXggdnVlY2FsX19tZW51XCIsYXR0cnM6e1wicm9sZVwiOlwidGFibGlzdFwiLFwiYXJpYS1sYWJlbFwiOlwiQ2FsZW5kYXIgdmlld3MgbmF2aWdhdGlvblwifX0sX3ZtLl9sKChfdm0udmlld1Byb3BzLnZpZXdzKSxmdW5jdGlvbih2LGlkKXtyZXR1cm4gKHYuZW5hYmxlZCk/X2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwidnVlY2FsX192aWV3LWJ0blwiLGNsYXNzOnsgJ3Z1ZWNhbF9fdmlldy1idG4tLWFjdGl2ZSc6IF92bS52aWV3UHJvcHMudmlldy5pZCA9PT0gaWQsICd2dWVjYWxfX3ZpZXctYnRuLS1oaWdobGlnaHRlZCc6IF92bS5oaWdobGlnaHRlZENvbnRyb2wgPT09IGlkIH0sYXR0cnM6e1wiYXJpYS1sYWJlbFwiOigodi5sYWJlbCkgKyBcIiB2aWV3XCIpfSxvbjp7XCJkcmFnZW50ZXJcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnRW50ZXIoJGV2ZW50LCBpZCwgX3ZtLiRwYXJlbnQsIF92bS4kZGF0YSl9LFwiZHJhZ2xlYXZlXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0ub3B0aW9ucy5lZGl0YWJsZUV2ZW50cyAmJiBfdm0udmlld1NlbGVjdG9yRHJhZ0xlYXZlKCRldmVudCwgaWQsIF92bS4kcGFyZW50LCBfdm0uJGRhdGEpfSxcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRwYXJlbnQuc3dpdGNoVmlldyhpZCwgbnVsbCwgdHJ1ZSl9fX0sW192bS5fdihfdm0uX3Modi5sYWJlbCkpXSk6X3ZtLl9lKCl9KSwwKTpfdm0uX2UoKSwoIV92bS5vcHRpb25zLmhpZGVUaXRsZUJhcik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX190aXRsZS1iYXJcIn0sW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fYXJyb3cgdnVlY2FsX19hcnJvdy0tcHJldlwiLGNsYXNzOnsgJ3Z1ZWNhbF9fYXJyb3ctLWhpZ2hsaWdodGVkJzogX3ZtLmhpZ2hsaWdodGVkQ29udHJvbCA9PT0gJ3ByZXZpb3VzJyB9LGF0dHJzOntcImFyaWEtbGFiZWxcIjooXCJQcmV2aW91cyBcIiArIChfdm0udmlld1Byb3BzLnZpZXcuaWQpKX0sb246e1wiY2xpY2tcIjpfdm0ucHJldmlvdXMsXCJkcmFnZW50ZXJcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnRW50ZXIoJGV2ZW50LCAncHJldmlvdXMnLCBfdm0uJHBhcmVudCwgX3ZtLiRkYXRhKX0sXCJkcmFnbGVhdmVcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnTGVhdmUoJGV2ZW50LCAncHJldmlvdXMnLCBfdm0uJHBhcmVudCwgX3ZtLiRkYXRhKX19fSxbX3ZtLl90KFwiYXJyb3ctcHJldlwiKV0sMiksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fdGl0bGVcIixhdHRyczp7XCJncm93XCI6XCJcIn19LFtfYyhfdm0ub3B0aW9ucy50cmFuc2l0aW9ucyA/ICd0cmFuc2l0aW9uJyA6ICdkaXYnLHt0YWc6XCJjb21wb25lbnRcIixhdHRyczp7XCJuYW1lXCI6KFwic2xpZGUtZmFkZS0tXCIgKyBfdm0udHJhbnNpdGlvbkRpcmVjdGlvbil9fSxbX2MoISFfdm0uYnJvYWRlclZpZXcgPyAnYnV0dG9uJyA6ICdzcGFuJyx7a2V5OihcIlwiICsgKF92bS52aWV3UHJvcHMudmlldy5pZCkgKyAoX3ZtLnZpZXdQcm9wcy52aWV3LnN0YXJ0RGF0ZS50b1N0cmluZygpKSksdGFnOlwiY29tcG9uZW50XCIsYXR0cnM6e1wiYXJpYS1sYWJlbFwiOiEhX3ZtLmJyb2FkZXJWaWV3ID8gKFwiR28gdG8gXCIgKyBfdm0uYnJvYWRlclZpZXcgKyBcIiB2aWV3XCIpIDogZmFsc2V9LG9uOntcImNsaWNrXCI6X3ZtLnN3aXRjaFRvQnJvYWRlclZpZXd9fSxbX3ZtLl90KFwidGl0bGVcIildLDIpXSwxKV0sMSksKF92bS5vcHRpb25zLnRvZGF5QnV0dG9uKT9fYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX3RvZGF5LWJ0blwiLGNsYXNzOnsgJ3Z1ZWNhbF9fdG9kYXktYnRuLS1oaWdobGlnaHRlZCc6IF92bS5oaWdobGlnaHRlZENvbnRyb2wgPT09ICd0b2RheScgfSxhdHRyczp7XCJhcmlhLWxhYmVsXCI6XCJUb2RheVwifSxvbjp7XCJjbGlja1wiOl92bS5nb1RvVG9kYXksXCJkcmFnZW50ZXJcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnRW50ZXIoJGV2ZW50LCAndG9kYXknLCBfdm0uJHBhcmVudCwgX3ZtLiRkYXRhKX0sXCJkcmFnbGVhdmVcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnTGVhdmUoJGV2ZW50LCAndG9kYXknLCBfdm0uJHBhcmVudCwgX3ZtLiRkYXRhKX19fSxbX3ZtLl90KFwidG9kYXktYnV0dG9uXCIpXSwyKTpfdm0uX2UoKSxfYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2Fycm93IHZ1ZWNhbF9fYXJyb3ctLW5leHRcIixjbGFzczp7ICd2dWVjYWxfX2Fycm93LS1oaWdobGlnaHRlZCc6IF92bS5oaWdobGlnaHRlZENvbnRyb2wgPT09ICduZXh0JyB9LGF0dHJzOntcImFyaWEtbGFiZWxcIjooXCJOZXh0IFwiICsgKF92bS52aWV3UHJvcHMudmlldy5pZCkpfSxvbjp7XCJjbGlja1wiOl92bS5uZXh0LFwiZHJhZ2VudGVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0ub3B0aW9ucy5lZGl0YWJsZUV2ZW50cyAmJiBfdm0udmlld1NlbGVjdG9yRHJhZ0VudGVyKCRldmVudCwgJ25leHQnLCBfdm0uJHBhcmVudCwgX3ZtLiRkYXRhKX0sXCJkcmFnbGVhdmVcIjpmdW5jdGlvbigkZXZlbnQpe192bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS52aWV3U2VsZWN0b3JEcmFnTGVhdmUoJGV2ZW50LCAnbmV4dCcsIF92bS4kcGFyZW50LCBfdm0uJGRhdGEpfX19LFtfdm0uX3QoXCJhcnJvdy1uZXh0XCIpXSwyKV0pOl92bS5fZSgpLChfdm0udmlld1Byb3BzLndlZWtEYXlzSW5IZWFkZXIpP19jKCd3ZWVrZGF5cy1oZWFkaW5ncycse2F0dHJzOntcInZ1ZWNhbFwiOl92bS4kcGFyZW50LFwidmlld1wiOl92bS52aWV3UHJvcHMudmlldyxcIndlZWstZGF5c1wiOl92bS53ZWVrRGF5cyxcInRyYW5zaXRpb24tZGlyZWN0aW9uXCI6X3ZtLnRyYW5zaXRpb25EaXJlY3Rpb24sXCJzd2l0Y2gtdG8tbmFycm93ZXItdmlld1wiOl92bS5zd2l0Y2hUb05hcnJvd2VyVmlld30sc2NvcGVkU2xvdHM6X3ZtLl91KFt7a2V5Olwid2Vla2RheS1oZWFkaW5nXCIsZm46ZnVuY3Rpb24ocmVmKXtcbnZhciBoZWFkaW5nID0gcmVmLmhlYWRpbmc7XG52YXIgdmlldyA9IHJlZi52aWV3O1xucmV0dXJuIFtfdm0uX3QoXCJ3ZWVrZGF5LWhlYWRpbmdcIixudWxsLHtcImhlYWRpbmdcIjpoZWFkaW5nLFwidmlld1wiOnZpZXd9KV19fV0sbnVsbCx0cnVlKX0pOl92bS5fZSgpLF9jKCd0cmFuc2l0aW9uJyx7YXR0cnM6e1wibmFtZVwiOihcInNsaWRlLWZhZGUtLVwiICsgX3ZtLnRyYW5zaXRpb25EaXJlY3Rpb24pfX0sWyhfdm0udmlld1Byb3BzLnZpZXcuaWQgPT09ICdkYXknICYmIF92bS4kcGFyZW50Lmhhc1NwbGl0cyAmJiBfdm0ub3B0aW9ucy5zdGlja3lTcGxpdExhYmVscyAmJiAhX3ZtLm9wdGlvbnMubWluU3BsaXRXaWR0aCk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fc3BsaXQtZGF5cy1oZWFkZXJzXCJ9LF92bS5fbCgoX3ZtLmRheVNwbGl0cyksZnVuY3Rpb24oc3BsaXQsaSl7cmV0dXJuIF9jKCdkaXYnLHtrZXk6aSxzdGF0aWNDbGFzczpcImRheS1zcGxpdC1oZWFkZXJcIixjbGFzczpzcGxpdC5jbGFzcyB8fCBmYWxzZX0sW192bS5fdihfdm0uX3Moc3BsaXQubGFiZWwpKV0pfSksMCk6X3ZtLl9lKCldKV0sMSl9XG52YXIgaGVhZGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMTE3MzM5NTNfbGFuZ19wdWdfc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvaGVhZGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMTczMzk1MyZsYW5nPXB1ZyZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcIixcImNhY2hlSWRlbnRpZmllclwiOlwiNDg3ZjgyMTctdnVlLWxvYWRlci10ZW1wbGF0ZVwifSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvcHVnLXBsYWluLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL3dlZWtkYXlzLWhlYWRpbmdzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD05YTBjMTlkMCZsYW5nPXB1ZyZcbnZhciB3ZWVrZGF5c19oZWFkaW5nc3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzlhMGMxOWQwX2xhbmdfcHVnX3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4IHZ1ZWNhbF9fd2Vla2RheXMtaGVhZGluZ3NcIn0sX3ZtLl9sKChfdm0uaGVhZGluZ3MpLGZ1bmN0aW9uKGhlYWRpbmcsaSl7cmV0dXJuICghaGVhZGluZy5oaWRlKT9fYygnZGl2Jyx7a2V5Omksc3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2ZsZXggdnVlY2FsX19oZWFkaW5nXCIsY2xhc3M6eyB0b2RheTogaGVhZGluZy50b2RheSwgY2xpY2thYmxlOiBfdm0uY2VsbEhlYWRpbmdzQ2xpY2thYmxlIH0sc3R5bGU6KF92bS53ZWVrZGF5Q2VsbFN0eWxlcyksb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe192bS52aWV3LmlkID09PSAnd2VlaycgJiYgX3ZtLnNlbGVjdENlbGwoaGVhZGluZy5kYXRlLCAkZXZlbnQpfSxcImRibGNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0udmlldy5pZCA9PT0gJ3dlZWsnICYmIF92bS52dWVjYWwuZGJsY2xpY2tUb05hdmlnYXRlICYmIF92bS5zd2l0Y2hUb05hcnJvd2VyVmlldygpfX19LFtfYygndHJhbnNpdGlvbicse2F0dHJzOntcIm5hbWVcIjooXCJzbGlkZS1mYWRlLS1cIiArIF92bS50cmFuc2l0aW9uRGlyZWN0aW9uKSxcImFwcGVhclwiOl92bS52dWVjYWwudHJhbnNpdGlvbnN9fSxbX2MoJ2Rpdicse2tleTpfdm0udnVlY2FsLnRyYW5zaXRpb25zID8gKGkgKyBcIi1cIiArIChoZWFkaW5nLmRheU9mTW9udGgpKSA6IGZhbHNlLHN0YXRpY0NsYXNzOlwidnVlY2FsX19mbGV4XCIsYXR0cnM6e1wiY29sdW1uXCI6XCJcIn19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2ZsZXggd2Vla2RheS1sYWJlbFwiLGF0dHJzOntcImdyb3dcIjpcIlwifX0sW192bS5fdChcIndlZWtkYXktaGVhZGluZ1wiLFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiZnVsbFwifSxbX3ZtLl92KF92bS5fcyhoZWFkaW5nLmZ1bGwpKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJzbWFsbFwifSxbX3ZtLl92KF92bS5fcyhoZWFkaW5nLnNtYWxsKSldKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwieHNtYWxsXCJ9LFtfdm0uX3YoX3ZtLl9zKGhlYWRpbmcueHNtYWxsKSldKSwoaGVhZGluZy5kYXlPZk1vbnRoKT9fYygnc3BhbicsW192bS5fdihcIsKgXCIrX3ZtLl9zKGhlYWRpbmcuZGF5T2ZNb250aCkpXSk6X3ZtLl9lKCldLHtcImhlYWRpbmdcIjpfdm0uY2xlYW51cEhlYWRpbmcoaGVhZGluZyksXCJ2aWV3XCI6X3ZtLnZpZXd9KV0sMiksKF92bS52dWVjYWwuaGFzU3BsaXRzICYmIF92bS52dWVjYWwuc3RpY2t5U3BsaXRMYWJlbHMpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleCB2dWVjYWxfX3NwbGl0LWRheXMtaGVhZGVyc1wiLGF0dHJzOntcImdyb3dcIjpcIlwifX0sX3ZtLl9sKChfdm0udnVlY2FsLmRheVNwbGl0cyksZnVuY3Rpb24oc3BsaXQsaSl7cmV0dXJuIF9jKCdkaXYnLHtrZXk6aSxzdGF0aWNDbGFzczpcImRheS1zcGxpdC1oZWFkZXJcIixjbGFzczpzcGxpdC5jbGFzcyB8fCBmYWxzZX0sW192bS5fdihfdm0uX3Moc3BsaXQubGFiZWwpKV0pfSksMCk6X3ZtLl9lKCldKV0pXSwxKTpfdm0uX2UoKX0pLDApfVxudmFyIHdlZWtkYXlzX2hlYWRpbmdzdnVlX3R5cGVfdGVtcGxhdGVfaWRfOWEwYzE5ZDBfbGFuZ19wdWdfc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvd2Vla2RheXMtaGVhZGluZ3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTlhMGMxOWQwJmxhbmc9cHVnJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvY2VsbC11dGlscy5qc1xuLyoqXG4gKiBTZWxlY3QgYSBjZWxsIGFuZCBnbyB0byBuYXJyb3dlciB2aWV3IG9uIGRvdWJsZSBjbGljayBvciBzaW5nbGUgY2xpY2sgYWNjb3JkaW5nIHRvIHZ1ZWNhbCBvcHRpb24uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSBzd2l0Y2hpbmcgdG8gbmFycm93ZXIgdmlldy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgVGhlIHZ1ZWNhbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgc2VsZWN0ZWQgY2VsbCBkYXRlIGF0IHRoZSBleGFjdCB0aW1lIHdoZXJlIGl0IHdhcyBjbGlja2VkICh0aHJvdWdoIGN1cnNvciBjb29yZHMpLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzcGxpdCBUaGUgc2VsZWN0ZWQgY2VsbCBzcGxpdCBpZiBhbnkuXG4gKi9cbnZhciBjZWxsX3V0aWxzX3NlbGVjdENlbGwgPSBmdW5jdGlvbiBzZWxlY3RDZWxsKCkge1xuICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgdnVlY2FsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBzcGxpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAvLyBDZWxsLWNsaWNrIGV2ZW50IHJldHVybnMgYSBkYXRlIGFuZCB0aW1lIGF0IGN1cnNvciBwb3NpdGlvbi5cbiAgdnVlY2FsLiRlbWl0KCdjZWxsLWNsaWNrJywgc3BsaXQgPyB7XG4gICAgZGF0ZTogZGF0ZSxcbiAgICBzcGxpdDogc3BsaXRcbiAgfSA6IGRhdGUpOyAvLyBTd2l0Y2ggdG8gbmFycm93ZXIgdmlldy5cblxuICBpZiAodnVlY2FsLmNsaWNrVG9OYXZpZ2F0ZSB8fCBmb3JjZSkgdnVlY2FsLnN3aXRjaFRvTmFycm93ZXJWaWV3KCk7IC8vIEhhbmRsZSBkb3VibGUgY2xpY2sgbWFudWFsbHkgZm9yIHRvdWNoIGRldmljZXMuXG4gIGVsc2UgaWYgKHZ1ZWNhbC5kYmxjbGlja1RvTmF2aWdhdGUgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICB2dWVjYWwuZG9tRXZlbnRzLmRibFRhcEFDZWxsLnRhcHMrKztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdnVlY2FsLmRvbUV2ZW50cy5kYmxUYXBBQ2VsbC50YXBzID0gMDtcbiAgICAgIH0sIHZ1ZWNhbC5kb21FdmVudHMuZGJsVGFwQUNlbGwudGltZW91dCk7XG5cbiAgICAgIGlmICh2dWVjYWwuZG9tRXZlbnRzLmRibFRhcEFDZWxsLnRhcHMgPj0gMikge1xuICAgICAgICB2dWVjYWwuZG9tRXZlbnRzLmRibFRhcEFDZWxsLnRhcHMgPSAwO1xuICAgICAgICB2dWVjYWwuc3dpdGNoVG9OYXJyb3dlclZpZXcoKTtcbiAgICAgICAgdnVlY2FsLiRlbWl0KCdjZWxsLWRibGNsaWNrJywgc3BsaXQgPyB7XG4gICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICBzcGxpdDogc3BsaXRcbiAgICAgICAgfSA6IGRhdGUpO1xuICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIFNlbGVjdCBhIGNlbGwgYW5kIGdvIHRvIG5hcnJvd2VyIHZpZXcgb24gZW50ZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSBzd2l0Y2hpbmcgdG8gbmFycm93ZXIgdmlldy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgVGhlIHZ1ZWNhbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBUaGUgc2VsZWN0ZWQgY2VsbCBkYXRlIGF0IHRoZSBleGFjdCB0aW1lIHdoZXJlIGl0IHdhcyBjbGlja2VkICh0aHJvdWdoIGN1cnNvciBjb29yZHMpLlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzcGxpdCBUaGUgc2VsZWN0ZWQgY2VsbCBzcGxpdCBpZiBhbnkuXG4gKi9cblxudmFyIGtleVByZXNzRW50ZXJDZWxsID0gZnVuY3Rpb24ga2V5UHJlc3NFbnRlckNlbGwodnVlY2FsLCBkYXRlLCBzcGxpdCkge1xuICAvLyBDZWxsLWtleS1wcmVzcy1lbnRlciBldmVudCByZXR1cm5zIGEgZGF0ZSBhbmQgdGltZSBhdCBjdXJzb3IgcG9zaXRpb24uXG4gIHZ1ZWNhbC4kZW1pdCgnY2VsbC1rZXlwcmVzcy1lbnRlcicsIHNwbGl0ID8ge1xuICAgIGRhdGU6IGRhdGUsXG4gICAgc3BsaXQ6IHNwbGl0XG4gIH0gOiBkYXRlKTsgLy8gU3dpdGNoIHRvIG5hcnJvd2VyIHZpZXcuXG5cbiAgdnVlY2FsLnN3aXRjaFRvTmFycm93ZXJWaWV3KCk7XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvd2Vla2RheXMtaGVhZGluZ3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgd2Vla2RheXNfaGVhZGluZ3N2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczoge1xuICAgIHZ1ZWNhbDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZXc6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uRGlyZWN0aW9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAncmlnaHQnXG4gICAgfSxcbiAgICB3ZWVrRGF5czoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3dpdGNoVG9OYXJyb3dlclZpZXc6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNlbGVjdENlbGw6IGZ1bmN0aW9uIHNlbGVjdENlbGwoZGF0ZSwgRE9NRXZlbnQpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGRhdGUuc2V0TWludXRlcyh0aGlzLnZ1ZWNhbC5taW51dGVzQXRDdXJzb3IoRE9NRXZlbnQpLm1pbnV0ZXMpO1xuXG4gICAgICBjZWxsX3V0aWxzX3NlbGVjdENlbGwoZmFsc2UsIHRoaXMudnVlY2FsLCBkYXRlLCBET01FdmVudCk7XG4gICAgfSxcbiAgICBjbGVhbnVwSGVhZGluZzogZnVuY3Rpb24gY2xlYW51cEhlYWRpbmcoaGVhZGluZykge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgbGFiZWw6IGhlYWRpbmcuZnVsbCxcbiAgICAgICAgZGF0ZTogaGVhZGluZy5kYXRlXG4gICAgICB9LCBoZWFkaW5nLnRvZGF5ID8ge1xuICAgICAgICB0b2RheTogaGVhZGluZy50b2RheVxuICAgICAgfSA6IHt9KTtcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGVhZGluZ3M6IGZ1bmN0aW9uIGhlYWRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFbJ21vbnRoJywgJ3dlZWsnXS5pbmNsdWRlcyh0aGlzLnZpZXcuaWQpKSByZXR1cm4gW107XG4gICAgICB2YXIgdG9kYXlGb3VuZCA9IGZhbHNlO1xuICAgICAgdmFyIGhlYWRpbmdzID0gdGhpcy53ZWVrRGF5cy5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy52aWV3LnN0YXJ0RGF0ZS5hZGREYXlzKGkpO1xuXG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgaGlkZTogY2VsbC5oaWRlLFxuICAgICAgICAgIGZ1bGw6IGNlbGwubGFiZWwsXG4gICAgICAgICAgLy8gSWYgZGVmaW5lZCBpbiBpMThuIGZpbGUsIHdlZWtEYXlzU2hvcnQgb3ZlcnJpZGVzIGRlZmF1bHQgdHJ1bmNhdGlvbiBvZlxuICAgICAgICAgIC8vIHdlZWsgZGF5cyB3aGVuIGRvZXMgbm90IGZpdCBvbiBzY3JlZW4gb3Igd2l0aCBzbWFsbC94c21hbGwgb3B0aW9ucy5cbiAgICAgICAgICBzbWFsbDogY2VsbC5zaG9ydCB8fCBjZWxsLmxhYmVsLnN1YnN0cigwLCAzKSxcbiAgICAgICAgICB4c21hbGw6IGNlbGwuc2hvcnQgfHwgY2VsbC5sYWJlbC5zdWJzdHIoMCwgMSlcbiAgICAgICAgfSwgX3RoaXMudmlldy5pZCA9PT0gJ3dlZWsnID8ge1xuICAgICAgICAgIGRheU9mTW9udGg6IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgdG9kYXk6ICF0b2RheUZvdW5kICYmIGRhdGUuaXNUb2RheSgpICYmICF0b2RheUZvdW5kKytcbiAgICAgICAgfSA6IHt9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhlYWRpbmdzO1xuICAgIH0sXG4gICAgY2VsbFdpZHRoOiBmdW5jdGlvbiBjZWxsV2lkdGgoKSB7XG4gICAgICByZXR1cm4gMTAwIC8gKDcgLSB0aGlzLndlZWtEYXlzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIGRheSkge1xuICAgICAgICByZXR1cm4gdG90YWwgKyBkYXkuaGlkZTtcbiAgICAgIH0sIDApKTtcbiAgICB9LFxuICAgIHdlZWtkYXlDZWxsU3R5bGVzOiBmdW5jdGlvbiB3ZWVrZGF5Q2VsbFN0eWxlcygpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy52dWVjYWwuaGlkZVdlZWtkYXlzLmxlbmd0aCA/IHtcbiAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHRoaXMuY2VsbFdpZHRoLCBcIiVcIilcbiAgICAgIH0gOiB7fSk7XG4gICAgfSxcbiAgICBjZWxsSGVhZGluZ3NDbGlja2FibGU6IGZ1bmN0aW9uIGNlbGxIZWFkaW5nc0NsaWNrYWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuaWQgPT09ICd3ZWVrJyAmJiAodGhpcy52dWVjYWwuY2xpY2tUb05hdmlnYXRlIHx8IHRoaXMudnVlY2FsLmRibGNsaWNrVG9OYXZpZ2F0ZSk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC93ZWVrZGF5cy1oZWFkaW5ncy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdnVlX2NhbF93ZWVrZGF5c19oZWFkaW5nc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh3ZWVrZGF5c19oZWFkaW5nc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvd2Vla2RheXMtaGVhZGluZ3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlxudmFyIHdlZWtkYXlzX2hlYWRpbmdzdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIwMjlcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC93ZWVrZGF5cy1oZWFkaW5ncy52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgdnVlX2NhbF93ZWVrZGF5c19oZWFkaW5nc3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgd2Vla2RheXNfaGVhZGluZ3N2dWVfdHlwZV90ZW1wbGF0ZV9pZF85YTBjMTlkMF9sYW5nX3B1Z19yZW5kZXIsXG4gIHdlZWtkYXlzX2hlYWRpbmdzdnVlX3R5cGVfdGVtcGxhdGVfaWRfOWEwYzE5ZDBfbGFuZ19wdWdfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgd2Vla2RheXNfaGVhZGluZ3MgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmVudHJpZXMuanNcbnZhciBlc19vYmplY3RfZW50cmllcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZmFkXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZHJhZy1hbmQtZHJvcC5qc1xuXG5cblxuXG5cblxuXG5cblxuLy8gQHRvZG86XG4vLyBPSyAtIGVtaXQgdGhlIGBldmVudC1kcm9wYCAmIGBldmVudC1jaGFuZ2VgIGV2ZW50cyBvbiBldmVudCBkcm9wXG4vLyBPSyAtIGhhbmRsZSBkcmFnIGFuZCBkcm9wIGFuZCBzcGxpdHMgLyBoaWdobGlnaHQgc3BsaXRzIHNlcGFyYXRlbHlcbi8vIE9LIC0gYWRkIHNwbGl0IGluIGVtaXR0ZWQgZXZlbnRcbi8vIE9LIC0gY2hlY2sgdGhhdCBldmVudC5kcmFnZ2FibGUgPSBmYWxzZSBwcmV2ZW50cyBkcmFnZ2luZ1xuLy8gT0sgLSBjaGVjayBlZGdlIGFuZCBJRVxuLy8gT0sgLSBhbHNvIGdvIHRvIG5hcnJvd2VyIHZpZXcgZnJvbSBtb250aCB2aWV3XG4vLyBPSyAtIEZpeCBkcmFnIGltYWdlIG5vdCB2aXNpYmxlIG9uIFNhZmFyaVxuLy8gT0sgLSBTdXBwb3J0IGRyYWcgb3ZlciB0b2RheSBidXR0b25cbi8vIE9LIC0gZHJvcCBhbiBldmVudCB0aGF0IHdvdWxkIHN0YXJ0IGJlZm9yZSBsYXN0IG1pZG5pZ2h0XG4vLyBPSyAtIFByZXZlbnQgZHJhZ2dpbmcgYmFja2dyb3VuZCBldmVudHNcbi8vIE9LIC0gQWxsb3cgZHJhZ2dpbmcgdGltZWxlc3MgZXZlbnRzXG4vLyBPSyAtIEZpeCBldmVudCBkZWxldGlvblxuLy8gT0sgLSBPbmx5IHRyaWdnZXIgdmlldyBjaGFuZ2UgaWYgaXQgY2hhbmdlZFxuLy8gT0sgLSBBZGQgb3B0aW9uIHRvIHNuYXAgdG8gdGltZSBvbiBldmVudCBkcm9wXG4vLyBPSyAtIGFkZCBqYXZhZG9jXG4vLyAgICAtIG1vZHVsYXJpemUgdGhpcyBmaWxlP1xudmFyIGhvbGRPdmVyVGltZW91dCA9IDgwMDsgLy8gSG93IGxvbmcgd2Ugc2hvdWxkIGhvbGQgb3ZlciBhbiBlbGVtZW50IGJlZm9yZSBpdCByZWFjdHMuXG5cbnZhciBjaGFuZ2VWaWV3VGltZW91dCA9IG51bGw7XG52YXIgcHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwgPSBudWxsO1xudmFyIHZpZXdCZWZvcmVEcmFnID0ge1xuICBpZDogbnVsbCxcbiAgZGF0ZTogbnVsbFxufTsgLy8gVG8gZ28gYmFjayBpZiBjYW5jZWxsaW5nLlxuXG52YXIgdmlld0NoYW5nZWQgPSBmYWxzZTtcbnZhciBjYW5jZWxWaWV3Q2hhbmdlID0gdHJ1ZTtcbnZhciBkcmFnT3ZlckNlbGwgPSB7XG4gIGVsOiBudWxsLFxuICBjZWxsOiBudWxsLFxuICB0aW1lb3V0OiBudWxsXG59O1xuLyoqXG4gKiBPbiBldmVudCBkcmFnIHN0YXJ0LCBvbmx5IHBvc3NpYmxlIGlmIGVkaXRhYmxlRXZlbnQgaXMgdHJ1ZS5cbiAqIC8hXFwgVGhpcyBpcyB1c2luZyB0aGUgbmF0aXZlIEhUTUw1IGRyYWcgJiBkcm9wLCBub3Qgc3VwcG9ydGVkIG9uIHRvdWNoIGRldmljZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkcmFnZ2VkLlxuICogQHBhcmFtIHtPYmplY3R9IHZ1ZWNhbCBUaGUgaW5zdGFuY2Ugb2YgVnVlIENhbCBjb21wb25lbnQuXG4gKi9cblxudmFyIGV2ZW50RHJhZ1N0YXJ0ID0gZnVuY3Rpb24gZXZlbnREcmFnU3RhcnQoZSwgZXZlbnQsIHZ1ZWNhbCkge1xuICAvLyBDYW5jZWwgdGhlIGRyYWcgaWYgZXZlbnQgaGFzIGRyYWdnYWJsZSBzZXQgdG8gZmFsc2UgYW5kIHRyeWluZyB0byBkcmFnIGEgdGV4dCBzZWxlY3Rpb24uXG4gIGlmIChlLnRhcmdldC5ub2RlVHlwZSA9PT0gMykgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsICcuLi4nKTsgLy8gV2l0aG91dCB0aGlzIHRoZSBkcmFnIHdpbGwgbm90IGhhcHBlbiBpbiBGaXJlZm94LlxuXG4gIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gIHZhciBfdnVlY2FsJGRvbUV2ZW50cyA9IHZ1ZWNhbC5kb21FdmVudHMsXG4gICAgICBjbGlja0hvbGRBbkV2ZW50ID0gX3Z1ZWNhbCRkb21FdmVudHMuY2xpY2tIb2xkQW5FdmVudCxcbiAgICAgIGRyYWdBbkV2ZW50ID0gX3Z1ZWNhbCRkb21FdmVudHMuZHJhZ0FuRXZlbnQ7IC8vIENhbmNlbCBhbnkgZGVsZXRlIG9uIGRyYWdTdGFydCAoaWYgaGVsZCBmb3IgdG9vIGxvbmcpLiBEb24ndCBkcmFnIGFuIGV2ZW50IHdpdGggYSB2aXNpYmxlIGRlbGV0ZSBidXR0b24uXG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2xpY2tIb2xkQW5FdmVudC5fZWlkID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQoY2xpY2tIb2xkQW5FdmVudC50aW1lb3V0SWQpO1xuICAgIGV2ZW50LmRlbGV0aW5nID0gZmFsc2U7XG4gIH0sIDApO1xuICBkcmFnQW5FdmVudC5fZWlkID0gZXZlbnQuX2VpZDtcbiAgZXZlbnQuZHJhZ2dpbmcgPSB0cnVlOyAvLyBDb250cm9scyB0aGUgQ1NTIGNsYXNzIG9mIHRoZSBzdGF0aWMgZXZlbnQgdGhhdCByZW1haW5zIHdoaWxlIGEgY29weSBpcyBiZWluZyBkcmFnZ2VkLlxuICAvLyBUaGFua3MgdG8gdGhpcyBjbGFzcywgdGhlIGV2ZW50IGJlaW5nIGRyYWdnZWQgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3R5bGUuXG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2ZW50LmRyYWdnaW5nU3RhdGljID0gdHJ1ZTtcbiAgfSwgMCk7XG4gIHZpZXdDaGFuZ2VkID0gZmFsc2U7XG4gIHZpZXdCZWZvcmVEcmFnID0ge1xuICAgIGlkOiB2dWVjYWwudmlldy5pZCxcbiAgICBkYXRlOiB2dWVjYWwudmlldy5zdGFydERhdGVcbiAgfTtcblxuICB2YXIgX3Z1ZWNhbCRtaW51dGVzQXRDdXJzID0gdnVlY2FsLm1pbnV0ZXNBdEN1cnNvcihlKSxcbiAgICAgIG1pbnV0ZXMgPSBfdnVlY2FsJG1pbnV0ZXNBdEN1cnMubWludXRlczsgLy8gV2hlbiBjbGljayBhbmQgZHJhZyBhbiBldmVudCB0aGUgY3Vyc29yIGNhbiBiZSBhbnl3aGVyZSBpbiB0aGUgZXZlbnQsXG4gIC8vIHdoZW4gbGF0ZXIgZHJvcHBpbmcgdGhlIGV2ZW50LCB3ZSBuZWVkIHRvIHN1YnRyYWN0IHRoZSBjdXJzb3IgcG9zaXRpb24gaW4gdGhlIGV2ZW50LlxuXG5cbiAgZHJhZ0FuRXZlbnQuY3Vyc29yR3JhYkF0ID0gbWludXRlcyAtIGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXM7XG4gIGNhbmNlbFZpZXdDaGFuZ2UgPSB0cnVlOyAvLyBSZS1pbml0IHRoZSBjYW5jZWwgdmlldzogc2hvdWxkIGNhbmNlbCB1bmxlc3MgYSBjZWxsIHJlY2VpdmVkIHRoZSBldmVudC5cbn07XG4vKipcbiAqIE9uIGV2ZW50IGRyYWcgZW5kLCB3aGVuIHJlbGVhc2luZyB0aGUgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkcmFnZ2VkLlxuICogQHBhcmFtIHtPYmplY3R9IHZ1ZWNhbCBUaGUgaW5zdGFuY2Ugb2YgVnVlIENhbCBjb21wb25lbnQuXG4gKi9cblxudmFyIGV2ZW50RHJhZ0VuZCA9IGZ1bmN0aW9uIGV2ZW50RHJhZ0VuZChlLCBldmVudCwgdnVlY2FsKSB7XG4gIHZhciBkcmFnQW5FdmVudCA9IHZ1ZWNhbC5kb21FdmVudHMuZHJhZ0FuRXZlbnQ7XG4gIGRyYWdBbkV2ZW50Ll9laWQgPSBudWxsO1xuICBldmVudC5kcmFnZ2luZyA9IGZhbHNlO1xuICBldmVudC5kcmFnZ2luZ1N0YXRpYyA9IGZhbHNlOyAvLyBXaGVuIGRyb3BwaW5nIHRoZSBldmVudCwgY2FuY2VsIHZpZXcgY2hhbmdlIGlmIG5vIGNlbGwgcmVjZWl2ZWQgdGhlIGV2ZW50IChpbiBjZWxsRHJhZ0Ryb3ApLlxuXG4gIGlmICh2aWV3Q2hhbmdlZCAmJiBjYW5jZWxWaWV3Q2hhbmdlICYmIHZpZXdCZWZvcmVEcmFnLmlkKSB2dWVjYWwuc3dpdGNoVmlldyh2aWV3QmVmb3JlRHJhZy5pZCwgdmlld0JlZm9yZURyYWcuZGF0ZSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBPbiBjZWxsL3NwbGl0IGVudGVyIHdpdGggYSBkcmFnZ2luZyBldmVudC5cbiAqIEhpZ2hsaWdodCB0aGUgY2VsbCwgYW5kIGlmIG9uIGB5ZWFyc2AsIGB5ZWFyYCwgYG1vbnRoYCB2aWV3LFxuICogc2V0IGEgdGltZXIgdG8gZ28gZGVlcGVyIG9uIGRyYWcgaG9sZCBvdmVyIHRoaXMgY2VsbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gY2VsbCBUaGUgY2VsbCBjb21wb25lbnQncyAkZGF0YS5cbiAqIEBwYXJhbSB7RGF0ZX0gY2VsbERhdGUgVGhlIGhvdmVyZWQgY2VsbCBzdGFydGluZyBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHZ1ZWNhbCBUaGUgaW5zdGFuY2Ugb2YgVnVlIENhbCBjb21wb25lbnQuXG4gKi9cblxudmFyIGNlbGxEcmFnRW50ZXIgPSBmdW5jdGlvbiBjZWxsRHJhZ0VudGVyKGUsIGNlbGwsIGNlbGxEYXRlLCB2dWVjYWwpIHtcbiAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldDsgLy8gQ2FuY2VsIGRyYWdFbnRlciBldmVudCBpZiBob3ZlcmluZyBhIGNoaWxkLlxuXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICBpZiAodGFyZ2V0ID09PSBkcmFnT3ZlckNlbGwuZWwgfHwgIXRhcmdldC5jbGFzc05hbWUuaW5jbHVkZXMoJ3Z1ZWNhbF9fY2VsbC1jb250ZW50JykpIHJldHVybiBmYWxzZTsgLy8gVW4taGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBjZWxsLlxuXG4gIGlmIChkcmFnT3ZlckNlbGwuZWwpIGRyYWdPdmVyQ2VsbC5jZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gIGRyYWdPdmVyQ2VsbCA9IHtcbiAgICBlbDogdGFyZ2V0LFxuICAgIGNlbGw6IGNlbGwsXG4gICAgdGltZW91dDogY2xlYXJUaW1lb3V0KGRyYWdPdmVyQ2VsbC50aW1lb3V0KVxuICB9O1xuICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTsgLy8gT24gYHllYXJzYCwgYHllYXJgICYgYG1vbnRoYCB2aWV3cywgZ28gdG8gbmFycm93ZXIgdmlldyBvbiBkcmFnIGFuZCBob2xkLlxuXG4gIGlmIChbJ3llYXJzJywgJ3llYXInLCAnbW9udGgnXS5pbmNsdWRlcyh2dWVjYWwudmlldy5pZCkpIHtcbiAgICBkcmFnT3ZlckNlbGwudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZ1ZWNhbC5zd2l0Y2hUb05hcnJvd2VyVmlldyhjZWxsRGF0ZSk7XG4gICAgfSwgMjAwMCk7XG4gIH1cbn07XG4vKipcbiAqIE9uIGNlbGwvc3BsaXQgZHJhZyBvdmVyLCBoaWdobGlnaHQgdGhlIGNlbGwgYmVpbmcgaG92ZXJlZCxcbiAqIFVzZWZ1bCB3aGVuIHN0YXJ0aW5nIHRvIGRyYWcgZXZlbnQgb24gdGhlIHNhbWUgY2VsbC9zcGxpdCBpdCdzIGluLlxuICogV2FybmluZzogVGhpcyBpcyBmaXJlZCByZXBlYXRlZGx5IGFzIGxvbmcgYXMgeW91IHN0YXkgb3ZlciB0aGlzIGNlbGwvc3BsaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNlbGwgVGhlIGNlbGwgY29tcG9uZW50J3MgJGRhdGEuXG4gKiBAcGFyYW0ge0RhdGV9IGNlbGxEYXRlIFRoZSBob3ZlcmVkIGNlbGwgc3RhcnRpbmcgZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgVGhlIGluc3RhbmNlIG9mIFZ1ZSBDYWwgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzcGxpdCBUaGUgb3B0aW9uYWwgc3BsaXQgYmVpbmcgaG92ZXJlZCBpZiBhbnkuXG4gKi9cblxudmFyIGNlbGxEcmFnT3ZlciA9IGZ1bmN0aW9uIGNlbGxEcmFnT3ZlcihlLCBjZWxsLCBjZWxsRGF0ZSwgdnVlY2FsLCBzcGxpdCkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGNlbGwuaGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICBpZiAoc3BsaXQgfHwgc3BsaXQgPT09IDApIGNlbGwuaGlnaGxpZ2h0ZWRTcGxpdCA9IHNwbGl0O1xufTtcbi8qKlxuICogV2hlbiBldmVudCBkcmFnIGxlYXZlcyBhIGNlbGwvc3BsaXQuXG4gKiBSZW1vdmUgdGhlIGNlbGwvc3BsaXQgaGlnaGxpZ2h0ZWQgc3RhdGUuXG4gKiBXYXJuaW5nOiBjZWxsIGRyYWdsZWF2ZSBldmVudCBoYXBwZW5zIEFGVEVSIGFub3RoZXIgY2VsbCBkcmFnZW50ZXIhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGNlbGwgVGhlIGNlbGwgY29tcG9uZW50J3MgJGRhdGEuXG4gKiBAcGFyYW0ge0RhdGV9IGNlbGxEYXRlIFRoZSBob3ZlcmVkIGNlbGwgc3RhcnRpbmcgZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgVGhlIGluc3RhbmNlIG9mIFZ1ZSBDYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBjZWxsRHJhZ0xlYXZlID0gZnVuY3Rpb24gY2VsbERyYWdMZWF2ZShlLCBjZWxsLCBjZWxsRGF0ZSwgdnVlY2FsKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgaWYgKGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm47XG4gIGNlbGwuaGlnaGxpZ2h0ZWRTcGxpdCA9IGZhbHNlOyAvLyBPbmx5IGNhbmNlbCB0aGUgdGltZXIgaWYgbGVhdmluZyB0aGUgY3VycmVudCBjZWxsIHRvIG5vIG90aGVyIG9uZS5cbiAgLy8gSWYgbGVhdmluZyB0aGlzIGNlbGwgdG8gZW50ZXIgYW5vdGhlciwgYSBjYW5jZWwgaXMgZG9uZSBpbiBjZWxsRHJhZ0VudGVyLFxuICAvLyBhbmQgYSBuZXcgdGltZXIgaXMgc3RhcnRlZC5cblxuICBpZiAoZHJhZ092ZXJDZWxsLmNlbGwgPT09IGNlbGwpIHtcbiAgICBjbGVhclRpbWVvdXQoZHJhZ092ZXJDZWxsLnRpbWVvdXQpO1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICBkcmFnT3ZlckNlbGwgPSB7XG4gICAgICBlbDogbnVsbCxcbiAgICAgIGNlbGw6IG51bGwsXG4gICAgICB0aW1lb3V0OiBudWxsXG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogT24gc3VjY2Vzc2Z1bCBldmVudCBkcm9wIGludG8gYSBjZWxsL3NwbGl0LlxuICogQ2hhbmdlIHRoZSBldmVudCBzdGFydCBhbmQgZW5kIHRpbWUgYW5kIHJlbW92ZSB0aGUgZXZlbnQgZHJhZ2dpbmcgc3RhdGVcbiAqIGFuZCBjZWxsL3NwbGl0IGhpZ2hsaWdodGVkIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsIFRoZSBjZWxsIGNvbXBvbmVudCdzICRkYXRhLlxuICogQHBhcmFtIHtEYXRlfSBjZWxsRGF0ZSBUaGUgaG92ZXJlZCBjZWxsIHN0YXJ0aW5nIGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gdnVlY2FsIFRoZSBpbnN0YW5jZSBvZiBWdWUgQ2FsIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc3BsaXQgVGhlIG9wdGlvbmFsIHNwbGl0IGJlaW5nIGRyb3BwZWQgaW50bywgaWYgYW55LlxuICovXG5cbnZhciBkcmFnX2FuZF9kcm9wX2NlbGxEcmFnRHJvcCA9IGZ1bmN0aW9uIGNlbGxEcmFnRHJvcChlLCBjZWxsLCBjZWxsRGF0ZSwgdnVlY2FsLCBzcGxpdCkge1xuICAvLyBOZWVkZWQgdG8gcHJldmVudCBuYXZpZ2F0aW9uIHRvIHRoZSB0ZXh0IHNldCBpbiBkYXRhVHJhbnNmZXIgZnJvbSBldmVudERyYWdTdGFydCgpLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHZhciB2aWV3ID0gdnVlY2FsLnZpZXcsXG4gICAgICBkcmFnQW5FdmVudCA9IHZ1ZWNhbC5kb21FdmVudHMuZHJhZ0FuRXZlbnQsXG4gICAgICBtdXRhYmxlRXZlbnRzID0gdnVlY2FsLm11dGFibGVFdmVudHMsXG4gICAgICBtaW51dGVzQXRDdXJzb3IgPSB2dWVjYWwubWludXRlc0F0Q3Vyc29yLFxuICAgICAgc25hcFRvVGltZSA9IHZ1ZWNhbC5zbmFwVG9UaW1lOyAvLyBGaW5kIHRoZSBkcmFnZ2VkIGV2ZW50IGZyb20gaXRzIF9laWQgaW4gdGhlIHZpZXcgb3IgbXV0YWJsZUV2ZW50cyBhcnJheS5cblxuICB2YXIgZXZlbnQgPSB2aWV3LmV2ZW50cy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUuX2VpZCA9PT0gZHJhZ0FuRXZlbnQuX2VpZDtcbiAgfSk7XG4gIHZhciBldmVudEluVmlldyA9ICEhZXZlbnQ7XG4gIGlmICghZXZlbnQpIGV2ZW50ID0gbXV0YWJsZUV2ZW50cy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUuX2VpZCA9PT0gZHJhZ0FuRXZlbnQuX2VpZDtcbiAgfSkgfHwge307IC8vIE1vZGlmeSB0aGUgZXZlbnQgc3RhcnQgYW5kIGVuZCBkYXRlLlxuXG4gIHZhciBfZXZlbnQgPSBldmVudCxcbiAgICAgIG9sZERhdGUgPSBfZXZlbnQuc3RhcnREYXRlLFxuICAgICAgb2xkU3BsaXQgPSBfZXZlbnQuc3BsaXQ7XG4gIHZhciBldmVudER1cmF0aW9uID0gZXZlbnQuZW5kVGltZU1pbnV0ZXMgLSBldmVudC5zdGFydFRpbWVNaW51dGVzOyAvLyBGb3JjZSB0aGUgc3RhcnQgb2YgdGhlIGV2ZW50IGF0IHByZXZpb3VzIG1pZG5pZ2h0IG1pbmltdW0uXG5cbiAgdmFyIHN0YXJ0VGltZU1pbnV0ZXMgPSBNYXRoLm1heChtaW51dGVzQXRDdXJzb3IoZSkubWludXRlcyAtIGRyYWdBbkV2ZW50LmN1cnNvckdyYWJBdCwgMCk7IC8vIE9uIGRyb3AsIHNuYXAgdG8gdGltZSBldmVyeSBYIG1pbnV0ZXMgaWYgdGhlIG9wdGlvbiBpcyBvbi5cblxuICBpZiAoc25hcFRvVGltZSkge1xuICAgIHZhciBwbHVzSGFsZlNuYXBUaW1lID0gc3RhcnRUaW1lTWludXRlcyArIHNuYXBUb1RpbWUgLyAyO1xuICAgIHN0YXJ0VGltZU1pbnV0ZXMgPSBwbHVzSGFsZlNuYXBUaW1lIC0gcGx1c0hhbGZTbmFwVGltZSAlIHNuYXBUb1RpbWU7XG4gIH1cblxuICBldmVudC5zdGFydFRpbWVNaW51dGVzID0gc3RhcnRUaW1lTWludXRlcztcbiAgZXZlbnQuc3RhcnREYXRlID0gbmV3IERhdGUobmV3IERhdGUoY2VsbERhdGUpLnNldE1pbnV0ZXMoc3RhcnRUaW1lTWludXRlcykpO1xuICBldmVudC5zdGFydCA9IFwiXCIuY29uY2F0KGV2ZW50LnN0YXJ0RGF0ZS5mb3JtYXQoKSwgXCIgXCIpLmNvbmNhdChldmVudC5zdGFydERhdGUuZm9ybWF0VGltZSgpKTsgLy8gRm9yY2UgdGhlIGVuZCBvZiB0aGUgZXZlbnQgYXQgbmV4dCBtaWRuaWdodCBtYXhpbXVtLlxuXG4gIGV2ZW50LmVuZFRpbWVNaW51dGVzID0gTWF0aC5taW4oc3RhcnRUaW1lTWludXRlcyArIGV2ZW50RHVyYXRpb24sIDI0ICogNjApO1xuICBldmVudC5lbmREYXRlID0gbmV3IERhdGUobmV3IERhdGUoY2VsbERhdGUpLnNldE1pbnV0ZXMoZXZlbnQuZW5kVGltZU1pbnV0ZXMpKTtcbiAgZXZlbnQuZW5kID0gXCJcIi5jb25jYXQoZXZlbnQuZW5kRGF0ZS5mb3JtYXQoKSwgXCIgXCIpLmNvbmNhdChldmVudC5lbmREYXRlLmZvcm1hdFRpbWUoKSk7XG4gIGV2ZW50LmRyYWdnaW5nID0gZmFsc2U7XG4gIGlmIChzcGxpdCB8fCBzcGxpdCA9PT0gMCkgZXZlbnQuc3BsaXQgPSBzcGxpdDtcbiAgaWYgKCFldmVudEluVmlldykgdnVlY2FsLmFkZEV2ZW50c1RvVmlldyhbZXZlbnRdKTtcbiAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICBjZWxsLmhpZ2hsaWdodGVkU3BsaXQgPSBudWxsO1xuICBjYW5jZWxWaWV3Q2hhbmdlID0gZmFsc2U7XG5cbiAgdmFyIHBhcmFtcyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICBldmVudDogdnVlY2FsLmNsZWFudXBFdmVudChldmVudCksXG4gICAgb2xkRGF0ZTogb2xkRGF0ZSxcbiAgICBuZXdEYXRlOiBldmVudC5zdGFydERhdGVcbiAgfSwgKHNwbGl0IHx8IHNwbGl0ID09PSAwKSAmJiB7XG4gICAgb2xkU3BsaXQ6IG9sZFNwbGl0LFxuICAgIG5ld1NwbGl0OiBzcGxpdFxuICB9KTtcblxuICB2dWVjYWwuJGVtaXQoJ2V2ZW50LWRyb3AnLCBwYXJhbXMpO1xuICB2dWVjYWwuJGVtaXQoJ2V2ZW50LWNoYW5nZScsIHBhcmFtcy5ldmVudCk7XG59O1xuLyoqXG4gKiBPbiBkcmFnIGVudGVyIG9uIGEgdmlldyBidXR0b24gb3Igb24gdG9kYXksIHByZXYgJiBuZXh0IGJ1dHRvbnMuXG4gKiBTZXRzIGEgaGlnaGxpZ2h0ZWQgc3RhdGUgb24gdGhlIGhvdmVyZWQgYnV0dG9uLCBhbmQgZ28gdG8gcmVxdWVzdGVkIHZpZXcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgaGVhZGVyIGVsZW1lbnQgYmVpbmcgaG92ZXJlZC4gT25lIG9mOlxuICogICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLCBuZXh0LCB0b2RheSwgeWVhcnMsIHllYXIsIG1vbnRoLCB3ZWVrLCBkYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gdnVlY2FsIFRoZSBpbnN0YW5jZSBvZiBWdWUgQ2FsIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJEYXRhIFRoZSBoZWFkZXIgY29tcG9uZW50J3MgJGRhdGEuXG4gKi9cblxudmFyIGRyYWdfYW5kX2Ryb3Bfdmlld1NlbGVjdG9yRHJhZ0VudGVyID0gZnVuY3Rpb24gdmlld1NlbGVjdG9yRHJhZ0VudGVyKGUsIGlkLCB2dWVjYWwsIGhlYWRlckRhdGEpIHtcbiAgaWYgKGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm47XG4gIGhlYWRlckRhdGEuaGlnaGxpZ2h0ZWRDb250cm9sID0gaWQ7XG4gIGNsZWFyVGltZW91dChjaGFuZ2VWaWV3VGltZW91dCk7XG4gIGNoYW5nZVZpZXdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFsncHJldmlvdXMnLCAnbmV4dCddLmluY2x1ZGVzKGlkKSkge1xuICAgICAgdnVlY2FsW2lkXSgpOyAvLyBLZWVwIHByZXNzaW5nIG9uIHByZXZpb3VzIG9yIG5leHQgYnV0dG9uIHVudGlsIHVzZXIgZ29lcyBhd2F5LlxuXG4gICAgICBjbGVhckludGVydmFsKHByZXNzUHJldk9yTmV4dEludGVydmFsKTtcbiAgICAgIHByZXNzUHJldk9yTmV4dEludGVydmFsID0gc2V0SW50ZXJ2YWwodnVlY2FsW2lkXSwgaG9sZE92ZXJUaW1lb3V0KTtcbiAgICB9IGVsc2UgaWYgKGlkID09PSAndG9kYXknKSB7XG4gICAgICBjbGVhckludGVydmFsKHByZXNzUHJldk9yTmV4dEludGVydmFsKTtcbiAgICAgIHZhciB2aWV3SWQ7XG5cbiAgICAgIGlmICh2dWVjYWwudmlldy5pZC5pbmNsdWRlcygneWVhcicpKSB7XG4gICAgICAgIHZpZXdJZCA9IE9iamVjdC5lbnRyaWVzKHZ1ZWNhbC52aWV3cykuZmluZChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgICB2aWQgPSBfcmVmMlswXSxcbiAgICAgICAgICAgICAgb2JqID0gX3JlZjJbMV07XG5cbiAgICAgICAgICByZXR1cm4gb2JqLmVuYWJsZWQgJiYgIXZpZC5pbmNsdWRlcygneWVhcicpO1xuICAgICAgICB9KVswXTtcbiAgICAgIH1cblxuICAgICAgdnVlY2FsLnN3aXRjaFZpZXcodmlld0lkIHx8IHZ1ZWNhbC52aWV3LmlkLCBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHZ1ZWNhbC5zd2l0Y2hWaWV3KGlkLCBudWxsLCB0cnVlKTtcblxuICAgIHZpZXdDaGFuZ2VkID0gdHJ1ZTtcbiAgfSwgaG9sZE92ZXJUaW1lb3V0KTtcbn07XG4vKipcbiAqIE9uIGRyYWcgbGVhdmUgb24gYSB2aWV3IGJ1dHRvbiBvciBvbiB0b2RheSwgcHJldiAmIG5leHQgYnV0dG9ucy5cbiAqIFJlbW92ZXMgdGhlIGhpZ2hsaWdodGVkIHN0YXRlIG9uIHRoZSBob3ZlcmVkIGJ1dHRvbiwgYW5kIGNhbmNlbCB0aGUgdGltZXIgdG9cbiAqIGdvIHRvIHRoZSByZXF1ZXN0ZWQgdmlldy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBoZWFkZXIgZWxlbWVudCBiZWluZyBob3ZlcmVkLiBPbmUgb2Y6XG4gKiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIG5leHQsIHRvZGF5LCB5ZWFycywgeWVhciwgbW9udGgsIHdlZWssIGRheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2dWVjYWwgVGhlIGluc3RhbmNlIG9mIFZ1ZSBDYWwgY29tcG9uZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlckRhdGEgVGhlIGhlYWRlciBjb21wb25lbnQncyAkZGF0YS5cbiAqL1xuXG52YXIgdmlld1NlbGVjdG9yRHJhZ0xlYXZlID0gZnVuY3Rpb24gdmlld1NlbGVjdG9yRHJhZ0xlYXZlKGUsIGlkLCB2dWVjYWwsIGhlYWRlckRhdGEpIHtcbiAgaWYgKGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm47IC8vIE9ubHkgY2FuY2VsIHRoZSB0aW1lciBpZiBsZWF2aW5nIHRoZSBjdXJyZW50IG5hdiBidXR0b24gdG8gbm8gb3RoZXIgb25lLlxuICAvLyBJZiBsZWF2aW5nIHRoaXMgbmF2IGJ1dHRvbiB0byBlbnRlciBhbm90aGVyLCBhIGNhbmNlbCBpcyBkb25lIGluIHZpZXdTZWxlY3RvckRyYWdFbnRlcixcbiAgLy8gYW5kIGEgbmV3IHRpbWVyIGlzIHN0YXJ0ZWQuXG5cbiAgaWYgKGhlYWRlckRhdGEuaGlnaGxpZ2h0ZWRDb250cm9sID09PSBpZCkge1xuICAgIGhlYWRlckRhdGEuaGlnaGxpZ2h0ZWRDb250cm9sID0gbnVsbDtcbiAgICBpZiAoY2hhbmdlVmlld1RpbWVvdXQpIGNoYW5nZVZpZXdUaW1lb3V0ID0gY2xlYXJUaW1lb3V0KGNoYW5nZVZpZXdUaW1lb3V0KTtcbiAgICBpZiAocHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwpIHByZXNzUHJldk9yTmV4dEludGVydmFsID0gY2xlYXJJbnRlcnZhbChwcmVzc1ByZXZPck5leHRJbnRlcnZhbCk7XG4gIH1cbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9oZWFkZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBoZWFkZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBjb21wb25lbnRzOiB7XG4gICAgV2Vla2RheXNIZWFkaW5nczogd2Vla2RheXNfaGVhZGluZ3NcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAvLyBWdWVjYWwgbWFpbiBjb21wb25lbnQgb3B0aW9ucyAocHJvcHMpLlxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXlTcGxpdHM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZXdQcm9wczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdlZWtEYXlzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBzd2l0Y2hUb05hcnJvd2VyVmlldzoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoaWdobGlnaHRlZENvbnRyb2w6IG51bGxcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgdGhpcy4kcGFyZW50LnByZXZpb3VzTmV4dChmYWxzZSk7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdGhpcy4kcGFyZW50LnByZXZpb3VzTmV4dCgpO1xuICAgIH0sXG4gICAgZ29Ub1RvZGF5OiBmdW5jdGlvbiBnb1RvVG9kYXkoKSB7XG4gICAgICAvLyBMYXN0IG1pZG5pZ2h0LlxuICAgICAgdGhpcy4kcGFyZW50LnVwZGF0ZVNlbGVjdGVkRGF0ZShuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKSk7XG4gICAgfSxcbiAgICBzd2l0Y2hUb0Jyb2FkZXJWaWV3OiBmdW5jdGlvbiBzd2l0Y2hUb0Jyb2FkZXJWaWV3KCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgaWYgKHRoaXMuYnJvYWRlclZpZXcpIHRoaXMuJHBhcmVudC5zd2l0Y2hWaWV3KHRoaXMuYnJvYWRlclZpZXcpO1xuICAgIH0sXG4gICAgdmlld1NlbGVjdG9yRHJhZ0VudGVyOiBkcmFnX2FuZF9kcm9wX3ZpZXdTZWxlY3RvckRyYWdFbnRlcixcbiAgICB2aWV3U2VsZWN0b3JEcmFnTGVhdmU6IHZpZXdTZWxlY3RvckRyYWdMZWF2ZVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHRyYW5zaXRpb25EaXJlY3Rpb246IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFyZW50LnRyYW5zaXRpb25EaXJlY3Rpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuJHBhcmVudC50cmFuc2l0aW9uRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gICAgYnJvYWRlclZpZXc6IGZ1bmN0aW9uIGJyb2FkZXJWaWV3KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZpZXdzID0gT2JqZWN0LmtleXModGhpcy52aWV3UHJvcHMudmlld3MpO1xuICAgICAgdmlld3MgPSB2aWV3cy5zbGljZSgwLCB2aWV3cy5pbmRleE9mKHRoaXMudmlld1Byb3BzLnZpZXcuaWQpKTtcbiAgICAgIHZpZXdzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB2aWV3cy5maW5kKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy52aWV3UHJvcHMudmlld3Nbdl0uZW5hYmxlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvaGVhZGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2dWVfY2FsX2hlYWRlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChoZWFkZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2hlYWRlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXG52YXIgaGVhZGVydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhOGFcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9oZWFkZXIudnVlXG5cblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBoZWFkZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICB2dWVfY2FsX2hlYWRlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgaGVhZGVydnVlX3R5cGVfdGVtcGxhdGVfaWRfMTE3MzM5NTNfbGFuZ19wdWdfcmVuZGVyLFxuICBoZWFkZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8xMTczMzk1M19sYW5nX3B1Z19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBoZWFkZXIgPSAoaGVhZGVyX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjQ4N2Y4MjE3LXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3B1Zy1wbGFpbi1sb2FkZXIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9jZWxsLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03NDc1ZjJmMCZsYW5nPXB1ZyZcbnZhciBjZWxsdnVlX3R5cGVfdGVtcGxhdGVfaWRfNzQ3NWYyZjBfbGFuZ19wdWdfcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygndHJhbnNpdGlvbi1ncm91cCcse3N0YXRpY0NsYXNzOlwidnVlY2FsX19jZWxsXCIsY2xhc3M6X3ZtLmNzc0NsYXNzZXMsc3R5bGU6KF92bS5jZWxsU3R5bGVzKSxhdHRyczp7XCJuYW1lXCI6KFwic2xpZGUtZmFkZS0tXCIgKyBfdm0udHJhbnNpdGlvbkRpcmVjdGlvbiksXCJ0YWdcIjpcImRpdlwiLFwiYXBwZWFyXCI6X3ZtLm9wdGlvbnMudHJhbnNpdGlvbnN9fSxbX3ZtLl9sKCgoX3ZtLnNwbGl0cy5sZW5ndGggPyBfdm0uc3BsaXRzIDogMSkpLGZ1bmN0aW9uKHNwbGl0LGkpe3JldHVybiBfYygnZGl2Jyx7a2V5Ol92bS5vcHRpb25zLnRyYW5zaXRpb25zID8gKF92bS52aWV3ICsgXCItXCIgKyAoX3ZtLmRhdGEuY29udGVudCkgKyBcIi1cIiArIGkpIDogaSxzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZmxleCB2dWVjYWxfX2NlbGwtY29udGVudFwiLGNsYXNzOl92bS5zcGxpdHMubGVuZ3RoICYmIChcInZ1ZWNhbF9fY2VsbC1zcGxpdCBcIiArIChzcGxpdC5jbGFzcykgKyAoX3ZtLmhpZ2hsaWdodGVkU3BsaXQgPT09IHNwbGl0LmlkID8gJyB2dWVjYWxfX2NlbGwtc3BsaXQtLWhpZ2hsaWdodGVkJyA6ICcnKSksYXR0cnM6e1wiZGF0YS1zcGxpdFwiOl92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQuaWQgOiBmYWxzZSxcImNvbHVtblwiOlwiXCIsXCJ0YWJpbmRleFwiOlwiMFwiLFwiYXJpYS1sYWJlbFwiOl92bS5kYXRhLmNvbnRlbnR9LG9uOntcImZvY3VzXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLm9uQ2VsbEZvY3VzKCRldmVudCl9LFwia2V5cHJlc3NcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmX3ZtLl9rKCRldmVudC5rZXlDb2RlLFwiZW50ZXJcIiwxMywkZXZlbnQua2V5LFwiRW50ZXJcIikpeyByZXR1cm4gbnVsbDsgfXJldHVybiBfdm0ub25DZWxsa2V5UHJlc3NFbnRlcigkZXZlbnQpfSxcInRvdWNoc3RhcnRcIjpmdW5jdGlvbigkZXZlbnQpeyFfdm0uaXNEaXNhYmxlZCAmJiBfdm0ub25DZWxsVG91Y2hTdGFydCgkZXZlbnQsIF92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQuaWQgOiBudWxsKX0sXCJtb3VzZWRvd25cIjpmdW5jdGlvbigkZXZlbnQpeyFfdm0uaXNEaXNhYmxlZCAmJiBfdm0ub25DZWxsTW91c2VEb3duKCRldmVudCwgX3ZtLnNwbGl0cy5sZW5ndGggPyBzcGxpdC5pZCA6IG51bGwpfSxcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXshX3ZtLmlzRGlzYWJsZWQgJiYgX3ZtLnNlbGVjdENlbGwoJGV2ZW50KX0sXCJkYmxjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7IV92bS5pc0Rpc2FibGVkICYmIF92bS5vbkNlbGxEYmxDbGljaygkZXZlbnQpfSxcImNvbnRleHRtZW51XCI6ZnVuY3Rpb24oJGV2ZW50KXshX3ZtLmlzRGlzYWJsZWQgJiYgX3ZtLm9wdGlvbnMuY2VsbENvbnRleHRtZW51ICYmIF92bS5vbkNlbGxDb250ZXh0TWVudSgkZXZlbnQpfSxcImRyYWdlbnRlclwiOmZ1bmN0aW9uKCRldmVudCl7IV92bS5pc0Rpc2FibGVkICYmIF92bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS5jZWxsRHJhZ0VudGVyKCRldmVudCwgX3ZtLiRkYXRhLCBfdm0uZGF0YS5zdGFydERhdGUsIF92bS4kcGFyZW50KX0sXCJkcmFnb3ZlclwiOmZ1bmN0aW9uKCRldmVudCl7IV92bS5pc0Rpc2FibGVkICYmIF92bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS5jZWxsRHJhZ092ZXIoJGV2ZW50LCBfdm0uJGRhdGEsIF92bS5kYXRhLnN0YXJ0RGF0ZSwgX3ZtLiRwYXJlbnQsIF92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQuaWQgOiBudWxsKX0sXCJkcmFnbGVhdmVcIjpmdW5jdGlvbigkZXZlbnQpeyFfdm0uaXNEaXNhYmxlZCAmJiBfdm0ub3B0aW9ucy5lZGl0YWJsZUV2ZW50cyAmJiBfdm0uY2VsbERyYWdMZWF2ZSgkZXZlbnQsIF92bS4kZGF0YSwgX3ZtLmRhdGEuc3RhcnREYXRlLCBfdm0uJHBhcmVudCl9LFwiZHJvcFwiOmZ1bmN0aW9uKCRldmVudCl7IV92bS5pc0Rpc2FibGVkICYmIF92bS5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIF92bS5jZWxsRHJhZ0Ryb3AoJGV2ZW50LCBfdm0uJGRhdGEsIF92bS5kYXRhLnN0YXJ0RGF0ZSwgX3ZtLiRwYXJlbnQsIF92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQuaWQgOiBudWxsKX19fSxbKF92bS5pc1dlZWtPckRheVZpZXcgJiYgIV92bS5hbGxEYXkgJiYgX3ZtLnNwZWNpYWxIb3Vycy5mcm9tICE9PSBudWxsKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX3NwZWNpYWwtaG91cnNcIixjbGFzczooXCJ2dWVjYWxfX3NwZWNpYWwtaG91cnMtLWRheVwiICsgKF92bS5zcGVjaWFsSG91cnMuZGF5KSArIFwiIFwiICsgKF92bS5zcGVjaWFsSG91cnMuY2xhc3MpKSxzdHlsZTooKFwiaGVpZ2h0OiBcIiArIChfdm0uc3BlY2lhbEhvdXJzLmhlaWdodCkgKyBcInB4O3RvcDogXCIgKyAoX3ZtLnNwZWNpYWxIb3Vycy50b3ApICsgXCJweFwiKSl9KTpfdm0uX2UoKSxfdm0uX3QoXCJjZWxsLWNvbnRlbnRcIixudWxsLHtcImV2ZW50c1wiOl92bS5ldmVudHMsXCJzZWxlY3RDZWxsXCI6ZnVuY3Rpb24gKCRldmVudCkgeyByZXR1cm4gX3ZtLnNlbGVjdENlbGwoJGV2ZW50LCB0cnVlKTsgfSxcInNwbGl0XCI6X3ZtLnNwbGl0cy5sZW5ndGggPyBzcGxpdCA6IGZhbHNlfSksKF92bS5ldmVudHNDb3VudCAmJiAoX3ZtLmlzV2Vla09yRGF5VmlldyB8fCAoX3ZtLnZpZXcgPT09ICdtb250aCcgJiYgX3ZtLm9wdGlvbnMuZXZlbnRzT25Nb250aFZpZXcpKSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidnVlY2FsX19jZWxsLWV2ZW50c1wifSxfdm0uX2woKChfdm0uc3BsaXRzLmxlbmd0aCA/IHNwbGl0LmV2ZW50cyA6IF92bS5ldmVudHMpKSxmdW5jdGlvbihldmVudCxqKXtyZXR1cm4gX2MoJ2V2ZW50Jyx7a2V5OmosYXR0cnM6e1widnVlY2FsXCI6X3ZtLiRwYXJlbnQsXCJjZWxsLWZvcm1hdHRlZC1kYXRlXCI6X3ZtLmRhdGEuZm9ybWF0dGVkRGF0ZSxcImV2ZW50XCI6ZXZlbnQsXCJhbGwtZGF5XCI6X3ZtLmFsbERheSxcImNlbGwtZXZlbnRzXCI6X3ZtLnNwbGl0cy5sZW5ndGggPyBzcGxpdC5ldmVudHMgOiBfdm0uZXZlbnRzLFwib3ZlcmxhcHNcIjooKF92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQub3ZlcmxhcHNbZXZlbnQuX2VpZF0gOiBfdm0uY2VsbE92ZXJsYXBzW2V2ZW50Ll9laWRdKSB8fCBbXSkub3ZlcmxhcHMsXCJldmVudC1wb3NpdGlvblwiOigoX3ZtLnNwbGl0cy5sZW5ndGggPyBzcGxpdC5vdmVybGFwc1tldmVudC5fZWlkXSA6IF92bS5jZWxsT3ZlcmxhcHNbZXZlbnQuX2VpZF0pIHx8IFtdKS5wb3NpdGlvbixcIm92ZXJsYXBzLXN0cmVha1wiOl92bS5zcGxpdHMubGVuZ3RoID8gc3BsaXQub3ZlcmxhcHNTdHJlYWsgOiBfdm0uY2VsbE92ZXJsYXBzU3RyZWFrfSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJldmVudFwiLGZuOmZ1bmN0aW9uKHJlZil7XG52YXIgZXZlbnQgPSByZWYuZXZlbnQ7XG52YXIgdmlldyA9IHJlZi52aWV3O1xucmV0dXJuIFtfdm0uX3QoXCJldmVudFwiLG51bGwse1widmlld1wiOnZpZXcsXCJldmVudFwiOmV2ZW50fSldfX1dLG51bGwsdHJ1ZSl9KX0pLDEpOl92bS5fZSgpXSwyKX0pLChfdm0udGltZWxpbmVWaXNpYmxlKT9fYygnZGl2Jyx7a2V5Ol92bS5vcHRpb25zLnRyYW5zaXRpb25zID8gKF92bS52aWV3ICsgXCItbm93LWxpbmVcIikgOiAnbm93LWxpbmUnLHN0YXRpY0NsYXNzOlwidnVlY2FsX19ub3ctbGluZVwiLHN0eWxlOigoXCJ0b3A6IFwiICsgX3ZtLnRvZGF5c1RpbWVQb3NpdGlvbiArIFwicHhcIikpLGF0dHJzOntcInRpdGxlXCI6X3ZtLiRwYXJlbnQuZm9ybWF0VGltZShfdm0ubm93SW5NaW51dGVzKX19KTpfdm0uX2UoKV0sMil9XG52YXIgY2VsbHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzc0NzVmMmYwX2xhbmdfcHVnX3N0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2NlbGwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTc0NzVmMmYwJmxhbmc9cHVnJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI0ODdmODIxNy12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy9wdWctcGxhaW4tbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZXZlbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE5ZTRmYTU5Jmxhbmc9cHVnJlxudmFyIGV2ZW50dnVlX3R5cGVfdGVtcGxhdGVfaWRfMTllNGZhNTlfbGFuZ19wdWdfcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2V2ZW50XCIsY2xhc3M6X3ZtLmV2ZW50Q2xhc3NlcyxzdHlsZTooX3ZtLmV2ZW50U3R5bGVzKSxhdHRyczp7XCJ0YWJpbmRleFwiOlwiMFwiLFwiZHJhZ2dhYmxlXCI6X3ZtLnZ1ZWNhbC5lZGl0YWJsZUV2ZW50cyAmJiBfdm0uZXZlbnQuZHJhZ2dhYmxlICYmICFfdm0uZXZlbnQuYmFja2dyb3VuZH0sb246e1wiZm9jdXNcIjpfdm0uZm9jdXNFdmVudCxcImtleXByZXNzXCI6ZnVuY3Rpb24oJGV2ZW50KXtpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJl92bS5faygkZXZlbnQua2V5Q29kZSxcImVudGVyXCIsMTMsJGV2ZW50LmtleSxcIkVudGVyXCIpKXsgcmV0dXJuIG51bGw7IH0kZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIF92bS5vbkNsaWNrKCRldmVudCl9LFwibW91c2VlbnRlclwiOl92bS5vbk1vdXNlRW50ZXIsXCJtb3VzZWxlYXZlXCI6X3ZtLm9uTW91c2VMZWF2ZSxcInRvdWNoc3RhcnRcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gX3ZtLm9uVG91Y2hTdGFydCgkZXZlbnQpfSxcIm1vdXNlZG93blwiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLm9uTW91c2VEb3duKCRldmVudCkgLyogRG9uJ3Qgc3RvcCBtb3VzZWRvd24gcHJvcGFnYXRpb24gJiB0cmlnZ2VyIGNlbGwgbW91c2Vkb3duICovfSxcImNsaWNrXCI6X3ZtLm9uQ2xpY2ssXCJkYmxjbGlja1wiOl92bS5vbkRibENsaWNrLFwiZHJhZ3N0YXJ0XCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0udnVlY2FsLmVkaXRhYmxlRXZlbnRzICYmIF92bS5ldmVudC5kcmFnZ2FibGUgJiYgIV92bS5ldmVudC5iYWNrZ3JvdW5kICYmIF92bS5vbkRyYWdTdGFydCgkZXZlbnQpfSxcImRyYWdlbmRcIjpmdW5jdGlvbigkZXZlbnQpe192bS52dWVjYWwuZWRpdGFibGVFdmVudHMgJiYgX3ZtLmV2ZW50LmRyYWdnYWJsZSAmJiAhX3ZtLmV2ZW50LmJhY2tncm91bmQgJiYgX3ZtLm9uRHJhZ0VuZCgkZXZlbnQpfX19LFsoX3ZtLnZ1ZWNhbC5lZGl0YWJsZUV2ZW50cyAmJiBfdm0uZXZlbnQuZGVsZXRhYmxlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWVjYWxfX2V2ZW50LWRlbGV0ZVwiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIF92bS5kZWxldGVFdmVudCgkZXZlbnQpfSxcInRvdWNoc3RhcnRcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gX3ZtLnRvdWNoRGVsZXRlRXZlbnQoJGV2ZW50KX19fSxbX3ZtLl92KF92bS5fcyhfdm0udnVlY2FsLnRleHRzLmRlbGV0ZUV2ZW50KSldKTpfdm0uX2UoKSxfdm0uX3QoXCJldmVudFwiLG51bGwse1wiZXZlbnRcIjpfdm0uZXZlbnQsXCJ2aWV3XCI6X3ZtLnZ1ZWNhbC52aWV3LmlkfSksKF92bS5yZXNpemFibGUpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZ1ZWNhbF9fZXZlbnQtcmVzaXplLWhhbmRsZVwiLGF0dHJzOntcImNvbnRlbnRlZGl0YWJsZVwiOlwiZmFsc2VcIn0sb246e1wibW91c2Vkb3duXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5vbkRyYWdIYW5kbGVNb3VzZURvd24oJGV2ZW50KX0sXCJ0b3VjaHN0YXJ0XCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5vbkRyYWdIYW5kbGVNb3VzZURvd24oJGV2ZW50KX19fSk6X3ZtLl9lKCldLDIpfVxudmFyIGV2ZW50dnVlX3R5cGVfdGVtcGxhdGVfaWRfMTllNGZhNTlfbGFuZ19wdWdfc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZXZlbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE5ZTRmYTU5Jmxhbmc9cHVnJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzXG52YXIgZXNfYXJyYXlfam9pbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMTViXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9ldmVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGV2ZW50dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgcHJvcHM6IHtcbiAgICBjZWxsRm9ybWF0dGVkRGF0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHZ1ZWNhbDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY2VsbEV2ZW50czoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgb3ZlcmxhcHM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50UG9zaXRpb246IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG92ZXJsYXBzU3RyZWFrOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBhbGxEYXk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8vIE9uIGFuIGV2ZW50LlxuICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdG91Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgLy8gUHJldmVudCBhIGRvdWJsZSBtb3VzZSBkb3duIG9uIHRvdWNoIGRldmljZXMuXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICF0b3VjaCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIF90aGlzJGRvbUV2ZW50cyA9IHRoaXMuZG9tRXZlbnRzLFxuICAgICAgICAgIGNsaWNrSG9sZEFuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMuY2xpY2tIb2xkQW5FdmVudCxcbiAgICAgICAgICBmb2N1c0FuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMuZm9jdXNBbkV2ZW50LFxuICAgICAgICAgIHJlc2l6ZUFuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMucmVzaXplQW5FdmVudCxcbiAgICAgICAgICBkcmFnQW5FdmVudCA9IF90aGlzJGRvbUV2ZW50cy5kcmFnQW5FdmVudDsgLy8gSWYgdGhlIGRlbGV0ZSBidXR0b24gaXMgYWxyZWFkeSBvdXQgYW5kIGV2ZW50IGlzIG9uIGZvY3VzIHRoZW4gZGVsZXRlIGV2ZW50LlxuXG4gICAgICBpZiAoZm9jdXNBbkV2ZW50Ll9laWQgPT09IHRoaXMuZXZlbnQuX2VpZCAmJiBjbGlja0hvbGRBbkV2ZW50Ll9laWQgPT09IHRoaXMuZXZlbnQuX2VpZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gRm9jdXMgdGhlIGNsaWNrZWQgZXZlbnQuXG5cblxuICAgICAgdGhpcy5mb2N1c0V2ZW50KCk7XG4gICAgICBjbGlja0hvbGRBbkV2ZW50Ll9laWQgPSBudWxsOyAvLyBSZWluaXQgY2xpY2sgaG9sZCBvbiBlYWNoIGNsaWNrLlxuICAgICAgLy8gU2hvdyBldmVudCBkZWxldGUgYnV0dG9uLlxuXG4gICAgICBpZiAodGhpcy52dWVjYWwuZWRpdGFibGVFdmVudHMpIHtcbiAgICAgICAgY2xpY2tIb2xkQW5FdmVudC50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXJlc2l6ZUFuRXZlbnQuX2VpZCAmJiAhZHJhZ0FuRXZlbnQuX2VpZCkge1xuICAgICAgICAgICAgY2xpY2tIb2xkQW5FdmVudC5fZWlkID0gX3RoaXMuZXZlbnQuX2VpZDtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50LmRlbGV0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNsaWNrSG9sZEFuRXZlbnQudGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnZ1ZWNhbC5lbWl0V2l0aEV2ZW50KCdldmVudC1tb3VzZS1lbnRlcicsIHRoaXMuZXZlbnQpO1xuICAgIH0sXG4gICAgb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy52dWVjYWwuZW1pdFdpdGhFdmVudCgnZXZlbnQtbW91c2UtbGVhdmUnLCB0aGlzLmV2ZW50KTtcbiAgICB9LFxuICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgIHRoaXMub25Nb3VzZURvd24oZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy52dWVjYWwub25FdmVudENsaWNrID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy52dWVjYWwub25FdmVudENsaWNrKHRoaXMuZXZlbnQsIGUpO1xuICAgIH0sXG4gICAgb25EYmxDbGljazogZnVuY3Rpb24gb25EYmxDbGljayhlKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudnVlY2FsLm9uRXZlbnREYmxjbGljayA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMudnVlY2FsLm9uRXZlbnREYmxjbGljayh0aGlzLmV2ZW50LCBlKTtcbiAgICB9LFxuICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydChlKSB7XG4gICAgICBldmVudERyYWdTdGFydChlLCB0aGlzLmV2ZW50LCB0aGlzLnZ1ZWNhbCk7XG4gICAgfSxcbiAgICBvbkRyYWdFbmQ6IGZ1bmN0aW9uIG9uRHJhZ0VuZChlKSB7XG4gICAgICBldmVudERyYWdFbmQoZSwgdGhpcy5ldmVudCwgdGhpcy52dWVjYWwpO1xuICAgIH0sXG4gICAgb25EcmFnSGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbiBvbkRyYWdIYW5kbGVNb3VzZURvd24oKSB7XG4gICAgICB0aGlzLmRvbUV2ZW50cy5kcmFnQW5FdmVudC5fZWlkID0gbnVsbDtcbiAgICAgIHRoaXMuZG9tRXZlbnRzLnJlc2l6ZUFuRXZlbnQgPSBPYmplY3QuYXNzaWduKHRoaXMuZG9tRXZlbnRzLnJlc2l6ZUFuRXZlbnQsIHtcbiAgICAgICAgX2VpZDogdGhpcy5ldmVudC5fZWlkLFxuICAgICAgICBzdGFydDogKHRoaXMuc2VnbWVudCB8fCB0aGlzLmV2ZW50KS5zdGFydCxcbiAgICAgICAgc3BsaXQ6IHRoaXMuZXZlbnQuc3BsaXQgfHwgbnVsbCxcbiAgICAgICAgc2VnbWVudDogISF0aGlzLnNlZ21lbnQgJiYgdGhpcy5zZWdtZW50LnN0YXJ0LFxuICAgICAgICBvcmlnaW5hbEVuZFRpbWVNaW51dGVzOiB0aGlzLmV2ZW50LmVuZFRpbWVNaW51dGVzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXZlbnQucmVzaXppbmcgPSB0cnVlO1xuICAgIH0sXG4gICAgZGVsZXRlRXZlbnQ6IGZ1bmN0aW9uIGRlbGV0ZUV2ZW50KCkge1xuICAgICAgdmFyIHRvdWNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIC8vIFByZXZlbnQgYSBkb3VibGUgbW91c2UgZG93biBvbiB0b3VjaCBkZXZpY2VzLlxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhdG91Y2gpIHJldHVybiBmYWxzZTtcbiAgICAgIGRlbGV0ZUFuRXZlbnQodGhpcy5ldmVudCwgdGhpcy52dWVjYWwpO1xuICAgIH0sXG4gICAgdG91Y2hEZWxldGVFdmVudDogZnVuY3Rpb24gdG91Y2hEZWxldGVFdmVudChldmVudCkge1xuICAgICAgdGhpcy5kZWxldGVFdmVudCh0cnVlKTtcbiAgICB9LFxuICAgIGNhbmNlbERlbGV0ZUV2ZW50OiBmdW5jdGlvbiBjYW5jZWxEZWxldGVFdmVudCgpIHtcbiAgICAgIHRoaXMuZXZlbnQuZGVsZXRpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIGZvY3VzRXZlbnQ6IGZ1bmN0aW9uIGZvY3VzRXZlbnQoKSB7XG4gICAgICB2YXIgZm9jdXNBbkV2ZW50ID0gdGhpcy5kb21FdmVudHMuZm9jdXNBbkV2ZW50O1xuICAgICAgdmFyIG9uRm9jdXMgPSBmb2N1c0FuRXZlbnQuX2VpZDtcbiAgICAgIGlmIChvbkZvY3VzID09PSB0aGlzLmV2ZW50Ll9laWQpIHJldHVybjtcbiAgICAgIHRoaXMudnVlY2FsLmVtaXRXaXRoRXZlbnQoJ2V2ZW50LWZvY3VzJywgdGhpcy5ldmVudCk7IC8vIFVuZm9jdXMgcHJldmlvdXMgZXZlbnQgaWYgYW55LlxuXG4gICAgICBpZiAob25Gb2N1cyAmJiBvbkZvY3VzICE9PSB0aGlzLmV2ZW50Ll9laWQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy52dWVjYWwudmlldy5ldmVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLl9laWQgPT09IGZvY3VzQW5FdmVudC5fZWlkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV2ZW50KSBldmVudC5mb2N1c2VkID0gZmFsc2U7XG4gICAgICB9IC8vIENhbmNlbCBkZWxldGUgb24gcHJldmlvdXMgZXZlbnQgaWYgYW55LlxuXG5cbiAgICAgIHRoaXMudnVlY2FsLmNhbmNlbERlbGV0ZSgpO1xuICAgICAgZm9jdXNBbkV2ZW50Ll9laWQgPSB0aGlzLmV2ZW50Ll9laWQ7XG4gICAgICB0aGlzLmV2ZW50LmZvY3VzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBEb24ndCByZWx5IG9uIGdsb2JhbCB2YXJpYWJsZXMgb3RoZXJ3aXNlIHdoZW5ldmVyIGl0IHdvdWxkIGNoYW5nZSBhbGwgdGhlIGV2ZW50cyB3b3VsZCBiZSByZWRyYXduLlxuICAgIGV2ZW50U3R5bGVzOiBmdW5jdGlvbiBldmVudFN0eWxlcygpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50LmFsbERheSB8fCAhdGhpcy52dWVjYWwudGltZSB8fCAhdGhpcy5ldmVudC5lbmRUaW1lTWludXRlcyB8fCB0aGlzLnZ1ZWNhbC52aWV3LmlkID09PSAnbW9udGgnIHx8IHRoaXMuYWxsRGF5KSByZXR1cm4ge307XG4gICAgICB2YXIgd2lkdGggPSAxMDAgLyBNYXRoLm1pbih0aGlzLm92ZXJsYXBzLmxlbmd0aCArIDEsIHRoaXMub3ZlcmxhcHNTdHJlYWspO1xuICAgICAgdmFyIGxlZnQgPSAxMDAgLyAodGhpcy5vdmVybGFwcy5sZW5ndGggKyAxKSAqIHRoaXMuZXZlbnRQb3NpdGlvbjtcblxuICAgICAgaWYgKHRoaXMudnVlY2FsLm1pbkV2ZW50V2lkdGggJiYgd2lkdGggPCB0aGlzLnZ1ZWNhbC5taW5FdmVudFdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy52dWVjYWwubWluRXZlbnRXaWR0aDtcbiAgICAgICAgbGVmdCA9ICgxMDAgLSB0aGlzLnZ1ZWNhbC5taW5FdmVudFdpZHRoKSAvIHRoaXMub3ZlcmxhcHMubGVuZ3RoICogdGhpcy5ldmVudFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IFwiXCIuY29uY2F0KCh0aGlzLnNlZ21lbnQgfHwgdGhpcy5ldmVudCkudG9wLCBcInB4XCIpLFxuICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KCh0aGlzLnNlZ21lbnQgfHwgdGhpcy5ldmVudCkuaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwiJVwiKSxcbiAgICAgICAgbGVmdDogdGhpcy5ldmVudC5sZWZ0ICYmIFwiXCIuY29uY2F0KHRoaXMuZXZlbnQubGVmdCwgXCJweFwiKSB8fCBcIlwiLmNvbmNhdChsZWZ0LCBcIiVcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBEb24ndCByZWx5IG9uIGdsb2JhbCB2YXJpYWJsZXMgb3RoZXJ3aXNlIHdoZW5ldmVyIGl0IHdvdWxkIGNoYW5nZSBhbGwgdGhlIGV2ZW50cyB3b3VsZCBiZSByZWRyYXduLlxuICAgIGV2ZW50Q2xhc3NlczogZnVuY3Rpb24gZXZlbnRDbGFzc2VzKCkge1xuICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICB2YXIgX3JlZiA9IHRoaXMuc2VnbWVudCB8fCB7fSxcbiAgICAgICAgICBpc0ZpcnN0RGF5ID0gX3JlZi5pc0ZpcnN0RGF5LFxuICAgICAgICAgIGlzTGFzdERheSA9IF9yZWYuaXNMYXN0RGF5O1xuXG4gICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCB0aGlzLmV2ZW50LmNsYXNzZXMuam9pbignICcpLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCAndnVlY2FsX19ldmVudC0tZm9jdXMnLCB0aGlzLmV2ZW50LmZvY3VzZWQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsICd2dWVjYWxfX2V2ZW50LS1yZXNpemluZycsIHRoaXMuZXZlbnQucmVzaXppbmcpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjIsICd2dWVjYWxfX2V2ZW50LS1iYWNrZ3JvdW5kJywgdGhpcy5ldmVudC5iYWNrZ3JvdW5kKSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCAndnVlY2FsX19ldmVudC0tZGVsZXRhYmxlJywgdGhpcy5ldmVudC5kZWxldGluZyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ3Z1ZWNhbF9fZXZlbnQtLWFsbC1kYXknLCB0aGlzLmV2ZW50LmFsbERheSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ3Z1ZWNhbF9fZXZlbnQtLWRyYWdnaW5nJywgIXRoaXMuZXZlbnQuZHJhZ2dpbmdTdGF0aWMgJiYgdGhpcy5ldmVudC5kcmFnZ2luZyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ3Z1ZWNhbF9fZXZlbnQtLXN0YXRpYycsIHRoaXMuZXZlbnQuZHJhZ2dpbmcgJiYgdGhpcy5ldmVudC5kcmFnZ2luZ1N0YXRpYyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ3Z1ZWNhbF9fZXZlbnQtLW11bHRpcGxlLWRheXMnLCAhIXRoaXMuc2VnbWVudCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ2V2ZW50LXN0YXJ0JywgdGhpcy5zZWdtZW50ICYmIGlzRmlyc3REYXkgJiYgIWlzTGFzdERheSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMiwgJ2V2ZW50LW1pZGRsZScsIHRoaXMuc2VnbWVudCAmJiAhaXNGaXJzdERheSAmJiAhaXNMYXN0RGF5KSwgX2RlZmluZVByb3BlcnR5KF9yZWYyLCAnZXZlbnQtZW5kJywgdGhpcy5zZWdtZW50ICYmIGlzTGFzdERheSAmJiAhaXNGaXJzdERheSksIF9yZWYyO1xuICAgIH0sXG4gICAgLy8gV2hlbiBtdWx0aXBsZS1kYXkgZXZlbnRzLCBhIHNlZ21lbnQgaXMgYSBwb3J0aW9uIG9mIGV2ZW50IHNwYW5uaW5nIG9uIDEgZGF5LlxuICAgIHNlZ21lbnQ6IGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudC5zZWdtZW50cyAmJiB0aGlzLmV2ZW50LnNlZ21lbnRzW3RoaXMuY2VsbEZvcm1hdHRlZERhdGVdIHx8IG51bGw7XG4gICAgfSxcbiAgICByZXNpemFibGU6IGZ1bmN0aW9uIHJlc2l6YWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZ1ZWNhbC5lZGl0YWJsZUV2ZW50cyAmJiB0aGlzLmV2ZW50LnJlc2l6YWJsZSAmJiB0aGlzLnZ1ZWNhbC50aW1lICYmIHRoaXMuZXZlbnQuZW5kVGltZU1pbnV0ZXMgJiYgIXRoaXMuYWxsRGF5ICYmICghdGhpcy5zZWdtZW50IHx8IHRoaXMuc2VnbWVudCAmJiB0aGlzLnNlZ21lbnQuaXNMYXN0RGF5KSAmJiB0aGlzLnZ1ZWNhbC52aWV3LmlkICE9PSAnbW9udGgnO1xuICAgIH0sXG4gICAgZG9tRXZlbnRzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudnVlY2FsLmRvbUV2ZW50cztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChvYmplY3QpIHtcbiAgICAgICAgdGhpcy52dWVjYWwuZG9tRXZlbnRzID0gb2JqZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZXZlbnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZ1ZV9jYWxfZXZlbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoZXZlbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2V2ZW50LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2NzcyZcbnZhciBldmVudHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZmY1XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvZXZlbnQudnVlXG5cblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBldmVudF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIHZ1ZV9jYWxfZXZlbnR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIGV2ZW50dnVlX3R5cGVfdGVtcGxhdGVfaWRfMTllNGZhNTlfbGFuZ19wdWdfcmVuZGVyLFxuICBldmVudHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzE5ZTRmYTU5X2xhbmdfcHVnX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZ1ZV9jYWxfZXZlbnQgPSAoZXZlbnRfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvY2VsbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNlbGx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBjb21wb25lbnRzOiB7XG4gICAgRXZlbnQ6IHZ1ZV9jYWxfZXZlbnRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAvLyBWdWUtY2FsIG1haW4gY29tcG9uZW50IG9wdGlvbnMgKHByb3BzKS5cbiAgICBvcHRpb25zOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGNlbGxTcGxpdHM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pblRpbWVzdGFtcDoge1xuICAgICAgdHlwZTogW051bWJlciwgbnVsbF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBtYXhUaW1lc3RhbXA6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIG51bGxdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgY2VsbFdpZHRoOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBCb29sZWFuXSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhbGxEYXk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2VsbE92ZXJsYXBzOiB7fSxcbiAgICAgIGNlbGxPdmVybGFwc1N0cmVhazogMSxcbiAgICAgIC8vIExhcmdlc3QgYW1vdW50IG9mIHNpbXVsdGFuZW91cyBldmVudHMgaW4gY2VsbC5cbiAgICAgIC8vIE9uIG1vdXNlIGRvd24sIHNhdmUgdGhlIHRpbWUgYXQgY3Vyc29yIHNvIGl0IGNhbiBiZSByZXVzZWQgb24gY2VsbCBmb2N1cyBldmVudFxuICAgICAgLy8gd2hlcmUgdGhlcmUgaXMgbm8gY3Vyc29yIGNvb3Jkcy5cbiAgICAgIHRpbWVBdEN1cnNvcjogbnVsbCxcbiAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgIC8vIE9uIGV2ZW50IGRyYWcgb3Zlci5cbiAgICAgIGhpZ2hsaWdodGVkU3BsaXQ6IG51bGxcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0U3BsaXRBdEN1cnNvcjogZnVuY3Rpb24gZ2V0U3BsaXRBdEN1cnNvcihET01FdmVudCkge1xuICAgICAgdmFyIHNwbGl0ID0gRE9NRXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndnVlY2FsX19jZWxsLXNwbGl0JykgJiYgRE9NRXZlbnQudGFyZ2V0IHx8IHRoaXMuJHBhcmVudC5maW5kQW5jZXN0b3IoRE9NRXZlbnQudGFyZ2V0LCAndnVlY2FsX19jZWxsLXNwbGl0Jyk7XG4gICAgICByZXR1cm4gc3BsaXQgJiYgc3BsaXQuYXR0cmlidXRlc1snZGF0YS1zcGxpdCddLnZhbHVlIHx8IG51bGw7XG4gICAgfSxcbiAgICBjaGVja0NlbGxPdmVybGFwcGluZ0V2ZW50czogZnVuY3Rpb24gY2hlY2tDZWxsT3ZlcmxhcHBpbmdFdmVudHMoKSB7XG4gICAgICAvLyBJZiBzcGxpdHMsIGNoZWNrQ2VsbE92ZXJsYXBwaW5nRXZlbnRzKCkgaXMgY2FsbGVkIGZyb20gd2l0aGluIGNvbXB1dGVkIHNwbGl0cy5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGltZSAmJiB0aGlzLmV2ZW50c0NvdW50ICYmICF0aGlzLnNwbGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzQ291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmNlbGxPdmVybGFwcyA9IFtdO1xuICAgICAgICAgIHRoaXMuY2VsbE92ZXJsYXBzU3RyZWFrID0gMTtcbiAgICAgICAgfSAvLyBJZiBvbmx5IDEgZXZlbnQgcmVtYWlucyByZS1pbml0IHRoZSBvdmVybGFwcy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2NoZWNrQ2VsbE92ZXJsYXBwaW5nID0gZXZlbnRfdXRpbHNfY2hlY2tDZWxsT3ZlcmxhcHBpbmdFdmVudHModGhpcy5ldmVudHMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciBfY2hlY2tDZWxsT3ZlcmxhcHBpbmcyID0gX3NsaWNlZFRvQXJyYXkoX2NoZWNrQ2VsbE92ZXJsYXBwaW5nLCAyKTtcblxuICAgICAgICAgICAgdGhpcy5jZWxsT3ZlcmxhcHMgPSBfY2hlY2tDZWxsT3ZlcmxhcHBpbmcyWzBdO1xuICAgICAgICAgICAgdGhpcy5jZWxsT3ZlcmxhcHNTdHJlYWsgPSBfY2hlY2tDZWxsT3ZlcmxhcHBpbmcyWzFdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzRE9NRWxlbWVudEFuRXZlbnQ6IGZ1bmN0aW9uIGlzRE9NRWxlbWVudEFuRXZlbnQoZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQuaXNET01FbGVtZW50QW5FdmVudChlbCk7XG4gICAgfSxcbiAgICBzZWxlY3RDZWxsOiBmdW5jdGlvbiBzZWxlY3RDZWxsKERPTUV2ZW50KSB7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHRoaXMub25DZWxsRm9jdXMoRE9NRXZlbnQpOyAvLyBJZiBzcGxpdHRpbmcgZGF5cywgYWxzbyByZXR1cm4gdGhlIGNsaWNrZWQgc3BsaXQgb24gY2VsbCBjbGljayB3aGVuIGVtaXR0aW5nIGV2ZW50LlxuXG4gICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0cy5sZW5ndGggPyB0aGlzLmdldFNwbGl0QXRDdXJzb3IoRE9NRXZlbnQpIDogbnVsbDtcblxuICAgICAgY2VsbF91dGlsc19zZWxlY3RDZWxsKGZvcmNlLCB0aGlzLiRwYXJlbnQsIHRoaXMudGltZUF0Q3Vyc29yLCBzcGxpdCk7XG5cbiAgICAgIHRoaXMudGltZUF0Q3Vyc29yID0gbnVsbDtcbiAgICB9LFxuICAgIG9uQ2VsbGtleVByZXNzRW50ZXI6IGZ1bmN0aW9uIG9uQ2VsbGtleVByZXNzRW50ZXIoRE9NRXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB0aGlzLm9uQ2VsbEZvY3VzKERPTUV2ZW50KTsgLy8gSWYgc3BsaXR0aW5nIGRheXMsIGFsc28gcmV0dXJuIHRoZSBjbGlja2VkIHNwbGl0IG9uIGNlbGwga2V5cHJlc3Mgd2hlbiBlbWl0dGluZyBldmVudC5cblxuICAgICAgdmFyIHNwbGl0ID0gdGhpcy5zcGxpdHMubGVuZ3RoID8gdGhpcy5nZXRTcGxpdEF0Q3Vyc29yKERPTUV2ZW50KSA6IG51bGw7XG4gICAgICBrZXlQcmVzc0VudGVyQ2VsbCh0aGlzLiRwYXJlbnQsIHRoaXMudGltZUF0Q3Vyc29yLCBzcGxpdCk7XG4gICAgICB0aGlzLnRpbWVBdEN1cnNvciA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNlbGwgZm9jdXMsIGZyb20gdGFiIGtleSBvciBmcm9tIGNsaWNrLCBlbWl0IHRoZSBjZWxsLWZvY3VzIGV2ZW50IHdpdGhcbiAgICAgKiB0aGUgZGF0ZSBvZiB0aGUgY2VsbCBzdGFydCB3aGVuIGZvY3VzaW5nIGZyb20gdGFiIG9yIHRoZSBkYXRlICYgdGltZSBhdCBjdXJzb3JcbiAgICAgKiBpZiBjbGljay90b3VjaC5cbiAgICAgKi9cbiAgICBvbkNlbGxGb2N1czogZnVuY3Rpb24gb25DZWxsRm9jdXMoRE9NRXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRoaXMuZGF0YS5zdGFydERhdGU7IC8vIElmIHNwbGl0dGluZyBkYXlzLCBhbHNvIHJldHVybiB0aGUgY2xpY2tlZCBzcGxpdCBvbiBjZWxsIGZvY3VzIHdoZW4gZW1pdHRpbmcgZXZlbnQuXG5cbiAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5zcGxpdHMubGVuZ3RoID8gdGhpcy5nZXRTcGxpdEF0Q3Vyc29yKERPTUV2ZW50KSA6IG51bGw7IC8vIENlbGwtZm9jdXMgZXZlbnQgcmV0dXJucyB0aGUgY2VsbCBzdGFydCBkYXRlIChhdCBtaWRuaWdodCkgaWYgdHJpZ2dlcmVkIGZyb20gdGFiIGtleSxcbiAgICAgICAgLy8gb3IgY3Vyc29yIGNvb3JkcyB0aW1lIGlmIGNsaWNrZWQuXG5cbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLnRpbWVBdEN1cnNvciB8fCB0aGlzLmRhdGEuc3RhcnREYXRlO1xuICAgICAgICB0aGlzLiRwYXJlbnQuJGVtaXQoJ2NlbGwtZm9jdXMnLCBzcGxpdCA/IHtcbiAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgIHNwbGl0OiBzcGxpdFxuICAgICAgICB9IDogZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNlbGxNb3VzZURvd246IGZ1bmN0aW9uIG9uQ2VsbE1vdXNlRG93bihET01FdmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNwbGl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHRvdWNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIC8vIFByZXZlbnQgYSBkb3VibGUgbW91c2UgZG93biBvbiB0b3VjaCBkZXZpY2VzLlxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhdG91Y2gpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBfdGhpcyRkb21FdmVudHMgPSB0aGlzLmRvbUV2ZW50cyxcbiAgICAgICAgICBjbGlja0hvbGRBQ2VsbCA9IF90aGlzJGRvbUV2ZW50cy5jbGlja0hvbGRBQ2VsbCxcbiAgICAgICAgICBmb2N1c0FuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMuZm9jdXNBbkV2ZW50OyAvLyBSZWluaXQgdGhlIGNsaWNrIHRyaWdnZXIgb24gZWFjaCBtb3VzZWRvd24uXG4gICAgICAvLyBJbiBzb21lIGNhc2VzIHdlIGV4cGxpY2l0bHkgc2V0IHRoaXMgZmxhZyB0byBwcmV2ZW50IHRoZSBjbGljayBldmVudCB0byB0cmlnZ2VyLFxuICAgICAgLy8gYW5kIGNhbmNlbCBldmVudCBjcmVhdGlvbi5cblxuICAgICAgdGhpcy5kb21FdmVudHMuY2FuY2VsQ2xpY2tFdmVudENyZWF0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLnRpbWVBdEN1cnNvciA9IG5ldyBEYXRlKHRoaXMuZGF0YS5zdGFydERhdGUpO1xuICAgICAgdGhpcy50aW1lQXRDdXJzb3Iuc2V0TWludXRlcyh0aGlzLiRwYXJlbnQubWludXRlc0F0Q3Vyc29yKERPTUV2ZW50KS5taW51dGVzKTtcbiAgICAgIHZhciBtb3VzZURvd25PbkV2ZW50ID0gdGhpcy5pc0RPTUVsZW1lbnRBbkV2ZW50KERPTUV2ZW50LnRhcmdldCk7IC8vIFVuZm9jdXMgYW4gZXZlbnQgaWYgYW55IGlzIGZvY3VzZWQgYW5kIGNsaWNraW5nIG9uIGNlbGwgb3V0c2lkZSBvZiBhbiBldmVudC5cblxuICAgICAgaWYgKCFtb3VzZURvd25PbkV2ZW50ICYmIGZvY3VzQW5FdmVudC5fZWlkKSB7XG4gICAgICAgICh0aGlzLiRwYXJlbnQudmlldy5ldmVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLl9laWQgPT09IGZvY3VzQW5FdmVudC5fZWlkO1xuICAgICAgICB9KSB8fCB7fSkuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgfSAvLyBJZiB0aGUgY2VsbENsaWNrSG9sZCBvcHRpb24gaXMgdHJ1ZSBhbmQgbm90IG1vdXNlZG93biBvbiBhbiBldmVudCwgY2xpY2sgJiBob2xkIHRvIGNyZWF0ZSBhbiBldmVudC5cblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlRXZlbnRzICYmIHRoaXMub3B0aW9ucy5jZWxsQ2xpY2tIb2xkICYmICFtb3VzZURvd25PbkV2ZW50ICYmIFsnbW9udGgnLCAnd2VlaycsICdkYXknXS5pbmNsdWRlcyh0aGlzLnZpZXcpKSB7XG4gICAgICAgIGNsaWNrSG9sZEFDZWxsLmNlbGxJZCA9IFwiXCIuY29uY2F0KHRoaXMuJHBhcmVudC5fdWlkLCBcIl9cIikuY29uY2F0KHRoaXMuZGF0YS5mb3JtYXR0ZWREYXRlKTtcbiAgICAgICAgY2xpY2tIb2xkQUNlbGwuc3BsaXQgPSBzcGxpdDtcbiAgICAgICAgY2xpY2tIb2xkQUNlbGwudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNsaWNrSG9sZEFDZWxsLmNlbGxJZCAmJiAhX3RoaXMuZG9tRXZlbnRzLmNhbmNlbENsaWNrRXZlbnRDcmVhdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuJHBhcmVudC5jcmVhdGVFdmVudChfdGhpcy50aW1lQXRDdXJzb3IsIGNsaWNrSG9sZEFDZWxsLnNwbGl0ID8ge1xuICAgICAgICAgICAgICBzcGxpdDogY2xpY2tIb2xkQUNlbGwuc3BsaXRcbiAgICAgICAgICAgIH0gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjbGlja0hvbGRBQ2VsbC50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2VsbFRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uQ2VsbFRvdWNoU3RhcnQoRE9NRXZlbnQpIHtcbiAgICAgIHZhciBzcGxpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIC8vIElmIG5vdCBtb3VzZWRvd24gb24gYW4gZXZlbnQuXG4gICAgICB0aGlzLm9uQ2VsbE1vdXNlRG93bihET01FdmVudCwgc3BsaXQsIHRydWUpO1xuICAgIH0sXG4gICAgb25DZWxsRGJsQ2xpY2s6IGZ1bmN0aW9uIG9uQ2VsbERibENsaWNrKERPTUV2ZW50KSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0YS5zdGFydERhdGUpO1xuICAgICAgZGF0ZS5zZXRNaW51dGVzKHRoaXMuJHBhcmVudC5taW51dGVzQXRDdXJzb3IoRE9NRXZlbnQpLm1pbnV0ZXMpOyAvLyBJZiBzcGxpdHRpbmcgZGF5cywgYWxzbyByZXR1cm4gdGhlIGNsaWNrZWQgc3BsaXQgb24gY2VsbCBkYmxjbGljayB3aGVuIGVtaXR0aW5nIGV2ZW50LlxuXG4gICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0cy5sZW5ndGggPyB0aGlzLmdldFNwbGl0QXRDdXJzb3IoRE9NRXZlbnQpIDogbnVsbDtcbiAgICAgIHRoaXMuJHBhcmVudC4kZW1pdCgnY2VsbC1kYmxjbGljaycsIHNwbGl0ID8ge1xuICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICBzcGxpdDogc3BsaXRcbiAgICAgIH0gOiBkYXRlKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGJsY2xpY2tUb05hdmlnYXRlKSB0aGlzLiRwYXJlbnQuc3dpdGNoVG9OYXJyb3dlclZpZXcoKTtcbiAgICB9LFxuICAgIG9uQ2VsbENvbnRleHRNZW51OiBmdW5jdGlvbiBvbkNlbGxDb250ZXh0TWVudShET01FdmVudCkge1xuICAgICAgRE9NRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBET01FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGEuc3RhcnREYXRlKTtcblxuICAgICAgdmFyIF90aGlzJCRwYXJlbnQkbWludXRlcyA9IHRoaXMuJHBhcmVudC5taW51dGVzQXRDdXJzb3IoRE9NRXZlbnQpLFxuICAgICAgICAgIGN1cnNvckNvb3JkcyA9IF90aGlzJCRwYXJlbnQkbWludXRlcy5jdXJzb3JDb29yZHMsXG4gICAgICAgICAgbWludXRlcyA9IF90aGlzJCRwYXJlbnQkbWludXRlcy5taW51dGVzO1xuXG4gICAgICBkYXRlLnNldE1pbnV0ZXMobWludXRlcyk7IC8vIElmIHNwbGl0dGluZyBkYXlzLCBhbHNvIHJldHVybiB0aGUgY2xpY2tlZCBzcGxpdCBvbiBjZWxsIGNvbnRleHRtZW51IHdoZW4gZW1pdHRpbmcgZXZlbnQuXG5cbiAgICAgIHZhciBzcGxpdCA9IHRoaXMuc3BsaXRzLmxlbmd0aCA/IHRoaXMuZ2V0U3BsaXRBdEN1cnNvcihET01FdmVudCkgOiBudWxsO1xuICAgICAgdGhpcy4kcGFyZW50LiRlbWl0KCdjZWxsLWNvbnRleHRtZW51JywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBkYXRlOiBkYXRlXG4gICAgICB9LCBjdXJzb3JDb29yZHMsIHt9LCBzcGxpdCB8fCB7fSkpO1xuICAgIH0sXG4gICAgY2VsbERyYWdPdmVyOiBjZWxsRHJhZ092ZXIsXG4gICAgY2VsbERyYWdFbnRlcjogY2VsbERyYWdFbnRlcixcbiAgICBjZWxsRHJhZ0xlYXZlOiBjZWxsRHJhZ0xlYXZlLFxuICAgIGNlbGxEcmFnRHJvcDogZHJhZ19hbmRfZHJvcF9jZWxsRHJhZ0Ryb3BcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBub3dJbk1pbnV0ZXM6IGZ1bmN0aW9uIG5vd0luTWludXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQubm93LmdldEhvdXJzKCkgKiA2MCArIHRoaXMuJHBhcmVudC5ub3cuZ2V0TWludXRlcygpO1xuICAgIH0sXG4gICAgaXNCZWZvcmVNaW5EYXRlOiBmdW5jdGlvbiBpc0JlZm9yZU1pbkRhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5UaW1lc3RhbXAgIT09IG51bGwgJiYgdGhpcy5taW5UaW1lc3RhbXAgPiB0aGlzLmRhdGEuZW5kRGF0ZS5nZXRUaW1lKCk7XG4gICAgfSxcbiAgICBpc0FmdGVyTWF4RGF0ZTogZnVuY3Rpb24gaXNBZnRlck1heERhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXhUaW1lc3RhbXAgJiYgdGhpcy5tYXhUaW1lc3RhbXAgPCB0aGlzLmRhdGEuc3RhcnREYXRlLmdldFRpbWUoKTtcbiAgICB9LFxuICAgIC8vIElzIHRoZSBjdXJyZW50IGNlbGwgZGlzYWJsZWQgb3Igbm90LlxuICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0JlZm9yZU1pbkRhdGUgfHwgdGhpcy5pc0FmdGVyTWF4RGF0ZTtcbiAgICB9LFxuICAgIC8vIElzIHRoZSBjdXJyZW50IGNlbGwgc2VsZWN0ZWQgb3Igbm90LlxuICAgIGlzU2VsZWN0ZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IHRoaXMuJHBhcmVudC52aWV3LnNlbGVjdGVkRGF0ZTtcblxuICAgICAgICBpZiAodGhpcy52aWV3ID09PSAneWVhcnMnKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdGhpcy5kYXRhLnN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlldyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdGhpcy5kYXRhLnN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpICYmIHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpID09PSB0aGlzLmRhdGEuc3RhcnREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIH0gZWxzZSBzZWxlY3RlZCA9IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPT09IHRoaXMuZGF0YS5zdGFydERhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkYXRlKSB7XG4gICAgICAgIHRoaXMuJHBhcmVudC52aWV3LnNlbGVjdGVkRGF0ZSA9IGRhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb21FdmVudHM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcGFyZW50LmRvbUV2ZW50cztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChvYmplY3QpIHtcbiAgICAgICAgdGhpcy4kcGFyZW50LmRvbUV2ZW50cyA9IG9iamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHRzOiBmdW5jdGlvbiB0ZXh0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQudGV4dHM7XG4gICAgfSxcbiAgICB2aWV3OiBmdW5jdGlvbiB2aWV3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC52aWV3LmlkO1xuICAgIH0sXG4gICAgLy8gQ2FjaGUgcmVzdWx0IGZvciBwZXJmb3JtYW5jZS5cbiAgICBpc1dlZWtPckRheVZpZXc6IGZ1bmN0aW9uIGlzV2Vla09yRGF5VmlldygpIHtcbiAgICAgIHJldHVybiBbJ3dlZWsnLCAnZGF5J10uaW5jbHVkZXModGhpcy52aWV3KTtcbiAgICB9LFxuICAgIHRyYW5zaXRpb25EaXJlY3Rpb246IGZ1bmN0aW9uIHRyYW5zaXRpb25EaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcGFyZW50LnRyYW5zaXRpb25EaXJlY3Rpb247XG4gICAgfSxcbiAgICBzcGVjaWFsSG91cnM6IGZ1bmN0aW9uIHNwZWNpYWxIb3VycygpIHtcbiAgICAgIHZhciBfdGhpcyRkYXRhJHNwZWNpYWxIb3UgPSB0aGlzLmRhdGEuc3BlY2lhbEhvdXJzLFxuICAgICAgICAgIGZyb20gPSBfdGhpcyRkYXRhJHNwZWNpYWxIb3UuZnJvbSxcbiAgICAgICAgICB0byA9IF90aGlzJGRhdGEkc3BlY2lhbEhvdS50bztcbiAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCB0aGlzLm9wdGlvbnMudGltZUZyb20pO1xuICAgICAgdG8gPSBNYXRoLm1pbih0bywgdGhpcy5vcHRpb25zLnRpbWVUbyk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuZGF0YS5zcGVjaWFsSG91cnMsIHtcbiAgICAgICAgaGVpZ2h0OiAodG8gLSBmcm9tKSAqIHRoaXMudGltZVNjYWxlLFxuICAgICAgICB0b3A6IChmcm9tIC0gdGhpcy5vcHRpb25zLnRpbWVGcm9tKSAqIHRoaXMudGltZVNjYWxlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV2ZW50czogZnVuY3Rpb24gZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgIGNlbGxTdGFydCA9IF90aGlzJGRhdGEuc3RhcnREYXRlLFxuICAgICAgICAgIGNlbGxFbmQgPSBfdGhpcyRkYXRhLmVuZERhdGU7XG4gICAgICB2YXIgZXZlbnRzID0gW107IC8vIENhbGN1bGF0ZSBldmVudHMgb24gbW9udGgvd2Vlay9kYXkgdmlld3Mgb3IgeWVhcnMveWVhciBpZiBldmVudHNDb3VudE9uWWVhclZpZXcuXG5cbiAgICAgIGlmICghKFsneWVhcnMnLCAneWVhciddLmluY2x1ZGVzKHRoaXMudmlldykgJiYgIXRoaXMub3B0aW9ucy5ldmVudHNDb3VudE9uWWVhclZpZXcpKSB7XG4gICAgICAgIC8vIE1lYW5zIHRoYXQgd2hlbiAkcGFyZW50LnZpZXcuZXZlbnRzIGNoYW5nZXMgYWxsIHRoZSBjZWxscyB3aWxsIGJlIGxvb2tpbmcgdXAgbmV3IHZhbHVlLiA6L1xuICAgICAgICAvLyBBbHNvIGNsb25lIGFycmF5IHRvIHByZXZlbnQgbW9kaWZ5aW5nIG9yaWdpbmFsLlxuICAgICAgICBldmVudHMgPSB0aGlzLiRwYXJlbnQudmlldy5ldmVudHMuc2xpY2UoMCk7XG5cbiAgICAgICAgaWYgKHRoaXMudmlldyA9PT0gJ21vbnRoJykge1xuICAgICAgICAgIHZhciBfZXZlbnRzO1xuXG4gICAgICAgICAgKF9ldmVudHMgPSBldmVudHMpLnB1c2guYXBwbHkoX2V2ZW50cywgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuJHBhcmVudC52aWV3Lm91dE9mU2NvcGVFdmVudHMpKTtcbiAgICAgICAgfSAvLyBPbmx5IGtlZXAgZXZlbnRzIGluIGNlbGwgdGltZSByYW5nZS5cblxuXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnRJblJhbmdlKGUsIGNlbGxTdGFydCwgY2VsbEVuZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dBbGxEYXlFdmVudHMgJiYgdGhpcy52aWV3ICE9PSAnbW9udGgnKSBldmVudHMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuICEhZS5hbGxEYXkgPT09IF90aGlzMi5hbGxEYXk7XG4gICAgICAgIH0pOyAvLyBGcm9tIGV2ZW50cyBpbiB2aWV3LCBmaWx0ZXIgdGhlIG9uZXMgdGhhdCBhcmUgb3V0IG9mIGB0aW1lLWZyb21gLWB0aW1lLXRvYCByYW5nZSBpbiB0aGlzIGNlbGwuXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aW1lICYmIHRoaXMuaXNXZWVrT3JEYXlWaWV3ICYmICF0aGlzLmFsbERheSkge1xuICAgICAgICAgIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICB0aW1lRnJvbSA9IF90aGlzJG9wdGlvbnMudGltZUZyb20sXG4gICAgICAgICAgICAgIHRpbWVUbyA9IF90aGlzJG9wdGlvbnMudGltZVRvO1xuICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZS5kYXlzQ291bnQgPiAxICYmIGUuc2VnbWVudHNbX3RoaXMyLmRhdGEuZm9ybWF0dGVkRGF0ZV0gfHwge307XG4gICAgICAgICAgICB2YXIgc2luZ2xlRGF5SW5SYW5nZSA9IGUuZGF5c0NvdW50ID09PSAxICYmIGUuc3RhcnRUaW1lTWludXRlcyA8IHRpbWVUbyAmJiBlLmVuZFRpbWVNaW51dGVzID4gdGltZUZyb207XG4gICAgICAgICAgICB2YXIgbXVsdGlwbGVEYXlJblJhbmdlID0gZS5kYXlzQ291bnQgPiAxICYmIHNlZ21lbnQuc3RhcnRUaW1lTWludXRlcyA8IHRpbWVUbyAmJiBzZWdtZW50LmVuZFRpbWVNaW51dGVzID4gdGltZUZyb207XG4gICAgICAgICAgICB2YXIgcmVjdXJyTXVsdERheUluUmFuZ2UgPSBmYWxzZTsgLy8gZS5kYXlzQ291bnQgPiAxICYmIGUucmVwZWF0ICYmIHJlY3VycmluZ0V2ZW50SW5SYW5nZShlLCBjZWxsU3RhcnQsIGNlbGxFbmQpXG5cbiAgICAgICAgICAgIHJldHVybiBlLmFsbERheSB8fCBzaW5nbGVEYXlJblJhbmdlIHx8IG11bHRpcGxlRGF5SW5SYW5nZSB8fCByZWN1cnJNdWx0RGF5SW5SYW5nZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBQb3NpdGlvbiBldmVudHMgd2l0aCB0aW1lIGluIHRoZSB0aW1lbGluZSB3aGVuIHRoZXJlIGlzIGEgdGltZWxpbmUgYW5kIG5vdCBpbiBhbGxEYXkgc2xvdC5cblxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGltZSAmJiB0aGlzLmlzV2Vla09yRGF5VmlldyAmJiAhKHRoaXMub3B0aW9ucy5zaG93QWxsRGF5RXZlbnRzICYmIHRoaXMuYWxsRGF5KSkge1xuICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gYWxsLWRheSBldmVudHMgYXJlIHBvc2l0aW9ubmVkIHZpYSBjc3M6IHRvcC0wICYgYm90dG9tLTAuXG4gICAgICAgICAgICAvLyBTbyB0aGV5IGJlaGF2ZSBhcyBiYWNrZ3JvdW5kIGV2ZW50cyBpZiBub3QgaW4gYWxsRGF5IHNsb3QuXG4gICAgICAgICAgICAvLyBAdG9kbzogRG8gd2Ugd2FudCB0aGlzIG9yIG5vdD9cbiAgICAgICAgICAgIHZhciBldmVudFRvVXBkYXRlID0gZXZlbnQuc2VnbWVudHMgJiYgZXZlbnQuc2VnbWVudHNbX3RoaXMyLmRhdGEuZm9ybWF0dGVkRGF0ZV0gfHwgZXZlbnQ7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnN0YXJ0VGltZU1pbnV0ZXMgfHwgZXZlbnQuZW5kVGltZU1pbnV0ZXMpICYmICFldmVudC5hbGxEYXkpIHVwZGF0ZUV2ZW50UG9zaXRpb24oZXZlbnRUb1VwZGF0ZSwgX3RoaXMyLiRwYXJlbnQpO1xuICAgICAgICAgIH0pOyAvLyBTb3J0IGV2ZW50cyBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuXG4gICAgICAgICAgZXZlbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IDwgYi5zdGFydCA/IC0xIDogMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBJZiBzcGxpdHMsIGNoZWNrQ2VsbE92ZXJsYXBwaW5nRXZlbnRzKCkgaXMgY2FsbGVkIGZyb20gd2l0aGluIGNvbXB1dGVkIHNwbGl0cy5cblxuXG4gICAgICAgIGlmICghdGhpcy5jZWxsU3BsaXRzLmxlbmd0aCkgdGhpcy4kbmV4dFRpY2sodGhpcy5jaGVja0NlbGxPdmVybGFwcGluZ0V2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSxcbiAgICBldmVudHNDb3VudDogZnVuY3Rpb24gZXZlbnRzQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoO1xuICAgIH0sXG4gICAgc3BsaXRzOiBmdW5jdGlvbiBzcGxpdHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuY2VsbFNwbGl0cy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IF90aGlzMy5ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuc3BsaXQgPT09IGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfY2hlY2tDZWxsT3ZlcmxhcHBpbmczID0gZXZlbnRfdXRpbHNfY2hlY2tDZWxsT3ZlcmxhcHBpbmdFdmVudHMoZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiAhZS5iYWNrZ3JvdW5kICYmICFlLmFsbERheTtcbiAgICAgICAgfSksIF90aGlzMy5vcHRpb25zKSxcbiAgICAgICAgICAgIF9jaGVja0NlbGxPdmVybGFwcGluZzQgPSBfc2xpY2VkVG9BcnJheShfY2hlY2tDZWxsT3ZlcmxhcHBpbmczLCAyKSxcbiAgICAgICAgICAgIG92ZXJsYXBzID0gX2NoZWNrQ2VsbE92ZXJsYXBwaW5nNFswXSxcbiAgICAgICAgICAgIHN0cmVhayA9IF9jaGVja0NlbGxPdmVybGFwcGluZzRbMV07XG5cbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBpdGVtLCB7XG4gICAgICAgICAgb3ZlcmxhcHM6IG92ZXJsYXBzLFxuICAgICAgICAgIG92ZXJsYXBzU3RyZWFrOiBzdHJlYWssXG4gICAgICAgICAgZXZlbnRzOiBldmVudHNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNzc0NsYXNzZXM6IGZ1bmN0aW9uIGNzc0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAndnVlY2FsX19jZWxsLS1jdXJyZW50JzogdGhpcy5kYXRhLmN1cnJlbnQsXG4gICAgICAgIC8vIEUuZy4gQ3VycmVudCB5ZWFyIGluIHllYXJzIHZpZXcuXG4gICAgICAgICd2dWVjYWxfX2NlbGwtLXRvZGF5JzogdGhpcy5kYXRhLnRvZGF5LFxuICAgICAgICAndnVlY2FsX19jZWxsLS1vdXQtb2Ytc2NvcGUnOiB0aGlzLmRhdGEub3V0T2ZTY29wZSxcbiAgICAgICAgJ3Z1ZWNhbF9fY2VsbC0tYmVmb3JlLW1pbic6IHRoaXMuaXNEaXNhYmxlZCAmJiB0aGlzLmlzQmVmb3JlTWluRGF0ZSxcbiAgICAgICAgJ3Z1ZWNhbF9fY2VsbC0tYWZ0ZXItbWF4JzogdGhpcy5pc0Rpc2FibGVkICYmIHRoaXMuaXNBZnRlck1heERhdGUsXG4gICAgICAgICd2dWVjYWxfX2NlbGwtLWRpc2FibGVkJzogdGhpcy5pc0Rpc2FibGVkLFxuICAgICAgICAndnVlY2FsX19jZWxsLS1zZWxlY3RlZCc6IHRoaXMuaXNTZWxlY3RlZCxcbiAgICAgICAgJ3Z1ZWNhbF9fY2VsbC0taGlnaGxpZ2h0ZWQnOiB0aGlzLmhpZ2hsaWdodGVkLFxuICAgICAgICAndnVlY2FsX19jZWxsLS1oYXMtc3BsaXRzJzogdGhpcy5zcGxpdHMubGVuZ3RoLFxuICAgICAgICAndnVlY2FsX19jZWxsLS1oYXMtZXZlbnRzJzogdGhpcy5ldmVudHNDb3VudFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNlbGxTdHlsZXM6IGZ1bmN0aW9uIGNlbGxTdHlsZXMoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuY2VsbFdpZHRoID8ge1xuICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQodGhpcy5jZWxsV2lkdGgsIFwiJVwiKVxuICAgICAgfSA6IHt9KTtcbiAgICB9LFxuICAgIHRpbWVsaW5lVmlzaWJsZTogZnVuY3Rpb24gdGltZWxpbmVWaXNpYmxlKCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGEudG9kYXkgfHwgIXRoaXMub3B0aW9ucy50aW1lIHx8IHRoaXMuYWxsRGF5IHx8ICF0aGlzLmlzV2Vla09yRGF5VmlldykgcmV0dXJuO1xuICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC5ub3cuZ2V0SG91cnMoKSAqIDYwICsgdGhpcy4kcGFyZW50Lm5vdy5nZXRNaW51dGVzKCkgPD0gdGhpcy5vcHRpb25zLnRpbWVUbztcbiAgICB9LFxuICAgIHRvZGF5c1RpbWVQb3NpdGlvbjogZnVuY3Rpb24gdG9kYXlzVGltZVBvc2l0aW9uKCkge1xuICAgICAgLy8gU2tpcCB0aGUgTWF0aHMgaWYgbm90IHJlbGV2YW50LlxuICAgICAgaWYgKCF0aGlzLmRhdGEudG9kYXkgfHwgIXRoaXMub3B0aW9ucy50aW1lKSByZXR1cm47XG4gICAgICB2YXIgc3RhcnRUaW1lTWludXRlcyA9IHRoaXMuJHBhcmVudC5ub3cuZ2V0SG91cnMoKSAqIDYwICsgdGhpcy4kcGFyZW50Lm5vdy5nZXRNaW51dGVzKCk7XG4gICAgICB2YXIgbWludXRlc0Zyb21Ub3AgPSBzdGFydFRpbWVNaW51dGVzIC0gdGhpcy5vcHRpb25zLnRpbWVGcm9tO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobWludXRlc0Zyb21Ub3AgKiB0aGlzLnRpbWVTY2FsZSk7XG4gICAgfSxcbiAgICB0aW1lU2NhbGU6IGZ1bmN0aW9uIHRpbWVTY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGltZUNlbGxIZWlnaHQgLyB0aGlzLm9wdGlvbnMudGltZVN0ZXA7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9jZWxsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2dWVfY2FsX2NlbGx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoY2VsbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvY2VsbC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXG52YXIgY2VsbHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDExXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Z1ZS1jYWwvY2VsbC52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGNlbGxfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICB2dWVfY2FsX2NlbGx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIGNlbGx2dWVfdHlwZV90ZW1wbGF0ZV9pZF83NDc1ZjJmMF9sYW5nX3B1Z19yZW5kZXIsXG4gIGNlbGx2dWVfdHlwZV90ZW1wbGF0ZV9pZF83NDc1ZjJmMF9sYW5nX3B1Z19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2dWVfY2FsX2NlbGwgPSAoY2VsbF9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9zdHlsZXMuc2Nzc1xudmFyIHN0eWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMGFhXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvdnVlLWNhbC9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG5cbnZhciB2dWVfY2FsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfbWludXRlc0luQURheSA9IDI0ICogNjA7IC8vIERvbid0IGRvIHRoZSBtYXRocyBldmVyeSB0aW1lLlxuXG52YXIgdGV4dHNEZWZhdWx0cyA9IHtcbiAgd2Vla0RheXM6IEFycmF5KDcpLmZpbGwoJycpLFxuICB3ZWVrRGF5c1Nob3J0OiBbXSxcbiAgbW9udGhzOiBBcnJheSgxMikuZmlsbCgnJyksXG4gIHllYXJzOiAnJyxcbiAgeWVhcjogJycsXG4gIG1vbnRoOiAnJyxcbiAgd2VlazogJycsXG4gIGRheTogJycsXG4gIHRvZGF5OiAnJyxcbiAgbm9FdmVudDogJycsXG4gIGFsbERheTogJycsXG4gIGRlbGV0ZUV2ZW50OiAnJyxcbiAgY3JlYXRlRXZlbnQ6ICcnLFxuICBkYXRlRm9ybWF0OiAnZGRkZCBNTU1NIEQsIFlZWVknLFxuICBhbTogJ2FtJyxcbiAgcG06ICdwbSdcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2dWVfY2FsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ3Z1ZS1jYWwnLFxuICBjb21wb25lbnRzOiB7XG4gICAgJ3Z1ZWNhbC1jZWxsJzogdnVlX2NhbF9jZWxsLFxuICAgICd2dWVjYWwtaGVhZGVyJzogaGVhZGVyLFxuICAgIFdlZWtkYXlzSGVhZGluZ3M6IHdlZWtkYXlzX2hlYWRpbmdzXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2VsbENsaWNrSG9sZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGNlbGxDb250ZXh0bWVudToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjbGlja1RvTmF2aWdhdGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGJsY2xpY2tUb05hdmlnYXRlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgZGVmYXVsdFZpZXc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICd3ZWVrJ1xuICAgIH0sXG4gICAgZGlzYWJsZVZpZXdzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBlZGl0YWJsZUV2ZW50czoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50c0NvdW50T25ZZWFyVmlldzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBldmVudHNPbk1vbnRoVmlldzoge1xuICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGlkZUJvZHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGlkZVRpdGxlQmFyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhpZGVWaWV3U2VsZWN0b3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaGlkZVdlZWtkYXlzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlV2Vla2VuZHM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbG9jYWxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZW4nXG4gICAgfSxcbiAgICBtYXhEYXRlOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBEYXRlXSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBtaW5DZWxsV2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG1pbkRhdGU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIERhdGVdLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIG1pbkV2ZW50V2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG1pblNwbGl0V2lkdGg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG9uRXZlbnRDbGljazoge1xuICAgICAgdHlwZTogW0Z1bmN0aW9uLCBudWxsXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG9uRXZlbnRDcmVhdGU6IHtcbiAgICAgIHR5cGU6IFtGdW5jdGlvbiwgbnVsbF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBvbkV2ZW50RGJsY2xpY2s6IHtcbiAgICAgIHR5cGU6IFtGdW5jdGlvbiwgbnVsbF0sXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBvdmVybGFwc1BlclRpbWVTdGVwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJlc2l6ZVg6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2VsZWN0ZWREYXRlOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBEYXRlXSxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBzaG93QWxsRGF5RXZlbnRzOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzaG93V2Vla051bWJlcnM6IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNuYXBUb1RpbWU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIHNtYWxsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNwZWNpYWxIb3Vyczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwbGl0RGF5czoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnRXZWVrT25TdW5kYXk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc3RpY2t5U3BsaXRMYWJlbHM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIHRpbWVDZWxsSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiA0MFxuICAgIH0sXG4gICAgLy8gSW4gcGl4ZWxzLlxuICAgIHRpbWVGb3JtYXQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICB0aW1lRnJvbToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgLy8gSW4gbWludXRlcy5cbiAgICB0aW1lU3RlcDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogNjBcbiAgICB9LFxuICAgIC8vIEluIG1pbnV0ZXMuXG4gICAgdGltZVRvOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiB2dWVfY2FsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfbWludXRlc0luQURheVxuICAgIH0sXG4gICAgLy8gSW4gbWludXRlcy5cbiAgICB0b2RheUJ1dHRvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIHR3ZWx2ZUhvdXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgd2F0Y2hSZWFsVGltZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBFeHBlbnNpdmUsIHNvIG9ubHkgdHJpZ2dlciBvbiBkZW1hbmQuXG4gICAgeHNtYWxsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIE1ha2UgdGV4dHMgcmVhY3RpdmUgYmVmb3JlIGEgbG9jYWxlIGlzIGxvYWRlZC5cbiAgICAgIHRleHRzOiBfb2JqZWN0U3ByZWFkMih7fSwgdGV4dHNEZWZhdWx0cyksXG4gICAgICByZWFkeTogZmFsc2UsXG4gICAgICAvLyBJcyB2dWUtY2FsIHJlYWR5LlxuICAgICAgLy8gQXQgYW55IHRpbWUgdGhpcyBvYmplY3Qgd2lsbCBiZSBmaWxsZWQgd2l0aCBjdXJyZW50IHZpZXcsIHZpc2libGUgZXZlbnRzIGFuZCBzZWxlY3RlZCBkYXRlLlxuICAgICAgdmlldzoge1xuICAgICAgICBpZDogJycsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICAgICAgc3RhcnREYXRlOiBudWxsLFxuICAgICAgICBlbmREYXRlOiBudWxsLFxuICAgICAgICBmaXJzdENlbGxEYXRlOiBudWxsLFxuICAgICAgICBsYXN0Q2VsbERhdGU6IG51bGwsXG4gICAgICAgIHNlbGVjdGVkRGF0ZTogbnVsbCxcbiAgICAgICAgLy8gQWxsIHRoZSBldmVudHMgYXJlIHN0b3JlZCBpbiB0aGUgbXV0YWJsZUV2ZW50cyBhcnJheSwgYnV0IHN1YnNldCBvZiB2aXNpYmxlIG9uZXMgYXJlIHBhc3NlZFxuICAgICAgICAvLyBJbnRvIHRoZSBjdXJyZW50IHZpZXcgZm9yIGZhc3QgbG9va3VwIGFuZCBtYW5pcHVsYXRpb24uXG4gICAgICAgIGV2ZW50czogW11cbiAgICAgIH0sXG4gICAgICBldmVudElkSW5jcmVtZW50OiAxLFxuICAgICAgLy8gSW50ZXJuYWwgdW5pcXVlIGlkLlxuICAgICAgLy8gUHJlc2V0IGF0IG5vdyBkYXRlIG9uIGxvYWQsIGJ1dCB1cGRhdGVkIGV2ZXJ5IG1pbnV0ZSBpZiB3YXRjaFJlYWxUaW1lLFxuICAgICAgLy8gb3IgdXBkYXRlZCBhdCBsZWFzdCBvbiBlYWNoIGNlbGxzIHJlcmVuZGVyLCBpbiBvcmRlciB0byBrZWVwIFRvZGF5J3MgZGF0ZSBhY2N1cmF0ZS5cbiAgICAgIG5vdzogbmV3IERhdGUoKSxcbiAgICAgIC8vIFVzZWZ1bCB3aGVuIHdhdGNoUmVhbFRpbWUgPSB0cnVlLCAyIHRpbWVvdXRzOiAxIHRvIHNuYXAgdG8gcm91bmQgbWludXRlcywgdGhlbiAxIGV2ZXJ5IG1pbnV0ZS5cbiAgICAgIHRpbWVUaWNrZXJJZHM6IFtudWxsLCBudWxsXSxcbiAgICAgIC8vIEFsbCB0aGUgcG9zc2libGUgZXZlbnRzL2NlbGxzIGludGVycmFjdGlvbnM6XG4gICAgICAvLyBlLmcuIGZvY3VzLCBjbGljaywgY2xpY2sgJiBob2xkLCByZXNpemUsIGRyYWcgJiBkcm9wIChjb21pbmcpLlxuICAgICAgZG9tRXZlbnRzOiB7XG4gICAgICAgIHJlc2l6ZUFuRXZlbnQ6IHtcbiAgICAgICAgICBfZWlkOiBudWxsLFxuICAgICAgICAgIC8vIE9ubHkgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICBzcGxpdDogbnVsbCxcbiAgICAgICAgICBzZWdtZW50OiBudWxsLFxuICAgICAgICAgIG9yaWdpbmFsRW5kVGltZU1pbnV0ZXM6IDAsXG4gICAgICAgICAgZW5kVGltZU1pbnV0ZXM6IDAsXG4gICAgICAgICAgc3RhcnRDZWxsOiBudWxsLFxuICAgICAgICAgIGVuZENlbGw6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ0FuRXZlbnQ6IHtcbiAgICAgICAgICBfZWlkOiBudWxsLFxuICAgICAgICAgIC8vIE9ubHkgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICBjdXJzb3JHcmFiQXQ6IDAgLy8gVGhlIGN1cnNvciBwb3NpdGlvbiAoaW4gbWludXRlcykgaW4gdGhlIGV2ZW50LlxuXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzQW5FdmVudDoge1xuICAgICAgICAgIF9laWQ6IG51bGwgLy8gT25seSBvbmUgYXQgYSB0aW1lLlxuXG4gICAgICAgIH0sXG4gICAgICAgIGNsaWNrSG9sZEFuRXZlbnQ6IHtcbiAgICAgICAgICBfZWlkOiBudWxsLFxuICAgICAgICAgIC8vIE9ubHkgb25lIGF0IGEgdGltZS5cbiAgICAgICAgICB0aW1lb3V0OiAxMjAwLFxuICAgICAgICAgIC8vIEhvbGQgZm9yIDEuMnMgdG8gZGVsZXRlIGFuIGV2ZW50LlxuICAgICAgICAgIHRpbWVvdXRJZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBkYmxUYXBBQ2VsbDoge1xuICAgICAgICAgIHRhcHM6IDAsXG4gICAgICAgICAgdGltZW91dDogNTAwIC8vIEFsbG93ZWQgbGF0ZW5jeSBiZXR3ZWVuIGZpcnN0IGFuZCBzZWNvbmQgY2xpY2suXG5cbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tIb2xkQUNlbGw6IHtcbiAgICAgICAgICBjZWxsSWQ6IG51bGwsXG4gICAgICAgICAgc3BsaXQ6IG51bGwsXG4gICAgICAgICAgdGltZW91dDogMTIwMCxcbiAgICAgICAgICAvLyBIb2xkIGZvciAxLjJzIHRvIGNyZWF0ZSBhbiBldmVudC5cbiAgICAgICAgICB0aW1lb3V0SWQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQSBzaW5nbGUgY2xpY2sgY2FuIHRyaWdnZXIgZXZlbnQgY3JlYXRpb24gaWYgdGhlIHVzZXIgZGVjaWRlcyBzby5cbiAgICAgICAgLy8gQnV0IHByZXZlbnQgdGhpcyB0byBoYXBwZW4gb24gY2xpY2sgJiBob2xkLCBvbiBldmVudCBjbGljayBhbmQgb24gcmVzaXplIGV2ZW50LlxuICAgICAgICBjYW5jZWxDbGlja0V2ZW50Q3JlYXRpb246IGZhbHNlXG4gICAgICB9LFxuICAgICAgLy8gVGhlIGV2ZW50cyBzb3VyY2Ugb2YgdHJ1dGguXG4gICAgICAvLyBBbiBhcnJheSBvZiBtdXRhYmxlIGV2ZW50cyB1cGRhdGVkIGVhY2ggdGltZSBnaXZlbiBleHRlcm5hbCBldmVudHMgYXJyYXkgY2hhbmdlcy5cbiAgICAgIG11dGFibGVFdmVudHM6IFtdLFxuICAgICAgLy8gVHJhbnNpdGlvbiB3aGVuIHN3aXRjaGluZyB2aWV3LiBsZWZ0IHdoZW4gZ29pbmcgdG93YXJkIHRoZSBwYXN0LCByaWdodCB3aGVuIGdvaW5nIHRvd2FyZCBmdXR1cmUuXG4gICAgICB0cmFuc2l0aW9uRGlyZWN0aW9uOiAncmlnaHQnXG4gICAgfTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8qKlxuICAgICAqIE9ubHkgaW1wb3J0IGxvY2FsZSBvbiBkZW1hbmQgdG8ga2VlcCBhIHNtYWxsIGxpYnJhcnkgd2VpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2FsZSB0aGUgbGFuZ3VhZ2UgdXNlciB3aGlzaGVzIHRvIGhhdmUgb24gdnVlLWNhbFxuICAgICAqL1xuICAgIGxvYWRMb2NhbGU6IGZ1bmN0aW9uIGxvYWRMb2NhbGUobG9jYWxlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5sb2NhbGUgPT09ICdlbicpIHRoaXMudGV4dHMgPSBPYmplY3QuYXNzaWduKHt9LCB0ZXh0c0RlZmF1bHRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzIxM1wiKSk7ZWxzZSB7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIxNzkwXCIpKFwiLi9cIi5jb25jYXQobG9jYWxlKSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBfdGhpcy50ZXh0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRleHRzRGVmYXVsdHMsIHJlc3BvbnNlLmRlZmF1bHQpO1xuXG4gICAgICAgICAgZGF0ZV91dGlsc191cGRhdGVEYXRlVGV4dHMoX3RoaXMudGV4dHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2svZGJsY2xpY2sgb2YgYSBjZWxsIGdvIHRvIGEgbmFycm93ZXIgdmlldyBpZiBhdmFpbGFibGUuXG4gICAgICogRS5nLiBDbGljayBvbiBtb250aCBjZWxsIHRha2VzIHlvdSB0byB3ZWVrIHZpZXcgaWYgbm90IGhpZGRlbiwgb3RoZXJ3aXNlIG9uIGRheSB2aWV3IGlmIG5vdCBoaWRkZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IERhdGV9IGRhdGUgQSBzdGFydGluZyBkYXRlIGZvciB0aGUgdmlldywgaWYgbm9uZSwgZmFsbGJhY2tzIHRvIHRoZSBzZWxlY3RlZCBkYXRlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbHNvIGVtcHR5IGZhbGxiYWNrcyB0byB0aGUgY3VycmVudCB2aWV3IHN0YXJ0IGRhdGUuXG4gICAgICovXG4gICAgc3dpdGNoVG9OYXJyb3dlclZpZXc6IGZ1bmN0aW9uIHN3aXRjaFRvTmFycm93ZXJWaWV3KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdGhpcy50cmFuc2l0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHZhciB2aWV3cyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3MpO1xuICAgICAgdmlld3MgPSB2aWV3cy5zbGljZSh2aWV3cy5pbmRleE9mKHRoaXMudmlldy5pZCkgKyAxKTtcbiAgICAgIHZhciB2aWV3ID0gdmlld3MuZmluZChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnZpZXdzW3ZdLmVuYWJsZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmICh2aWV3KSB0aGlzLnN3aXRjaFZpZXcodmlldywgZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRvIHRoZSBzcGVjaWZpZWQgdmlldyBvbiB2aWV3IHNlbGVjdG9yIGNsaWNrLCBvciBwcm9ncmFtbWF0aWNhbGx5IGZvcm0gZXh0ZXJuYWwgY2FsbCAodmlhICRyZWZzKS5cbiAgICAgKiBJZiBhIGRhdGUgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgc2VsZWN0ZWQgYW5kIGlmIHRoZSB2aWV3IGRvZXMgbm90IGNvbnRhaW4gaXQsIGl0IHdpbGwgZ28gdG8gdGhhdCBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZpZXcgdGhlIHZpZXcgdG8gZ28gdG8uIEFtb25nIGB5ZWFyc2AsIGB5ZWFyYCwgYG1vbnRoYCwgYHdlZWtgLCBgZGF5YC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IERhdGV9IGRhdGUgQSBzdGFydGluZyBkYXRlIGZvciB0aGUgdmlldywgaWYgbm9uZSwgZmFsbGJhY2tzIHRvIHRoZSBzZWxlY3RlZCBkYXRlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbHNvIGVtcHR5IGZhbGxiYWNrcyB0byB0aGUgY3VycmVudCB2aWV3IHN0YXJ0IGRhdGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmcm9tVmlld1NlbGVjdG9yIHRvIGtub3cgaWYgdGhlIGNhbGxlciBpcyB0aGUgYnVpbHQtaW4gdmlldyBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBzd2l0Y2hWaWV3OiBmdW5jdGlvbiBzd2l0Y2hWaWV3KHZpZXcpIHtcbiAgICAgIHZhciBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIGZyb21WaWV3U2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy50cmFuc2l0aW9ucyAmJiBmcm9tVmlld1NlbGVjdG9yKSB7XG4gICAgICAgIHZhciB2aWV3cyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3MpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25EaXJlY3Rpb24gPSB2aWV3cy5pbmRleE9mKHRoaXMudmlldy5pZCkgPiB2aWV3cy5pbmRleE9mKHZpZXcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3LmV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy52aWV3LmlkID0gdmlldztcbiAgICAgIHRoaXMudmlldy5maXJzdENlbGxEYXRlID0gbnVsbDsgLy8gRm9yIG1vbnRoIHZpZXcsIGlmIGZpbGxpbmcgY2VsbHMgYmVmb3JlIDFzdCBvZiBtb250aC5cblxuICAgICAgdGhpcy52aWV3Lmxhc3RDZWxsRGF0ZSA9IG51bGw7IC8vIEZvciBtb250aCB2aWV3LCBpZiBmaWxsaW5nIGNlbGxzIGFmdGVyIGN1cnJlbnQgbW9udGguXG5cbiAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICBkYXRlID0gdGhpcy52aWV3LnNlbGVjdGVkRGF0ZSB8fCB0aGlzLnZpZXcuc3RhcnREYXRlO1xuICAgICAgICBpZiAodmlldyA9PT0gJ3dlZWsnKSBkYXRlID0gZ2V0UHJldmlvdXNGaXJzdERheU9mV2VlayhkYXRlLCB0aGlzLnN0YXJ0V2Vla09uU3VuZGF5KTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2aWV3KSB7XG4gICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBBbHdheXMgZmlsbCBmaXJzdCBjZWxsIHdpdGggYSBtdWx0aXBsZSBvZiAyNSB5ZWFycywgRS5nLiB5ZWFyIDIwMDAsIG9yIDIwMjUuXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3RhcnREYXRlID0gbmV3IERhdGUoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAyNSkgKiAyNSB8fCAyMDAwLCAwLCAxKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlID0gbmV3IERhdGUodGhpcy52aWV3LnN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpICsgMjUsIDAsIDEpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmVuZERhdGUuc2V0U2Vjb25kcygtMSk7IC8vIEVuZCBhdCAyMzo1OTo1OS5cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmVuZERhdGUgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCkgKyAxLCAwLCAxKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlLnNldFNlY29uZHMoLTEpOyAvLyBFbmQgYXQgMjM6NTk6NTkuXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAxKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlLnNldFNlY29uZHMoLTEpOyAvLyBFbmQgYXQgMjM6NTk6NTkuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aCBpcyBub3QgYSBGaXJzdERheU9mV2VlayAoTW9uZGF5IG9yIFN1bmRheSksIHByZXBlbmQgbWlzc2luZyBkYXlzIHRvIHRoZSBkYXlzIGFycmF5LlxuXG4gICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbmV3IERhdGUodGhpcy52aWV3LnN0YXJ0RGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydERhdGUuZ2V0RGF5KCkgIT09ICh0aGlzLnN0YXJ0V2Vla09uU3VuZGF5ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IGdldFByZXZpb3VzRmlyc3REYXlPZldlZWsoc3RhcnREYXRlLCB0aGlzLnN0YXJ0V2Vla09uU3VuZGF5KTtcbiAgICAgICAgICAgIH0gLy8gVXNlZCBpbiB2aWV3Q2VsbHMgY29tcHV0ZWQgYXJyYXkgJiByZXR1cm5lZCBpbiBlbWl0dGVkIGV2ZW50cy5cblxuXG4gICAgICAgICAgICB0aGlzLnZpZXcuZmlyc3RDZWxsRGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICAgICAgICAgIHRoaXMudmlldy5sYXN0Q2VsbERhdGUgPSBzdGFydERhdGUuYWRkRGF5cyg0MSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcubGFzdENlbGxEYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlV2Vla2VuZHMpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZpcnN0IHdlZWtlbmQgZnJvbSBmaXJzdENlbGxEYXRlIGlmIGhpZGUtd2Vla2VuZHMuXG4gICAgICAgICAgICAgIGlmIChbMCwgNl0uaW5jbHVkZXModGhpcy52aWV3LmZpcnN0Q2VsbERhdGUuZ2V0RGF5KCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRheXNUb0FkZCA9IHRoaXMudmlldy5maXJzdENlbGxEYXRlLmdldERheSgpID09PSA2ICYmICF0aGlzLnN0YXJ0V2Vla09uU3VuZGF5ID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZpcnN0Q2VsbERhdGUgPSB0aGlzLnZpZXcuZmlyc3RDZWxsRGF0ZS5hZGREYXlzKGRheXNUb0FkZCk7XG4gICAgICAgICAgICAgIH0gLy8gUmVtb3ZlIGZpcnN0IHdlZWtlbmQgZnJvbSBzdGFydERhdGUgaWYgaGlkZS13ZWVrZW5kcy5cblxuXG4gICAgICAgICAgICAgIGlmIChbMCwgNl0uaW5jbHVkZXModGhpcy52aWV3LnN0YXJ0RGF0ZS5nZXREYXkoKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RheXNUb0FkZCA9IHRoaXMudmlldy5zdGFydERhdGUuZ2V0RGF5KCkgPT09IDYgPyAyIDogMTtcblxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zdGFydERhdGUgPSB0aGlzLnZpZXcuc3RhcnREYXRlLmFkZERheXMoX2RheXNUb0FkZCk7XG4gICAgICAgICAgICAgIH0gLy8gUmVtb3ZlIGxhc3Qgd2Vla2VuZCBmcm9tIGxhc3RDZWxsRGF0ZSBpZiBoaWRlLXdlZWtlbmRzLlxuXG5cbiAgICAgICAgICAgICAgaWYgKFswLCA2XS5pbmNsdWRlcyh0aGlzLnZpZXcubGFzdENlbGxEYXRlLmdldERheSgpKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXlzVG9TdWJ0cmFjdCA9IHRoaXMudmlldy5sYXN0Q2VsbERhdGUuZ2V0RGF5KCkgPT09IDAgJiYgIXRoaXMuc3RhcnRXZWVrT25TdW5kYXkgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcubGFzdENlbGxEYXRlID0gdGhpcy52aWV3Lmxhc3RDZWxsRGF0ZS5zdWJ0cmFjdERheXMoZGF5c1RvU3VidHJhY3QpO1xuICAgICAgICAgICAgICB9IC8vIFJlbW92ZSBsYXN0IHdlZWtlbmQgZnJvbSBlbmREYXRlIGlmIGhpZGUtd2Vla2VuZHMuXG5cblxuICAgICAgICAgICAgICBpZiAoWzAsIDZdLmluY2x1ZGVzKHRoaXMudmlldy5lbmREYXRlLmdldERheSgpKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGF5c1RvU3VidHJhY3QgPSB0aGlzLnZpZXcuZW5kRGF0ZS5nZXREYXkoKSA9PT0gMCA/IDIgOiAxO1xuXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmVuZERhdGUgPSB0aGlzLnZpZXcuZW5kRGF0ZS5zdWJ0cmFjdERheXMoX2RheXNUb1N1YnRyYWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdlZWtEYXlzQ291bnQgPSB0aGlzLmhpZGVXZWVrZW5kcyA/IDUgOiA3O1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0YXJ0RGF0ZSA9IHRoaXMuaGlkZVdlZWtlbmRzICYmIHRoaXMuc3RhcnRXZWVrT25TdW5kYXkgPyBkYXRlLmFkZERheXMoMSkgOiBkYXRlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0YXJ0RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlID0gZGF0ZS5hZGREYXlzKHdlZWtEYXlzQ291bnQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmVuZERhdGUuc2V0U2Vjb25kcygtMSk7IC8vIEVuZCBhdCAyMzo1OTo1OS5cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0YXJ0RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc3RhcnREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy52aWV3LmVuZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5lbmREYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDApOyAvLyBFbmQgYXQgMjM6NTk6NTkuXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudHNUb1ZpZXcoKTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgdmFyIF9zdGFydERhdGUgPSB0aGlzLnZpZXcuc3RhcnREYXRlO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgICBzdGFydERhdGU6IF9zdGFydERhdGUsXG4gICAgICAgICAgZW5kRGF0ZTogdGhpcy52aWV3LmVuZERhdGVcbiAgICAgICAgfSwgdGhpcy52aWV3LmlkID09PSAnbW9udGgnID8ge1xuICAgICAgICAgIGZpcnN0Q2VsbERhdGU6IHRoaXMudmlldy5maXJzdENlbGxEYXRlLFxuICAgICAgICAgIGxhc3RDZWxsRGF0ZTogdGhpcy52aWV3Lmxhc3RDZWxsRGF0ZSxcbiAgICAgICAgICBvdXRPZlNjb3BlRXZlbnRzOiB0aGlzLnZpZXcub3V0T2ZTY29wZUV2ZW50cy5tYXAodGhpcy5jbGVhbnVwRXZlbnQpXG4gICAgICAgIH0gOiB7fSwge1xuICAgICAgICAgIGV2ZW50czogdGhpcy52aWV3LmV2ZW50cy5tYXAodGhpcy5jbGVhbnVwRXZlbnQpXG4gICAgICAgIH0sIHRoaXMudmlldy5pZCA9PT0gJ3dlZWsnID8ge1xuICAgICAgICAgIHdlZWs6IHRoaXMuc3RhcnRXZWVrT25TdW5kYXkgPyBfc3RhcnREYXRlLmFkZERheXMoMSkuZ2V0V2VlaygpIDogX3N0YXJ0RGF0ZS5nZXRXZWVrKClcbiAgICAgICAgfSA6IHt9KTtcblxuICAgICAgICB0aGlzLiRlbWl0KCd2aWV3LWNoYW5nZScsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3J0aGFuZCBmdW5jdGlvbiBmb3IgZXh0ZXJuYWwgY2FsbCAodmlhICRyZWZzKS5cbiAgICAgKi9cbiAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICB0aGlzLnByZXZpb3VzTmV4dChmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3J0aGFuZCBmdW5jdGlvbiBmb3IgZXh0ZXJuYWwgY2FsbCAodmlhICRyZWZzKS5cbiAgICAgKi9cbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdGhpcy5wcmV2aW91c05leHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2sgb24gcHJldmlvdXMgb3IgbmV4dCBhcnJvdywgdXBkYXRlIHRoZSBjYWxlbmRhciB2aXNpYmxlIGRhdGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5leHRcbiAgICAgKi9cbiAgICBwcmV2aW91c05leHQ6IGZ1bmN0aW9uIHByZXZpb3VzTmV4dCgpIHtcbiAgICAgIHZhciBuZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdGhpcy50cmFuc2l0aW9uRGlyZWN0aW9uID0gbmV4dCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBuZXh0ID8gMSA6IC0xO1xuICAgICAgdmFyIGZpcnN0Q2VsbERhdGUgPSBudWxsO1xuICAgICAgdmFyIF90aGlzJHZpZXcgPSB0aGlzLnZpZXcsXG4gICAgICAgICAgc3RhcnREYXRlID0gX3RoaXMkdmlldy5zdGFydERhdGUsXG4gICAgICAgICAgdmlld0lkID0gX3RoaXMkdmlldy5pZDtcblxuICAgICAgc3dpdGNoICh2aWV3SWQpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUuZ2V0RnVsbFllYXIoKSArIDI1ICogbW9kaWZpZXIsIDAsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUuZ2V0RnVsbFllYXIoKSArIDEgKiBtb2RpZmllciwgMSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUuZ2V0RnVsbFllYXIoKSwgc3RhcnREYXRlLmdldE1vbnRoKCkgKyAxICogbW9kaWZpZXIsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBnZXRQcmV2aW91c0ZpcnN0RGF5T2ZXZWVrKHN0YXJ0RGF0ZSwgdGhpcy5zdGFydFdlZWtPblN1bmRheSlbbmV4dCA/ICdhZGREYXlzJyA6ICdzdWJ0cmFjdERheXMnXSg3KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBzdGFydERhdGVbbmV4dCA/ICdhZGREYXlzJyA6ICdzdWJ0cmFjdERheXMnXSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Q2VsbERhdGUpIHRoaXMuc3dpdGNoVmlldyh2aWV3SWQsIGZpcnN0Q2VsbERhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnRzIChzdWJzZXQgZnJvbSBtdXRhYmxlRXZlbnRzKSB0byB0aGUgY3VycmVudCB2aWV3IChpbiBgdGhpcy52aWV3LmV2ZW50c2ApLlxuICAgICAqIFRoaXMgaXMgZG9uZSBmb3IgcGVyZm9ybWFuY2UsIHNvIHRoYXQgYWxsIHRoZSBjZWxscyBoYXZlIGEgcXVpY2sgbG9va3VwIG9mIG9ubHkgd2hhdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50c1xuICAgICAqL1xuICAgIGFkZEV2ZW50c1RvVmlldzogZnVuY3Rpb24gYWRkRXZlbnRzVG9WaWV3KCkge1xuICAgICAgdmFyIF90aGlzJHZpZXckZXZlbnRzLFxuICAgICAgICAgIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBldmVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIF90aGlzJHZpZXcyID0gdGhpcy52aWV3LFxuICAgICAgICAgIGlkID0gX3RoaXMkdmlldzIuaWQsXG4gICAgICAgICAgc3RhcnREYXRlID0gX3RoaXMkdmlldzIuc3RhcnREYXRlLFxuICAgICAgICAgIGVuZERhdGUgPSBfdGhpcyR2aWV3Mi5lbmREYXRlLFxuICAgICAgICAgIGZpcnN0Q2VsbERhdGUgPSBfdGhpcyR2aWV3Mi5maXJzdENlbGxEYXRlLFxuICAgICAgICAgIGxhc3RDZWxsRGF0ZSA9IF90aGlzJHZpZXcyLmxhc3RDZWxsRGF0ZTsgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgdmlldyBpZiBub3QgZXhwbGljaXRlbHkgZ2l2aW5nIGFuIGFycmF5IG9mIGV2ZW50cyB0byBhZGQuXG5cbiAgICAgIGlmICghZXZlbnRzLmxlbmd0aCkgdGhpcy52aWV3LmV2ZW50cyA9IFtdOyAvLyBAdG9kbzogcmVtb3ZlIHRoZSBjb2RlIHRoYXQgZXhwbGljaXRlbHkgdXBkYXRlcyB0aGlzLm11dGFibGVFdmVudHMgKGUuZyBvbiBldmVudCByZXNpemUpLlxuICAgICAgLy8gYXMgd2UgYXJlIGFscmVhZHkgbXV0YXRpbmcgdGhlIGV2ZW50IGZyb20gbXV0YWJsZUV2ZW50cy5cblxuICAgICAgZXZlbnRzID0gZXZlbnRzLmxlbmd0aCA/IGV2ZW50cyA6IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLm11dGFibGVFdmVudHMpOyAvLyBJbiBubyBldmVudCBvciBpZiBvbiB5ZWFycy95ZWFyIHZpZXcgYW5kIGV2ZW50c0NvdW50T25ZZWFyVmlldyBpcyBmYWxzZVxuICAgICAgLy8gdGhlbiBkb24ndCBhZGQgZXZlbnRzIHRvIHZpZXcuXG5cbiAgICAgIGlmICghZXZlbnRzIHx8IFsneWVhcnMnLCAneWVhciddLmluY2x1ZGVzKGlkKSAmJiAhdGhpcy5ldmVudHNDb3VudE9uWWVhclZpZXcpIHJldHVybjsgLy8gRmlyc3QgcmVtb3ZlIHRoZSBldmVudHMgdGhhdCBhcmUgbm90IGluIHZpZXcuXG4gICAgICAvLyBLZWVwIHRoZSB1bmZpbHRlcmVkIGFycmF5IG9mIGV2ZW50cyBmb3Igb3V0T2ZTY29wZUV2ZW50cyBiZWxsb3cuXG5cbiAgICAgIHZhciBmaWx0ZXJlZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SW5SYW5nZShlLCBzdGFydERhdGUsIGVuZERhdGUpO1xuICAgICAgfSk7IC8vIEZvciBlYWNoIG11bHRpcGxlLWRheSBldmVudCBhbmQgb25seSBpZiBuZWVkZWQsIGNyZWF0ZSBpdHMgc2VnbWVudHMgKD0gZGF5cykgZm9yIHJlbmRlcmluZyBpbiB0aGUgdmlldy5cbiAgICAgIC8vIElmIHdlIGRvbid0IGRpc3BsYXkgdGhlIGV2ZW50IG9uIG1vbnRoIHZpZXcgKGV2ZW50c09uTW9udGhWaWV3ID0gZmFsc2UpIHRoZW4gZG9uJ3QgY3JlYXRlIHNlZ21lbnRzLlxuXG4gICAgICBpZiAoWydtb250aCcsICd3ZWVrJywgJ2RheSddLmluY2x1ZGVzKGlkKSAmJiAhKGlkID09PSAnbW9udGgnICYmICF0aGlzLmV2ZW50c09uTW9udGhWaWV3KSkge1xuICAgICAgICBmaWx0ZXJlZEV2ZW50cyA9IGZpbHRlcmVkRXZlbnRzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmRheXNDb3VudCA+IDEgPyBldmVudF91dGlsc19jcmVhdGVFdmVudFNlZ21lbnRzKGUsIGZpcnN0Q2VsbERhdGUgfHwgc3RhcnREYXRlLCBsYXN0Q2VsbERhdGUgfHwgZW5kRGF0ZSkgOiBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgKF90aGlzJHZpZXckZXZlbnRzID0gdGhpcy52aWV3LmV2ZW50cykucHVzaC5hcHBseShfdGhpcyR2aWV3JGV2ZW50cywgX3RvQ29uc3VtYWJsZUFycmF5KGZpbHRlcmVkRXZlbnRzKSk7XG5cbiAgICAgIGlmIChpZCA9PT0gJ21vbnRoJykge1xuICAgICAgICAvLyBTYXZlIG91dCBvZiBzY29wZSBldmVudHMgaW50byB0aGUgdmlldyBvYmplY3Qgc2VwYXJhdGVkIGZyb20gdGhlIGFycmF5IG9mIGluLXNjb3BlIGV2ZW50cy5cbiAgICAgICAgdGhpcy52aWV3Lm91dE9mU2NvcGVFdmVudHMgPSBbXTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZXZlbnRJblJhbmdlKGUsIGZpcnN0Q2VsbERhdGUsIHN0YXJ0RGF0ZSkgfHwgZXZlbnRJblJhbmdlKGUsIGVuZERhdGUsIGxhc3RDZWxsRGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIGV2ZW50cyB0byB0aGUgdmlldy5vdXRPZlNjb3BlRXZlbnRzIGFycmF5IGlmIG5vdCBhbHJlYWR5IGluIHZpZXcuZXZlbnRzXG4gICAgICAgICAgICAvLyAobXVsdGlwbGUtZGF5IGV2ZW50cyBjYXNlKS5cbiAgICAgICAgICAgIGlmICghX3RoaXMzLnZpZXcuZXZlbnRzLnNvbWUoZnVuY3Rpb24gKGUyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlMi5fZWlkID09PSBlLl9laWQ7XG4gICAgICAgICAgICB9KSkgX3RoaXMzLnZpZXcub3V0T2ZTY29wZUV2ZW50cy5wdXNoKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGZpbmQgYSBET00gYW5jZXN0b3Igb2YgYSBnaXZlbiBET00gbm9kZSBgZWxgIG1hdGNoaW5nIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWwgYSBET00gbm9kZSB0byBmaW5kIGFuY2VzdG9yIGZyb20uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IENsYXNzIHRoZSBDU1MgY2xhc3MgbmFtZSBvZiB0aGUgYW5jZXN0b3IuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWF0Y2hlZCBET00gbm9kZSBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgICAqL1xuICAgIGZpbmRBbmNlc3RvcjogZnVuY3Rpb24gZmluZEFuY2VzdG9yKGVsLCBDbGFzcykge1xuICAgICAgd2hpbGUgKChlbCA9IGVsLnBhcmVudEVsZW1lbnQpICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3MpKSB7fVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHdoZXRoZXIgYSBjbGlja2VkIERPTSBub2RlIGlzIG9yIGlzIHdpdGhpbiBhIGNhbGVuZGFyIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsIGEgRE9NIG5vZGUgdG8gY2hlY2sgaWYgZXZlbnQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgaXMgLSBvciBpcyBpbiAtIGFuIGV2ZW50LlxuICAgICAqL1xuICAgIGlzRE9NRWxlbWVudEFuRXZlbnQ6IGZ1bmN0aW9uIGlzRE9NRWxlbWVudEFuRXZlbnQoZWwpIHtcbiAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Z1ZWNhbF9fZXZlbnQnKSB8fCB0aGlzLmZpbmRBbmNlc3RvcihlbCwgJ3Z1ZWNhbF9fZXZlbnQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBtb3VzZW1vdmUgYW55d2hlcmUgaW4gdGhlIHBhZ2UuXG4gICAgICogSWYgcmVzaXppbmcgYW4gZXZlbnQgd2FzIHN0YXJ0ZWQgZWFybGllciwgdGhpcyB3aWxsIHVwZGF0ZSBldmVudCBlbmQuXG4gICAgICogSWYgcmVzaXppbmcgd2FzIG5vdCBzdGFydGVkLCB0aGlzIG1ldGhvZCBpcyBjYWxjdWxhdGlvbiBpcyBhdm9pZGVkIHdpdGggYSBwcmVtYXR1cmUgcmV0dXJuLlxuICAgICAqIE5vdGVzOiBFdmVudCByZXNpemluZyBpcyBzdGFydGVkIGluIGNlbGwgY29tcG9uZW50IChvbk1vdXNlRG93bikgYnV0IHBsYWNlIG9uTW91c2VNb3ZlICYgb25Nb3VzZVVwXG4gICAgICogICAgICAgIGhhbmRsZXJzIGluIHRoZSBzaW5nbGUtaW5zdGFuY2UgcGFyZW50IGZvciBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBuYXRpdmUgRE9NIGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZSkge1xuICAgICAgdmFyIF90aGlzJGRvbUV2ZW50cyA9IHRoaXMuZG9tRXZlbnRzLFxuICAgICAgICAgIHJlc2l6ZUFuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMucmVzaXplQW5FdmVudCxcbiAgICAgICAgICBkcmFnQW5FdmVudCA9IF90aGlzJGRvbUV2ZW50cy5kcmFnQW5FdmVudDtcbiAgICAgIGlmIChyZXNpemVBbkV2ZW50Ll9laWQgPT09IG51bGwgJiYgZHJhZ0FuRXZlbnQuX2VpZCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAocmVzaXplQW5FdmVudC5fZWlkKSB7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMudmlldy5ldmVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLl9laWQgPT09IHJlc2l6ZUFuRXZlbnQuX2VpZDtcbiAgICAgICAgfSkgfHwge1xuICAgICAgICAgIHNlZ21lbnRzOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfdGhpcyRtaW51dGVzQXRDdXJzb3IgPSB0aGlzLm1pbnV0ZXNBdEN1cnNvcihlKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBfdGhpcyRtaW51dGVzQXRDdXJzb3IubWludXRlcyxcbiAgICAgICAgICAgIGN1cnNvckNvb3JkcyA9IF90aGlzJG1pbnV0ZXNBdEN1cnNvci5jdXJzb3JDb29yZHM7XG5cbiAgICAgICAgdmFyIHNlZ21lbnQgPSBldmVudC5zZWdtZW50cyAmJiBldmVudC5zZWdtZW50c1tyZXNpemVBbkV2ZW50LnNlZ21lbnRdOyAvLyBEb24ndCBhbGxvdyB0aW1lIGFib3ZlIDI0IGhvdXJzLlxuXG4gICAgICAgIGV2ZW50LmVuZFRpbWVNaW51dGVzID0gcmVzaXplQW5FdmVudC5lbmRUaW1lTWludXRlcyA9IE1hdGgubWluKG1pbnV0ZXMsIHZ1ZV9jYWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19taW51dGVzSW5BRGF5KTsgLy8gUHJldmVudCByZWR1Y2luZyBldmVudCBkdXJhdGlvbiB0byBsZXNzIHRoYW4gMSBtaW4gc28gaXQgZG9lcyBub3QgZGlzYXBwZWFyLlxuXG4gICAgICAgIGV2ZW50LmVuZFRpbWVNaW51dGVzID0gcmVzaXplQW5FdmVudC5lbmRUaW1lTWludXRlcyA9IE1hdGgubWF4KGV2ZW50LmVuZFRpbWVNaW51dGVzLCB0aGlzLnRpbWVGcm9tICsgMSwgKHNlZ21lbnQgfHwgZXZlbnQpLnN0YXJ0VGltZU1pbnV0ZXMgKyAxKTsgLy8gT24gcmVzaXplLCBzbmFwIHRvIHRpbWUgZXZlcnkgWCBtaW51dGVzIGlmIHRoZSBvcHRpb24gaXMgb24uXG5cbiAgICAgICAgaWYgKHRoaXMuc25hcFRvVGltZSkge1xuICAgICAgICAgIHZhciBwbHVzSGFsZlNuYXBUaW1lID0gZXZlbnQuZW5kVGltZU1pbnV0ZXMgKyB0aGlzLnNuYXBUb1RpbWUgLyAyO1xuICAgICAgICAgIGV2ZW50LmVuZFRpbWVNaW51dGVzID0gcGx1c0hhbGZTbmFwVGltZSAtIHBsdXNIYWxmU25hcFRpbWUgJSB0aGlzLnNuYXBUb1RpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudCkgc2VnbWVudC5lbmRUaW1lTWludXRlcyA9IGV2ZW50LmVuZFRpbWVNaW51dGVzO1xuICAgICAgICBldmVudC5lbmREYXRlLnNldEhvdXJzKDAsIGV2ZW50LmVuZFRpbWVNaW51dGVzLCBldmVudC5lbmRUaW1lTWludXRlcyA9PT0gdnVlX2NhbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX21pbnV0ZXNJbkFEYXkgPyAtMSA6IDAsIC8vIFJlbW92ZSAxIHNlY29uZCBpZiB0aW1lIGlzIDI0OjAwLlxuICAgICAgICAwKTtcbiAgICAgICAgZXZlbnQuZW5kID0gZm9ybWF0RGF0ZUxpdGUoZXZlbnQuZW5kRGF0ZSkgKyAnICcgKyBkYXRlX3V0aWxzX2Zvcm1hdFRpbWUoZXZlbnQuZW5kVGltZU1pbnV0ZXMpOyAvLyBSZXNpemUgZXZlbnRzIGhvcml6b250YWxseSBpZiByZXNpemUteCBpcyBlbmFibGVkIChhZGQvcmVtb3ZlIHNlZ21lbnRzKS5cblxuICAgICAgICBpZiAodGhpcy5yZXNpemVYICYmIHRoaXMudmlldy5pZCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgZXZlbnQuZGF5c0NvdW50ID0gY291bnREYXlzKGV2ZW50LnN0YXJ0RGF0ZSwgZXZlbnQuZW5kRGF0ZSk7XG4gICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy4kcmVmcy5jZWxscztcbiAgICAgICAgICB2YXIgY2VsbFdpZHRoID0gY2VsbHMub2Zmc2V0V2lkdGggLyBjZWxscy5jaGlsZEVsZW1lbnRDb3VudDtcbiAgICAgICAgICB2YXIgZW5kQ2VsbCA9IE1hdGguZmxvb3IoY3Vyc29yQ29vcmRzLnggLyBjZWxsV2lkdGgpO1xuXG4gICAgICAgICAgaWYgKCFyZXNpemVBbkV2ZW50LnN0YXJ0Q2VsbCkge1xuICAgICAgICAgICAgcmVzaXplQW5FdmVudC5zdGFydENlbGwgPSBlbmRDZWxsIC0gKGV2ZW50LmRheXNDb3VudCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNpemVBbkV2ZW50LmVuZENlbGwgIT09IGVuZENlbGwpIHtcbiAgICAgICAgICAgIHJlc2l6ZUFuRXZlbnQuZW5kQ2VsbCA9IGVuZENlbGw7XG4gICAgICAgICAgICB2YXIgZW5kRGF0ZSA9IGV2ZW50LnN0YXJ0RGF0ZS5hZGREYXlzKGVuZENlbGwgLSByZXNpemVBbkV2ZW50LnN0YXJ0Q2VsbCk7XG4gICAgICAgICAgICB2YXIgbmV3RGF5c0NvdW50ID0gY291bnREYXlzKGV2ZW50LnN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdEYXlzQ291bnQgIT09IGV2ZW50LmRheXNDb3VudCkge1xuICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IGFsbCBzZWdtZW50cyBhcmUgdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgICAgdmFyIGxhc3RTZWdtZW50Rm9ybWF0dGVkRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChuZXdEYXlzQ291bnQgPiBldmVudC5kYXlzQ291bnQpIGxhc3RTZWdtZW50Rm9ybWF0dGVkRGF0ZSA9IGV2ZW50X3V0aWxzX2FkZEV2ZW50U2VnbWVudChldmVudCk7ZWxzZSBsYXN0U2VnbWVudEZvcm1hdHRlZERhdGUgPSBldmVudF91dGlsc19yZW1vdmVFdmVudFNlZ21lbnQoZXZlbnQpO1xuICAgICAgICAgICAgICByZXNpemVBbkV2ZW50LnNlZ21lbnQgPSBsYXN0U2VnbWVudEZvcm1hdHRlZERhdGU7XG4gICAgICAgICAgICAgIGV2ZW50LmVuZFRpbWVNaW51dGVzICs9IDAuMDAxOyAvLyBGb3JjZSB1cGRhdGluZyB0aGUgY3VycmVudCBldmVudC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBtb3VzZXVwIGFueXdoZXJlIGluIHRoZSBwYWdlLCBub3Qgb25seSBvbiBhIGNlbGwgb3IgZXZlbnQuXG4gICAgICogVGhlbiBlbmQgdXAgYW55IHJlc2l6ZSwgZHJhZyAmIGRyb3AsIGNsaWNrICYgaG9sZCBvciBldmVudCBvciBjZWxsLlxuICAgICAqIE5vdGVzOiBNb3VzZXVwIGNhbiBuZXZlciBjYW5jZWwgYSBjbGljayB3aXRoIHByZXZlbnREZWZhdWx0IG9yIHN0b3BQcm9wYWdhdGlvbixcbiAgICAgKiAgICAgICAgQnV0IGl0IGFsd2F5cyBoYXBwZW5zIGJlZm9yZSB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgbmF0aXZlIERPTSBldmVudCBvYmplY3QuXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbiBvbk1vdXNlVXAoZSkge1xuICAgICAgdmFyIF90aGlzJGRvbUV2ZW50czIgPSB0aGlzLmRvbUV2ZW50cyxcbiAgICAgICAgICByZXNpemVBbkV2ZW50ID0gX3RoaXMkZG9tRXZlbnRzMi5yZXNpemVBbkV2ZW50LFxuICAgICAgICAgIGNsaWNrSG9sZEFuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMyLmNsaWNrSG9sZEFuRXZlbnQsXG4gICAgICAgICAgY2xpY2tIb2xkQUNlbGwgPSBfdGhpcyRkb21FdmVudHMyLmNsaWNrSG9sZEFDZWxsOyAvLyBPbiBldmVudCByZXNpemUgZW5kLCBlbWl0IGV2ZW50IGlmIGR1cmF0aW9uIGhhcyBjaGFuZ2VkLlxuXG4gICAgICBpZiAocmVzaXplQW5FdmVudC5fZWlkKSB7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmNhbmNlbENsaWNrRXZlbnRDcmVhdGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMudmlldy5ldmVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLl9laWQgPT09IHJlc2l6ZUFuRXZlbnQuX2VpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmVuZFRpbWVNaW51dGVzICE9PSByZXNpemVBbkV2ZW50Lm9yaWdpbmFsRW5kVGltZU1pbnV0ZXMpIHtcbiAgICAgICAgICAvLyBTdG9yZSBtb2RpZmllZCBldmVudCBiYWNrIGluIG11dGFibGUgZXZlbnRzLlxuICAgICAgICAgIHZhciBtdXRhYmxlRXZlbnQgPSB0aGlzLm11dGFibGVFdmVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuX2VpZCA9PT0gcmVzaXplQW5FdmVudC5fZWlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG11dGFibGVFdmVudC5lbmRUaW1lTWludXRlcyA9IGV2ZW50LmVuZFRpbWVNaW51dGVzO1xuICAgICAgICAgIG11dGFibGVFdmVudC5lbmQgPSBldmVudC5lbmQ7XG4gICAgICAgICAgbXV0YWJsZUV2ZW50LmVuZERhdGUgPSBldmVudC5lbmREYXRlO1xuICAgICAgICAgIHRoaXMuZW1pdFdpdGhFdmVudCgnZXZlbnQtZHVyYXRpb24tY2hhbmdlJywgZXZlbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdFdpdGhFdmVudCgnZXZlbnQtY2hhbmdlJywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50KSBldmVudC5yZXNpemluZyA9IGZhbHNlO1xuICAgICAgICByZXNpemVBbkV2ZW50Ll9laWQgPSBudWxsO1xuICAgICAgICByZXNpemVBbkV2ZW50LnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgcmVzaXplQW5FdmVudC5zcGxpdCA9IG51bGw7XG4gICAgICAgIHJlc2l6ZUFuRXZlbnQuc2VnbWVudCA9IG51bGw7XG4gICAgICAgIHJlc2l6ZUFuRXZlbnQub3JpZ2luYWxFbmRUaW1lTWludXRlcyA9IG51bGw7XG4gICAgICAgIHJlc2l6ZUFuRXZlbnQuZW5kVGltZU1pbnV0ZXMgPSBudWxsO1xuICAgICAgICByZXNpemVBbkV2ZW50LnN0YXJ0Q2VsbCA9IG51bGw7XG4gICAgICAgIHJlc2l6ZUFuRXZlbnQuZW5kQ2VsbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRE9NRWxlbWVudEFuRXZlbnQoZS50YXJnZXQpKSB0aGlzLmRvbUV2ZW50cy5jYW5jZWxDbGlja0V2ZW50Q3JlYXRpb24gPSB0cnVlOyAvLyBJZiBub3QgbW91c2UgdXAgb24gYW4gZXZlbnQsIHVuZm9jdXMgYW55IGV2ZW50IGV4Y2VwdCBpZiBqdXN0IGRyYWdnZWQuXG4gICAgICBlbHNlIGlmICghcmVzaXplQW5FdmVudC5fZWlkKSB0aGlzLnVuZm9jdXNFdmVudCgpOyAvLyBQcmV2ZW50IHNob3dpbmcgZGVsZXRlIGJ1dHRvbiBpZiBjbGljayBhbmQgaG9sZCB3YXMgbm90IGxvbmcgZW5vdWdoLlxuICAgICAgLy8gQ2xpY2sgJiBob2xkIHRpbWVvdXQgaXMgaW5pdGlhdGVkIGluIG9uTW91c2VEb3duKCkgaW4gZXZlbnQgY29tcG9uZW50LlxuXG4gICAgICBpZiAoY2xpY2tIb2xkQW5FdmVudC50aW1lb3V0SWQgJiYgIWNsaWNrSG9sZEFuRXZlbnQuX2VpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xpY2tIb2xkQW5FdmVudC50aW1lb3V0SWQpO1xuICAgICAgICBjbGlja0hvbGRBbkV2ZW50LnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9IC8vIFByZXZlbnQgY3JlYXRpbmcgYW4gZXZlbnQgaWYgY2xpY2sgYW5kIGhvbGQgd2FzIG5vdCBsb25nIGVub3VnaC5cblxuXG4gICAgICBpZiAoY2xpY2tIb2xkQUNlbGwudGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjbGlja0hvbGRBQ2VsbC50aW1lb3V0SWQpO1xuICAgICAgICBjbGlja0hvbGRBQ2VsbC50aW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIGBlc2NhcGVgIGtleXByZXNzIHdoZW4gZGVsZXRlIGJ1dHRvbiBpcyB2aXNpYmxlLCBhbmQgY2FuY2VsIGRlbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIG5hdGl2ZSBET00gZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIG9uS2V5VXA6IGZ1bmN0aW9uIG9uS2V5VXAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHRoaXMuY2FuY2VsRGVsZXRlKCk7IC8vIEVzY2FwZSBrZXkuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuZm9jdXMgYW4gZXZlbnQgKGUuZy4gd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGZvY3VzZWQgZXZlbnQpLlxuICAgICAqL1xuICAgIHVuZm9jdXNFdmVudDogZnVuY3Rpb24gdW5mb2N1c0V2ZW50KCkge1xuICAgICAgdmFyIF90aGlzJGRvbUV2ZW50czMgPSB0aGlzLmRvbUV2ZW50cyxcbiAgICAgICAgICBmb2N1c0FuRXZlbnQgPSBfdGhpcyRkb21FdmVudHMzLmZvY3VzQW5FdmVudCxcbiAgICAgICAgICBjbGlja0hvbGRBbkV2ZW50ID0gX3RoaXMkZG9tRXZlbnRzMy5jbGlja0hvbGRBbkV2ZW50O1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy52aWV3LmV2ZW50cy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLl9laWQgPT09IChmb2N1c0FuRXZlbnQuX2VpZCB8fCBjbGlja0hvbGRBbkV2ZW50Ll9laWQpO1xuICAgICAgfSk7XG4gICAgICBmb2N1c0FuRXZlbnQuX2VpZCA9IG51bGw7IC8vIENhbmNlbCBldmVudCBmb2N1cy5cblxuICAgICAgY2xpY2tIb2xkQW5FdmVudC5fZWlkID0gbnVsbDsgLy8gSGlkZSBkZWxldGUgYnV0dG9uLlxuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICBldmVudC5kZWxldGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYW4gZXZlbnQgZGVsZXRpb24gKGUuZy4gd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHZpc2libGUgZGVsZXRlIGJ1dHRvbikuXG4gICAgICovXG4gICAgY2FuY2VsRGVsZXRlOiBmdW5jdGlvbiBjYW5jZWxEZWxldGUoKSB7XG4gICAgICB2YXIgY2xpY2tIb2xkQW5FdmVudCA9IHRoaXMuZG9tRXZlbnRzLmNsaWNrSG9sZEFuRXZlbnQ7XG5cbiAgICAgIGlmIChjbGlja0hvbGRBbkV2ZW50Ll9laWQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy52aWV3LmV2ZW50cy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuX2VpZCA9PT0gY2xpY2tIb2xkQW5FdmVudC5fZWlkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV2ZW50KSBldmVudC5kZWxldGluZyA9IGZhbHNlO1xuICAgICAgICBjbGlja0hvbGRBbkV2ZW50Ll9laWQgPSBudWxsO1xuICAgICAgICBjbGlja0hvbGRBbkV2ZW50LnRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFmdGVyIGVkaXRpbmcgYW4gZXZlbnQgdGl0bGUgKGlmIGB0aGlzLmVkaXRhYmxlYCksIHNhdmUgdGhlIG5ldyBzdHJpbmcgaW50byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICogYW5kIGVtaXQgZXZlbnQgdG8gdGhlIG91dHNpZGUgd29ybGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgbmF0aXZlIERPTSBldmVudCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSB2dWUtY2FsIGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBvbkV2ZW50VGl0bGVCbHVyOiBmdW5jdGlvbiBvbkV2ZW50VGl0bGVCbHVyKGUsIGV2ZW50KSB7XG4gICAgICAvLyBJZiBubyBjaGFuZ2UgY2FuY2VsIGFjdGlvbi5cbiAgICAgIGlmIChldmVudC50aXRsZSA9PT0gZS50YXJnZXQuaW5uZXJIVE1MKSByZXR1cm47XG4gICAgICBldmVudC50aXRsZSA9IGUudGFyZ2V0LmlubmVySFRNTDtcbiAgICAgIHRoaXMuZW1pdFdpdGhFdmVudCgnZXZlbnQtdGl0bGUtY2hhbmdlJywgZXZlbnQpO1xuICAgICAgdGhpcy5lbWl0V2l0aEV2ZW50KCdldmVudC1jaGFuZ2UnLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBgbXV0YWJsZUV2ZW50c2AgYXJyYXkgb2YgZXZlbnRzIGlzIHRoZSBzb3VyY2Ugb2YgdHJ1dGguXG4gICAgICogSXQgaXMgZmlyc3QgcG9wdWxhdGVkIGZyb20gdGhlIGBldmVudHNgIHByb3AgYW5kIGV2ZXJ5IHRpbWUgdGhlIGBldmVudHNgIHByb3AgY2hhbmdlcy5cbiAgICAgKiBXaGVuIHRoZSB1c2VyIHVwZGF0ZXMgYW4gZXZlbnQgdGhyb3VnaCBpbnRlcnJhY3Rpb25zLCB0aGUgZXZlbnQgZ2V0cyB1cGRhdGVkIGhlcmUuXG4gICAgICogTm90ZXM6IG11dGFibGVFdmVudHMgY291bGRuJ3QgYmUgYSBjb21wdXRlZCB2YXJpYWJsZSBiYXNlZCBvbiB0aGlzLmV2ZW50cywgYmVjYXVzZSB3ZSBhZGRcbiAgICAgKiAgICAgICAgaXRlbXMgdG8gdGhlIGFycmF5LiAoQ2Fubm90IG11dGF0ZSBwcm9wcylcbiAgICAgKi9cbiAgICB1cGRhdGVNdXRhYmxlRXZlbnRzOiBmdW5jdGlvbiB1cGRhdGVNdXRhYmxlRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMubXV0YWJsZUV2ZW50cyA9IFtdOyAvLyBGb3IgZWFjaCBldmVudCBvZiB0aGUgYGV2ZW50c2AgcHJvcCwgcHJlcGFyZSB0aGUgZXZlbnQgZm9yIHZ1ZS1jYWw6XG4gICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGtleXM6IHN0YXJ0LCBzdGFydERhdGUsIHN0YXJ0VGltZU1pbnV0ZXMsIGVuZCwgZW5kRGF0ZSwgZW5kVGltZU1pbnV0ZXMsIGRheXNDb3VudC5cbiAgICAgIC8vIExvdHMgb2YgdGhlc2UgdmFyaWFibGVzIG1heSBsb29rIHJlZHVuZGFudCBidXQgYXJlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIGFzIGEgY2FjaGVkIHJlc3VsdCBvZiBjYWxjdWxhdGlvbi4gOilcblxuICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gYGV2ZW50LnN0YXJ0YCBhY2NlcHRzIGEgZm9ybWF0dGVkIHN0cmluZyAtIGBldmVudC5zdGFydERhdGVgIGFjY2VwdHMgYSBEYXRlIG9iamVjdC5cbiAgICAgICAgdmFyIHN0YXJ0RGF0ZSwgc3RhcnREYXRlRiwgc3RhcnRUaW1lLCBob3Vyc1N0YXJ0LCBtaW51dGVzU3RhcnQ7XG5cbiAgICAgICAgaWYgKGV2ZW50LnN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9ldmVudCRzdGFydCRzcGxpdCwgX2V2ZW50JHN0YXJ0JHNwbGl0MiwgX2V2ZW50JHN0YXJ0JHNwbGl0MiQsIF9zdGFydFRpbWUkc3BsaXQsIF9zdGFydFRpbWUkc3BsaXQyO1xuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgIShfZXZlbnQkc3RhcnQkc3BsaXQgPSBldmVudC5zdGFydC5zcGxpdCgnICcpLCBfZXZlbnQkc3RhcnQkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2V2ZW50JHN0YXJ0JHNwbGl0LCAyKSwgc3RhcnREYXRlRiA9IF9ldmVudCRzdGFydCRzcGxpdDJbMF0sIF9ldmVudCRzdGFydCRzcGxpdDIkID0gX2V2ZW50JHN0YXJ0JHNwbGl0MlsxXSwgc3RhcnRUaW1lID0gX2V2ZW50JHN0YXJ0JHNwbGl0MiQgPT09IHZvaWQgMCA/ICcnIDogX2V2ZW50JHN0YXJ0JHNwbGl0MiQsIF9ldmVudCRzdGFydCRzcGxpdCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgICAgIShfc3RhcnRUaW1lJHNwbGl0ID0gc3RhcnRUaW1lLnNwbGl0KCc6JyksIF9zdGFydFRpbWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3N0YXJ0VGltZSRzcGxpdCwgMiksIGhvdXJzU3RhcnQgPSBfc3RhcnRUaW1lJHNwbGl0MlswXSwgbWludXRlc1N0YXJ0ID0gX3N0YXJ0VGltZSRzcGxpdDJbMV0sIF9zdGFydFRpbWUkc3BsaXQpO1xuICAgICAgICAgIHN0YXJ0RGF0ZSA9IHN0cmluZ1RvRGF0ZShldmVudC5zdGFydCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc3RhcnREYXRlICYmIGV2ZW50LnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICBzdGFydERhdGVGID0gZm9ybWF0RGF0ZUxpdGUoZXZlbnQuc3RhcnREYXRlKTtcbiAgICAgICAgICBob3Vyc1N0YXJ0ID0gZXZlbnQuc3RhcnREYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgbWludXRlc1N0YXJ0ID0gZXZlbnQuc3RhcnREYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICBzdGFydERhdGUgPSBldmVudC5zdGFydERhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRUaW1lTWludXRlcyA9IHBhcnNlSW50KGhvdXJzU3RhcnQpICogNjAgKyBwYXJzZUludChtaW51dGVzU3RhcnQpO1xuXG4gICAgICAgIHZhciBzdGFydCA9IGV2ZW50LnN0YXJ0IHx8IHN0YXJ0RGF0ZUYgKyAnICcgKyBkYXRlX3V0aWxzX2Zvcm1hdFRpbWUoc3RhcnRUaW1lTWludXRlcyk7IC8vIGBldmVudC5lbmRgIGFjY2VwdHMgYSBmb3JtYXR0ZWQgc3RyaW5nIC0gYGV2ZW50LmVuZERhdGVgIGFjY2VwdHMgYSBEYXRlIG9iamVjdC5cblxuXG4gICAgICAgIHZhciBlbmREYXRlLCBlbmREYXRlRiwgZW5kVGltZSwgaG91cnNFbmQsIG1pbnV0ZXNFbmQ7XG5cbiAgICAgICAgaWYgKGV2ZW50LmVuZCkge1xuICAgICAgICAgIHZhciBfZXZlbnQkZW5kJHNwbGl0LCBfZXZlbnQkZW5kJHNwbGl0MiwgX2V2ZW50JGVuZCRzcGxpdDIkLCBfZW5kVGltZSRzcGxpdCwgX2VuZFRpbWUkc3BsaXQyO1xuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgIShfZXZlbnQkZW5kJHNwbGl0ID0gZXZlbnQuZW5kLnNwbGl0KCcgJyksIF9ldmVudCRlbmQkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2V2ZW50JGVuZCRzcGxpdCwgMiksIGVuZERhdGVGID0gX2V2ZW50JGVuZCRzcGxpdDJbMF0sIF9ldmVudCRlbmQkc3BsaXQyJCA9IF9ldmVudCRlbmQkc3BsaXQyWzFdLCBlbmRUaW1lID0gX2V2ZW50JGVuZCRzcGxpdDIkID09PSB2b2lkIDAgPyAnJyA6IF9ldmVudCRlbmQkc3BsaXQyJCwgX2V2ZW50JGVuZCRzcGxpdCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgICAgICAgIShfZW5kVGltZSRzcGxpdCA9IGVuZFRpbWUuc3BsaXQoJzonKSwgX2VuZFRpbWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2VuZFRpbWUkc3BsaXQsIDIpLCBob3Vyc0VuZCA9IF9lbmRUaW1lJHNwbGl0MlswXSwgbWludXRlc0VuZCA9IF9lbmRUaW1lJHNwbGl0MlsxXSwgX2VuZFRpbWUkc3BsaXQpO1xuICAgICAgICAgIGVuZERhdGUgPSBzdHJpbmdUb0RhdGUoZXZlbnQuZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5lbmREYXRlICYmIGV2ZW50LmVuZERhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgZW5kRGF0ZUYgPSBmb3JtYXREYXRlTGl0ZShldmVudC5lbmREYXRlKTtcbiAgICAgICAgICBob3Vyc0VuZCA9IGV2ZW50LmVuZERhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICBtaW51dGVzRW5kID0gZXZlbnQuZW5kRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgZW5kRGF0ZSA9IGV2ZW50LmVuZERhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kVGltZU1pbnV0ZXMgPSBwYXJzZUludChob3Vyc0VuZCkgKiA2MCArIHBhcnNlSW50KG1pbnV0ZXNFbmQpO1xuXG4gICAgICAgIHZhciBlbmQgPSBldmVudC5lbmQgfHwgZW5kRGF0ZUYgKyAnICcgKyBkYXRlX3V0aWxzX2Zvcm1hdFRpbWUoZW5kVGltZU1pbnV0ZXMpOyAvLyBDb3JyZWN0IHRoZSBjb21tb24gcHJhY3RpY2UgdG8gZW5kIGF0IDAwOjAwIG9yIDI0OjAwIHRvIGNvdW50IGEgZnVsbCBkYXkuXG5cblxuICAgICAgICBpZiAoIWVuZFRpbWVNaW51dGVzIHx8IGVuZFRpbWVNaW51dGVzID09PSB2dWVfY2FsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfbWludXRlc0luQURheSkge1xuICAgICAgICAgIGVuZERhdGUuc2V0U2Vjb25kcygtMSk7IC8vIEVuZCBhdCAyMzo1OTo1OS5cblxuICAgICAgICAgIGVuZERhdGVGID0gZm9ybWF0RGF0ZUxpdGUoZW5kRGF0ZSk7XG4gICAgICAgICAgZW5kVGltZU1pbnV0ZXMgPSB2dWVfY2FsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfbWludXRlc0luQURheTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtdWx0aXBsZURheXMgPSBzdGFydERhdGVGICE9PSBlbmREYXRlRjtcbiAgICAgICAgZXZlbnQgPSBPYmplY3QuYXNzaWduKF9vYmplY3RTcHJlYWQyKHt9LCBldmVudERlZmF1bHRzLCB7XG4gICAgICAgICAgLy8gS2VlcCB0aGUgZXZlbnQgaWRzIHNjb3BlZCB0byB0aGlzIGNhbGVuZGFyIGluc3RhbmNlLlxuICAgICAgICAgIF9laWQ6IFwiXCIuY29uY2F0KF90aGlzNC5fdWlkLCBcIl9cIikuY29uY2F0KF90aGlzNC5ldmVudElkSW5jcmVtZW50KyspLFxuICAgICAgICAgIHNlZ21lbnRzOiBtdWx0aXBsZURheXMgPyB7fSA6IG51bGwsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlLFxuICAgICAgICAgIHN0YXJ0VGltZU1pbnV0ZXM6IHN0YXJ0VGltZU1pbnV0ZXMsXG4gICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgZW5kRGF0ZTogZW5kRGF0ZSxcbiAgICAgICAgICBlbmRUaW1lTWludXRlczogZW5kVGltZU1pbnV0ZXMsXG4gICAgICAgICAgZGF5c0NvdW50OiBtdWx0aXBsZURheXMgPyBjb3VudERheXMoc3RhcnREYXRlLCBlbmREYXRlKSA6IDEsXG4gICAgICAgICAgY2xhc3NlczogKGV2ZW50LmNsYXNzIHx8ICcnKS5zcGxpdCgnICcpXG4gICAgICAgIH0pLCBldmVudCk7XG5cbiAgICAgICAgX3RoaXM0Lm11dGFibGVFdmVudHMucHVzaChldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgY3Vyc29yIGZyb20gdGhlIGNlbGxzIHdyYXBwZXIgcmVmZXJlbnRpYWwgKGByZWY9XCJjZWxsc1wiYCkuXG4gICAgICpcbiAgICAgKiBAdG9kbyBDYWNoZSBib3VuZGluZyBib3ggJiB1cGRhdGUgaXQgb24gcmVzaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBuYXRpdmUgRE9NIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvbnRhaW5pbmcgeyB4OiB7TnVtYmVyfSwgeToge051bWJlcn0gfVxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihlKSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuJHJlZnMuY2VsbHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBfcmVmID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmIGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICB5OiBjbGllbnRZIC0gcmVjdC50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIG1pbnV0ZXMgZnJvbSB0aGUgdG9wIHRvIHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgbmF0aXZlIERPTSBldmVudCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjb250YWluaW5nIHsgbWludXRlczoge051bWJlcn0sIGN1cnNvckNvb3JkczogeyB4OiB7TnVtYmVyfSwgeToge051bWJlcn0gfSB9XG4gICAgICovXG4gICAgbWludXRlc0F0Q3Vyc29yOiBmdW5jdGlvbiBtaW51dGVzQXRDdXJzb3IoZSkge1xuICAgICAgdmFyIG1pbnV0ZXMgPSAwO1xuICAgICAgdmFyIGN1cnNvckNvb3JkcyA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBlID09PSAnbnVtYmVyJykgbWludXRlcyA9IGU7ZWxzZSBpZiAoX3R5cGVvZihlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY3Vyc29yQ29vcmRzID0gdGhpcy5nZXRQb3NpdGlvbihlKTtcbiAgICAgICAgbWludXRlcyA9IE1hdGgucm91bmQoY3Vyc29yQ29vcmRzLnkgKiB0aGlzLnRpbWVTdGVwIC8gcGFyc2VJbnQodGhpcy50aW1lQ2VsbEhlaWdodCkgKyB0aGlzLnRpbWVGcm9tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICAgIGN1cnNvckNvb3JkczogY3Vyc29yQ29vcmRzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IGluIHZ1ZS1jYWwgbWVtb3J5IChpbiB0aGUgbXV0YWJsZUV2ZW50cyBhcnJheSkgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIGRhdGUgJiB0aW1lLlxuICAgICAqIFByb3h5IG1ldGhvZCB0byBhbGxvdyBjYWxsIGZyb20gY2VsbCBjbGljayAmIGhvbGQgb3IgZXh0ZXJuYWwgY2FsbCAodmlhICRyZWZzKS5cbiAgICAgKiBOb3RlczogRXZlbnQgZHVyYXRpb24gaXMgYnkgZGVmYXVsdCAyIGhvdXJzLiBZb3UgY2FuIG92ZXJyaWRlIHRoZSBldmVudCBlbmQgdGhyb3VnaCBldmVudE9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IERhdGV9IGRhdGVUaW1lIGRhdGUgJiB0aW1lIGF0IHdoaWNoIHRoZSBldmVudCB3aWxsIHN0YXJ0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE9wdGlvbnMgYW4gb2JqZWN0IG9mIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGV2ZW50IGNyZWF0aW9uIGRlZmF1bHRzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNhbiBiZSBhbnkga2V5IGFsbG93ZWQgaW4gYW4gZXZlbnQgb2JqZWN0KVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNyZWF0ZWQgZXZlbnQuXG4gICAgICovXG4gICAgY3JlYXRlRXZlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGRhdGVUaW1lKSB7XG4gICAgICB2YXIgZXZlbnRPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBldmVudF91dGlsc19jcmVhdGVBbkV2ZW50KGRhdGVUaW1lLCBldmVudE9wdGlvbnMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIHRoZSB2dWUtY2FsIHByaXZhdGUgdmFycyBmcm9tIHRoZSBldmVudCAoYmVmb3JlIHJldHVybmluZyBpdCB0aHJvdWdoICRlbWl0KCkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCBvYmplY3QgdG8gY2xlYW51cC5cbiAgICAgKi9cbiAgICBjbGVhbnVwRXZlbnQ6IGZ1bmN0aW9uIGNsZWFudXBFdmVudChldmVudCkge1xuICAgICAgZXZlbnQgPSBfb2JqZWN0U3ByZWFkMih7fSwgZXZlbnQpOyAvLyBEZWxldGUgdnVlLWNhbCBzcGVjaWZpYyBwcm9wcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIHNldCBvZiBwcm9wcyBzbyB1c2VyXG4gICAgICAvLyBjYW4gcGxhY2Ugd2hhdGV2ZXIgdGhleSB3YW50IGluc2lkZSBhbiBldmVudCBhbmQgc2VlIGl0IHJldHVybmVkLlxuXG4gICAgICB2YXIgZGlzY2FyZFByb3BzID0gWydoZWlnaHQnLCAndG9wJywgJ2NsYXNzZXMnLCAnc2VnbWVudHMnLCAnZGVsZXRhYmxlJywgJ2RlbGV0aW5nJywgJ3Jlc2l6YWJsZScsICdyZXNpemluZycsICdkcmFnZ2FibGUnLCAnZHJhZ2dpbmcnLCAnZHJhZ2dpbmdTdGF0aWMnLCAnZm9jdXNlZCddO1xuICAgICAgZGlzY2FyZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgaW4gZXZlbnQpIGRlbGV0ZSBldmVudFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFldmVudC5yZXBlYXQpIGRlbGV0ZSBldmVudC5yZXBlYXQ7IC8vIElmIGVtcHR5IHdlIGRvbid0IG5lZWQgaXQuXG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgKGN1c3RvbSBET00gZXZlbnQpIHRvIHRoZSBvdXRzaWRlIHdvcmxkLlxuICAgICAqIFRoaXMgZXZlbnQgaGFzIGFuIGV2ZW50IG5hbWUgYW5kIGEgY2xlYW4gY2FsZW5kYXIgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZW1pdHRlZCBldmVudCAoZS5nLiBgZXZlbnQtZm9jdXNgKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRvIHJldHVybiB0byB0aGUgb3V0c2lkZSB3b3JsZC5cbiAgICAgKi9cbiAgICBlbWl0V2l0aEV2ZW50OiBmdW5jdGlvbiBlbWl0V2l0aEV2ZW50KGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoZXZlbnROYW1lLCB0aGlzLmNsZWFudXBFdmVudChldmVudCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNlbGVjdGVkIGRhdGU6XG4gICAgICogLSBvbiBjcmVhdGVkLCBmcm9tIGdpdmVuIHNlbGVjdGVkRGF0ZSBwcm9wXG4gICAgICogLSBvbiBjbGljay9kYmxDbGljayBvZiBhbm90aGVyIGNlbGxcbiAgICAgKiAtIGZyb20gZXh0ZXJuYWwgY2FsbCAodmlhICRyZWZzKVxuICAgICAqIC0gd2hlbiB0aGUgZ2l2ZW4gc2VsZWN0ZWREYXRlIHByb3AgY2hhbmdlcy5cbiAgICAgKiBJZiBkYXRlIGlzIG5vdCBpbiB0aGUgdmlldywgdGhlIHZpZXcgd2lsbCBjaGFuZ2UgdG8gc2hvdyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgdXBkYXRlU2VsZWN0ZWREYXRlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZERhdGUoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgJiYgdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSBkYXRlID0gc3RyaW5nVG9EYXRlKGRhdGUpO2Vsc2UgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpOyAvLyBDbG9uZSB0byBrZWVwIG9yaWdpbmFsIHVudG91Y2hlZC5cblxuICAgICAgaWYgKGRhdGUgJiYgZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IHRoaXMudmlldy5zZWxlY3RlZERhdGU7XG4gICAgICAgIGlmIChzZWxlY3RlZERhdGUpIHRoaXMudHJhbnNpdGlvbkRpcmVjdGlvbiA9IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPiBkYXRlLmdldFRpbWUoKSA/ICdsZWZ0JyA6ICdyaWdodCc7IC8vIFNlbGVjdCB0aGUgZGF5IGF0IG1pZG5pZ2h0IGluIG9yZGVyIHRvIGFsbG93IGZldGNoaW5nIGV2ZW50cyBvbiB3aG9sZSBkYXkuXG4gICAgICAgIC8vIFNldHRpbmcgbWlsbGlzZWNvbmRzIHRvIDAgaXMgY3JpdGljYWwgYXMgd2VsbCBmb3IgdGltZXN0YW1wIGNvbXBhcmlzb24uXG5cbiAgICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZERhdGUgfHwgc2VsZWN0ZWREYXRlLmdldFRpbWUoKSAhPT0gZGF0ZS5nZXRUaW1lKCkpIHRoaXMudmlldy5zZWxlY3RlZERhdGUgPSBkYXRlO1xuICAgICAgICB0aGlzLnN3aXRjaFZpZXcodGhpcy52aWV3LmlkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIGRhdGUgYW5kIHJldHVybnMgdGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICogU2hvcnRoYW5kIGZ1bmN0aW9uLCB0byBhdm9pZCBwYXNzaW5nIHRoZSBsb2NhbGl6ZWQgdGV4dHMgZXZlcnl3aGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nIHwgRGF0ZX0gZGF0ZSB0aGUgZGF0ZSB0byBmb3JtYXQgLSBjYW4gY29udGFpbiB0aGUgdGltZSBpbmZvIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IHRoZSB3YW50ZWQgZm9ybWF0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ1lZWVktTU0tREQnO1xuICAgICAgcmV0dXJuIGRhdGVfdXRpbHNfZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMudGV4dHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgdGltZSBhbmQgcmV0dXJucyB0aGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKiBTaG9ydGhhbmQgZnVuY3Rpb24sIHRvIGF2b2lkIHBhc3NpbmcgdGhlIGNvbW1vbiBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSB0aGUgdGltZSB0byBmb3JtYXQgaW4gbWludXRlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IHRoZSB3YW50ZWQgZm9ybWF0LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGZvcm1hdHRlZCB0aW1lLlxuICAgICAqL1xuICAgIGZvcm1hdFRpbWU6IGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZGF0ZV91dGlsc19mb3JtYXRUaW1lKHRpbWUsIGZvcm1hdCB8fCB0aGlzLnRpbWVGb3JtYXQgfHwgKHRoaXMudHdlbHZlSG91ciA/ICdoOm1te2FtfScgOiAnSEg6bW0nKSwgdGhpcy50ZXh0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERvdWJsZSBjaGVja3MgdGhlIHdlZWsgbnVtYmVyIGlzIGNvcnJlY3QuIFJlYWQgYmVsbG93IHRvIHVuZGVyc3RhbmQhXG4gICAgICogdGhpcyBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBgZ2V0V2VlaygpYCBmdW5jdGlvbiBmb3IgcGVyZm9ybWFuY2U6XG4gICAgICogQXMgdGhpcyBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZnJvbSB0aGUgdGVtcGxhdGUgYW5kIGNhbm5vdCBiZSBpbiBjb21wdXRlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAqIGEgcGFyYW1ldGVyLCB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gYXZvaWRzIHRoZSBgZ2V0V2VlaygpYCBmdW5jdGlvbiBjYWxsIDUgdGltZXMgb3V0IG9mIDZcbiAgICAgKiB1c2luZyB0aGUgY29tcHV0ZWQgYGZpcnN0Q2VsbERhdGVXZWVrTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIFJlYXNvbiB3aHk6XG4gICAgICogR2V0dGluZyB0aGUgd2VlayBudW1iZXIgaXMgbm90IHRoYXQgc3RyYWlnaHRmb3J3YXJkIGFzIHRoZXJlIG1pZ2h0IGJlIGEgNTNyZCB3ZWVrIGluIHRoZSB5ZWFyLlxuICAgICAqIFdoZW5ldmVyIHRoZSB5ZWFyIHN0YXJ0cyBvbiBhIFRodXJzZGF5IG9yIGFueSBsZWFwIHllYXIgc3RhcnRpbmcgb24gYSBXZWRuZXNkYXksIHRoaXMgd2VlayB3aWxsIGJlIDUzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdlZWtGcm9tRmlyc3RDZWxsIE51bWJlciBmcm9tIDAgdG8gNi5cbiAgICAgKi9cbiAgICBnZXRXZWVrTnVtYmVyOiBmdW5jdGlvbiBnZXRXZWVrTnVtYmVyKHdlZWtGcm9tRmlyc3RDZWxsKSB7XG4gICAgICB2YXIgZmlyc3RDZWxsV2Vla051bWJlciA9IHRoaXMuZmlyc3RDZWxsRGF0ZVdlZWtOdW1iZXI7XG4gICAgICB2YXIgY3VycmVudFdlZWtOdW1iZXIgPSBmaXJzdENlbGxXZWVrTnVtYmVyICsgd2Vla0Zyb21GaXJzdENlbGw7XG4gICAgICB2YXIgbW9kaWZpZXIgPSB0aGlzLnN0YXJ0V2Vla09uU3VuZGF5ID8gMSA6IDA7XG5cbiAgICAgIGlmIChjdXJyZW50V2Vla051bWJlciA+IDUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZmlyc3RDZWxsRGF0ZS5hZGREYXlzKDcgKiB3ZWVrRnJvbUZpcnN0Q2VsbCArIG1vZGlmaWVyKS5nZXRXZWVrKCk7XG4gICAgICB9IGVsc2UgcmV0dXJuIGN1cnJlbnRXZWVrTnVtYmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbmx5IGlmIHdhdGNoUmVhbFRpbWUgaXMgdHJ1ZS5cbiAgICAgKiBQdWxsIHRoZSBjdXJyZW50IHRpbWUgZnJvbSB1c2VyIG1hY2hpbmUgZXZlcnkgbWludXRlIHRvIGtlZXAgdnVlLWNhbCBhY2N1cmF0ZSBldmVuIHdoZW4gaWRsZS5cbiAgICAgKiBUaGlzIHdpbGwgcmVkcmF3IHRoZSBub3cgbGluZSBldmVyeSBtaW51dGUgYW5kIGVuc3VyZSB0aGF0IFRvZGF5J3MgZGF0ZSBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgICovXG4gICAgdGltZVRpY2s6IGZ1bmN0aW9uIHRpbWVUaWNrKCkge1xuICAgICAgLy8gVXBkYXRpbmcgYG5vd2Agd2lsbCByZS10cmlnZ2VyIHRoZSBjb21wdXRlZCBgdG9kYXlzVGltZVBvc2l0aW9uYCBpbiBjZWxsLnZ1ZS5cbiAgICAgIHRoaXMubm93ID0gbmV3IERhdGUoKTtcbiAgICAgIHRoaXMudGltZVRpY2tlcklkc1sxXSA9IHNldFRpbWVvdXQodGhpcy50aW1lVGljaywgNjAgKiAxMDAwKTsgLy8gRXZlcnkgbWludXRlLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYWJsZSBmcm9tIG91dHNpZGUgb2YgVnVlIENhbC5cbiAgICAgKi9cbiAgICB1cGRhdGVEYXRlVGV4dHM6IGZ1bmN0aW9uIHVwZGF0ZURhdGVUZXh0cygpIHtcbiAgICAgIGRhdGVfdXRpbHNfdXBkYXRlRGF0ZVRleHRzKHRoaXMudGV4dHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBXaW5kb3dzIGRldmljZXMsIHRoZSAudnVlY2FsX19iZydzIHZlcnRpY2FsIHNjcm9sbGJhciB0YWtlcyBzcGFjZSBhbmQgcHVzaGVzIHRoZSBjb250ZW50LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIHB1c2ggdGhlIGFsbC1kYXkgYmFyIHRvIGhhdmUgaXQgcHJvcGVybHkgYWxpZ25lZC5cbiAgICAgKiBUaGUgY2FsY3VsYXRlZCBzdHlsZSB3aWxsIGJlIHBsYWNlZCBpbiB0aGUgZG9jbWVudCBoZWFkIGluIGEgc3R5bGUgdGFnIHNvIGl0J3Mgb25seSBkb25lIG9uY2VcbiAgICAgKiAodGhlIHNjcm9sbGJhciB3aWR0aCBuZXZlciBjaGFuZ2VzKS5cbiAgICAgKiBSZWYuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRvbmlhbmRyZS92dWUtY2FsL2lzc3Vlcy8yMjFcbiAgICAgKi9cbiAgICBhbGlnbkFsbERheUJhcjogZnVuY3Rpb24gYWxpZ25BbGxEYXlCYXIoKSB7XG4gICAgICAvLyBJZiBhbHJlYWR5IGRvbmUgZnJvbSBhbm90aGVyIGluc3RhbmNlLCBleGl0LlxuICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGlnbi1hbGwtZGF5LWJhcicpKSByZXR1cm47XG4gICAgICB2YXIgYmcgPSB0aGlzLiRyZWZzLnZ1ZWNhbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd2dWVjYWxfX2JnJylbMF07XG4gICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBiZy5vZmZzZXRXaWR0aCAtIGJnLmNoaWxkcmVuWzBdLm9mZnNldFdpZHRoOyAvLyBPbmx5IGFkZCBhIHN0eWxlIHRhZyBvbmNlIGFuZCBpZiBhIHNjcm9sbGJhciB3aWR0aCBpcyBkZXRlY3RlZC5cblxuICAgICAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gJ2FsaWduLWFsbC1kYXktYmFyJztcbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIHN0eWxlLmlubmVySFRNTCA9IFwiLnZ1ZWNhbF9fYWxsLWRheSB7cGFkZGluZy1yaWdodDogXCIuY29uY2F0KHNjcm9sbGJhcldpZHRoLCBcInB4fVwiKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMubG9hZExvY2FsZSh0aGlzLmxvY2FsZSk7XG5cbiAgICBkYXRlX3V0aWxzX3VwZGF0ZURhdGVUZXh0cyh0aGlzLnRleHRzKTsgLy8gSW5pdCB0aGUgYXJyYXkgb2YgZXZlbnRzLCB0aGVuIGtlZXAgbGlzdGVuaW5nIGZvciBjaGFuZ2VzIGluIHdhdGNoZXIuXG5cblxuICAgIHRoaXMudXBkYXRlTXV0YWJsZUV2ZW50cyh0aGlzLmV2ZW50cyk7XG4gICAgdGhpcy52aWV3LmlkID0gdGhpcy5kZWZhdWx0VmlldztcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGUpIHRoaXMudXBkYXRlU2VsZWN0ZWREYXRlKHRoaXMuc2VsZWN0ZWREYXRlKTtlbHNlIHtcbiAgICAgIHRoaXMudmlldy5zZWxlY3RlZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5zd2l0Y2hWaWV3KHRoaXMuZGVmYXVsdFZpZXcpO1xuICAgIH0gLy8gVGltZXJzIGFyZSBleHBlbnNpdmUsIHRoaXMgc2hvdWxkIG9ubHkgdHJpZ2dlciBvbiBkZW1hbmQuXG5cbiAgICBpZiAodGhpcy50aW1lICYmIHRoaXMud2F0Y2hSZWFsVGltZSkge1xuICAgICAgLy8gU25hcCB0aGUgdGltZSB0aWNrZXIgb24gc2hhcnAgbWludXRlcyAod2hlbiBzZWNvbmRzID0gMCksIHNvIHRoYXQgd2UgY2FuIHNldFxuICAgICAgLy8gdGhlIHRpbWUgdGlja2VyIGludGVydmFsIHRvIDYwIHNlY29uZHMgYW5kIHNwYXJlIHNvbWUgZnVuY3Rpb24gY2FsbHMuXG4gICAgICB0aGlzLnRpbWVUaWNrZXJJZHNbMF0gPSBzZXRUaW1lb3V0KHRoaXMudGltZVRpY2ssICg2MCAtIHRoaXMubm93LmdldFNlY29uZHMoKSkgKiAxMDAwKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuXG4gICAgaWYgKHRoaXMuZWRpdGFibGVFdmVudHMpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGhhc1RvdWNoID8gJ3RvdWNobW92ZScgOiAnbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihoYXNUb3VjaCA/ICd0b3VjaGVuZCcgOiAnbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcCk7XG4gICAgfSAvLyBEaXNhYmxlIGNvbnRleHQgbWVudSBvbiB0b3VjaCBkZXZpY2VzIG9uIHRoZSB3aG9sZSB2dWUtY2FsIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaGFzVG91Y2gpIHtcbiAgICAgIHRoaXMuJHJlZnMudnVlY2FsLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9O1xuICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudG9uaWFuZHJlL3Z1ZS1jYWwvaXNzdWVzLzIyMVxuXG5cbiAgICBpZiAodGhpcy5zaG93QWxsRGF5RXZlbnRzKSB0aGlzLmFsaWduQWxsRGF5QmFyKCk7IC8vIEVtaXQgdGhlIGByZWFkeWAgZXZlbnQgd2l0aCB1c2VmdWwgcGFyYW1ldGVycy5cblxuICAgIHZhciBzdGFydERhdGUgPSB0aGlzLnZpZXcuc3RhcnREYXRlO1xuXG4gICAgdmFyIHBhcmFtcyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHZpZXc6IHRoaXMudmlldy5pZCxcbiAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZTogdGhpcy52aWV3LmVuZERhdGVcbiAgICB9LCB0aGlzLnZpZXcuaWQgPT09ICdtb250aCcgPyB7XG4gICAgICBmaXJzdENlbGxEYXRlOiB0aGlzLnZpZXcuZmlyc3RDZWxsRGF0ZSxcbiAgICAgIGxhc3RDZWxsRGF0ZTogdGhpcy52aWV3Lmxhc3RDZWxsRGF0ZVxuICAgIH0gOiB7fSwge1xuICAgICAgZXZlbnRzOiB0aGlzLnZpZXcuZXZlbnRzLm1hcCh0aGlzLmNsZWFudXBFdmVudClcbiAgICB9LCB0aGlzLnZpZXcuaWQgPT09ICd3ZWVrJyA/IHtcbiAgICAgIHdlZWs6IHRoaXMuc3RhcnRXZWVrT25TdW5kYXkgPyBzdGFydERhdGUuYWRkRGF5cygxKS5nZXRXZWVrKCkgOiBzdGFydERhdGUuZ2V0V2VlaygpXG4gICAgfSA6IHt9KTtcblxuICAgIHRoaXMuJGVtaXQoJ3JlYWR5JywgcGFyYW1zKTtcbiAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB2YXIgaGFzVG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFzVG91Y2ggPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGhhc1RvdWNoID8gJ3RvdWNoZW5kJyA6ICdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcCk7IC8vIERvbid0IGtlZXAgdGhlIHRpY2tpbmcgcnVubmluZyBpZiB1bnVzZWQuXG5cbiAgICBpZiAodGhpcy50aW1lVGlja2VySWRzWzBdKSBjbGVhclRpbWVvdXQodGhpcy50aW1lVGlja2VySWRzWzBdKTtcbiAgICBpZiAodGhpcy50aW1lVGlja2VySWRzWzFdKSBjbGVhclRpbWVvdXQodGhpcy50aW1lVGlja2VySWRzWzFdKTtcbiAgICB0aGlzLnRpbWVUaWNrZXJJZHMgPSBbbnVsbCwgbnVsbF07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdmlld3M6IGZ1bmN0aW9uIHZpZXdzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy50ZXh0cy55ZWFycyxcbiAgICAgICAgICBlbmFibGVkOiAhdGhpcy5kaXNhYmxlVmlld3MuaW5jbHVkZXMoJ3llYXJzJylcbiAgICAgICAgfSxcbiAgICAgICAgeWVhcjoge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLnRleHRzLnllYXIsXG4gICAgICAgICAgZW5hYmxlZDogIXRoaXMuZGlzYWJsZVZpZXdzLmluY2x1ZGVzKCd5ZWFyJylcbiAgICAgICAgfSxcbiAgICAgICAgbW9udGg6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy50ZXh0cy5tb250aCxcbiAgICAgICAgICBlbmFibGVkOiAhdGhpcy5kaXNhYmxlVmlld3MuaW5jbHVkZXMoJ21vbnRoJylcbiAgICAgICAgfSxcbiAgICAgICAgd2Vlazoge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLnRleHRzLndlZWssXG4gICAgICAgICAgZW5hYmxlZDogIXRoaXMuZGlzYWJsZVZpZXdzLmluY2x1ZGVzKCd3ZWVrJylcbiAgICAgICAgfSxcbiAgICAgICAgZGF5OiB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMudGV4dHMuZGF5LFxuICAgICAgICAgIGVuYWJsZWQ6ICF0aGlzLmRpc2FibGVWaWV3cy5pbmNsdWRlcygnZGF5JylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGhhc1RpbWVDb2x1bW46IGZ1bmN0aW9uIGhhc1RpbWVDb2x1bW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lICYmIFsnd2VlaycsICdkYXknXS5pbmNsdWRlcyh0aGlzLnZpZXcuaWQpO1xuICAgIH0sXG4gICAgaXNTaG9ydE1vbnRoVmlldzogZnVuY3Rpb24gaXNTaG9ydE1vbnRoVmlldygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuaWQgPT09ICdtb250aCcgJiYgdGhpcy5ldmVudHNPbk1vbnRoVmlldyA9PT0gJ3Nob3J0JztcbiAgICB9LFxuICAgIGZpcnN0Q2VsbERhdGVXZWVrTnVtYmVyOiBmdW5jdGlvbiBmaXJzdENlbGxEYXRlV2Vla051bWJlcigpIHtcbiAgICAgIHZhciBkYXRlID0gdGhpcy52aWV3LmZpcnN0Q2VsbERhdGU7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydFdlZWtPblN1bmRheSA/IGRhdGUuYWRkRGF5cygxKS5nZXRXZWVrKCkgOiBkYXRlLmdldFdlZWsoKTtcbiAgICB9LFxuICAgIC8vIEZvciB3ZWVrICYgZGF5IHZpZXdzLlxuICAgIHRpbWVDZWxsczogZnVuY3Rpb24gdGltZUNlbGxzKCkge1xuICAgICAgdmFyIHRpbWVDZWxscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50aW1lRnJvbSwgbWF4ID0gdGhpcy50aW1lVG87IGkgPCBtYXg7IGkgKz0gdGhpcy50aW1lU3RlcCkge1xuICAgICAgICB0aW1lQ2VsbHMucHVzaCh7XG4gICAgICAgICAgaG91cnM6IE1hdGguZmxvb3IoaSAvIDYwKSxcbiAgICAgICAgICBtaW51dGVzOiBpICUgNjAsXG4gICAgICAgICAgbGFiZWw6IHRoaXMuZm9ybWF0VGltZShpKSxcbiAgICAgICAgICB2YWx1ZTogaVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpbWVDZWxscztcbiAgICB9LFxuICAgIC8vIEZpbHRlciBvdXQgdGhlIGRheSBzcGxpdHMgdGhhdCBhcmUgaGlkZGVuLlxuICAgIGRheVNwbGl0czogZnVuY3Rpb24gZGF5U3BsaXRzKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnNwbGl0RGF5cy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFpdGVtLmhpZGU7XG4gICAgICB9KSB8fCBbXSkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgaXRlbSwge1xuICAgICAgICAgIGlkOiBpdGVtLmlkIHx8IGkgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSkgLy8gTWFrZSBzdXJlIHRoZXJlJ3MgYWx3YXlzIGFuIGlkLlxuICAgICAgO1xuICAgIH0sXG4gICAgLy8gV2hldGhlciB0aGUgY3VycmVudCB2aWV3IGhhcyBkYXlzIHNwbGl0cy5cbiAgICBoYXNTcGxpdHM6IGZ1bmN0aW9uIGhhc1NwbGl0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmRheVNwbGl0cy5sZW5ndGggJiYgWyd3ZWVrJywgJ2RheSddLmluY2x1ZGVzKHRoaXMudmlldy5pZCk7XG4gICAgfSxcbiAgICBjb250ZW50TWluV2lkdGg6IGZ1bmN0aW9uIGNvbnRlbnRNaW5XaWR0aCgpIHtcbiAgICAgIHZhciBtaW5XaWR0aCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5oYXNTcGxpdHMgJiYgdGhpcy5taW5TcGxpdFdpZHRoKSBtaW5XaWR0aCA9IHRoaXMudmlzaWJsZURheXNDb3VudCAqIHRoaXMubWluU3BsaXRXaWR0aCAqIHRoaXMuZGF5U3BsaXRzLmxlbmd0aDtlbHNlIGlmICh0aGlzLm1pbkNlbGxXaWR0aCAmJiB0aGlzLnZpZXcuaWQgPT09ICd3ZWVrJykgbWluV2lkdGggPSB0aGlzLnZpc2libGVEYXlzQ291bnQgKiB0aGlzLm1pbkNlbGxXaWR0aDtcbiAgICAgIHJldHVybiBtaW5XaWR0aDtcbiAgICB9LFxuICAgIG1pblRpbWVzdGFtcDogZnVuY3Rpb24gbWluVGltZXN0YW1wKCkge1xuICAgICAgdmFyIGRhdGUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMubWluRGF0ZSAmJiB0eXBlb2YgdGhpcy5taW5EYXRlID09PSAnc3RyaW5nJykgZGF0ZSA9IHN0cmluZ1RvRGF0ZSh0aGlzLm1pbkRhdGUpO2Vsc2UgaWYgKHRoaXMubWluRGF0ZSAmJiB0aGlzLm1pbkRhdGUgaW5zdGFuY2VvZiBEYXRlKSBkYXRlID0gdGhpcy5taW5EYXRlO1xuICAgICAgcmV0dXJuIGRhdGUgPyBkYXRlLmdldFRpbWUoKSA6IG51bGw7XG4gICAgfSxcbiAgICBtYXhUaW1lc3RhbXA6IGZ1bmN0aW9uIG1heFRpbWVzdGFtcCgpIHtcbiAgICAgIHZhciBkYXRlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm1heERhdGUgJiYgdHlwZW9mIHRoaXMubWF4RGF0ZSA9PT0gJ3N0cmluZycpIGRhdGUgPSBzdHJpbmdUb0RhdGUodGhpcy5tYXhEYXRlKTtlbHNlIGlmICh0aGlzLm1heERhdGUgJiYgdGhpcy5taW5EYXRlIGluc3RhbmNlb2YgRGF0ZSkgZGF0ZSA9IHRoaXMubWF4RGF0ZTtcbiAgICAgIHJldHVybiBkYXRlID8gZGF0ZS5nZXRUaW1lKCkgOiBudWxsO1xuICAgIH0sXG4gICAgd2Vla0RheXM6IGZ1bmN0aW9uIHdlZWtEYXlzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyR0ZXh0cyA9IHRoaXMudGV4dHMsXG4gICAgICAgICAgd2Vla0RheXMgPSBfdGhpcyR0ZXh0cy53ZWVrRGF5cyxcbiAgICAgICAgICBfdGhpcyR0ZXh0cyR3ZWVrRGF5c1MgPSBfdGhpcyR0ZXh0cy53ZWVrRGF5c1Nob3J0LFxuICAgICAgICAgIHdlZWtEYXlzU2hvcnQgPSBfdGhpcyR0ZXh0cyR3ZWVrRGF5c1MgPT09IHZvaWQgMCA/IFtdIDogX3RoaXMkdGV4dHMkd2Vla0RheXNTOyAvLyBEbyBub3QgbW9kaWZ5IG9yaWdpbmFsIGZvciBuZXh0IGluc3RhbmNlcy5cblxuICAgICAgd2Vla0RheXMgPSB3ZWVrRGF5cy5zbGljZSgwKS5tYXAoZnVuY3Rpb24gKGRheSwgaSkge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGxhYmVsOiBkYXlcbiAgICAgICAgfSwgd2Vla0RheXNTaG9ydC5sZW5ndGggPyB7XG4gICAgICAgICAgc2hvcnQ6IHdlZWtEYXlzU2hvcnRbaV1cbiAgICAgICAgfSA6IHt9LCB7XG4gICAgICAgICAgaGlkZTogX3RoaXM1LmhpZGVXZWVrZW5kcyAmJiBpID49IDUgfHwgX3RoaXM1LmhpZGVXZWVrZGF5cy5sZW5ndGggJiYgX3RoaXM1LmhpZGVXZWVrZGF5cy5pbmNsdWRlcyhpICsgMSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0V2Vla09uU3VuZGF5KSB3ZWVrRGF5cy51bnNoaWZ0KHdlZWtEYXlzLnBvcCgpKTtcbiAgICAgIHJldHVybiB3ZWVrRGF5cztcbiAgICB9LFxuICAgIHdlZWtEYXlzSW5IZWFkZXI6IGZ1bmN0aW9uIHdlZWtEYXlzSW5IZWFkZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LmlkID09PSAnbW9udGgnIHx8IHRoaXMudmlldy5pZCA9PT0gJ3dlZWsnICYmICF0aGlzLm1pbkNlbGxXaWR0aCAmJiAhdGhpcy5taW5TcGxpdFdpZHRoO1xuICAgIH0sXG4gICAgbW9udGhzOiBmdW5jdGlvbiBtb250aHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0cy5tb250aHMubWFwKGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhYmVsOiBtb250aFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBQcmVwYXJlIHRoZSBzcGVjaWFsIGhvdXJzIG9iamVjdCBvbmNlIGZvciBhbGwgYXQgcm9vdCBsZXZlbCBhbmQgbm90IGluIGNlbGwuXG4gICAgc3BlY2lhbERheUhvdXJzOiBmdW5jdGlvbiBzcGVjaWFsRGF5SG91cnMoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmV0dXJuIEFycmF5KDcpLmZpbGwoJycpLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkge1xuICAgICAgICB2YXIgX3JlZjIgPSBfdGhpczYuc3BlY2lhbEhvdXJzW2kgKyAxXSB8fCB7fSxcbiAgICAgICAgICAgIGZyb20gPSBfcmVmMi5mcm9tLFxuICAgICAgICAgICAgdG8gPSBfcmVmMi50byxcbiAgICAgICAgICAgIENsYXNzID0gX3JlZjIuY2xhc3M7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXk6IGkgKyAxLFxuICAgICAgICAgIGZyb206ICFbbnVsbCwgdW5kZWZpbmVkXS5pbmNsdWRlcyhmcm9tKSA/IGZyb20gKiAxIDogbnVsbCxcbiAgICAgICAgICB0bzogIVtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHRvKSA/IHRvICogMSA6IG51bGwsXG4gICAgICAgICAgY2xhc3M6IENsYXNzIHx8ICcnXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHZpZXdUaXRsZTogZnVuY3Rpb24gdmlld1RpdGxlKCkge1xuICAgICAgdmFyIHRpdGxlID0gJyc7XG4gICAgICB2YXIgZGF0ZSA9IHRoaXMudmlldy5zdGFydERhdGU7XG4gICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblxuICAgICAgc3dpdGNoICh0aGlzLnZpZXcuaWQpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy50ZXh0cy55ZWFycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZSA9IHllYXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlID0gXCJcIi5jb25jYXQodGhpcy5tb250aHNbbW9udGhdLmxhYmVsLCBcIiBcIikuY29uY2F0KHllYXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsYXN0RGF5T2ZXZWVrID0gdGhpcy52aWV3LmVuZERhdGU7IC8vIE1pZ2h0IGJlIGFub3RoZXIgZGF5IHRoYW4gU3VuZGF5LCBpZiBoaWRpbmcgZGF5cy5cblxuICAgICAgICAgICAgdmFyIHkxID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIG0xID0gdGhpcy50ZXh0cy5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnhzbWFsbCkgbTEgPSBtMS5zdWJzdHJpbmcoMCwgMyk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkTW9udGhZZWFyID0gXCJcIi5jb25jYXQobTEsIFwiIFwiKS5jb25jYXQoeTEpOyAvLyBJZiB3ZWVrIGlzIG5vdCBlbmRpbmcgaW4gdGhlIHNhbWUgbW9udGggaXQgc3RhcnRlZCBpbi5cblxuICAgICAgICAgICAgaWYgKGxhc3REYXlPZldlZWsuZ2V0TW9udGgoKSAhPT0gZGF0ZS5nZXRNb250aCgpKSB7XG4gICAgICAgICAgICAgIHZhciB5MiA9IGxhc3REYXlPZldlZWsuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgdmFyIG0yID0gdGhpcy50ZXh0cy5tb250aHNbbGFzdERheU9mV2Vlay5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMueHNtYWxsKSBtMiA9IG0yLnN1YnN0cmluZygwLCAzKTtcbiAgICAgICAgICAgICAgaWYgKHkxID09PSB5MikgZm9ybWF0dGVkTW9udGhZZWFyID0gXCJcIi5jb25jYXQobTEsIFwiIC0gXCIpLmNvbmNhdChtMiwgXCIgXCIpLmNvbmNhdCh5MSk7ZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc21hbGwpIGZvcm1hdHRlZE1vbnRoWWVhciA9IFwiXCIuY29uY2F0KG0xLnN1YnN0cmluZygwLCAzKSwgXCIgXCIpLmNvbmNhdCh5MSwgXCIgLSBcIikuY29uY2F0KG0yLnN1YnN0cmluZygwLCAzKSwgXCIgXCIpLmNvbmNhdCh5Mik7ZWxzZSBmb3JtYXR0ZWRNb250aFllYXIgPSBcIlwiLmNvbmNhdChtMSwgXCIgXCIpLmNvbmNhdCh5MSwgXCIgLSBcIikuY29uY2F0KG0yLCBcIiBcIikuY29uY2F0KHkyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aXRsZSA9IFwiXCIuY29uY2F0KHRoaXMudGV4dHMud2VlaywgXCIgXCIpLmNvbmNhdCh0aGlzLnN0YXJ0V2Vla09uU3VuZGF5ID8gZGF0ZS5hZGREYXlzKDEpLmdldFdlZWsoKSA6IGRhdGUuZ2V0V2VlaygpLCBcIiAoXCIpLmNvbmNhdChmb3JtYXR0ZWRNb250aFllYXIsIFwiKVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5mb3JtYXREYXRlKGRhdGUsIHRoaXMudGV4dHMuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9LFxuICAgIHZpZXdDZWxsczogZnVuY3Rpb24gdmlld0NlbGxzKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgdmFyIGZyb21ZZWFyID0gbnVsbDtcbiAgICAgIHZhciB0b2RheUZvdW5kID0gZmFsc2U7IC8vIElmIHdhdGNoUmVhbFRpbWUgPSB0cnVlLCBhIHRpbWUgdGlja2VyIHdpbGwga2VlcCB1cGRhdGluZyB0aGlzLm5vdyBldmVyeSBtaW51dGUuXG4gICAgICAvLyBJZiB3YXRjaFJlYWxUaW1lID0gZmFsc2UgLSBhbmQgYnkgZGVmYXVsdCAtIHVwZGF0ZSB0aGlzLm5vdyB2YWx1ZSBlYWNoIHRpbWUgd2UgcmVyZW5kZXIgdGhlIGNlbGxzXG4gICAgICAvLyBzbyB3ZSBrZWVwIFRvZGF5J3MgZGF0ZSBhbHdheXMgYWNjdXJhdGUgYXQgYSBtaW5pbXVtIGNvc3QgYW5kIG1heGltdW0gcGVyZm9ybWFuY2UuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICAgICAgaWYgKCF0aGlzLndhdGNoUmVhbFRpbWUpIHRoaXMubm93ID0gbmV3IERhdGUoKTtcbiAgICAgIHZhciBub3cgPSB0aGlzLm5vdztcblxuICAgICAgc3dpdGNoICh0aGlzLnZpZXcuaWQpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZyb21ZZWFyID0gdGhpcy52aWV3LnN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgY2VsbHMgPSBBcnJheS5hcHBseShudWxsLCBBcnJheSgyNSkpLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gbmV3IERhdGUoZnJvbVllYXIgKyBpLCAwLCAxKTtcbiAgICAgICAgICAgICAgdmFyIGVuZERhdGUgPSBuZXcgRGF0ZShmcm9tWWVhciArIGkgKyAxLCAwLCAxKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRTZWNvbmRzKC0xKTsgLy8gRW5kIGF0IDIzOjU5OjU5LlxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRGF0ZTogZm9ybWF0RGF0ZUxpdGUoc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICBlbmREYXRlOiBlbmREYXRlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZyb21ZZWFyICsgaSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBmcm9tWWVhciArIGkgPT09IG5vdy5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmcm9tWWVhciA9IHRoaXMudmlldy5zdGFydERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIGNlbGxzID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoMTIpKS5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGZyb21ZZWFyLCBpLCAxKTtcbiAgICAgICAgICAgICAgdmFyIGVuZERhdGUgPSBuZXcgRGF0ZShmcm9tWWVhciwgaSArIDEsIDEpO1xuICAgICAgICAgICAgICBlbmREYXRlLnNldFNlY29uZHMoLTEpOyAvLyBFbmQgYXQgMjM6NTk6NTkuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWREYXRlOiBmb3JtYXREYXRlTGl0ZShzdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIGVuZERhdGU6IGVuZERhdGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogX3RoaXM3LnhzbWFsbCA/IF90aGlzNy5tb250aHNbaV0ubGFiZWwuc3Vic3RyKDAsIDMpIDogX3RoaXM3Lm1vbnRoc1tpXS5sYWJlbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBpID09PSBub3cuZ2V0TW9udGgoKSAmJiBmcm9tWWVhciA9PT0gbm93LmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbW9udGggPSB0aGlzLnZpZXcuc3RhcnREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB2YXIgZmlyc3RDZWxsRGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlldy5maXJzdENlbGxEYXRlKTtcbiAgICAgICAgICAgIHRvZGF5Rm91bmQgPSBmYWxzZTsgLy8gQ3JlYXRlIDQyIGNlbGxzICg2IHJvd3MgeCA3IGRheXMpIGFuZCBwb3B1bGF0ZSB0aGVtIHdpdGggZGF5cy5cblxuICAgICAgICAgICAgY2VsbHMgPSBBcnJheS5hcHBseShudWxsLCBBcnJheSg0MikpLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnREYXRlID0gZmlyc3RDZWxsRGF0ZS5hZGREYXlzKGkpO1xuICAgICAgICAgICAgICB2YXIgZW5kRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoMjMsIDU5LCA1OSwgMCk7IC8vIEVuZCBhdCAyMzo1OTo1OS5cbiAgICAgICAgICAgICAgLy8gVG8gaW5jcmVhc2UgcGVyZm9ybWFuY2Ugc2tpcCBjaGVja2luZyBpc1RvZGF5IGlmIHRvZGF5IGFscmVhZHkgZm91bmQuXG5cbiAgICAgICAgICAgICAgdmFyIGlzVG9kYXkgPSAhdG9kYXlGb3VuZCAmJiBzdGFydERhdGUuaXNUb2RheSgpICYmICF0b2RheUZvdW5kKys7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkRGF0ZTogZm9ybWF0RGF0ZUxpdGUoc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICBlbmREYXRlOiBlbmREYXRlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0YXJ0RGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICAgICAgdG9kYXk6IGlzVG9kYXksXG4gICAgICAgICAgICAgICAgb3V0T2ZTY29wZTogc3RhcnREYXRlLmdldE1vbnRoKCkgIT09IG1vbnRoXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZVdlZWtlbmRzIHx8IHRoaXMuaGlkZVdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjZWxscyA9IGNlbGxzLmZpbHRlcihmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXkgPSBjZWxsLnN0YXJ0RGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRheSkgZGF5ID0gNzsgLy8gUHV0IFN1bmRheSBhdCBwb3NpdGlvbiA3IGluc3RlYWQgb2YgMC5cblxuICAgICAgICAgICAgICAgIHJldHVybiAhKF90aGlzNy5oaWRlV2Vla2VuZHMgJiYgZGF5ID49IDYgfHwgX3RoaXM3LmhpZGVXZWVrZGF5cy5sZW5ndGggJiYgX3RoaXM3LmhpZGVXZWVrZGF5cy5pbmNsdWRlcyhkYXkpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0b2RheUZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB0aGlzLnZpZXcuc3RhcnREYXRlO1xuICAgICAgICAgICAgdmFyIHdlZWtEYXlzID0gdGhpcy53ZWVrRGF5cztcbiAgICAgICAgICAgIGNlbGxzID0gd2Vla0RheXMubWFwKGZ1bmN0aW9uIChjZWxsLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydERhdGUgPSBmaXJzdERheU9mV2Vlay5hZGREYXlzKGkpO1xuICAgICAgICAgICAgICB2YXIgZW5kRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoMjMsIDU5LCA1OSwgMCk7IC8vIEVuZCBhdCAyMzo1OTo1OS5cblxuICAgICAgICAgICAgICB2YXIgZGF5T2ZXZWVrID0gKHN0YXJ0RGF0ZS5nZXREYXkoKSAtIDEgKyA3KSAlIDc7IC8vIERheSBvZiB0aGUgd2VlayBmcm9tIDAgdG8gNiB3aXRoIDYgPSBTdW5kYXkuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWREYXRlOiBmb3JtYXREYXRlTGl0ZShzdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIGVuZERhdGU6IGVuZERhdGUsXG4gICAgICAgICAgICAgICAgLy8gVG8gaW5jcmVhc2UgcGVyZm9ybWFuY2Ugc2tpcCBjaGVja2luZyBpc1RvZGF5IGlmIHRvZGF5IGFscmVhZHkgZm91bmQuXG4gICAgICAgICAgICAgICAgdG9kYXk6ICF0b2RheUZvdW5kICYmIHN0YXJ0RGF0ZS5pc1RvZGF5KCkgJiYgIXRvZGF5Rm91bmQrKyxcbiAgICAgICAgICAgICAgICBzcGVjaWFsSG91cnM6IF90aGlzNy5zcGVjaWFsRGF5SG91cnNbZGF5T2ZXZWVrXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjZWxsLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhd2Vla0RheXNbaV0uaGlkZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IHRoaXMudmlldy5zdGFydERhdGU7XG4gICAgICAgICAgICB2YXIgZW5kRGF0ZSA9IG5ldyBEYXRlKHRoaXMudmlldy5zdGFydERhdGUpO1xuICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycygyMywgNTksIDU5LCAwKTsgLy8gRW5kIGF0IDIzOjU5OjU5LlxuXG4gICAgICAgICAgICB2YXIgZGF5T2ZXZWVrID0gKHN0YXJ0RGF0ZS5nZXREYXkoKSAtIDEgKyA3KSAlIDc7IC8vIERheSBvZiB0aGUgd2VlayBmcm9tIDAgdG8gNiB3aXRoIDYgPSBTdW5kYXkuXG5cbiAgICAgICAgICAgIGNlbGxzID0gW3tcbiAgICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUsXG4gICAgICAgICAgICAgIGZvcm1hdHRlZERhdGU6IGZvcm1hdERhdGVMaXRlKHN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgIGVuZERhdGU6IGVuZERhdGUsXG4gICAgICAgICAgICAgIHRvZGF5OiBzdGFydERhdGUuaXNUb2RheSgpLFxuICAgICAgICAgICAgICBzcGVjaWFsSG91cnM6IHRoaXMuc3BlY2lhbERheUhvdXJzW2RheU9mV2Vla11cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSxcbiAgICAvLyBPbmx5IHdoZW4gaGlkaW5nIHdlZWtkYXlzIG9uIG1vbnRoIGFuZCB3ZWVrIHZpZXdzLlxuICAgIHZpc2libGVEYXlzQ291bnQ6IGZ1bmN0aW9uIHZpc2libGVEYXlzQ291bnQoKSB7XG4gICAgICBpZiAodGhpcy52aWV3LmlkID09PSAnZGF5JykgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gNyAtIHRoaXMud2Vla0RheXMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgZGF5KSB7XG4gICAgICAgIHJldHVybiB0b3RhbCArIGRheS5oaWRlO1xuICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICBjZWxsV2lkdGg6IGZ1bmN0aW9uIGNlbGxXaWR0aCgpIHtcbiAgICAgIHJldHVybiAxMDAgLyB0aGlzLnZpc2libGVEYXlzQ291bnQ7XG4gICAgfSxcbiAgICBjc3NDbGFzc2VzOiBmdW5jdGlvbiBjc3NDbGFzc2VzKCkge1xuICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICByZXR1cm4gX3JlZjMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCBcInZ1ZWNhbC0tXCIuY29uY2F0KHRoaXMudmlldy5pZCwgXCItdmlld1wiKSwgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgXCJ2dWVjYWwtLVwiLmNvbmNhdCh0aGlzLmxvY2FsZSksIHRoaXMubG9jYWxlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCAndnVlY2FsLS1uby10aW1lJywgIXRoaXMudGltZSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tdmlldy13aXRoLXRpbWUnLCB0aGlzLmhhc1RpbWVDb2x1bW4pLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsICd2dWVjYWwtLXdlZWstbnVtYmVycycsIHRoaXMuc2hvd1dlZWtOdW1iZXJzICYmIHRoaXMudmlldy5pZCA9PT0gJ21vbnRoJyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tdHdlbHZlLWhvdXInLCB0aGlzLnR3ZWx2ZUhvdXIpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsICd2dWVjYWwtLWNsaWNrLXRvLW5hdmlnYXRlJywgdGhpcy5jbGlja1RvTmF2aWdhdGUpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsICd2dWVjYWwtLWhpZGUtd2Vla2VuZHMnLCB0aGlzLmhpZGVXZWVrZW5kcyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tc3BsaXQtZGF5cycsIHRoaXMuaGFzU3BsaXRzKSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCAndnVlY2FsLS1zdGlja3ktc3BsaXQtbGFiZWxzJywgdGhpcy5oYXNTcGxpdHMgJiYgdGhpcy5zdGlja3lTcGxpdExhYmVscyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tb3ZlcmZsb3cteCcsIHRoaXMubWluQ2VsbFdpZHRoICYmIHRoaXMudmlldy5pZCA9PT0gJ3dlZWsnIHx8IHRoaXMuaGFzU3BsaXRzICYmIHRoaXMubWluU3BsaXRXaWR0aCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tc21hbGwnLCB0aGlzLnNtYWxsKSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCAndnVlY2FsLS14c21hbGwnLCB0aGlzLnhzbWFsbCksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tcmVzaXppbmctZXZlbnQnLCB0aGlzLmRvbUV2ZW50cy5yZXNpemVBbkV2ZW50LmVuZFRpbWVNaW51dGVzKSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCAndnVlY2FsLS1kcmFnZ2luZy1ldmVudCcsIHRoaXMuZG9tRXZlbnRzLmRyYWdBbkV2ZW50Ll9laWQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsICd2dWVjYWwtLWV2ZW50cy1vbi1tb250aC12aWV3JywgdGhpcy5ldmVudHNPbk1vbnRoVmlldyksIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgJ3Z1ZWNhbC0tc2hvcnQtZXZlbnRzJywgdGhpcy52aWV3LmlkID09PSAnbW9udGgnICYmIHRoaXMuZXZlbnRzT25Nb250aFZpZXcgPT09ICdzaG9ydCcpLCBfcmVmMztcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZXZlbnRzOiB7XG4gICAgICAvLyBUbyBiZSBhYmxlIHRvIGRldGVjdCBhbiBldmVudCBhdHRyaWJ1dGUgY2hhbmdlLCBpdCBoYXMgdG8gYmUgZmlyc3QgaW5pdGlhbGl6ZWQgd2l0aCBhIHZhbHVlLlxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihldmVudHMsIG9sZEV2ZW50cykge1xuICAgICAgICB0aGlzLnVwZGF0ZU11dGFibGVFdmVudHMoZXZlbnRzKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudHNUb1ZpZXcoKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfSxcbiAgICBsb2NhbGU6IGZ1bmN0aW9uIGxvY2FsZShfbG9jYWxlKSB7XG4gICAgICB0aGlzLmxvYWRMb2NhbGUoX2xvY2FsZSk7XG4gICAgfSxcbiAgICBzZWxlY3RlZERhdGU6IGZ1bmN0aW9uIHNlbGVjdGVkRGF0ZShkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkRGF0ZShkYXRlKTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX3Z1ZV9jYWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAodnVlX2NhbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy92dWUtY2FsL2luZGV4LnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIHZ1ZV9jYWxfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX3Z1ZV9jYWx2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdnVlX2NhbCA9ICh2dWVfY2FsX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL2VudHJ5LWxpYi5qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVudHJ5X2xpYiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHZ1ZV9jYWwpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmI2YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThiNVwiKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNjYlwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGM0XCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0MThcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZGRlXCIpO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlNDBcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKTtcbnZhciBVU0VTX1RPX0xFTkdUSCA9IGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoKCdzbGljZScsIHsgQUNDRVNTT1JTOiB0cnVlLCAwOiAwLCAxOiAyIH0pO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB8fCAhVVNFU19UT19MRU5HVEggfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheShPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmM2YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRhZFwiKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFkODBcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmRiY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmZGJmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5MzBcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgIVN5bWJvbC5zaGFtXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZlYTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5Qcm9taXNlO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pW1wiZGVmYXVsdFwiXTsiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS03LW9uZU9mLTMtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNy1vbmVPZi0zLTIhLi92dWVjYWwuY3NzXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMWY0YWZiM2VcIiwgY29udGVudCwgZmFsc2UsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTctb25lT2YtMy0xIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS03LW9uZU9mLTMtMiEuL3Z1ZWNhbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS03LW9uZU9mLTMtMSEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNy1vbmVPZi0zLTIhLi92dWVjYWwuY3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9jYWxlbmRhclllYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzJlwiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI2NjYxYjY4MlwiLCBjb250ZW50LCBmYWxzZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2NhbGVuZGFyWWVhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0yIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2NhbGVuZGFyWWVhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yOTY0ZjIxYiZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjBkZjdhYmVlXCIsIGNvbnRlbnQsIGZhbHNlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOS1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0zIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9Mjk2NGYyMWImbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS05LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yOTY0ZjIxYiZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCByZXF1ZXN0IGZyb20gXCIuL3JlcXVlc3RcIjtcclxuXHJcbi8qKlxyXG4gKiDojrflj5blhajlubTml6XljobmlbDmja5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxZZWFyQ2FsZW5kZXIoe3R5cGUsIGlkLCB5ek5hbWUsIHllYXJ9KSB7XHJcbiAgcmV0dXJuIHJlcXVlc3Qoe1xyXG4gICAgdXJsOiAnaHR0cDovLzExNi41Mi42LjExODoxODg5OS9LUVpMWVpXL2hvbWUvZ2V0WWVhclJMJyxcclxuICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICBwYXJhbXM6IHtcclxuICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgaWQ6IGlkLFxyXG4gICAgICB5ek5hbWU6IHl6TmFtZSB8fCAnQVFJJyxcclxuICAgICAgeWVhcjogeWVhclxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICog56m65rCU5pel5Y6GXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlBaXJDYWxlbmRlcih7aWQsIHRpbWUsIHl6TmFtZX0pIHtcclxuICByZXR1cm4gcmVxdWVzdCh7XHJcbiAgICB1cmw6ICdodHRwOi8vMTE2LjUyLjYuMTE4OjE4ODk5L0tRWkxZWlcvaG9tZS9nZXRLUVJMJyxcclxuICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICBwYXJhbXM6IHtcclxuICAgICAgaWQ6IGlkLFxyXG4gICAgICB0aW1lOiB0aW1lLFxyXG4gICAgICB5ek5hbWU6IHl6TmFtZVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vY2FsZW5kYXJZZWFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNGI0MDllYyZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9jYWxlbmRhclllYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9jYWxlbmRhclllYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL2NhbGVuZGFyWWVhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIkQ6XFxcXGhlbGlwaW5nV29ya1xcXFxBUFBcXFxca21FbnZQb3J0YWJsZVxcXFx3ZWJhcHBPU1xcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcwNGI0MDllYycpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcwNGI0MDllYycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcwNGI0MDllYycsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vY2FsZW5kYXJZZWFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNGI0MDllYyZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcwNGI0MDllYycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvY2FsZW5kYXIvY2FsZW5kYXJZZWFyLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vY2FsZW5kYXJZZWFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9jYWxlbmRhclllYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanM/P3JlZi0tOS1vbmVPZi0xLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOS1vbmVPZi0xLTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOS1vbmVPZi0xLTIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vY2FsZW5kYXJZZWFyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2NzcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1xcXCJjYWNoZURpcmVjdG9yeVxcXCI6XFxcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclxcXCIsXFxcImNhY2hlSWRlbnRpZmllclxcXCI6XFxcIjRiYWUwNDgyLXZ1ZS1sb2FkZXItdGVtcGxhdGVcXFwifSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vY2FsZW5kYXJZZWFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNGI0MDllYyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5NjRmMjFiJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTI5NjRmMjFiJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMjk2NGYyMWJcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCJEOlxcXFxoZWxpcGluZ1dvcmtcXFxcQVBQXFxcXGttRW52UG9ydGFibGVcXFxcd2ViYXBwT1NcXFxcbm9kZV9tb2R1bGVzXFxcXHZ1ZS1ob3QtcmVsb2FkLWFwaVxcXFxkaXN0XFxcXGluZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMjk2NGYyMWInKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMjk2NGYyMWInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMjk2NGYyMWInLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yOTY0ZjIxYiZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcyOTY0ZjIxYicsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL3ZpZXdzL2FpckhvbWVQYWdlL2FpckNhbGVuZGFyRGV0YWlsL2luZGV4LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTktb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTktb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS05LW9uZU9mLTEtMyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTI5NjRmMjFiJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1xcXCJjYWNoZURpcmVjdG9yeVxcXCI6XFxcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclxcXCIsXFxcImNhY2hlSWRlbnRpZmllclxcXCI6XFxcIjRiYWUwNDgyLXZ1ZS1sb2FkZXItdGVtcGxhdGVcXFwifSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5NjRmMjFiJnNjb3BlZD10cnVlJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==